#include "../types.h"
#ifndef PACK_GL_H
#define PACK_GL_H

#ifndef glAccum_RETURN
typedef struct {
    GLenum op;
    GLfloat value;
} glAccum_ARGS;
typedef struct {
    int index;
    glAccum_ARGS args;
} glAccum_PACKED;
#endif
#ifndef glAccumxOES_RETURN
typedef struct {
    GLenum op;
    GLfixed value;
} glAccumxOES_ARGS;
typedef struct {
    int index;
    glAccumxOES_ARGS args;
} glAccumxOES_PACKED;
#endif
#ifndef glActiveProgramEXT_RETURN
typedef struct {
    GLuint program;
} glActiveProgramEXT_ARGS;
typedef struct {
    int index;
    glActiveProgramEXT_ARGS args;
} glActiveProgramEXT_PACKED;
#endif
#ifndef glActiveShaderProgram_RETURN
typedef struct {
    GLuint pipeline;
    GLuint program;
} glActiveShaderProgram_ARGS;
typedef struct {
    int index;
    glActiveShaderProgram_ARGS args;
} glActiveShaderProgram_PACKED;
#endif
#ifndef glActiveStencilFaceEXT_RETURN
typedef struct {
    GLenum face;
} glActiveStencilFaceEXT_ARGS;
typedef struct {
    int index;
    glActiveStencilFaceEXT_ARGS args;
} glActiveStencilFaceEXT_PACKED;
#endif
#ifndef glActiveTexture_RETURN
typedef struct {
    GLenum texture;
} glActiveTexture_ARGS;
typedef struct {
    int index;
    glActiveTexture_ARGS args;
} glActiveTexture_PACKED;
#endif
#ifndef glActiveTextureARB_RETURN
typedef struct {
    GLenum texture;
} glActiveTextureARB_ARGS;
typedef struct {
    int index;
    glActiveTextureARB_ARGS args;
} glActiveTextureARB_PACKED;
#endif
#ifndef glActiveVaryingNV_RETURN
typedef struct {
    GLuint program;
    GLchar * name;
} glActiveVaryingNV_ARGS;
typedef struct {
    int index;
    glActiveVaryingNV_ARGS args;
} glActiveVaryingNV_PACKED;
#endif
#ifndef glAlphaFragmentOp1ATI_RETURN
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
} glAlphaFragmentOp1ATI_ARGS;
typedef struct {
    int index;
    glAlphaFragmentOp1ATI_ARGS args;
} glAlphaFragmentOp1ATI_PACKED;
#endif
#ifndef glAlphaFragmentOp2ATI_RETURN
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
} glAlphaFragmentOp2ATI_ARGS;
typedef struct {
    int index;
    glAlphaFragmentOp2ATI_ARGS args;
} glAlphaFragmentOp2ATI_PACKED;
#endif
#ifndef glAlphaFragmentOp3ATI_RETURN
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
    GLuint arg3;
    GLuint arg3Rep;
    GLuint arg3Mod;
} glAlphaFragmentOp3ATI_ARGS;
typedef struct {
    int index;
    glAlphaFragmentOp3ATI_ARGS args;
} glAlphaFragmentOp3ATI_PACKED;
#endif
#ifndef glAlphaFunc_RETURN
typedef struct {
    GLenum func;
    GLfloat ref;
} glAlphaFunc_ARGS;
typedef struct {
    int index;
    glAlphaFunc_ARGS args;
} glAlphaFunc_PACKED;
#endif
#ifndef glAlphaFuncxOES_RETURN
typedef struct {
    GLenum func;
    GLfixed ref;
} glAlphaFuncxOES_ARGS;
typedef struct {
    int index;
    glAlphaFuncxOES_ARGS args;
} glAlphaFuncxOES_PACKED;
#endif
#ifndef glApplyTextureEXT_RETURN
typedef struct {
    GLenum mode;
} glApplyTextureEXT_ARGS;
typedef struct {
    int index;
    glApplyTextureEXT_ARGS args;
} glApplyTextureEXT_PACKED;
#endif
#ifndef glAreProgramsResidentNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * programs;
    GLboolean * residences;
} glAreProgramsResidentNV_ARGS;
typedef struct {
    int index;
    glAreProgramsResidentNV_ARGS args;
} glAreProgramsResidentNV_PACKED;
#endif
#ifndef glAreTexturesResident_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLboolean * residences;
} glAreTexturesResident_ARGS;
typedef struct {
    int index;
    glAreTexturesResident_ARGS args;
} glAreTexturesResident_PACKED;
#endif
#ifndef glAreTexturesResidentEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLboolean * residences;
} glAreTexturesResidentEXT_ARGS;
typedef struct {
    int index;
    glAreTexturesResidentEXT_ARGS args;
} glAreTexturesResidentEXT_PACKED;
#endif
#ifndef glArrayElement_RETURN
typedef struct {
    GLint i;
} glArrayElement_ARGS;
typedef struct {
    int index;
    glArrayElement_ARGS args;
} glArrayElement_PACKED;
#endif
#ifndef glArrayElementEXT_RETURN
typedef struct {
    GLint i;
} glArrayElementEXT_ARGS;
typedef struct {
    int index;
    glArrayElementEXT_ARGS args;
} glArrayElementEXT_PACKED;
#endif
#ifndef glArrayObjectATI_RETURN
typedef struct {
    GLenum array;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLuint buffer;
    GLuint offset;
} glArrayObjectATI_ARGS;
typedef struct {
    int index;
    glArrayObjectATI_ARGS args;
} glArrayObjectATI_PACKED;
#endif
#ifndef glAsyncMarkerSGIX_RETURN
typedef struct {
    GLuint marker;
} glAsyncMarkerSGIX_ARGS;
typedef struct {
    int index;
    glAsyncMarkerSGIX_ARGS args;
} glAsyncMarkerSGIX_PACKED;
#endif
#ifndef glAttachObjectARB_RETURN
typedef struct {
    GLhandleARB containerObj;
    GLhandleARB obj;
} glAttachObjectARB_ARGS;
typedef struct {
    int index;
    glAttachObjectARB_ARGS args;
} glAttachObjectARB_PACKED;
#endif
#ifndef glAttachShader_RETURN
typedef struct {
    GLuint program;
    GLuint shader;
} glAttachShader_ARGS;
typedef struct {
    int index;
    glAttachShader_ARGS args;
} glAttachShader_PACKED;
#endif
#ifndef glBegin_RETURN
typedef struct {
    GLenum mode;
} glBegin_ARGS;
typedef struct {
    int index;
    glBegin_ARGS args;
} glBegin_PACKED;
#endif
#ifndef glBeginConditionalRender_RETURN
typedef struct {
    GLuint id;
    GLenum mode;
} glBeginConditionalRender_ARGS;
typedef struct {
    int index;
    glBeginConditionalRender_ARGS args;
} glBeginConditionalRender_PACKED;
#endif
#ifndef glBeginConditionalRenderNV_RETURN
typedef struct {
    GLuint id;
    GLenum mode;
} glBeginConditionalRenderNV_ARGS;
typedef struct {
    int index;
    glBeginConditionalRenderNV_ARGS args;
} glBeginConditionalRenderNV_PACKED;
#endif
#ifndef glBeginConditionalRenderNVX_RETURN
typedef struct {
    GLuint id;
} glBeginConditionalRenderNVX_ARGS;
typedef struct {
    int index;
    glBeginConditionalRenderNVX_ARGS args;
} glBeginConditionalRenderNVX_PACKED;
#endif
#ifndef glBeginFragmentShaderATI_RETURN
typedef struct {
    int index;
} glBeginFragmentShaderATI_PACKED;
#endif
#ifndef glBeginOcclusionQueryNV_RETURN
typedef struct {
    GLuint id;
} glBeginOcclusionQueryNV_ARGS;
typedef struct {
    int index;
    glBeginOcclusionQueryNV_ARGS args;
} glBeginOcclusionQueryNV_PACKED;
#endif
#ifndef glBeginPerfMonitorAMD_RETURN
typedef struct {
    GLuint monitor;
} glBeginPerfMonitorAMD_ARGS;
typedef struct {
    int index;
    glBeginPerfMonitorAMD_ARGS args;
} glBeginPerfMonitorAMD_PACKED;
#endif
#ifndef glBeginQuery_RETURN
typedef struct {
    GLenum target;
    GLuint id;
} glBeginQuery_ARGS;
typedef struct {
    int index;
    glBeginQuery_ARGS args;
} glBeginQuery_PACKED;
#endif
#ifndef glBeginQueryARB_RETURN
typedef struct {
    GLenum target;
    GLuint id;
} glBeginQueryARB_ARGS;
typedef struct {
    int index;
    glBeginQueryARB_ARGS args;
} glBeginQueryARB_PACKED;
#endif
#ifndef glBeginQueryIndexed_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint id;
} glBeginQueryIndexed_ARGS;
typedef struct {
    int index;
    glBeginQueryIndexed_ARGS args;
} glBeginQueryIndexed_PACKED;
#endif
#ifndef glBeginTransformFeedback_RETURN
typedef struct {
    GLenum primitiveMode;
} glBeginTransformFeedback_ARGS;
typedef struct {
    int index;
    glBeginTransformFeedback_ARGS args;
} glBeginTransformFeedback_PACKED;
#endif
#ifndef glBeginTransformFeedbackEXT_RETURN
typedef struct {
    GLenum primitiveMode;
} glBeginTransformFeedbackEXT_ARGS;
typedef struct {
    int index;
    glBeginTransformFeedbackEXT_ARGS args;
} glBeginTransformFeedbackEXT_PACKED;
#endif
#ifndef glBeginTransformFeedbackNV_RETURN
typedef struct {
    GLenum primitiveMode;
} glBeginTransformFeedbackNV_ARGS;
typedef struct {
    int index;
    glBeginTransformFeedbackNV_ARGS args;
} glBeginTransformFeedbackNV_PACKED;
#endif
#ifndef glBeginVertexShaderEXT_RETURN
typedef struct {
    int index;
} glBeginVertexShaderEXT_PACKED;
#endif
#ifndef glBeginVideoCaptureNV_RETURN
typedef struct {
    GLuint video_capture_slot;
} glBeginVideoCaptureNV_ARGS;
typedef struct {
    int index;
    glBeginVideoCaptureNV_ARGS args;
} glBeginVideoCaptureNV_PACKED;
#endif
#ifndef glBindAttribLocation_RETURN
typedef struct {
    GLuint program;
    GLuint index;
    GLchar * name;
} glBindAttribLocation_ARGS;
typedef struct {
    int index;
    glBindAttribLocation_ARGS args;
} glBindAttribLocation_PACKED;
#endif
#ifndef glBindAttribLocationARB_RETURN
typedef struct {
    GLhandleARB programObj;
    GLuint index;
    GLcharARB * name;
} glBindAttribLocationARB_ARGS;
typedef struct {
    int index;
    glBindAttribLocationARB_ARGS args;
} glBindAttribLocationARB_PACKED;
#endif
#ifndef glBindBuffer_RETURN
typedef struct {
    GLenum target;
    GLuint buffer;
} glBindBuffer_ARGS;
typedef struct {
    int index;
    glBindBuffer_ARGS args;
} glBindBuffer_PACKED;
#endif
#ifndef glBindBufferARB_RETURN
typedef struct {
    GLenum target;
    GLuint buffer;
} glBindBufferARB_ARGS;
typedef struct {
    int index;
    glBindBufferARB_ARGS args;
} glBindBufferARB_PACKED;
#endif
#ifndef glBindBufferBase_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
} glBindBufferBase_ARGS;
typedef struct {
    int index;
    glBindBufferBase_ARGS args;
} glBindBufferBase_PACKED;
#endif
#ifndef glBindBufferBaseEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
} glBindBufferBaseEXT_ARGS;
typedef struct {
    int index;
    glBindBufferBaseEXT_ARGS args;
} glBindBufferBaseEXT_PACKED;
#endif
#ifndef glBindBufferBaseNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
} glBindBufferBaseNV_ARGS;
typedef struct {
    int index;
    glBindBufferBaseNV_ARGS args;
} glBindBufferBaseNV_PACKED;
#endif
#ifndef glBindBufferOffsetEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
} glBindBufferOffsetEXT_ARGS;
typedef struct {
    int index;
    glBindBufferOffsetEXT_ARGS args;
} glBindBufferOffsetEXT_PACKED;
#endif
#ifndef glBindBufferOffsetNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
} glBindBufferOffsetNV_ARGS;
typedef struct {
    int index;
    glBindBufferOffsetNV_ARGS args;
} glBindBufferOffsetNV_PACKED;
#endif
#ifndef glBindBufferRange_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} glBindBufferRange_ARGS;
typedef struct {
    int index;
    glBindBufferRange_ARGS args;
} glBindBufferRange_PACKED;
#endif
#ifndef glBindBufferRangeEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} glBindBufferRangeEXT_ARGS;
typedef struct {
    int index;
    glBindBufferRangeEXT_ARGS args;
} glBindBufferRangeEXT_PACKED;
#endif
#ifndef glBindBufferRangeNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} glBindBufferRangeNV_ARGS;
typedef struct {
    int index;
    glBindBufferRangeNV_ARGS args;
} glBindBufferRangeNV_PACKED;
#endif
#ifndef glBindFragDataLocation_RETURN
typedef struct {
    GLuint program;
    GLuint color;
    GLchar * name;
} glBindFragDataLocation_ARGS;
typedef struct {
    int index;
    glBindFragDataLocation_ARGS args;
} glBindFragDataLocation_PACKED;
#endif
#ifndef glBindFragDataLocationEXT_RETURN
typedef struct {
    GLuint program;
    GLuint color;
    GLchar * name;
} glBindFragDataLocationEXT_ARGS;
typedef struct {
    int index;
    glBindFragDataLocationEXT_ARGS args;
} glBindFragDataLocationEXT_PACKED;
#endif
#ifndef glBindFragDataLocationIndexed_RETURN
typedef struct {
    GLuint program;
    GLuint colorNumber;
    GLuint index;
    GLchar * name;
} glBindFragDataLocationIndexed_ARGS;
typedef struct {
    int index;
    glBindFragDataLocationIndexed_ARGS args;
} glBindFragDataLocationIndexed_PACKED;
#endif
#ifndef glBindFragmentShaderATI_RETURN
typedef struct {
    GLuint id;
} glBindFragmentShaderATI_ARGS;
typedef struct {
    int index;
    glBindFragmentShaderATI_ARGS args;
} glBindFragmentShaderATI_PACKED;
#endif
#ifndef glBindFramebuffer_RETURN
typedef struct {
    GLenum target;
    GLuint framebuffer;
} glBindFramebuffer_ARGS;
typedef struct {
    int index;
    glBindFramebuffer_ARGS args;
} glBindFramebuffer_PACKED;
#endif
#ifndef glBindFramebufferEXT_RETURN
typedef struct {
    GLenum target;
    GLuint framebuffer;
} glBindFramebufferEXT_ARGS;
typedef struct {
    int index;
    glBindFramebufferEXT_ARGS args;
} glBindFramebufferEXT_PACKED;
#endif
#ifndef glBindImageTexture_RETURN
typedef struct {
    GLuint unit;
    GLuint texture;
    GLint level;
    GLboolean layered;
    GLint layer;
    GLenum access;
    GLenum format;
} glBindImageTexture_ARGS;
typedef struct {
    int index;
    glBindImageTexture_ARGS args;
} glBindImageTexture_PACKED;
#endif
#ifndef glBindImageTextureEXT_RETURN
typedef struct {
    GLuint index;
    GLuint texture;
    GLint level;
    GLboolean layered;
    GLint layer;
    GLenum access;
    GLint format;
} glBindImageTextureEXT_ARGS;
typedef struct {
    int index;
    glBindImageTextureEXT_ARGS args;
} glBindImageTextureEXT_PACKED;
#endif
#ifndef glBindLightParameterEXT_RETURN
typedef struct {
    GLenum light;
    GLenum value;
} glBindLightParameterEXT_ARGS;
typedef struct {
    int index;
    glBindLightParameterEXT_ARGS args;
} glBindLightParameterEXT_PACKED;
#endif
#ifndef glBindMaterialParameterEXT_RETURN
typedef struct {
    GLenum face;
    GLenum value;
} glBindMaterialParameterEXT_ARGS;
typedef struct {
    int index;
    glBindMaterialParameterEXT_ARGS args;
} glBindMaterialParameterEXT_PACKED;
#endif
#ifndef glBindMultiTextureEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLuint texture;
} glBindMultiTextureEXT_ARGS;
typedef struct {
    int index;
    glBindMultiTextureEXT_ARGS args;
} glBindMultiTextureEXT_PACKED;
#endif
#ifndef glBindParameterEXT_RETURN
typedef struct {
    GLenum value;
} glBindParameterEXT_ARGS;
typedef struct {
    int index;
    glBindParameterEXT_ARGS args;
} glBindParameterEXT_PACKED;
#endif
#ifndef glBindProgramARB_RETURN
typedef struct {
    GLenum target;
    GLuint program;
} glBindProgramARB_ARGS;
typedef struct {
    int index;
    glBindProgramARB_ARGS args;
} glBindProgramARB_PACKED;
#endif
#ifndef glBindProgramNV_RETURN
typedef struct {
    GLenum target;
    GLuint id;
} glBindProgramNV_ARGS;
typedef struct {
    int index;
    glBindProgramNV_ARGS args;
} glBindProgramNV_PACKED;
#endif
#ifndef glBindProgramPipeline_RETURN
typedef struct {
    GLuint pipeline;
} glBindProgramPipeline_ARGS;
typedef struct {
    int index;
    glBindProgramPipeline_ARGS args;
} glBindProgramPipeline_PACKED;
#endif
#ifndef glBindRenderbuffer_RETURN
typedef struct {
    GLenum target;
    GLuint renderbuffer;
} glBindRenderbuffer_ARGS;
typedef struct {
    int index;
    glBindRenderbuffer_ARGS args;
} glBindRenderbuffer_PACKED;
#endif
#ifndef glBindRenderbufferEXT_RETURN
typedef struct {
    GLenum target;
    GLuint renderbuffer;
} glBindRenderbufferEXT_ARGS;
typedef struct {
    int index;
    glBindRenderbufferEXT_ARGS args;
} glBindRenderbufferEXT_PACKED;
#endif
#ifndef glBindSampler_RETURN
typedef struct {
    GLuint unit;
    GLuint sampler;
} glBindSampler_ARGS;
typedef struct {
    int index;
    glBindSampler_ARGS args;
} glBindSampler_PACKED;
#endif
#ifndef glBindTexGenParameterEXT_RETURN
typedef struct {
    GLenum unit;
    GLenum coord;
    GLenum value;
} glBindTexGenParameterEXT_ARGS;
typedef struct {
    int index;
    glBindTexGenParameterEXT_ARGS args;
} glBindTexGenParameterEXT_PACKED;
#endif
#ifndef glBindTexture_RETURN
typedef struct {
    GLenum target;
    GLuint texture;
} glBindTexture_ARGS;
typedef struct {
    int index;
    glBindTexture_ARGS args;
} glBindTexture_PACKED;
#endif
#ifndef glBindTextureEXT_RETURN
typedef struct {
    GLenum target;
    GLuint texture;
} glBindTextureEXT_ARGS;
typedef struct {
    int index;
    glBindTextureEXT_ARGS args;
} glBindTextureEXT_PACKED;
#endif
#ifndef glBindTextureUnitParameterEXT_RETURN
typedef struct {
    GLenum unit;
    GLenum value;
} glBindTextureUnitParameterEXT_ARGS;
typedef struct {
    int index;
    glBindTextureUnitParameterEXT_ARGS args;
} glBindTextureUnitParameterEXT_PACKED;
#endif
#ifndef glBindTransformFeedback_RETURN
typedef struct {
    GLenum target;
    GLuint id;
} glBindTransformFeedback_ARGS;
typedef struct {
    int index;
    glBindTransformFeedback_ARGS args;
} glBindTransformFeedback_PACKED;
#endif
#ifndef glBindTransformFeedbackNV_RETURN
typedef struct {
    GLenum target;
    GLuint id;
} glBindTransformFeedbackNV_ARGS;
typedef struct {
    int index;
    glBindTransformFeedbackNV_ARGS args;
} glBindTransformFeedbackNV_PACKED;
#endif
#ifndef glBindVertexArray_RETURN
typedef struct {
    GLuint array;
} glBindVertexArray_ARGS;
typedef struct {
    int index;
    glBindVertexArray_ARGS args;
} glBindVertexArray_PACKED;
#endif
#ifndef glBindVertexArrayAPPLE_RETURN
typedef struct {
    GLuint array;
} glBindVertexArrayAPPLE_ARGS;
typedef struct {
    int index;
    glBindVertexArrayAPPLE_ARGS args;
} glBindVertexArrayAPPLE_PACKED;
#endif
#ifndef glBindVertexBuffer_RETURN
typedef struct {
    GLuint bindingindex;
    GLuint buffer;
    GLintptr offset;
    GLsizei stride;
} glBindVertexBuffer_ARGS;
typedef struct {
    int index;
    glBindVertexBuffer_ARGS args;
} glBindVertexBuffer_PACKED;
#endif
#ifndef glBindVertexShaderEXT_RETURN
typedef struct {
    GLuint id;
} glBindVertexShaderEXT_ARGS;
typedef struct {
    int index;
    glBindVertexShaderEXT_ARGS args;
} glBindVertexShaderEXT_PACKED;
#endif
#ifndef glBindVideoCaptureStreamBufferNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum frame_region;
    GLintptrARB offset;
} glBindVideoCaptureStreamBufferNV_ARGS;
typedef struct {
    int index;
    glBindVideoCaptureStreamBufferNV_ARGS args;
} glBindVideoCaptureStreamBufferNV_PACKED;
#endif
#ifndef glBindVideoCaptureStreamTextureNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum frame_region;
    GLenum target;
    GLuint texture;
} glBindVideoCaptureStreamTextureNV_ARGS;
typedef struct {
    int index;
    glBindVideoCaptureStreamTextureNV_ARGS args;
} glBindVideoCaptureStreamTextureNV_PACKED;
#endif
#ifndef glBinormal3bEXT_RETURN
typedef struct {
    GLbyte bx;
    GLbyte by;
    GLbyte bz;
} glBinormal3bEXT_ARGS;
typedef struct {
    int index;
    glBinormal3bEXT_ARGS args;
} glBinormal3bEXT_PACKED;
#endif
#ifndef glBinormal3bvEXT_RETURN
typedef struct {
    GLbyte * v;
} glBinormal3bvEXT_ARGS;
typedef struct {
    int index;
    glBinormal3bvEXT_ARGS args;
} glBinormal3bvEXT_PACKED;
#endif
#ifndef glBinormal3dEXT_RETURN
typedef struct {
    GLdouble bx __attribute__ ((aligned(8)));
    GLdouble by __attribute__ ((aligned(8)));
    GLdouble bz __attribute__ ((aligned(8)));
} glBinormal3dEXT_ARGS;
typedef struct {
    int index;
    glBinormal3dEXT_ARGS args;
} glBinormal3dEXT_PACKED;
#endif
#ifndef glBinormal3dvEXT_RETURN
typedef struct {
    GLdouble * v;
} glBinormal3dvEXT_ARGS;
typedef struct {
    int index;
    glBinormal3dvEXT_ARGS args;
} glBinormal3dvEXT_PACKED;
#endif
#ifndef glBinormal3fEXT_RETURN
typedef struct {
    GLfloat bx;
    GLfloat by;
    GLfloat bz;
} glBinormal3fEXT_ARGS;
typedef struct {
    int index;
    glBinormal3fEXT_ARGS args;
} glBinormal3fEXT_PACKED;
#endif
#ifndef glBinormal3fvEXT_RETURN
typedef struct {
    GLfloat * v;
} glBinormal3fvEXT_ARGS;
typedef struct {
    int index;
    glBinormal3fvEXT_ARGS args;
} glBinormal3fvEXT_PACKED;
#endif
#ifndef glBinormal3iEXT_RETURN
typedef struct {
    GLint bx;
    GLint by;
    GLint bz;
} glBinormal3iEXT_ARGS;
typedef struct {
    int index;
    glBinormal3iEXT_ARGS args;
} glBinormal3iEXT_PACKED;
#endif
#ifndef glBinormal3ivEXT_RETURN
typedef struct {
    GLint * v;
} glBinormal3ivEXT_ARGS;
typedef struct {
    int index;
    glBinormal3ivEXT_ARGS args;
} glBinormal3ivEXT_PACKED;
#endif
#ifndef glBinormal3sEXT_RETURN
typedef struct {
    GLshort bx;
    GLshort by;
    GLshort bz;
} glBinormal3sEXT_ARGS;
typedef struct {
    int index;
    glBinormal3sEXT_ARGS args;
} glBinormal3sEXT_PACKED;
#endif
#ifndef glBinormal3svEXT_RETURN
typedef struct {
    GLshort * v;
} glBinormal3svEXT_ARGS;
typedef struct {
    int index;
    glBinormal3svEXT_ARGS args;
} glBinormal3svEXT_PACKED;
#endif
#ifndef glBinormalPointerEXT_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glBinormalPointerEXT_ARGS;
typedef struct {
    int index;
    glBinormalPointerEXT_ARGS args;
} glBinormalPointerEXT_PACKED;
#endif
#ifndef glBitmap_RETURN
typedef struct {
    GLsizei width;
    GLsizei height;
    GLfloat xorig;
    GLfloat yorig;
    GLfloat xmove;
    GLfloat ymove;
    GLubyte * bitmap;
} glBitmap_ARGS;
typedef struct {
    int index;
    glBitmap_ARGS args;
} glBitmap_PACKED;
#endif
#ifndef glBitmapxOES_RETURN
typedef struct {
    GLsizei width;
    GLsizei height;
    GLfixed xorig;
    GLfixed yorig;
    GLfixed xmove;
    GLfixed ymove;
    GLubyte * bitmap;
} glBitmapxOES_ARGS;
typedef struct {
    int index;
    glBitmapxOES_ARGS args;
} glBitmapxOES_PACKED;
#endif
#ifndef glBlendColor_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} glBlendColor_ARGS;
typedef struct {
    int index;
    glBlendColor_ARGS args;
} glBlendColor_PACKED;
#endif
#ifndef glBlendColorEXT_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} glBlendColorEXT_ARGS;
typedef struct {
    int index;
    glBlendColorEXT_ARGS args;
} glBlendColorEXT_PACKED;
#endif
#ifndef glBlendColorxOES_RETURN
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} glBlendColorxOES_ARGS;
typedef struct {
    int index;
    glBlendColorxOES_ARGS args;
} glBlendColorxOES_PACKED;
#endif
#ifndef glBlendEquation_RETURN
typedef struct {
    GLenum mode;
} glBlendEquation_ARGS;
typedef struct {
    int index;
    glBlendEquation_ARGS args;
} glBlendEquation_PACKED;
#endif
#ifndef glBlendEquationEXT_RETURN
typedef struct {
    GLenum mode;
} glBlendEquationEXT_ARGS;
typedef struct {
    int index;
    glBlendEquationEXT_ARGS args;
} glBlendEquationEXT_PACKED;
#endif
#ifndef glBlendEquationIndexedAMD_RETURN
typedef struct {
    GLuint buf;
    GLenum mode;
} glBlendEquationIndexedAMD_ARGS;
typedef struct {
    int index;
    glBlendEquationIndexedAMD_ARGS args;
} glBlendEquationIndexedAMD_PACKED;
#endif
#ifndef glBlendEquationSeparate_RETURN
typedef struct {
    GLenum modeRGB;
    GLenum modeAlpha;
} glBlendEquationSeparate_ARGS;
typedef struct {
    int index;
    glBlendEquationSeparate_ARGS args;
} glBlendEquationSeparate_PACKED;
#endif
#ifndef glBlendEquationSeparateEXT_RETURN
typedef struct {
    GLenum modeRGB;
    GLenum modeAlpha;
} glBlendEquationSeparateEXT_ARGS;
typedef struct {
    int index;
    glBlendEquationSeparateEXT_ARGS args;
} glBlendEquationSeparateEXT_PACKED;
#endif
#ifndef glBlendEquationSeparateIndexedAMD_RETURN
typedef struct {
    GLuint buf;
    GLenum modeRGB;
    GLenum modeAlpha;
} glBlendEquationSeparateIndexedAMD_ARGS;
typedef struct {
    int index;
    glBlendEquationSeparateIndexedAMD_ARGS args;
} glBlendEquationSeparateIndexedAMD_PACKED;
#endif
#ifndef glBlendEquationSeparatei_RETURN
typedef struct {
    GLuint buf;
    GLenum modeRGB;
    GLenum modeAlpha;
} glBlendEquationSeparatei_ARGS;
typedef struct {
    int index;
    glBlendEquationSeparatei_ARGS args;
} glBlendEquationSeparatei_PACKED;
#endif
#ifndef glBlendEquationSeparateiARB_RETURN
typedef struct {
    GLuint buf;
    GLenum modeRGB;
    GLenum modeAlpha;
} glBlendEquationSeparateiARB_ARGS;
typedef struct {
    int index;
    glBlendEquationSeparateiARB_ARGS args;
} glBlendEquationSeparateiARB_PACKED;
#endif
#ifndef glBlendEquationi_RETURN
typedef struct {
    GLuint buf;
    GLenum mode;
} glBlendEquationi_ARGS;
typedef struct {
    int index;
    glBlendEquationi_ARGS args;
} glBlendEquationi_PACKED;
#endif
#ifndef glBlendEquationiARB_RETURN
typedef struct {
    GLuint buf;
    GLenum mode;
} glBlendEquationiARB_ARGS;
typedef struct {
    int index;
    glBlendEquationiARB_ARGS args;
} glBlendEquationiARB_PACKED;
#endif
#ifndef glBlendFunc_RETURN
typedef struct {
    GLenum sfactor;
    GLenum dfactor;
} glBlendFunc_ARGS;
typedef struct {
    int index;
    glBlendFunc_ARGS args;
} glBlendFunc_PACKED;
#endif
#ifndef glBlendFuncIndexedAMD_RETURN
typedef struct {
    GLuint buf;
    GLenum src;
    GLenum dst;
} glBlendFuncIndexedAMD_ARGS;
typedef struct {
    int index;
    glBlendFuncIndexedAMD_ARGS args;
} glBlendFuncIndexedAMD_PACKED;
#endif
#ifndef glBlendFuncSeparate_RETURN
typedef struct {
    GLenum sfactorRGB;
    GLenum dfactorRGB;
    GLenum sfactorAlpha;
    GLenum dfactorAlpha;
} glBlendFuncSeparate_ARGS;
typedef struct {
    int index;
    glBlendFuncSeparate_ARGS args;
} glBlendFuncSeparate_PACKED;
#endif
#ifndef glBlendFuncSeparateEXT_RETURN
typedef struct {
    GLenum sfactorRGB;
    GLenum dfactorRGB;
    GLenum sfactorAlpha;
    GLenum dfactorAlpha;
} glBlendFuncSeparateEXT_ARGS;
typedef struct {
    int index;
    glBlendFuncSeparateEXT_ARGS args;
} glBlendFuncSeparateEXT_PACKED;
#endif
#ifndef glBlendFuncSeparateINGR_RETURN
typedef struct {
    GLenum sfactorRGB;
    GLenum dfactorRGB;
    GLenum sfactorAlpha;
    GLenum dfactorAlpha;
} glBlendFuncSeparateINGR_ARGS;
typedef struct {
    int index;
    glBlendFuncSeparateINGR_ARGS args;
} glBlendFuncSeparateINGR_PACKED;
#endif
#ifndef glBlendFuncSeparateIndexedAMD_RETURN
typedef struct {
    GLuint buf;
    GLenum srcRGB;
    GLenum dstRGB;
    GLenum srcAlpha;
    GLenum dstAlpha;
} glBlendFuncSeparateIndexedAMD_ARGS;
typedef struct {
    int index;
    glBlendFuncSeparateIndexedAMD_ARGS args;
} glBlendFuncSeparateIndexedAMD_PACKED;
#endif
#ifndef glBlendFuncSeparatei_RETURN
typedef struct {
    GLuint buf;
    GLenum srcRGB;
    GLenum dstRGB;
    GLenum srcAlpha;
    GLenum dstAlpha;
} glBlendFuncSeparatei_ARGS;
typedef struct {
    int index;
    glBlendFuncSeparatei_ARGS args;
} glBlendFuncSeparatei_PACKED;
#endif
#ifndef glBlendFuncSeparateiARB_RETURN
typedef struct {
    GLuint buf;
    GLenum srcRGB;
    GLenum dstRGB;
    GLenum srcAlpha;
    GLenum dstAlpha;
} glBlendFuncSeparateiARB_ARGS;
typedef struct {
    int index;
    glBlendFuncSeparateiARB_ARGS args;
} glBlendFuncSeparateiARB_PACKED;
#endif
#ifndef glBlendFunci_RETURN
typedef struct {
    GLuint buf;
    GLenum src;
    GLenum dst;
} glBlendFunci_ARGS;
typedef struct {
    int index;
    glBlendFunci_ARGS args;
} glBlendFunci_PACKED;
#endif
#ifndef glBlendFunciARB_RETURN
typedef struct {
    GLuint buf;
    GLenum src;
    GLenum dst;
} glBlendFunciARB_ARGS;
typedef struct {
    int index;
    glBlendFunciARB_ARGS args;
} glBlendFunciARB_PACKED;
#endif
#ifndef glBlitFramebuffer_RETURN
typedef struct {
    GLint srcX0;
    GLint srcY0;
    GLint srcX1;
    GLint srcY1;
    GLint dstX0;
    GLint dstY0;
    GLint dstX1;
    GLint dstY1;
    GLbitfield mask;
    GLenum filter;
} glBlitFramebuffer_ARGS;
typedef struct {
    int index;
    glBlitFramebuffer_ARGS args;
} glBlitFramebuffer_PACKED;
#endif
#ifndef glBlitFramebufferEXT_RETURN
typedef struct {
    GLint srcX0;
    GLint srcY0;
    GLint srcX1;
    GLint srcY1;
    GLint dstX0;
    GLint dstY0;
    GLint dstX1;
    GLint dstY1;
    GLbitfield mask;
    GLenum filter;
} glBlitFramebufferEXT_ARGS;
typedef struct {
    int index;
    glBlitFramebufferEXT_ARGS args;
} glBlitFramebufferEXT_PACKED;
#endif
#ifndef glBufferAddressRangeNV_RETURN
typedef struct {
    GLenum pname;
    GLuint index;
    GLuint64EXT address;
    GLsizeiptr length;
} glBufferAddressRangeNV_ARGS;
typedef struct {
    int index;
    glBufferAddressRangeNV_ARGS args;
} glBufferAddressRangeNV_PACKED;
#endif
#ifndef glBufferData_RETURN
typedef struct {
    GLenum target;
    GLsizeiptr size;
    GLvoid * data;
    GLenum usage;
} glBufferData_ARGS;
typedef struct {
    int index;
    glBufferData_ARGS args;
} glBufferData_PACKED;
#endif
#ifndef glBufferDataARB_RETURN
typedef struct {
    GLenum target;
    GLsizeiptrARB size;
    GLvoid * data;
    GLenum usage;
} glBufferDataARB_ARGS;
typedef struct {
    int index;
    glBufferDataARB_ARGS args;
} glBufferDataARB_PACKED;
#endif
#ifndef glBufferParameteriAPPLE_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} glBufferParameteriAPPLE_ARGS;
typedef struct {
    int index;
    glBufferParameteriAPPLE_ARGS args;
} glBufferParameteriAPPLE_PACKED;
#endif
#ifndef glBufferSubData_RETURN
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} glBufferSubData_ARGS;
typedef struct {
    int index;
    glBufferSubData_ARGS args;
} glBufferSubData_PACKED;
#endif
#ifndef glBufferSubDataARB_RETURN
typedef struct {
    GLenum target;
    GLintptrARB offset;
    GLsizeiptrARB size;
    GLvoid * data;
} glBufferSubDataARB_ARGS;
typedef struct {
    int index;
    glBufferSubDataARB_ARGS args;
} glBufferSubDataARB_PACKED;
#endif
#ifndef glCallList_RETURN
typedef struct {
    GLuint list;
} glCallList_ARGS;
typedef struct {
    int index;
    glCallList_ARGS args;
} glCallList_PACKED;
#endif
#ifndef glCallLists_RETURN
typedef struct {
    GLsizei n;
    GLenum type;
    GLvoid * lists;
} glCallLists_ARGS;
typedef struct {
    int index;
    glCallLists_ARGS args;
} glCallLists_PACKED;
#endif
#ifndef glCheckFramebufferStatus_RETURN
typedef struct {
    GLenum target;
} glCheckFramebufferStatus_ARGS;
typedef struct {
    int index;
    glCheckFramebufferStatus_ARGS args;
} glCheckFramebufferStatus_PACKED;
#endif
#ifndef glCheckFramebufferStatusEXT_RETURN
typedef struct {
    GLenum target;
} glCheckFramebufferStatusEXT_ARGS;
typedef struct {
    int index;
    glCheckFramebufferStatusEXT_ARGS args;
} glCheckFramebufferStatusEXT_PACKED;
#endif
#ifndef glCheckNamedFramebufferStatusEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum target;
} glCheckNamedFramebufferStatusEXT_ARGS;
typedef struct {
    int index;
    glCheckNamedFramebufferStatusEXT_ARGS args;
} glCheckNamedFramebufferStatusEXT_PACKED;
#endif
#ifndef glClampColor_RETURN
typedef struct {
    GLenum target;
    GLenum clamp;
} glClampColor_ARGS;
typedef struct {
    int index;
    glClampColor_ARGS args;
} glClampColor_PACKED;
#endif
#ifndef glClampColorARB_RETURN
typedef struct {
    GLenum target;
    GLenum clamp;
} glClampColorARB_ARGS;
typedef struct {
    int index;
    glClampColorARB_ARGS args;
} glClampColorARB_PACKED;
#endif
#ifndef glClear_RETURN
typedef struct {
    GLbitfield mask;
} glClear_ARGS;
typedef struct {
    int index;
    glClear_ARGS args;
} glClear_PACKED;
#endif
#ifndef glClearAccum_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} glClearAccum_ARGS;
typedef struct {
    int index;
    glClearAccum_ARGS args;
} glClearAccum_PACKED;
#endif
#ifndef glClearAccumxOES_RETURN
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} glClearAccumxOES_ARGS;
typedef struct {
    int index;
    glClearAccumxOES_ARGS args;
} glClearAccumxOES_PACKED;
#endif
#ifndef glClearBufferData_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLenum format;
    GLenum type;
    void * data;
} glClearBufferData_ARGS;
typedef struct {
    int index;
    glClearBufferData_ARGS args;
} glClearBufferData_PACKED;
#endif
#ifndef glClearBufferSubData_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLintptr offset;
    GLsizeiptr size;
    GLenum format;
    GLenum type;
    void * data;
} glClearBufferSubData_ARGS;
typedef struct {
    int index;
    glClearBufferSubData_ARGS args;
} glClearBufferSubData_PACKED;
#endif
#ifndef glClearBufferfi_RETURN
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLfloat depth;
    GLint stencil;
} glClearBufferfi_ARGS;
typedef struct {
    int index;
    glClearBufferfi_ARGS args;
} glClearBufferfi_PACKED;
#endif
#ifndef glClearBufferfv_RETURN
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLfloat * value;
} glClearBufferfv_ARGS;
typedef struct {
    int index;
    glClearBufferfv_ARGS args;
} glClearBufferfv_PACKED;
#endif
#ifndef glClearBufferiv_RETURN
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLint * value;
} glClearBufferiv_ARGS;
typedef struct {
    int index;
    glClearBufferiv_ARGS args;
} glClearBufferiv_PACKED;
#endif
#ifndef glClearBufferuiv_RETURN
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLuint * value;
} glClearBufferuiv_ARGS;
typedef struct {
    int index;
    glClearBufferuiv_ARGS args;
} glClearBufferuiv_PACKED;
#endif
#ifndef glClearColor_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} glClearColor_ARGS;
typedef struct {
    int index;
    glClearColor_ARGS args;
} glClearColor_PACKED;
#endif
#ifndef glClearColorIiEXT_RETURN
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;
} glClearColorIiEXT_ARGS;
typedef struct {
    int index;
    glClearColorIiEXT_ARGS args;
} glClearColorIiEXT_PACKED;
#endif
#ifndef glClearColorIuiEXT_RETURN
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;
} glClearColorIuiEXT_ARGS;
typedef struct {
    int index;
    glClearColorIuiEXT_ARGS args;
} glClearColorIuiEXT_PACKED;
#endif
#ifndef glClearColorxOES_RETURN
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} glClearColorxOES_ARGS;
typedef struct {
    int index;
    glClearColorxOES_ARGS args;
} glClearColorxOES_PACKED;
#endif
#ifndef glClearDepth_RETURN
typedef struct {
    GLdouble depth __attribute__ ((aligned(8)));
} glClearDepth_ARGS;
typedef struct {
    int index;
    glClearDepth_ARGS args;
} glClearDepth_PACKED;
#endif
#ifndef glClearDepthdNV_RETURN
typedef struct {
    GLdouble depth __attribute__ ((aligned(8)));
} glClearDepthdNV_ARGS;
typedef struct {
    int index;
    glClearDepthdNV_ARGS args;
} glClearDepthdNV_PACKED;
#endif
#ifndef glClearDepthf_RETURN
typedef struct {
    GLfloat depth;
} glClearDepthf_ARGS;
typedef struct {
    int index;
    glClearDepthf_ARGS args;
} glClearDepthf_PACKED;
#endif
#ifndef glClearDepthfOES_RETURN
typedef struct {
    GLclampf depth;
} glClearDepthfOES_ARGS;
typedef struct {
    int index;
    glClearDepthfOES_ARGS args;
} glClearDepthfOES_PACKED;
#endif
#ifndef glClearDepthxOES_RETURN
typedef struct {
    GLfixed depth;
} glClearDepthxOES_ARGS;
typedef struct {
    int index;
    glClearDepthxOES_ARGS args;
} glClearDepthxOES_PACKED;
#endif
#ifndef glClearIndex_RETURN
typedef struct {
    GLfloat c;
} glClearIndex_ARGS;
typedef struct {
    int index;
    glClearIndex_ARGS args;
} glClearIndex_PACKED;
#endif
#ifndef glClearNamedBufferDataEXT_RETURN
typedef struct {
    GLuint buffer;
    GLenum internalformat;
    GLenum format;
    GLenum type;
    void * data;
} glClearNamedBufferDataEXT_ARGS;
typedef struct {
    int index;
    glClearNamedBufferDataEXT_ARGS args;
} glClearNamedBufferDataEXT_PACKED;
#endif
#ifndef glClearNamedBufferSubDataEXT_RETURN
typedef struct {
    GLuint buffer;
    GLenum internalformat;
    GLenum format;
    GLenum type;
    GLsizeiptr offset;
    GLsizeiptr size;
    void * data;
} glClearNamedBufferSubDataEXT_ARGS;
typedef struct {
    int index;
    glClearNamedBufferSubDataEXT_ARGS args;
} glClearNamedBufferSubDataEXT_PACKED;
#endif
#ifndef glClearStencil_RETURN
typedef struct {
    GLint s;
} glClearStencil_ARGS;
typedef struct {
    int index;
    glClearStencil_ARGS args;
} glClearStencil_PACKED;
#endif
#ifndef glClientActiveTexture_RETURN
typedef struct {
    GLenum texture;
} glClientActiveTexture_ARGS;
typedef struct {
    int index;
    glClientActiveTexture_ARGS args;
} glClientActiveTexture_PACKED;
#endif
#ifndef glClientActiveTextureARB_RETURN
typedef struct {
    GLenum texture;
} glClientActiveTextureARB_ARGS;
typedef struct {
    int index;
    glClientActiveTextureARB_ARGS args;
} glClientActiveTextureARB_PACKED;
#endif
#ifndef glClientActiveVertexStreamATI_RETURN
typedef struct {
    GLenum stream;
} glClientActiveVertexStreamATI_ARGS;
typedef struct {
    int index;
    glClientActiveVertexStreamATI_ARGS args;
} glClientActiveVertexStreamATI_PACKED;
#endif
#ifndef glClientAttribDefaultEXT_RETURN
typedef struct {
    GLbitfield mask;
} glClientAttribDefaultEXT_ARGS;
typedef struct {
    int index;
    glClientAttribDefaultEXT_ARGS args;
} glClientAttribDefaultEXT_PACKED;
#endif
#ifndef glClientWaitSync_RETURN
typedef struct {
    GLsync sync;
    GLbitfield flags;
    GLuint64 timeout;
} glClientWaitSync_ARGS;
typedef struct {
    int index;
    glClientWaitSync_ARGS args;
} glClientWaitSync_PACKED;
#endif
#ifndef glClipPlane_RETURN
typedef struct {
    GLenum plane;
    GLdouble * equation;
} glClipPlane_ARGS;
typedef struct {
    int index;
    glClipPlane_ARGS args;
} glClipPlane_PACKED;
#endif
#ifndef glClipPlanefOES_RETURN
typedef struct {
    GLenum plane;
    GLfloat * equation;
} glClipPlanefOES_ARGS;
typedef struct {
    int index;
    glClipPlanefOES_ARGS args;
} glClipPlanefOES_PACKED;
#endif
#ifndef glClipPlanexOES_RETURN
typedef struct {
    GLenum plane;
    GLfixed * equation;
} glClipPlanexOES_ARGS;
typedef struct {
    int index;
    glClipPlanexOES_ARGS args;
} glClipPlanexOES_PACKED;
#endif
#ifndef glColor3b_RETURN
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
} glColor3b_ARGS;
typedef struct {
    int index;
    glColor3b_ARGS args;
} glColor3b_PACKED;
#endif
#ifndef glColor3bv_RETURN
typedef struct {
    GLbyte * v;
} glColor3bv_ARGS;
typedef struct {
    int index;
    glColor3bv_ARGS args;
} glColor3bv_PACKED;
#endif
#ifndef glColor3d_RETURN
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
} glColor3d_ARGS;
typedef struct {
    int index;
    glColor3d_ARGS args;
} glColor3d_PACKED;
#endif
#ifndef glColor3dv_RETURN
typedef struct {
    GLdouble * v;
} glColor3dv_ARGS;
typedef struct {
    int index;
    glColor3dv_ARGS args;
} glColor3dv_PACKED;
#endif
#ifndef glColor3f_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
} glColor3f_ARGS;
typedef struct {
    int index;
    glColor3f_ARGS args;
} glColor3f_PACKED;
#endif
#ifndef glColor3fVertex3fSUN_RETURN
typedef struct {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glColor3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glColor3fVertex3fSUN_ARGS args;
} glColor3fVertex3fSUN_PACKED;
#endif
#ifndef glColor3fVertex3fvSUN_RETURN
typedef struct {
    GLfloat * c;
    GLfloat * v;
} glColor3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glColor3fVertex3fvSUN_ARGS args;
} glColor3fVertex3fvSUN_PACKED;
#endif
#ifndef glColor3fv_RETURN
typedef struct {
    GLfloat * v;
} glColor3fv_ARGS;
typedef struct {
    int index;
    glColor3fv_ARGS args;
} glColor3fv_PACKED;
#endif
#ifndef glColor3hNV_RETURN
typedef struct {
    GLhalfNV red;
    GLhalfNV green;
    GLhalfNV blue;
} glColor3hNV_ARGS;
typedef struct {
    int index;
    glColor3hNV_ARGS args;
} glColor3hNV_PACKED;
#endif
#ifndef glColor3hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glColor3hvNV_ARGS;
typedef struct {
    int index;
    glColor3hvNV_ARGS args;
} glColor3hvNV_PACKED;
#endif
#ifndef glColor3i_RETURN
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
} glColor3i_ARGS;
typedef struct {
    int index;
    glColor3i_ARGS args;
} glColor3i_PACKED;
#endif
#ifndef glColor3iv_RETURN
typedef struct {
    GLint * v;
} glColor3iv_ARGS;
typedef struct {
    int index;
    glColor3iv_ARGS args;
} glColor3iv_PACKED;
#endif
#ifndef glColor3s_RETURN
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
} glColor3s_ARGS;
typedef struct {
    int index;
    glColor3s_ARGS args;
} glColor3s_PACKED;
#endif
#ifndef glColor3sv_RETURN
typedef struct {
    GLshort * v;
} glColor3sv_ARGS;
typedef struct {
    int index;
    glColor3sv_ARGS args;
} glColor3sv_PACKED;
#endif
#ifndef glColor3ub_RETURN
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
} glColor3ub_ARGS;
typedef struct {
    int index;
    glColor3ub_ARGS args;
} glColor3ub_PACKED;
#endif
#ifndef glColor3ubv_RETURN
typedef struct {
    GLubyte * v;
} glColor3ubv_ARGS;
typedef struct {
    int index;
    glColor3ubv_ARGS args;
} glColor3ubv_PACKED;
#endif
#ifndef glColor3ui_RETURN
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
} glColor3ui_ARGS;
typedef struct {
    int index;
    glColor3ui_ARGS args;
} glColor3ui_PACKED;
#endif
#ifndef glColor3uiv_RETURN
typedef struct {
    GLuint * v;
} glColor3uiv_ARGS;
typedef struct {
    int index;
    glColor3uiv_ARGS args;
} glColor3uiv_PACKED;
#endif
#ifndef glColor3us_RETURN
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
} glColor3us_ARGS;
typedef struct {
    int index;
    glColor3us_ARGS args;
} glColor3us_PACKED;
#endif
#ifndef glColor3usv_RETURN
typedef struct {
    GLushort * v;
} glColor3usv_ARGS;
typedef struct {
    int index;
    glColor3usv_ARGS args;
} glColor3usv_PACKED;
#endif
#ifndef glColor3xOES_RETURN
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
} glColor3xOES_ARGS;
typedef struct {
    int index;
    glColor3xOES_ARGS args;
} glColor3xOES_PACKED;
#endif
#ifndef glColor3xvOES_RETURN
typedef struct {
    GLfixed * components;
} glColor3xvOES_ARGS;
typedef struct {
    int index;
    glColor3xvOES_ARGS args;
} glColor3xvOES_PACKED;
#endif
#ifndef glColor4b_RETURN
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    GLbyte alpha;
} glColor4b_ARGS;
typedef struct {
    int index;
    glColor4b_ARGS args;
} glColor4b_PACKED;
#endif
#ifndef glColor4bv_RETURN
typedef struct {
    GLbyte * v;
} glColor4bv_ARGS;
typedef struct {
    int index;
    glColor4bv_ARGS args;
} glColor4bv_PACKED;
#endif
#ifndef glColor4d_RETURN
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
    GLdouble alpha __attribute__ ((aligned(8)));
} glColor4d_ARGS;
typedef struct {
    int index;
    glColor4d_ARGS args;
} glColor4d_PACKED;
#endif
#ifndef glColor4dv_RETURN
typedef struct {
    GLdouble * v;
} glColor4dv_ARGS;
typedef struct {
    int index;
    glColor4dv_ARGS args;
} glColor4dv_PACKED;
#endif
#ifndef glColor4f_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} glColor4f_ARGS;
typedef struct {
    int index;
    glColor4f_ARGS args;
} glColor4f_PACKED;
#endif
#ifndef glColor4fNormal3fVertex3fSUN_RETURN
typedef struct {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glColor4fNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glColor4fNormal3fVertex3fSUN_ARGS args;
} glColor4fNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glColor4fNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} glColor4fNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glColor4fNormal3fVertex3fvSUN_ARGS args;
} glColor4fNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glColor4fv_RETURN
typedef struct {
    GLfloat * v;
} glColor4fv_ARGS;
typedef struct {
    int index;
    glColor4fv_ARGS args;
} glColor4fv_PACKED;
#endif
#ifndef glColor4hNV_RETURN
typedef struct {
    GLhalfNV red;
    GLhalfNV green;
    GLhalfNV blue;
    GLhalfNV alpha;
} glColor4hNV_ARGS;
typedef struct {
    int index;
    glColor4hNV_ARGS args;
} glColor4hNV_PACKED;
#endif
#ifndef glColor4hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glColor4hvNV_ARGS;
typedef struct {
    int index;
    glColor4hvNV_ARGS args;
} glColor4hvNV_PACKED;
#endif
#ifndef glColor4i_RETURN
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;
} glColor4i_ARGS;
typedef struct {
    int index;
    glColor4i_ARGS args;
} glColor4i_PACKED;
#endif
#ifndef glColor4iv_RETURN
typedef struct {
    GLint * v;
} glColor4iv_ARGS;
typedef struct {
    int index;
    glColor4iv_ARGS args;
} glColor4iv_PACKED;
#endif
#ifndef glColor4s_RETURN
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
    GLshort alpha;
} glColor4s_ARGS;
typedef struct {
    int index;
    glColor4s_ARGS args;
} glColor4s_PACKED;
#endif
#ifndef glColor4sv_RETURN
typedef struct {
    GLshort * v;
} glColor4sv_ARGS;
typedef struct {
    int index;
    glColor4sv_ARGS args;
} glColor4sv_PACKED;
#endif
#ifndef glColor4ub_RETURN
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    GLubyte alpha;
} glColor4ub_ARGS;
typedef struct {
    int index;
    glColor4ub_ARGS args;
} glColor4ub_PACKED;
#endif
#ifndef glColor4ubVertex2fSUN_RETURN
typedef struct {
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
} glColor4ubVertex2fSUN_ARGS;
typedef struct {
    int index;
    glColor4ubVertex2fSUN_ARGS args;
} glColor4ubVertex2fSUN_PACKED;
#endif
#ifndef glColor4ubVertex2fvSUN_RETURN
typedef struct {
    GLubyte * c;
    GLfloat * v;
} glColor4ubVertex2fvSUN_ARGS;
typedef struct {
    int index;
    glColor4ubVertex2fvSUN_ARGS args;
} glColor4ubVertex2fvSUN_PACKED;
#endif
#ifndef glColor4ubVertex3fSUN_RETURN
typedef struct {
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glColor4ubVertex3fSUN_ARGS;
typedef struct {
    int index;
    glColor4ubVertex3fSUN_ARGS args;
} glColor4ubVertex3fSUN_PACKED;
#endif
#ifndef glColor4ubVertex3fvSUN_RETURN
typedef struct {
    GLubyte * c;
    GLfloat * v;
} glColor4ubVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glColor4ubVertex3fvSUN_ARGS args;
} glColor4ubVertex3fvSUN_PACKED;
#endif
#ifndef glColor4ubv_RETURN
typedef struct {
    GLubyte * v;
} glColor4ubv_ARGS;
typedef struct {
    int index;
    glColor4ubv_ARGS args;
} glColor4ubv_PACKED;
#endif
#ifndef glColor4ui_RETURN
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;
} glColor4ui_ARGS;
typedef struct {
    int index;
    glColor4ui_ARGS args;
} glColor4ui_PACKED;
#endif
#ifndef glColor4uiv_RETURN
typedef struct {
    GLuint * v;
} glColor4uiv_ARGS;
typedef struct {
    int index;
    glColor4uiv_ARGS args;
} glColor4uiv_PACKED;
#endif
#ifndef glColor4us_RETURN
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
    GLushort alpha;
} glColor4us_ARGS;
typedef struct {
    int index;
    glColor4us_ARGS args;
} glColor4us_PACKED;
#endif
#ifndef glColor4usv_RETURN
typedef struct {
    GLushort * v;
} glColor4usv_ARGS;
typedef struct {
    int index;
    glColor4usv_ARGS args;
} glColor4usv_PACKED;
#endif
#ifndef glColor4xOES_RETURN
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} glColor4xOES_ARGS;
typedef struct {
    int index;
    glColor4xOES_ARGS args;
} glColor4xOES_PACKED;
#endif
#ifndef glColor4xvOES_RETURN
typedef struct {
    GLfixed * components;
} glColor4xvOES_ARGS;
typedef struct {
    int index;
    glColor4xvOES_ARGS args;
} glColor4xvOES_PACKED;
#endif
#ifndef glColorFormatNV_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} glColorFormatNV_ARGS;
typedef struct {
    int index;
    glColorFormatNV_ARGS args;
} glColorFormatNV_PACKED;
#endif
#ifndef glColorFragmentOp1ATI_RETURN
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMask;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
} glColorFragmentOp1ATI_ARGS;
typedef struct {
    int index;
    glColorFragmentOp1ATI_ARGS args;
} glColorFragmentOp1ATI_PACKED;
#endif
#ifndef glColorFragmentOp2ATI_RETURN
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMask;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
} glColorFragmentOp2ATI_ARGS;
typedef struct {
    int index;
    glColorFragmentOp2ATI_ARGS args;
} glColorFragmentOp2ATI_PACKED;
#endif
#ifndef glColorFragmentOp3ATI_RETURN
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMask;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
    GLuint arg3;
    GLuint arg3Rep;
    GLuint arg3Mod;
} glColorFragmentOp3ATI_ARGS;
typedef struct {
    int index;
    glColorFragmentOp3ATI_ARGS args;
} glColorFragmentOp3ATI_PACKED;
#endif
#ifndef glColorMask_RETURN
typedef struct {
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;
} glColorMask_ARGS;
typedef struct {
    int index;
    glColorMask_ARGS args;
} glColorMask_PACKED;
#endif
#ifndef glColorMaskIndexedEXT_RETURN
typedef struct {
    GLuint index;
    GLboolean r;
    GLboolean g;
    GLboolean b;
    GLboolean a;
} glColorMaskIndexedEXT_ARGS;
typedef struct {
    int index;
    glColorMaskIndexedEXT_ARGS args;
} glColorMaskIndexedEXT_PACKED;
#endif
#ifndef glColorMaski_RETURN
typedef struct {
    GLuint index;
    GLboolean r;
    GLboolean g;
    GLboolean b;
    GLboolean a;
} glColorMaski_ARGS;
typedef struct {
    int index;
    glColorMaski_ARGS args;
} glColorMaski_PACKED;
#endif
#ifndef glColorMaterial_RETURN
typedef struct {
    GLenum face;
    GLenum mode;
} glColorMaterial_ARGS;
typedef struct {
    int index;
    glColorMaterial_ARGS args;
} glColorMaterial_PACKED;
#endif
#ifndef glColorP3ui_RETURN
typedef struct {
    GLenum type;
    GLuint color;
} glColorP3ui_ARGS;
typedef struct {
    int index;
    glColorP3ui_ARGS args;
} glColorP3ui_PACKED;
#endif
#ifndef glColorP3uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * color;
} glColorP3uiv_ARGS;
typedef struct {
    int index;
    glColorP3uiv_ARGS args;
} glColorP3uiv_PACKED;
#endif
#ifndef glColorP4ui_RETURN
typedef struct {
    GLenum type;
    GLuint color;
} glColorP4ui_ARGS;
typedef struct {
    int index;
    glColorP4ui_ARGS args;
} glColorP4ui_PACKED;
#endif
#ifndef glColorP4uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * color;
} glColorP4uiv_ARGS;
typedef struct {
    int index;
    glColorP4uiv_ARGS args;
} glColorP4uiv_PACKED;
#endif
#ifndef glColorPointer_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glColorPointer_ARGS;
typedef struct {
    int index;
    glColorPointer_ARGS args;
} glColorPointer_PACKED;
#endif
#ifndef glColorPointerEXT_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} glColorPointerEXT_ARGS;
typedef struct {
    int index;
    glColorPointerEXT_ARGS args;
} glColorPointerEXT_PACKED;
#endif
#ifndef glColorPointerListIBM_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} glColorPointerListIBM_ARGS;
typedef struct {
    int index;
    glColorPointerListIBM_ARGS args;
} glColorPointerListIBM_PACKED;
#endif
#ifndef glColorPointervINTEL_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLvoid * pointer;
} glColorPointervINTEL_ARGS;
typedef struct {
    int index;
    glColorPointervINTEL_ARGS args;
} glColorPointervINTEL_PACKED;
#endif
#ifndef glColorSubTable_RETURN
typedef struct {
    GLenum target;
    GLsizei start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLvoid * data;
} glColorSubTable_ARGS;
typedef struct {
    int index;
    glColorSubTable_ARGS args;
} glColorSubTable_PACKED;
#endif
#ifndef glColorSubTableEXT_RETURN
typedef struct {
    GLenum target;
    GLsizei start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLvoid * data;
} glColorSubTableEXT_ARGS;
typedef struct {
    int index;
    glColorSubTableEXT_ARGS args;
} glColorSubTableEXT_PACKED;
#endif
#ifndef glColorTable_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * table;
} glColorTable_ARGS;
typedef struct {
    int index;
    glColorTable_ARGS args;
} glColorTable_PACKED;
#endif
#ifndef glColorTableEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * table;
} glColorTableEXT_ARGS;
typedef struct {
    int index;
    glColorTableEXT_ARGS args;
} glColorTableEXT_PACKED;
#endif
#ifndef glColorTableParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glColorTableParameterfv_ARGS;
typedef struct {
    int index;
    glColorTableParameterfv_ARGS args;
} glColorTableParameterfv_PACKED;
#endif
#ifndef glColorTableParameterfvSGI_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glColorTableParameterfvSGI_ARGS;
typedef struct {
    int index;
    glColorTableParameterfvSGI_ARGS args;
} glColorTableParameterfvSGI_PACKED;
#endif
#ifndef glColorTableParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glColorTableParameteriv_ARGS;
typedef struct {
    int index;
    glColorTableParameteriv_ARGS args;
} glColorTableParameteriv_PACKED;
#endif
#ifndef glColorTableParameterivSGI_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glColorTableParameterivSGI_ARGS;
typedef struct {
    int index;
    glColorTableParameterivSGI_ARGS args;
} glColorTableParameterivSGI_PACKED;
#endif
#ifndef glColorTableSGI_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * table;
} glColorTableSGI_ARGS;
typedef struct {
    int index;
    glColorTableSGI_ARGS args;
} glColorTableSGI_PACKED;
#endif
#ifndef glCombinerInputNV_RETURN
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum variable;
    GLenum input;
    GLenum mapping;
    GLenum componentUsage;
} glCombinerInputNV_ARGS;
typedef struct {
    int index;
    glCombinerInputNV_ARGS args;
} glCombinerInputNV_PACKED;
#endif
#ifndef glCombinerOutputNV_RETURN
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum abOutput;
    GLenum cdOutput;
    GLenum sumOutput;
    GLenum scale;
    GLenum bias;
    GLboolean abDotProduct;
    GLboolean cdDotProduct;
    GLboolean muxSum;
} glCombinerOutputNV_ARGS;
typedef struct {
    int index;
    glCombinerOutputNV_ARGS args;
} glCombinerOutputNV_PACKED;
#endif
#ifndef glCombinerParameterfNV_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glCombinerParameterfNV_ARGS;
typedef struct {
    int index;
    glCombinerParameterfNV_ARGS args;
} glCombinerParameterfNV_PACKED;
#endif
#ifndef glCombinerParameterfvNV_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glCombinerParameterfvNV_ARGS;
typedef struct {
    int index;
    glCombinerParameterfvNV_ARGS args;
} glCombinerParameterfvNV_PACKED;
#endif
#ifndef glCombinerParameteriNV_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glCombinerParameteriNV_ARGS;
typedef struct {
    int index;
    glCombinerParameteriNV_ARGS args;
} glCombinerParameteriNV_PACKED;
#endif
#ifndef glCombinerParameterivNV_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glCombinerParameterivNV_ARGS;
typedef struct {
    int index;
    glCombinerParameterivNV_ARGS args;
} glCombinerParameterivNV_PACKED;
#endif
#ifndef glCombinerStageParameterfvNV_RETURN
typedef struct {
    GLenum stage;
    GLenum pname;
    GLfloat * params;
} glCombinerStageParameterfvNV_ARGS;
typedef struct {
    int index;
    glCombinerStageParameterfvNV_ARGS args;
} glCombinerStageParameterfvNV_PACKED;
#endif
#ifndef glCompileShader_RETURN
typedef struct {
    GLuint shader;
} glCompileShader_ARGS;
typedef struct {
    int index;
    glCompileShader_ARGS args;
} glCompileShader_PACKED;
#endif
#ifndef glCompileShaderARB_RETURN
typedef struct {
    GLhandleARB shaderObj;
} glCompileShaderARB_ARGS;
typedef struct {
    int index;
    glCompileShaderARB_ARGS args;
} glCompileShaderARB_PACKED;
#endif
#ifndef glCompileShaderIncludeARB_RETURN
typedef struct {
    GLuint shader;
    GLsizei count;
    GLchar * path;
    GLint * length;
} glCompileShaderIncludeARB_ARGS;
typedef struct {
    int index;
    glCompileShaderIncludeARB_ARGS args;
} glCompileShaderIncludeARB_PACKED;
#endif
#ifndef glCompressedMultiTexImage1DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedMultiTexImage1DEXT_ARGS;
typedef struct {
    int index;
    glCompressedMultiTexImage1DEXT_ARGS args;
} glCompressedMultiTexImage1DEXT_PACKED;
#endif
#ifndef glCompressedMultiTexImage2DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedMultiTexImage2DEXT_ARGS;
typedef struct {
    int index;
    glCompressedMultiTexImage2DEXT_ARGS args;
} glCompressedMultiTexImage2DEXT_PACKED;
#endif
#ifndef glCompressedMultiTexImage3DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedMultiTexImage3DEXT_ARGS;
typedef struct {
    int index;
    glCompressedMultiTexImage3DEXT_ARGS args;
} glCompressedMultiTexImage3DEXT_PACKED;
#endif
#ifndef glCompressedMultiTexSubImage1DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedMultiTexSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glCompressedMultiTexSubImage1DEXT_ARGS args;
} glCompressedMultiTexSubImage1DEXT_PACKED;
#endif
#ifndef glCompressedMultiTexSubImage2DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedMultiTexSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glCompressedMultiTexSubImage2DEXT_ARGS args;
} glCompressedMultiTexSubImage2DEXT_PACKED;
#endif
#ifndef glCompressedMultiTexSubImage3DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedMultiTexSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glCompressedMultiTexSubImage3DEXT_ARGS args;
} glCompressedMultiTexSubImage3DEXT_PACKED;
#endif
#ifndef glCompressedTexImage1D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexImage1D_ARGS;
typedef struct {
    int index;
    glCompressedTexImage1D_ARGS args;
} glCompressedTexImage1D_PACKED;
#endif
#ifndef glCompressedTexImage1DARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexImage1DARB_ARGS;
typedef struct {
    int index;
    glCompressedTexImage1DARB_ARGS args;
} glCompressedTexImage1DARB_PACKED;
#endif
#ifndef glCompressedTexImage2D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexImage2D_ARGS;
typedef struct {
    int index;
    glCompressedTexImage2D_ARGS args;
} glCompressedTexImage2D_PACKED;
#endif
#ifndef glCompressedTexImage2DARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexImage2DARB_ARGS;
typedef struct {
    int index;
    glCompressedTexImage2DARB_ARGS args;
} glCompressedTexImage2DARB_PACKED;
#endif
#ifndef glCompressedTexImage3D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexImage3D_ARGS;
typedef struct {
    int index;
    glCompressedTexImage3D_ARGS args;
} glCompressedTexImage3D_PACKED;
#endif
#ifndef glCompressedTexImage3DARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexImage3DARB_ARGS;
typedef struct {
    int index;
    glCompressedTexImage3DARB_ARGS args;
} glCompressedTexImage3DARB_PACKED;
#endif
#ifndef glCompressedTexSubImage1D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexSubImage1D_ARGS;
typedef struct {
    int index;
    glCompressedTexSubImage1D_ARGS args;
} glCompressedTexSubImage1D_PACKED;
#endif
#ifndef glCompressedTexSubImage1DARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexSubImage1DARB_ARGS;
typedef struct {
    int index;
    glCompressedTexSubImage1DARB_ARGS args;
} glCompressedTexSubImage1DARB_PACKED;
#endif
#ifndef glCompressedTexSubImage2D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexSubImage2D_ARGS;
typedef struct {
    int index;
    glCompressedTexSubImage2D_ARGS args;
} glCompressedTexSubImage2D_PACKED;
#endif
#ifndef glCompressedTexSubImage2DARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexSubImage2DARB_ARGS;
typedef struct {
    int index;
    glCompressedTexSubImage2DARB_ARGS args;
} glCompressedTexSubImage2DARB_PACKED;
#endif
#ifndef glCompressedTexSubImage3D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexSubImage3D_ARGS;
typedef struct {
    int index;
    glCompressedTexSubImage3D_ARGS args;
} glCompressedTexSubImage3D_PACKED;
#endif
#ifndef glCompressedTexSubImage3DARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} glCompressedTexSubImage3DARB_ARGS;
typedef struct {
    int index;
    glCompressedTexSubImage3DARB_ARGS args;
} glCompressedTexSubImage3DARB_PACKED;
#endif
#ifndef glCompressedTextureImage1DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedTextureImage1DEXT_ARGS;
typedef struct {
    int index;
    glCompressedTextureImage1DEXT_ARGS args;
} glCompressedTextureImage1DEXT_PACKED;
#endif
#ifndef glCompressedTextureImage2DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedTextureImage2DEXT_ARGS;
typedef struct {
    int index;
    glCompressedTextureImage2DEXT_ARGS args;
} glCompressedTextureImage2DEXT_PACKED;
#endif
#ifndef glCompressedTextureImage3DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedTextureImage3DEXT_ARGS;
typedef struct {
    int index;
    glCompressedTextureImage3DEXT_ARGS args;
} glCompressedTextureImage3DEXT_PACKED;
#endif
#ifndef glCompressedTextureSubImage1DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedTextureSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glCompressedTextureSubImage1DEXT_ARGS args;
} glCompressedTextureSubImage1DEXT_PACKED;
#endif
#ifndef glCompressedTextureSubImage2DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedTextureSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glCompressedTextureSubImage2DEXT_ARGS args;
} glCompressedTextureSubImage2DEXT_PACKED;
#endif
#ifndef glCompressedTextureSubImage3DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} glCompressedTextureSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glCompressedTextureSubImage3DEXT_ARGS args;
} glCompressedTextureSubImage3DEXT_PACKED;
#endif
#ifndef glConvolutionFilter1D_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * image;
} glConvolutionFilter1D_ARGS;
typedef struct {
    int index;
    glConvolutionFilter1D_ARGS args;
} glConvolutionFilter1D_PACKED;
#endif
#ifndef glConvolutionFilter1DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * image;
} glConvolutionFilter1DEXT_ARGS;
typedef struct {
    int index;
    glConvolutionFilter1DEXT_ARGS args;
} glConvolutionFilter1DEXT_PACKED;
#endif
#ifndef glConvolutionFilter2D_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * image;
} glConvolutionFilter2D_ARGS;
typedef struct {
    int index;
    glConvolutionFilter2D_ARGS args;
} glConvolutionFilter2D_PACKED;
#endif
#ifndef glConvolutionFilter2DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * image;
} glConvolutionFilter2DEXT_ARGS;
typedef struct {
    int index;
    glConvolutionFilter2DEXT_ARGS args;
} glConvolutionFilter2DEXT_PACKED;
#endif
#ifndef glConvolutionParameterf_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat params;
} glConvolutionParameterf_ARGS;
typedef struct {
    int index;
    glConvolutionParameterf_ARGS args;
} glConvolutionParameterf_PACKED;
#endif
#ifndef glConvolutionParameterfEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat params;
} glConvolutionParameterfEXT_ARGS;
typedef struct {
    int index;
    glConvolutionParameterfEXT_ARGS args;
} glConvolutionParameterfEXT_PACKED;
#endif
#ifndef glConvolutionParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glConvolutionParameterfv_ARGS;
typedef struct {
    int index;
    glConvolutionParameterfv_ARGS args;
} glConvolutionParameterfv_PACKED;
#endif
#ifndef glConvolutionParameterfvEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glConvolutionParameterfvEXT_ARGS;
typedef struct {
    int index;
    glConvolutionParameterfvEXT_ARGS args;
} glConvolutionParameterfvEXT_PACKED;
#endif
#ifndef glConvolutionParameteri_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint params;
} glConvolutionParameteri_ARGS;
typedef struct {
    int index;
    glConvolutionParameteri_ARGS args;
} glConvolutionParameteri_PACKED;
#endif
#ifndef glConvolutionParameteriEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint params;
} glConvolutionParameteriEXT_ARGS;
typedef struct {
    int index;
    glConvolutionParameteriEXT_ARGS args;
} glConvolutionParameteriEXT_PACKED;
#endif
#ifndef glConvolutionParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glConvolutionParameteriv_ARGS;
typedef struct {
    int index;
    glConvolutionParameteriv_ARGS args;
} glConvolutionParameteriv_PACKED;
#endif
#ifndef glConvolutionParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glConvolutionParameterivEXT_ARGS;
typedef struct {
    int index;
    glConvolutionParameterivEXT_ARGS args;
} glConvolutionParameterivEXT_PACKED;
#endif
#ifndef glConvolutionParameterxOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} glConvolutionParameterxOES_ARGS;
typedef struct {
    int index;
    glConvolutionParameterxOES_ARGS args;
} glConvolutionParameterxOES_PACKED;
#endif
#ifndef glConvolutionParameterxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} glConvolutionParameterxvOES_ARGS;
typedef struct {
    int index;
    glConvolutionParameterxvOES_ARGS args;
} glConvolutionParameterxvOES_PACKED;
#endif
#ifndef glCopyBufferSubData_RETURN
typedef struct {
    GLenum readTarget;
    GLenum writeTarget;
    GLintptr readOffset;
    GLintptr writeOffset;
    GLsizeiptr size;
} glCopyBufferSubData_ARGS;
typedef struct {
    int index;
    glCopyBufferSubData_ARGS args;
} glCopyBufferSubData_PACKED;
#endif
#ifndef glCopyColorSubTable_RETURN
typedef struct {
    GLenum target;
    GLsizei start;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyColorSubTable_ARGS;
typedef struct {
    int index;
    glCopyColorSubTable_ARGS args;
} glCopyColorSubTable_PACKED;
#endif
#ifndef glCopyColorSubTableEXT_RETURN
typedef struct {
    GLenum target;
    GLsizei start;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyColorSubTableEXT_ARGS;
typedef struct {
    int index;
    glCopyColorSubTableEXT_ARGS args;
} glCopyColorSubTableEXT_PACKED;
#endif
#ifndef glCopyColorTable_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyColorTable_ARGS;
typedef struct {
    int index;
    glCopyColorTable_ARGS args;
} glCopyColorTable_PACKED;
#endif
#ifndef glCopyColorTableSGI_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyColorTableSGI_ARGS;
typedef struct {
    int index;
    glCopyColorTableSGI_ARGS args;
} glCopyColorTableSGI_PACKED;
#endif
#ifndef glCopyConvolutionFilter1D_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyConvolutionFilter1D_ARGS;
typedef struct {
    int index;
    glCopyConvolutionFilter1D_ARGS args;
} glCopyConvolutionFilter1D_PACKED;
#endif
#ifndef glCopyConvolutionFilter1DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyConvolutionFilter1DEXT_ARGS;
typedef struct {
    int index;
    glCopyConvolutionFilter1DEXT_ARGS args;
} glCopyConvolutionFilter1DEXT_PACKED;
#endif
#ifndef glCopyConvolutionFilter2D_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyConvolutionFilter2D_ARGS;
typedef struct {
    int index;
    glCopyConvolutionFilter2D_ARGS args;
} glCopyConvolutionFilter2D_PACKED;
#endif
#ifndef glCopyConvolutionFilter2DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyConvolutionFilter2DEXT_ARGS;
typedef struct {
    int index;
    glCopyConvolutionFilter2DEXT_ARGS args;
} glCopyConvolutionFilter2DEXT_PACKED;
#endif
#ifndef glCopyImageSubData_RETURN
typedef struct {
    GLuint srcName;
    GLenum srcTarget;
    GLint srcLevel;
    GLint srcX;
    GLint srcY;
    GLint srcZ;
    GLuint dstName;
    GLenum dstTarget;
    GLint dstLevel;
    GLint dstX;
    GLint dstY;
    GLint dstZ;
    GLsizei srcWidth;
    GLsizei srcHeight;
    GLsizei srcDepth;
} glCopyImageSubData_ARGS;
typedef struct {
    int index;
    glCopyImageSubData_ARGS args;
} glCopyImageSubData_PACKED;
#endif
#ifndef glCopyImageSubDataNV_RETURN
typedef struct {
    GLuint srcName;
    GLenum srcTarget;
    GLint srcLevel;
    GLint srcX;
    GLint srcY;
    GLint srcZ;
    GLuint dstName;
    GLenum dstTarget;
    GLint dstLevel;
    GLint dstX;
    GLint dstY;
    GLint dstZ;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} glCopyImageSubDataNV_ARGS;
typedef struct {
    int index;
    glCopyImageSubDataNV_ARGS args;
} glCopyImageSubDataNV_PACKED;
#endif
#ifndef glCopyMultiTexImage1DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} glCopyMultiTexImage1DEXT_ARGS;
typedef struct {
    int index;
    glCopyMultiTexImage1DEXT_ARGS args;
} glCopyMultiTexImage1DEXT_PACKED;
#endif
#ifndef glCopyMultiTexImage2DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} glCopyMultiTexImage2DEXT_ARGS;
typedef struct {
    int index;
    glCopyMultiTexImage2DEXT_ARGS args;
} glCopyMultiTexImage2DEXT_PACKED;
#endif
#ifndef glCopyMultiTexSubImage1DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyMultiTexSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glCopyMultiTexSubImage1DEXT_ARGS args;
} glCopyMultiTexSubImage1DEXT_PACKED;
#endif
#ifndef glCopyMultiTexSubImage2DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyMultiTexSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glCopyMultiTexSubImage2DEXT_ARGS args;
} glCopyMultiTexSubImage2DEXT_PACKED;
#endif
#ifndef glCopyMultiTexSubImage3DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyMultiTexSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glCopyMultiTexSubImage3DEXT_ARGS args;
} glCopyMultiTexSubImage3DEXT_PACKED;
#endif
#ifndef glCopyPathNV_RETURN
typedef struct {
    GLuint resultPath;
    GLuint srcPath;
} glCopyPathNV_ARGS;
typedef struct {
    int index;
    glCopyPathNV_ARGS args;
} glCopyPathNV_PACKED;
#endif
#ifndef glCopyPixels_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum type;
} glCopyPixels_ARGS;
typedef struct {
    int index;
    glCopyPixels_ARGS args;
} glCopyPixels_PACKED;
#endif
#ifndef glCopyTexImage1D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} glCopyTexImage1D_ARGS;
typedef struct {
    int index;
    glCopyTexImage1D_ARGS args;
} glCopyTexImage1D_PACKED;
#endif
#ifndef glCopyTexImage1DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} glCopyTexImage1DEXT_ARGS;
typedef struct {
    int index;
    glCopyTexImage1DEXT_ARGS args;
} glCopyTexImage1DEXT_PACKED;
#endif
#ifndef glCopyTexImage2D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} glCopyTexImage2D_ARGS;
typedef struct {
    int index;
    glCopyTexImage2D_ARGS args;
} glCopyTexImage2D_PACKED;
#endif
#ifndef glCopyTexImage2DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} glCopyTexImage2DEXT_ARGS;
typedef struct {
    int index;
    glCopyTexImage2DEXT_ARGS args;
} glCopyTexImage2DEXT_PACKED;
#endif
#ifndef glCopyTexSubImage1D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyTexSubImage1D_ARGS;
typedef struct {
    int index;
    glCopyTexSubImage1D_ARGS args;
} glCopyTexSubImage1D_PACKED;
#endif
#ifndef glCopyTexSubImage1DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyTexSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glCopyTexSubImage1DEXT_ARGS args;
} glCopyTexSubImage1DEXT_PACKED;
#endif
#ifndef glCopyTexSubImage2D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyTexSubImage2D_ARGS;
typedef struct {
    int index;
    glCopyTexSubImage2D_ARGS args;
} glCopyTexSubImage2D_PACKED;
#endif
#ifndef glCopyTexSubImage2DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyTexSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glCopyTexSubImage2DEXT_ARGS args;
} glCopyTexSubImage2DEXT_PACKED;
#endif
#ifndef glCopyTexSubImage3D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyTexSubImage3D_ARGS;
typedef struct {
    int index;
    glCopyTexSubImage3D_ARGS args;
} glCopyTexSubImage3D_PACKED;
#endif
#ifndef glCopyTexSubImage3DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyTexSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glCopyTexSubImage3DEXT_ARGS args;
} glCopyTexSubImage3DEXT_PACKED;
#endif
#ifndef glCopyTextureImage1DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} glCopyTextureImage1DEXT_ARGS;
typedef struct {
    int index;
    glCopyTextureImage1DEXT_ARGS args;
} glCopyTextureImage1DEXT_PACKED;
#endif
#ifndef glCopyTextureImage2DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} glCopyTextureImage2DEXT_ARGS;
typedef struct {
    int index;
    glCopyTextureImage2DEXT_ARGS args;
} glCopyTextureImage2DEXT_PACKED;
#endif
#ifndef glCopyTextureSubImage1DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} glCopyTextureSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glCopyTextureSubImage1DEXT_ARGS args;
} glCopyTextureSubImage1DEXT_PACKED;
#endif
#ifndef glCopyTextureSubImage2DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyTextureSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glCopyTextureSubImage2DEXT_ARGS args;
} glCopyTextureSubImage2DEXT_PACKED;
#endif
#ifndef glCopyTextureSubImage3DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glCopyTextureSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glCopyTextureSubImage3DEXT_ARGS args;
} glCopyTextureSubImage3DEXT_PACKED;
#endif
#ifndef glCoverFillPathInstancedNV_RETURN
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLenum coverMode;
    GLenum transformType;
    GLfloat * transformValues;
} glCoverFillPathInstancedNV_ARGS;
typedef struct {
    int index;
    glCoverFillPathInstancedNV_ARGS args;
} glCoverFillPathInstancedNV_PACKED;
#endif
#ifndef glCoverFillPathNV_RETURN
typedef struct {
    GLuint path;
    GLenum coverMode;
} glCoverFillPathNV_ARGS;
typedef struct {
    int index;
    glCoverFillPathNV_ARGS args;
} glCoverFillPathNV_PACKED;
#endif
#ifndef glCoverStrokePathInstancedNV_RETURN
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLenum coverMode;
    GLenum transformType;
    GLfloat * transformValues;
} glCoverStrokePathInstancedNV_ARGS;
typedef struct {
    int index;
    glCoverStrokePathInstancedNV_ARGS args;
} glCoverStrokePathInstancedNV_PACKED;
#endif
#ifndef glCoverStrokePathNV_RETURN
typedef struct {
    GLuint path;
    GLenum coverMode;
} glCoverStrokePathNV_ARGS;
typedef struct {
    int index;
    glCoverStrokePathNV_ARGS args;
} glCoverStrokePathNV_PACKED;
#endif
#ifndef glCreateProgram_RETURN
typedef struct {
    int index;
} glCreateProgram_PACKED;
#endif
#ifndef glCreateProgramObjectARB_RETURN
typedef struct {
    int index;
} glCreateProgramObjectARB_PACKED;
#endif
#ifndef glCreateShader_RETURN
typedef struct {
    GLenum type;
} glCreateShader_ARGS;
typedef struct {
    int index;
    glCreateShader_ARGS args;
} glCreateShader_PACKED;
#endif
#ifndef glCreateShaderObjectARB_RETURN
typedef struct {
    GLenum shaderType;
} glCreateShaderObjectARB_ARGS;
typedef struct {
    int index;
    glCreateShaderObjectARB_ARGS args;
} glCreateShaderObjectARB_PACKED;
#endif
#ifndef glCreateShaderProgramEXT_RETURN
typedef struct {
    GLenum type;
    GLchar * string;
} glCreateShaderProgramEXT_ARGS;
typedef struct {
    int index;
    glCreateShaderProgramEXT_ARGS args;
} glCreateShaderProgramEXT_PACKED;
#endif
#ifndef glCreateShaderProgramv_RETURN
typedef struct {
    GLenum type;
    GLsizei count;
    GLchar*const * strings;
} glCreateShaderProgramv_ARGS;
typedef struct {
    int index;
    glCreateShaderProgramv_ARGS args;
} glCreateShaderProgramv_PACKED;
#endif
#ifndef glCreateSyncFromCLeventARB_RETURN
typedef struct {
    struct _cl_context * context;
    struct _cl_event * event;
    GLbitfield flags;
} glCreateSyncFromCLeventARB_ARGS;
typedef struct {
    int index;
    glCreateSyncFromCLeventARB_ARGS args;
} glCreateSyncFromCLeventARB_PACKED;
#endif
#ifndef glCullFace_RETURN
typedef struct {
    GLenum mode;
} glCullFace_ARGS;
typedef struct {
    int index;
    glCullFace_ARGS args;
} glCullFace_PACKED;
#endif
#ifndef glCullParameterdvEXT_RETURN
typedef struct {
    GLenum pname;
    GLdouble * params;
} glCullParameterdvEXT_ARGS;
typedef struct {
    int index;
    glCullParameterdvEXT_ARGS args;
} glCullParameterdvEXT_PACKED;
#endif
#ifndef glCullParameterfvEXT_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glCullParameterfvEXT_ARGS;
typedef struct {
    int index;
    glCullParameterfvEXT_ARGS args;
} glCullParameterfvEXT_PACKED;
#endif
#ifndef glCurrentPaletteMatrixARB_RETURN
typedef struct {
    GLint index;
} glCurrentPaletteMatrixARB_ARGS;
typedef struct {
    int index;
    glCurrentPaletteMatrixARB_ARGS args;
} glCurrentPaletteMatrixARB_PACKED;
#endif
#ifndef glDebugMessageCallback_RETURN
typedef struct {
    GLDEBUGPROC callback;
    void * userParam;
} glDebugMessageCallback_ARGS;
typedef struct {
    int index;
    glDebugMessageCallback_ARGS args;
} glDebugMessageCallback_PACKED;
#endif
#ifndef glDebugMessageCallbackAMD_RETURN
typedef struct {
    GLDEBUGPROCAMD callback;
    GLvoid * userParam;
} glDebugMessageCallbackAMD_ARGS;
typedef struct {
    int index;
    glDebugMessageCallbackAMD_ARGS args;
} glDebugMessageCallbackAMD_PACKED;
#endif
#ifndef glDebugMessageCallbackARB_RETURN
typedef struct {
    GLDEBUGPROCARB callback;
    GLvoid * userParam;
} glDebugMessageCallbackARB_ARGS;
typedef struct {
    int index;
    glDebugMessageCallbackARB_ARGS args;
} glDebugMessageCallbackARB_PACKED;
#endif
#ifndef glDebugMessageControl_RETURN
typedef struct {
    GLenum source;
    GLenum type;
    GLenum severity;
    GLsizei count;
    GLuint * ids;
    GLboolean enabled;
} glDebugMessageControl_ARGS;
typedef struct {
    int index;
    glDebugMessageControl_ARGS args;
} glDebugMessageControl_PACKED;
#endif
#ifndef glDebugMessageControlARB_RETURN
typedef struct {
    GLenum source;
    GLenum type;
    GLenum severity;
    GLsizei count;
    GLuint * ids;
    GLboolean enabled;
} glDebugMessageControlARB_ARGS;
typedef struct {
    int index;
    glDebugMessageControlARB_ARGS args;
} glDebugMessageControlARB_PACKED;
#endif
#ifndef glDebugMessageEnableAMD_RETURN
typedef struct {
    GLenum category;
    GLenum severity;
    GLsizei count;
    GLuint * ids;
    GLboolean enabled;
} glDebugMessageEnableAMD_ARGS;
typedef struct {
    int index;
    glDebugMessageEnableAMD_ARGS args;
} glDebugMessageEnableAMD_PACKED;
#endif
#ifndef glDebugMessageInsert_RETURN
typedef struct {
    GLenum source;
    GLenum type;
    GLuint id;
    GLenum severity;
    GLsizei length;
    GLchar * buf;
} glDebugMessageInsert_ARGS;
typedef struct {
    int index;
    glDebugMessageInsert_ARGS args;
} glDebugMessageInsert_PACKED;
#endif
#ifndef glDebugMessageInsertAMD_RETURN
typedef struct {
    GLenum category;
    GLenum severity;
    GLuint id;
    GLsizei length;
    GLchar * buf;
} glDebugMessageInsertAMD_ARGS;
typedef struct {
    int index;
    glDebugMessageInsertAMD_ARGS args;
} glDebugMessageInsertAMD_PACKED;
#endif
#ifndef glDebugMessageInsertARB_RETURN
typedef struct {
    GLenum source;
    GLenum type;
    GLuint id;
    GLenum severity;
    GLsizei length;
    GLchar * buf;
} glDebugMessageInsertARB_ARGS;
typedef struct {
    int index;
    glDebugMessageInsertARB_ARGS args;
} glDebugMessageInsertARB_PACKED;
#endif
#ifndef glDeformSGIX_RETURN
typedef struct {
    GLbitfield mask;
} glDeformSGIX_ARGS;
typedef struct {
    int index;
    glDeformSGIX_ARGS args;
} glDeformSGIX_PACKED;
#endif
#ifndef glDeformationMap3dSGIX_RETURN
typedef struct {
    GLenum target;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint ustride;
    GLint uorder;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLint vstride;
    GLint vorder;
    GLdouble w1 __attribute__ ((aligned(8)));
    GLdouble w2 __attribute__ ((aligned(8)));
    GLint wstride;
    GLint worder;
    GLdouble * points;
} glDeformationMap3dSGIX_ARGS;
typedef struct {
    int index;
    glDeformationMap3dSGIX_ARGS args;
} glDeformationMap3dSGIX_PACKED;
#endif
#ifndef glDeformationMap3fSGIX_RETURN
typedef struct {
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLfloat w1;
    GLfloat w2;
    GLint wstride;
    GLint worder;
    GLfloat * points;
} glDeformationMap3fSGIX_ARGS;
typedef struct {
    int index;
    glDeformationMap3fSGIX_ARGS args;
} glDeformationMap3fSGIX_PACKED;
#endif
#ifndef glDeleteAsyncMarkersSGIX_RETURN
typedef struct {
    GLuint marker;
    GLsizei range;
} glDeleteAsyncMarkersSGIX_ARGS;
typedef struct {
    int index;
    glDeleteAsyncMarkersSGIX_ARGS args;
} glDeleteAsyncMarkersSGIX_PACKED;
#endif
#ifndef glDeleteBuffers_RETURN
typedef struct {
    GLsizei n;
    GLuint * buffers;
} glDeleteBuffers_ARGS;
typedef struct {
    int index;
    glDeleteBuffers_ARGS args;
} glDeleteBuffers_PACKED;
#endif
#ifndef glDeleteBuffersARB_RETURN
typedef struct {
    GLsizei n;
    GLuint * buffers;
} glDeleteBuffersARB_ARGS;
typedef struct {
    int index;
    glDeleteBuffersARB_ARGS args;
} glDeleteBuffersARB_PACKED;
#endif
#ifndef glDeleteFencesAPPLE_RETURN
typedef struct {
    GLsizei n;
    GLuint * fences;
} glDeleteFencesAPPLE_ARGS;
typedef struct {
    int index;
    glDeleteFencesAPPLE_ARGS args;
} glDeleteFencesAPPLE_PACKED;
#endif
#ifndef glDeleteFencesNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * fences;
} glDeleteFencesNV_ARGS;
typedef struct {
    int index;
    glDeleteFencesNV_ARGS args;
} glDeleteFencesNV_PACKED;
#endif
#ifndef glDeleteFragmentShaderATI_RETURN
typedef struct {
    GLuint id;
} glDeleteFragmentShaderATI_ARGS;
typedef struct {
    int index;
    glDeleteFragmentShaderATI_ARGS args;
} glDeleteFragmentShaderATI_PACKED;
#endif
#ifndef glDeleteFramebuffers_RETURN
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} glDeleteFramebuffers_ARGS;
typedef struct {
    int index;
    glDeleteFramebuffers_ARGS args;
} glDeleteFramebuffers_PACKED;
#endif
#ifndef glDeleteFramebuffersEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} glDeleteFramebuffersEXT_ARGS;
typedef struct {
    int index;
    glDeleteFramebuffersEXT_ARGS args;
} glDeleteFramebuffersEXT_PACKED;
#endif
#ifndef glDeleteLists_RETURN
typedef struct {
    GLuint list;
    GLsizei range;
} glDeleteLists_ARGS;
typedef struct {
    int index;
    glDeleteLists_ARGS args;
} glDeleteLists_PACKED;
#endif
#ifndef glDeleteNamedStringARB_RETURN
typedef struct {
    GLint namelen;
    GLchar * name;
} glDeleteNamedStringARB_ARGS;
typedef struct {
    int index;
    glDeleteNamedStringARB_ARGS args;
} glDeleteNamedStringARB_PACKED;
#endif
#ifndef glDeleteNamesAMD_RETURN
typedef struct {
    GLenum identifier;
    GLuint num;
    GLuint * names;
} glDeleteNamesAMD_ARGS;
typedef struct {
    int index;
    glDeleteNamesAMD_ARGS args;
} glDeleteNamesAMD_PACKED;
#endif
#ifndef glDeleteObjectARB_RETURN
typedef struct {
    GLhandleARB obj;
} glDeleteObjectARB_ARGS;
typedef struct {
    int index;
    glDeleteObjectARB_ARGS args;
} glDeleteObjectARB_PACKED;
#endif
#ifndef glDeleteOcclusionQueriesNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glDeleteOcclusionQueriesNV_ARGS;
typedef struct {
    int index;
    glDeleteOcclusionQueriesNV_ARGS args;
} glDeleteOcclusionQueriesNV_PACKED;
#endif
#ifndef glDeletePathsNV_RETURN
typedef struct {
    GLuint path;
    GLsizei range;
} glDeletePathsNV_ARGS;
typedef struct {
    int index;
    glDeletePathsNV_ARGS args;
} glDeletePathsNV_PACKED;
#endif
#ifndef glDeletePerfMonitorsAMD_RETURN
typedef struct {
    GLsizei n;
    GLuint * monitors;
} glDeletePerfMonitorsAMD_ARGS;
typedef struct {
    int index;
    glDeletePerfMonitorsAMD_ARGS args;
} glDeletePerfMonitorsAMD_PACKED;
#endif
#ifndef glDeleteProgram_RETURN
typedef struct {
    GLuint program;
} glDeleteProgram_ARGS;
typedef struct {
    int index;
    glDeleteProgram_ARGS args;
} glDeleteProgram_PACKED;
#endif
#ifndef glDeleteProgramPipelines_RETURN
typedef struct {
    GLsizei n;
    GLuint * pipelines;
} glDeleteProgramPipelines_ARGS;
typedef struct {
    int index;
    glDeleteProgramPipelines_ARGS args;
} glDeleteProgramPipelines_PACKED;
#endif
#ifndef glDeleteProgramsARB_RETURN
typedef struct {
    GLsizei n;
    GLuint * programs;
} glDeleteProgramsARB_ARGS;
typedef struct {
    int index;
    glDeleteProgramsARB_ARGS args;
} glDeleteProgramsARB_PACKED;
#endif
#ifndef glDeleteProgramsNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * programs;
} glDeleteProgramsNV_ARGS;
typedef struct {
    int index;
    glDeleteProgramsNV_ARGS args;
} glDeleteProgramsNV_PACKED;
#endif
#ifndef glDeleteQueries_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glDeleteQueries_ARGS;
typedef struct {
    int index;
    glDeleteQueries_ARGS args;
} glDeleteQueries_PACKED;
#endif
#ifndef glDeleteQueriesARB_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glDeleteQueriesARB_ARGS;
typedef struct {
    int index;
    glDeleteQueriesARB_ARGS args;
} glDeleteQueriesARB_PACKED;
#endif
#ifndef glDeleteRenderbuffers_RETURN
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} glDeleteRenderbuffers_ARGS;
typedef struct {
    int index;
    glDeleteRenderbuffers_ARGS args;
} glDeleteRenderbuffers_PACKED;
#endif
#ifndef glDeleteRenderbuffersEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} glDeleteRenderbuffersEXT_ARGS;
typedef struct {
    int index;
    glDeleteRenderbuffersEXT_ARGS args;
} glDeleteRenderbuffersEXT_PACKED;
#endif
#ifndef glDeleteSamplers_RETURN
typedef struct {
    GLsizei count;
    GLuint * samplers;
} glDeleteSamplers_ARGS;
typedef struct {
    int index;
    glDeleteSamplers_ARGS args;
} glDeleteSamplers_PACKED;
#endif
#ifndef glDeleteShader_RETURN
typedef struct {
    GLuint shader;
} glDeleteShader_ARGS;
typedef struct {
    int index;
    glDeleteShader_ARGS args;
} glDeleteShader_PACKED;
#endif
#ifndef glDeleteSync_RETURN
typedef struct {
    GLsync sync;
} glDeleteSync_ARGS;
typedef struct {
    int index;
    glDeleteSync_ARGS args;
} glDeleteSync_PACKED;
#endif
#ifndef glDeleteTextures_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
} glDeleteTextures_ARGS;
typedef struct {
    int index;
    glDeleteTextures_ARGS args;
} glDeleteTextures_PACKED;
#endif
#ifndef glDeleteTexturesEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
} glDeleteTexturesEXT_ARGS;
typedef struct {
    int index;
    glDeleteTexturesEXT_ARGS args;
} glDeleteTexturesEXT_PACKED;
#endif
#ifndef glDeleteTransformFeedbacks_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glDeleteTransformFeedbacks_ARGS;
typedef struct {
    int index;
    glDeleteTransformFeedbacks_ARGS args;
} glDeleteTransformFeedbacks_PACKED;
#endif
#ifndef glDeleteTransformFeedbacksNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glDeleteTransformFeedbacksNV_ARGS;
typedef struct {
    int index;
    glDeleteTransformFeedbacksNV_ARGS args;
} glDeleteTransformFeedbacksNV_PACKED;
#endif
#ifndef glDeleteVertexArrays_RETURN
typedef struct {
    GLsizei n;
    GLuint * arrays;
} glDeleteVertexArrays_ARGS;
typedef struct {
    int index;
    glDeleteVertexArrays_ARGS args;
} glDeleteVertexArrays_PACKED;
#endif
#ifndef glDeleteVertexArraysAPPLE_RETURN
typedef struct {
    GLsizei n;
    GLuint * arrays;
} glDeleteVertexArraysAPPLE_ARGS;
typedef struct {
    int index;
    glDeleteVertexArraysAPPLE_ARGS args;
} glDeleteVertexArraysAPPLE_PACKED;
#endif
#ifndef glDeleteVertexShaderEXT_RETURN
typedef struct {
    GLuint id;
} glDeleteVertexShaderEXT_ARGS;
typedef struct {
    int index;
    glDeleteVertexShaderEXT_ARGS args;
} glDeleteVertexShaderEXT_PACKED;
#endif
#ifndef glDepthBoundsEXT_RETURN
typedef struct {
    GLclampd zmin;
    GLclampd zmax;
} glDepthBoundsEXT_ARGS;
typedef struct {
    int index;
    glDepthBoundsEXT_ARGS args;
} glDepthBoundsEXT_PACKED;
#endif
#ifndef glDepthBoundsdNV_RETURN
typedef struct {
    GLdouble zmin __attribute__ ((aligned(8)));
    GLdouble zmax __attribute__ ((aligned(8)));
} glDepthBoundsdNV_ARGS;
typedef struct {
    int index;
    glDepthBoundsdNV_ARGS args;
} glDepthBoundsdNV_PACKED;
#endif
#ifndef glDepthFunc_RETURN
typedef struct {
    GLenum func;
} glDepthFunc_ARGS;
typedef struct {
    int index;
    glDepthFunc_ARGS args;
} glDepthFunc_PACKED;
#endif
#ifndef glDepthMask_RETURN
typedef struct {
    GLboolean flag;
} glDepthMask_ARGS;
typedef struct {
    int index;
    glDepthMask_ARGS args;
} glDepthMask_PACKED;
#endif
#ifndef glDepthRange_RETURN
typedef struct {
    GLdouble near __attribute__ ((aligned(8)));
    GLdouble far __attribute__ ((aligned(8)));
} glDepthRange_ARGS;
typedef struct {
    int index;
    glDepthRange_ARGS args;
} glDepthRange_PACKED;
#endif
#ifndef glDepthRangeArrayv_RETURN
typedef struct {
    GLuint first;
    GLsizei count;
    GLdouble * v;
} glDepthRangeArrayv_ARGS;
typedef struct {
    int index;
    glDepthRangeArrayv_ARGS args;
} glDepthRangeArrayv_PACKED;
#endif
#ifndef glDepthRangeIndexed_RETURN
typedef struct {
    GLuint index;
    GLdouble n __attribute__ ((aligned(8)));
    GLdouble f __attribute__ ((aligned(8)));
} glDepthRangeIndexed_ARGS;
typedef struct {
    int index;
    glDepthRangeIndexed_ARGS args;
} glDepthRangeIndexed_PACKED;
#endif
#ifndef glDepthRangedNV_RETURN
typedef struct {
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} glDepthRangedNV_ARGS;
typedef struct {
    int index;
    glDepthRangedNV_ARGS args;
} glDepthRangedNV_PACKED;
#endif
#ifndef glDepthRangef_RETURN
typedef struct {
    GLfloat near;
    GLfloat far;
} glDepthRangef_ARGS;
typedef struct {
    int index;
    glDepthRangef_ARGS args;
} glDepthRangef_PACKED;
#endif
#ifndef glDepthRangefOES_RETURN
typedef struct {
    GLclampf n;
    GLclampf f;
} glDepthRangefOES_ARGS;
typedef struct {
    int index;
    glDepthRangefOES_ARGS args;
} glDepthRangefOES_PACKED;
#endif
#ifndef glDepthRangexOES_RETURN
typedef struct {
    GLfixed n;
    GLfixed f;
} glDepthRangexOES_ARGS;
typedef struct {
    int index;
    glDepthRangexOES_ARGS args;
} glDepthRangexOES_PACKED;
#endif
#ifndef glDetachObjectARB_RETURN
typedef struct {
    GLhandleARB containerObj;
    GLhandleARB attachedObj;
} glDetachObjectARB_ARGS;
typedef struct {
    int index;
    glDetachObjectARB_ARGS args;
} glDetachObjectARB_PACKED;
#endif
#ifndef glDetachShader_RETURN
typedef struct {
    GLuint program;
    GLuint shader;
} glDetachShader_ARGS;
typedef struct {
    int index;
    glDetachShader_ARGS args;
} glDetachShader_PACKED;
#endif
#ifndef glDetailTexFuncSGIS_RETURN
typedef struct {
    GLenum target;
    GLsizei n;
    GLfloat * points;
} glDetailTexFuncSGIS_ARGS;
typedef struct {
    int index;
    glDetailTexFuncSGIS_ARGS args;
} glDetailTexFuncSGIS_PACKED;
#endif
#ifndef glDisable_RETURN
typedef struct {
    GLenum cap;
} glDisable_ARGS;
typedef struct {
    int index;
    glDisable_ARGS args;
} glDisable_PACKED;
#endif
#ifndef glDisableClientState_RETURN
typedef struct {
    GLenum array;
} glDisableClientState_ARGS;
typedef struct {
    int index;
    glDisableClientState_ARGS args;
} glDisableClientState_PACKED;
#endif
#ifndef glDisableClientStateIndexedEXT_RETURN
typedef struct {
    GLenum array;
    GLuint index;
} glDisableClientStateIndexedEXT_ARGS;
typedef struct {
    int index;
    glDisableClientStateIndexedEXT_ARGS args;
} glDisableClientStateIndexedEXT_PACKED;
#endif
#ifndef glDisableClientStateiEXT_RETURN
typedef struct {
    GLenum array;
    GLuint index;
} glDisableClientStateiEXT_ARGS;
typedef struct {
    int index;
    glDisableClientStateiEXT_ARGS args;
} glDisableClientStateiEXT_PACKED;
#endif
#ifndef glDisableIndexedEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
} glDisableIndexedEXT_ARGS;
typedef struct {
    int index;
    glDisableIndexedEXT_ARGS args;
} glDisableIndexedEXT_PACKED;
#endif
#ifndef glDisableVariantClientStateEXT_RETURN
typedef struct {
    GLuint id;
} glDisableVariantClientStateEXT_ARGS;
typedef struct {
    int index;
    glDisableVariantClientStateEXT_ARGS args;
} glDisableVariantClientStateEXT_PACKED;
#endif
#ifndef glDisableVertexArrayAttribEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint index;
} glDisableVertexArrayAttribEXT_ARGS;
typedef struct {
    int index;
    glDisableVertexArrayAttribEXT_ARGS args;
} glDisableVertexArrayAttribEXT_PACKED;
#endif
#ifndef glDisableVertexArrayEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLenum array;
} glDisableVertexArrayEXT_ARGS;
typedef struct {
    int index;
    glDisableVertexArrayEXT_ARGS args;
} glDisableVertexArrayEXT_PACKED;
#endif
#ifndef glDisableVertexAttribAPPLE_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
} glDisableVertexAttribAPPLE_ARGS;
typedef struct {
    int index;
    glDisableVertexAttribAPPLE_ARGS args;
} glDisableVertexAttribAPPLE_PACKED;
#endif
#ifndef glDisableVertexAttribArray_RETURN
typedef struct {
    GLuint index;
} glDisableVertexAttribArray_ARGS;
typedef struct {
    int index;
    glDisableVertexAttribArray_ARGS args;
} glDisableVertexAttribArray_PACKED;
#endif
#ifndef glDisableVertexAttribArrayARB_RETURN
typedef struct {
    GLuint index;
} glDisableVertexAttribArrayARB_ARGS;
typedef struct {
    int index;
    glDisableVertexAttribArrayARB_ARGS args;
} glDisableVertexAttribArrayARB_PACKED;
#endif
#ifndef glDisablei_RETURN
typedef struct {
    GLenum target;
    GLuint index;
} glDisablei_ARGS;
typedef struct {
    int index;
    glDisablei_ARGS args;
} glDisablei_PACKED;
#endif
#ifndef glDispatchCompute_RETURN
typedef struct {
    GLuint num_groups_x;
    GLuint num_groups_y;
    GLuint num_groups_z;
} glDispatchCompute_ARGS;
typedef struct {
    int index;
    glDispatchCompute_ARGS args;
} glDispatchCompute_PACKED;
#endif
#ifndef glDispatchComputeIndirect_RETURN
typedef struct {
    GLintptr indirect;
} glDispatchComputeIndirect_ARGS;
typedef struct {
    int index;
    glDispatchComputeIndirect_ARGS args;
} glDispatchComputeIndirect_PACKED;
#endif
#ifndef glDrawArrays_RETURN
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
} glDrawArrays_ARGS;
typedef struct {
    int index;
    glDrawArrays_ARGS args;
} glDrawArrays_PACKED;
#endif
#ifndef glDrawArraysEXT_RETURN
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
} glDrawArraysEXT_ARGS;
typedef struct {
    int index;
    glDrawArraysEXT_ARGS args;
} glDrawArraysEXT_PACKED;
#endif
#ifndef glDrawArraysIndirect_RETURN
typedef struct {
    GLenum mode;
    GLvoid * indirect;
} glDrawArraysIndirect_ARGS;
typedef struct {
    int index;
    glDrawArraysIndirect_ARGS args;
} glDrawArraysIndirect_PACKED;
#endif
#ifndef glDrawArraysInstanced_RETURN
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei instancecount;
} glDrawArraysInstanced_ARGS;
typedef struct {
    int index;
    glDrawArraysInstanced_ARGS args;
} glDrawArraysInstanced_PACKED;
#endif
#ifndef glDrawArraysInstancedARB_RETURN
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei primcount;
} glDrawArraysInstancedARB_ARGS;
typedef struct {
    int index;
    glDrawArraysInstancedARB_ARGS args;
} glDrawArraysInstancedARB_PACKED;
#endif
#ifndef glDrawArraysInstancedBaseInstance_RETURN
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei instancecount;
    GLuint baseinstance;
} glDrawArraysInstancedBaseInstance_ARGS;
typedef struct {
    int index;
    glDrawArraysInstancedBaseInstance_ARGS args;
} glDrawArraysInstancedBaseInstance_PACKED;
#endif
#ifndef glDrawArraysInstancedEXT_RETURN
typedef struct {
    GLenum mode;
    GLint start;
    GLsizei count;
    GLsizei primcount;
} glDrawArraysInstancedEXT_ARGS;
typedef struct {
    int index;
    glDrawArraysInstancedEXT_ARGS args;
} glDrawArraysInstancedEXT_PACKED;
#endif
#ifndef glDrawBuffer_RETURN
typedef struct {
    GLenum mode;
} glDrawBuffer_ARGS;
typedef struct {
    int index;
    glDrawBuffer_ARGS args;
} glDrawBuffer_PACKED;
#endif
#ifndef glDrawBuffers_RETURN
typedef struct {
    GLsizei n;
    GLenum * bufs;
} glDrawBuffers_ARGS;
typedef struct {
    int index;
    glDrawBuffers_ARGS args;
} glDrawBuffers_PACKED;
#endif
#ifndef glDrawBuffersARB_RETURN
typedef struct {
    GLsizei n;
    GLenum * bufs;
} glDrawBuffersARB_ARGS;
typedef struct {
    int index;
    glDrawBuffersARB_ARGS args;
} glDrawBuffersARB_PACKED;
#endif
#ifndef glDrawBuffersATI_RETURN
typedef struct {
    GLsizei n;
    GLenum * bufs;
} glDrawBuffersATI_ARGS;
typedef struct {
    int index;
    glDrawBuffersATI_ARGS args;
} glDrawBuffersATI_PACKED;
#endif
#ifndef glDrawElementArrayAPPLE_RETURN
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
} glDrawElementArrayAPPLE_ARGS;
typedef struct {
    int index;
    glDrawElementArrayAPPLE_ARGS args;
} glDrawElementArrayAPPLE_PACKED;
#endif
#ifndef glDrawElementArrayATI_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
} glDrawElementArrayATI_ARGS;
typedef struct {
    int index;
    glDrawElementArrayATI_ARGS args;
} glDrawElementArrayATI_PACKED;
#endif
#ifndef glDrawElements_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
} glDrawElements_ARGS;
typedef struct {
    int index;
    glDrawElements_ARGS args;
} glDrawElements_PACKED;
#endif
#ifndef glDrawElementsBaseVertex_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLint basevertex;
} glDrawElementsBaseVertex_ARGS;
typedef struct {
    int index;
    glDrawElementsBaseVertex_ARGS args;
} glDrawElementsBaseVertex_PACKED;
#endif
#ifndef glDrawElementsIndirect_RETURN
typedef struct {
    GLenum mode;
    GLenum type;
    GLvoid * indirect;
} glDrawElementsIndirect_ARGS;
typedef struct {
    int index;
    glDrawElementsIndirect_ARGS args;
} glDrawElementsIndirect_PACKED;
#endif
#ifndef glDrawElementsInstanced_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei instancecount;
} glDrawElementsInstanced_ARGS;
typedef struct {
    int index;
    glDrawElementsInstanced_ARGS args;
} glDrawElementsInstanced_PACKED;
#endif
#ifndef glDrawElementsInstancedARB_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei primcount;
} glDrawElementsInstancedARB_ARGS;
typedef struct {
    int index;
    glDrawElementsInstancedARB_ARGS args;
} glDrawElementsInstancedARB_PACKED;
#endif
#ifndef glDrawElementsInstancedBaseInstance_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    void * indices;
    GLsizei instancecount;
    GLuint baseinstance;
} glDrawElementsInstancedBaseInstance_ARGS;
typedef struct {
    int index;
    glDrawElementsInstancedBaseInstance_ARGS args;
} glDrawElementsInstancedBaseInstance_PACKED;
#endif
#ifndef glDrawElementsInstancedBaseVertex_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei instancecount;
    GLint basevertex;
} glDrawElementsInstancedBaseVertex_ARGS;
typedef struct {
    int index;
    glDrawElementsInstancedBaseVertex_ARGS args;
} glDrawElementsInstancedBaseVertex_PACKED;
#endif
#ifndef glDrawElementsInstancedBaseVertexBaseInstance_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    void * indices;
    GLsizei instancecount;
    GLint basevertex;
    GLuint baseinstance;
} glDrawElementsInstancedBaseVertexBaseInstance_ARGS;
typedef struct {
    int index;
    glDrawElementsInstancedBaseVertexBaseInstance_ARGS args;
} glDrawElementsInstancedBaseVertexBaseInstance_PACKED;
#endif
#ifndef glDrawElementsInstancedEXT_RETURN
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei primcount;
} glDrawElementsInstancedEXT_ARGS;
typedef struct {
    int index;
    glDrawElementsInstancedEXT_ARGS args;
} glDrawElementsInstancedEXT_PACKED;
#endif
#ifndef glDrawMeshArraysSUN_RETURN
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei width;
} glDrawMeshArraysSUN_ARGS;
typedef struct {
    int index;
    glDrawMeshArraysSUN_ARGS args;
} glDrawMeshArraysSUN_PACKED;
#endif
#ifndef glDrawPixels_RETURN
typedef struct {
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glDrawPixels_ARGS;
typedef struct {
    int index;
    glDrawPixels_ARGS args;
} glDrawPixels_PACKED;
#endif
#ifndef glDrawRangeElementArrayAPPLE_RETURN
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLint first;
    GLsizei count;
} glDrawRangeElementArrayAPPLE_ARGS;
typedef struct {
    int index;
    glDrawRangeElementArrayAPPLE_ARGS args;
} glDrawRangeElementArrayAPPLE_PACKED;
#endif
#ifndef glDrawRangeElementArrayATI_RETURN
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
} glDrawRangeElementArrayATI_ARGS;
typedef struct {
    int index;
    glDrawRangeElementArrayATI_ARGS args;
} glDrawRangeElementArrayATI_PACKED;
#endif
#ifndef glDrawRangeElements_RETURN
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
} glDrawRangeElements_ARGS;
typedef struct {
    int index;
    glDrawRangeElements_ARGS args;
} glDrawRangeElements_PACKED;
#endif
#ifndef glDrawRangeElementsBaseVertex_RETURN
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLint basevertex;
} glDrawRangeElementsBaseVertex_ARGS;
typedef struct {
    int index;
    glDrawRangeElementsBaseVertex_ARGS args;
} glDrawRangeElementsBaseVertex_PACKED;
#endif
#ifndef glDrawRangeElementsEXT_RETURN
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
} glDrawRangeElementsEXT_ARGS;
typedef struct {
    int index;
    glDrawRangeElementsEXT_ARGS args;
} glDrawRangeElementsEXT_PACKED;
#endif
#ifndef glDrawTextureNV_RETURN
typedef struct {
    GLuint texture;
    GLuint sampler;
    GLfloat x0;
    GLfloat y0;
    GLfloat x1;
    GLfloat y1;
    GLfloat z;
    GLfloat s0;
    GLfloat t0;
    GLfloat s1;
    GLfloat t1;
} glDrawTextureNV_ARGS;
typedef struct {
    int index;
    glDrawTextureNV_ARGS args;
} glDrawTextureNV_PACKED;
#endif
#ifndef glDrawTransformFeedback_RETURN
typedef struct {
    GLenum mode;
    GLuint id;
} glDrawTransformFeedback_ARGS;
typedef struct {
    int index;
    glDrawTransformFeedback_ARGS args;
} glDrawTransformFeedback_PACKED;
#endif
#ifndef glDrawTransformFeedbackInstanced_RETURN
typedef struct {
    GLenum mode;
    GLuint id;
    GLsizei instancecount;
} glDrawTransformFeedbackInstanced_ARGS;
typedef struct {
    int index;
    glDrawTransformFeedbackInstanced_ARGS args;
} glDrawTransformFeedbackInstanced_PACKED;
#endif
#ifndef glDrawTransformFeedbackNV_RETURN
typedef struct {
    GLenum mode;
    GLuint id;
} glDrawTransformFeedbackNV_ARGS;
typedef struct {
    int index;
    glDrawTransformFeedbackNV_ARGS args;
} glDrawTransformFeedbackNV_PACKED;
#endif
#ifndef glDrawTransformFeedbackStream_RETURN
typedef struct {
    GLenum mode;
    GLuint id;
    GLuint stream;
} glDrawTransformFeedbackStream_ARGS;
typedef struct {
    int index;
    glDrawTransformFeedbackStream_ARGS args;
} glDrawTransformFeedbackStream_PACKED;
#endif
#ifndef glDrawTransformFeedbackStreamInstanced_RETURN
typedef struct {
    GLenum mode;
    GLuint id;
    GLuint stream;
    GLsizei instancecount;
} glDrawTransformFeedbackStreamInstanced_ARGS;
typedef struct {
    int index;
    glDrawTransformFeedbackStreamInstanced_ARGS args;
} glDrawTransformFeedbackStreamInstanced_PACKED;
#endif
#ifndef glEdgeFlag_RETURN
typedef struct {
    GLboolean flag;
} glEdgeFlag_ARGS;
typedef struct {
    int index;
    glEdgeFlag_ARGS args;
} glEdgeFlag_PACKED;
#endif
#ifndef glEdgeFlagFormatNV_RETURN
typedef struct {
    GLsizei stride;
} glEdgeFlagFormatNV_ARGS;
typedef struct {
    int index;
    glEdgeFlagFormatNV_ARGS args;
} glEdgeFlagFormatNV_PACKED;
#endif
#ifndef glEdgeFlagPointer_RETURN
typedef struct {
    GLsizei stride;
    GLvoid * pointer;
} glEdgeFlagPointer_ARGS;
typedef struct {
    int index;
    glEdgeFlagPointer_ARGS args;
} glEdgeFlagPointer_PACKED;
#endif
#ifndef glEdgeFlagPointerEXT_RETURN
typedef struct {
    GLsizei stride;
    GLsizei count;
    GLboolean * pointer;
} glEdgeFlagPointerEXT_ARGS;
typedef struct {
    int index;
    glEdgeFlagPointerEXT_ARGS args;
} glEdgeFlagPointerEXT_PACKED;
#endif
#ifndef glEdgeFlagPointerListIBM_RETURN
typedef struct {
    GLint stride;
    GLboolean * pointer;
    GLint ptrstride;
} glEdgeFlagPointerListIBM_ARGS;
typedef struct {
    int index;
    glEdgeFlagPointerListIBM_ARGS args;
} glEdgeFlagPointerListIBM_PACKED;
#endif
#ifndef glEdgeFlagv_RETURN
typedef struct {
    GLboolean * flag;
} glEdgeFlagv_ARGS;
typedef struct {
    int index;
    glEdgeFlagv_ARGS args;
} glEdgeFlagv_PACKED;
#endif
#ifndef glElementPointerAPPLE_RETURN
typedef struct {
    GLenum type;
    GLvoid * pointer;
} glElementPointerAPPLE_ARGS;
typedef struct {
    int index;
    glElementPointerAPPLE_ARGS args;
} glElementPointerAPPLE_PACKED;
#endif
#ifndef glElementPointerATI_RETURN
typedef struct {
    GLenum type;
    GLvoid * pointer;
} glElementPointerATI_ARGS;
typedef struct {
    int index;
    glElementPointerATI_ARGS args;
} glElementPointerATI_PACKED;
#endif
#ifndef glEnable_RETURN
typedef struct {
    GLenum cap;
} glEnable_ARGS;
typedef struct {
    int index;
    glEnable_ARGS args;
} glEnable_PACKED;
#endif
#ifndef glEnableClientState_RETURN
typedef struct {
    GLenum array;
} glEnableClientState_ARGS;
typedef struct {
    int index;
    glEnableClientState_ARGS args;
} glEnableClientState_PACKED;
#endif
#ifndef glEnableClientStateIndexedEXT_RETURN
typedef struct {
    GLenum array;
    GLuint index;
} glEnableClientStateIndexedEXT_ARGS;
typedef struct {
    int index;
    glEnableClientStateIndexedEXT_ARGS args;
} glEnableClientStateIndexedEXT_PACKED;
#endif
#ifndef glEnableClientStateiEXT_RETURN
typedef struct {
    GLenum array;
    GLuint index;
} glEnableClientStateiEXT_ARGS;
typedef struct {
    int index;
    glEnableClientStateiEXT_ARGS args;
} glEnableClientStateiEXT_PACKED;
#endif
#ifndef glEnableIndexedEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
} glEnableIndexedEXT_ARGS;
typedef struct {
    int index;
    glEnableIndexedEXT_ARGS args;
} glEnableIndexedEXT_PACKED;
#endif
#ifndef glEnableVariantClientStateEXT_RETURN
typedef struct {
    GLuint id;
} glEnableVariantClientStateEXT_ARGS;
typedef struct {
    int index;
    glEnableVariantClientStateEXT_ARGS args;
} glEnableVariantClientStateEXT_PACKED;
#endif
#ifndef glEnableVertexArrayAttribEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint index;
} glEnableVertexArrayAttribEXT_ARGS;
typedef struct {
    int index;
    glEnableVertexArrayAttribEXT_ARGS args;
} glEnableVertexArrayAttribEXT_PACKED;
#endif
#ifndef glEnableVertexArrayEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLenum array;
} glEnableVertexArrayEXT_ARGS;
typedef struct {
    int index;
    glEnableVertexArrayEXT_ARGS args;
} glEnableVertexArrayEXT_PACKED;
#endif
#ifndef glEnableVertexAttribAPPLE_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
} glEnableVertexAttribAPPLE_ARGS;
typedef struct {
    int index;
    glEnableVertexAttribAPPLE_ARGS args;
} glEnableVertexAttribAPPLE_PACKED;
#endif
#ifndef glEnableVertexAttribArray_RETURN
typedef struct {
    GLuint index;
} glEnableVertexAttribArray_ARGS;
typedef struct {
    int index;
    glEnableVertexAttribArray_ARGS args;
} glEnableVertexAttribArray_PACKED;
#endif
#ifndef glEnableVertexAttribArrayARB_RETURN
typedef struct {
    GLuint index;
} glEnableVertexAttribArrayARB_ARGS;
typedef struct {
    int index;
    glEnableVertexAttribArrayARB_ARGS args;
} glEnableVertexAttribArrayARB_PACKED;
#endif
#ifndef glEnablei_RETURN
typedef struct {
    GLenum target;
    GLuint index;
} glEnablei_ARGS;
typedef struct {
    int index;
    glEnablei_ARGS args;
} glEnablei_PACKED;
#endif
#ifndef glEnd_RETURN
typedef struct {
    int index;
} glEnd_PACKED;
#endif
#ifndef glEndConditionalRender_RETURN
typedef struct {
    int index;
} glEndConditionalRender_PACKED;
#endif
#ifndef glEndConditionalRenderNV_RETURN
typedef struct {
    int index;
} glEndConditionalRenderNV_PACKED;
#endif
#ifndef glEndConditionalRenderNVX_RETURN
typedef struct {
    int index;
} glEndConditionalRenderNVX_PACKED;
#endif
#ifndef glEndFragmentShaderATI_RETURN
typedef struct {
    int index;
} glEndFragmentShaderATI_PACKED;
#endif
#ifndef glEndList_RETURN
typedef struct {
    int index;
} glEndList_PACKED;
#endif
#ifndef glEndOcclusionQueryNV_RETURN
typedef struct {
    int index;
} glEndOcclusionQueryNV_PACKED;
#endif
#ifndef glEndPerfMonitorAMD_RETURN
typedef struct {
    GLuint monitor;
} glEndPerfMonitorAMD_ARGS;
typedef struct {
    int index;
    glEndPerfMonitorAMD_ARGS args;
} glEndPerfMonitorAMD_PACKED;
#endif
#ifndef glEndQuery_RETURN
typedef struct {
    GLenum target;
} glEndQuery_ARGS;
typedef struct {
    int index;
    glEndQuery_ARGS args;
} glEndQuery_PACKED;
#endif
#ifndef glEndQueryARB_RETURN
typedef struct {
    GLenum target;
} glEndQueryARB_ARGS;
typedef struct {
    int index;
    glEndQueryARB_ARGS args;
} glEndQueryARB_PACKED;
#endif
#ifndef glEndQueryIndexed_RETURN
typedef struct {
    GLenum target;
    GLuint index;
} glEndQueryIndexed_ARGS;
typedef struct {
    int index;
    glEndQueryIndexed_ARGS args;
} glEndQueryIndexed_PACKED;
#endif
#ifndef glEndTransformFeedback_RETURN
typedef struct {
    int index;
} glEndTransformFeedback_PACKED;
#endif
#ifndef glEndTransformFeedbackEXT_RETURN
typedef struct {
    int index;
} glEndTransformFeedbackEXT_PACKED;
#endif
#ifndef glEndTransformFeedbackNV_RETURN
typedef struct {
    int index;
} glEndTransformFeedbackNV_PACKED;
#endif
#ifndef glEndVertexShaderEXT_RETURN
typedef struct {
    int index;
} glEndVertexShaderEXT_PACKED;
#endif
#ifndef glEndVideoCaptureNV_RETURN
typedef struct {
    GLuint video_capture_slot;
} glEndVideoCaptureNV_ARGS;
typedef struct {
    int index;
    glEndVideoCaptureNV_ARGS args;
} glEndVideoCaptureNV_PACKED;
#endif
#ifndef glEvalCoord1d_RETURN
typedef struct {
    GLdouble u __attribute__ ((aligned(8)));
} glEvalCoord1d_ARGS;
typedef struct {
    int index;
    glEvalCoord1d_ARGS args;
} glEvalCoord1d_PACKED;
#endif
#ifndef glEvalCoord1dv_RETURN
typedef struct {
    GLdouble * u;
} glEvalCoord1dv_ARGS;
typedef struct {
    int index;
    glEvalCoord1dv_ARGS args;
} glEvalCoord1dv_PACKED;
#endif
#ifndef glEvalCoord1f_RETURN
typedef struct {
    GLfloat u;
} glEvalCoord1f_ARGS;
typedef struct {
    int index;
    glEvalCoord1f_ARGS args;
} glEvalCoord1f_PACKED;
#endif
#ifndef glEvalCoord1fv_RETURN
typedef struct {
    GLfloat * u;
} glEvalCoord1fv_ARGS;
typedef struct {
    int index;
    glEvalCoord1fv_ARGS args;
} glEvalCoord1fv_PACKED;
#endif
#ifndef glEvalCoord1xOES_RETURN
typedef struct {
    GLfixed u;
} glEvalCoord1xOES_ARGS;
typedef struct {
    int index;
    glEvalCoord1xOES_ARGS args;
} glEvalCoord1xOES_PACKED;
#endif
#ifndef glEvalCoord1xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glEvalCoord1xvOES_ARGS;
typedef struct {
    int index;
    glEvalCoord1xvOES_ARGS args;
} glEvalCoord1xvOES_PACKED;
#endif
#ifndef glEvalCoord2d_RETURN
typedef struct {
    GLdouble u __attribute__ ((aligned(8)));
    GLdouble v __attribute__ ((aligned(8)));
} glEvalCoord2d_ARGS;
typedef struct {
    int index;
    glEvalCoord2d_ARGS args;
} glEvalCoord2d_PACKED;
#endif
#ifndef glEvalCoord2dv_RETURN
typedef struct {
    GLdouble * u;
} glEvalCoord2dv_ARGS;
typedef struct {
    int index;
    glEvalCoord2dv_ARGS args;
} glEvalCoord2dv_PACKED;
#endif
#ifndef glEvalCoord2f_RETURN
typedef struct {
    GLfloat u;
    GLfloat v;
} glEvalCoord2f_ARGS;
typedef struct {
    int index;
    glEvalCoord2f_ARGS args;
} glEvalCoord2f_PACKED;
#endif
#ifndef glEvalCoord2fv_RETURN
typedef struct {
    GLfloat * u;
} glEvalCoord2fv_ARGS;
typedef struct {
    int index;
    glEvalCoord2fv_ARGS args;
} glEvalCoord2fv_PACKED;
#endif
#ifndef glEvalCoord2xOES_RETURN
typedef struct {
    GLfixed u;
    GLfixed v;
} glEvalCoord2xOES_ARGS;
typedef struct {
    int index;
    glEvalCoord2xOES_ARGS args;
} glEvalCoord2xOES_PACKED;
#endif
#ifndef glEvalCoord2xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glEvalCoord2xvOES_ARGS;
typedef struct {
    int index;
    glEvalCoord2xvOES_ARGS args;
} glEvalCoord2xvOES_PACKED;
#endif
#ifndef glEvalMapsNV_RETURN
typedef struct {
    GLenum target;
    GLenum mode;
} glEvalMapsNV_ARGS;
typedef struct {
    int index;
    glEvalMapsNV_ARGS args;
} glEvalMapsNV_PACKED;
#endif
#ifndef glEvalMesh1_RETURN
typedef struct {
    GLenum mode;
    GLint i1;
    GLint i2;
} glEvalMesh1_ARGS;
typedef struct {
    int index;
    glEvalMesh1_ARGS args;
} glEvalMesh1_PACKED;
#endif
#ifndef glEvalMesh2_RETURN
typedef struct {
    GLenum mode;
    GLint i1;
    GLint i2;
    GLint j1;
    GLint j2;
} glEvalMesh2_ARGS;
typedef struct {
    int index;
    glEvalMesh2_ARGS args;
} glEvalMesh2_PACKED;
#endif
#ifndef glEvalPoint1_RETURN
typedef struct {
    GLint i;
} glEvalPoint1_ARGS;
typedef struct {
    int index;
    glEvalPoint1_ARGS args;
} glEvalPoint1_PACKED;
#endif
#ifndef glEvalPoint2_RETURN
typedef struct {
    GLint i;
    GLint j;
} glEvalPoint2_ARGS;
typedef struct {
    int index;
    glEvalPoint2_ARGS args;
} glEvalPoint2_PACKED;
#endif
#ifndef glExecuteProgramNV_RETURN
typedef struct {
    GLenum target;
    GLuint id;
    GLfloat * params;
} glExecuteProgramNV_ARGS;
typedef struct {
    int index;
    glExecuteProgramNV_ARGS args;
} glExecuteProgramNV_PACKED;
#endif
#ifndef glExtractComponentEXT_RETURN
typedef struct {
    GLuint res;
    GLuint src;
    GLuint num;
} glExtractComponentEXT_ARGS;
typedef struct {
    int index;
    glExtractComponentEXT_ARGS args;
} glExtractComponentEXT_PACKED;
#endif
#ifndef glFeedbackBuffer_RETURN
typedef struct {
    GLsizei size;
    GLenum type;
    GLfloat * buffer;
} glFeedbackBuffer_ARGS;
typedef struct {
    int index;
    glFeedbackBuffer_ARGS args;
} glFeedbackBuffer_PACKED;
#endif
#ifndef glFeedbackBufferxOES_RETURN
typedef struct {
    GLsizei n;
    GLenum type;
    GLfixed * buffer;
} glFeedbackBufferxOES_ARGS;
typedef struct {
    int index;
    glFeedbackBufferxOES_ARGS args;
} glFeedbackBufferxOES_PACKED;
#endif
#ifndef glFenceSync_RETURN
typedef struct {
    GLenum condition;
    GLbitfield flags;
} glFenceSync_ARGS;
typedef struct {
    int index;
    glFenceSync_ARGS args;
} glFenceSync_PACKED;
#endif
#ifndef glFinalCombinerInputNV_RETURN
typedef struct {
    GLenum variable;
    GLenum input;
    GLenum mapping;
    GLenum componentUsage;
} glFinalCombinerInputNV_ARGS;
typedef struct {
    int index;
    glFinalCombinerInputNV_ARGS args;
} glFinalCombinerInputNV_PACKED;
#endif
#ifndef glFinish_RETURN
typedef struct {
    int index;
} glFinish_PACKED;
#endif
#ifndef glFinishAsyncSGIX_RETURN
typedef struct {
    GLuint * markerp;
} glFinishAsyncSGIX_ARGS;
typedef struct {
    int index;
    glFinishAsyncSGIX_ARGS args;
} glFinishAsyncSGIX_PACKED;
#endif
#ifndef glFinishFenceAPPLE_RETURN
typedef struct {
    GLuint fence;
} glFinishFenceAPPLE_ARGS;
typedef struct {
    int index;
    glFinishFenceAPPLE_ARGS args;
} glFinishFenceAPPLE_PACKED;
#endif
#ifndef glFinishFenceNV_RETURN
typedef struct {
    GLuint fence;
} glFinishFenceNV_ARGS;
typedef struct {
    int index;
    glFinishFenceNV_ARGS args;
} glFinishFenceNV_PACKED;
#endif
#ifndef glFinishObjectAPPLE_RETURN
typedef struct {
    GLenum object;
    GLint name;
} glFinishObjectAPPLE_ARGS;
typedef struct {
    int index;
    glFinishObjectAPPLE_ARGS args;
} glFinishObjectAPPLE_PACKED;
#endif
#ifndef glFinishTextureSUNX_RETURN
typedef struct {
    int index;
} glFinishTextureSUNX_PACKED;
#endif
#ifndef glFlush_RETURN
typedef struct {
    int index;
} glFlush_PACKED;
#endif
#ifndef glFlushMappedBufferRange_RETURN
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr length;
} glFlushMappedBufferRange_ARGS;
typedef struct {
    int index;
    glFlushMappedBufferRange_ARGS args;
} glFlushMappedBufferRange_PACKED;
#endif
#ifndef glFlushMappedBufferRangeAPPLE_RETURN
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr size;
} glFlushMappedBufferRangeAPPLE_ARGS;
typedef struct {
    int index;
    glFlushMappedBufferRangeAPPLE_ARGS args;
} glFlushMappedBufferRangeAPPLE_PACKED;
#endif
#ifndef glFlushMappedNamedBufferRangeEXT_RETURN
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr length;
} glFlushMappedNamedBufferRangeEXT_ARGS;
typedef struct {
    int index;
    glFlushMappedNamedBufferRangeEXT_ARGS args;
} glFlushMappedNamedBufferRangeEXT_PACKED;
#endif
#ifndef glFlushPixelDataRangeNV_RETURN
typedef struct {
    GLenum target;
} glFlushPixelDataRangeNV_ARGS;
typedef struct {
    int index;
    glFlushPixelDataRangeNV_ARGS args;
} glFlushPixelDataRangeNV_PACKED;
#endif
#ifndef glFlushRasterSGIX_RETURN
typedef struct {
    int index;
} glFlushRasterSGIX_PACKED;
#endif
#ifndef glFlushStaticDataIBM_RETURN
typedef struct {
    GLenum target;
} glFlushStaticDataIBM_ARGS;
typedef struct {
    int index;
    glFlushStaticDataIBM_ARGS args;
} glFlushStaticDataIBM_PACKED;
#endif
#ifndef glFlushVertexArrayRangeAPPLE_RETURN
typedef struct {
    GLsizei length;
    GLvoid * pointer;
} glFlushVertexArrayRangeAPPLE_ARGS;
typedef struct {
    int index;
    glFlushVertexArrayRangeAPPLE_ARGS args;
} glFlushVertexArrayRangeAPPLE_PACKED;
#endif
#ifndef glFlushVertexArrayRangeNV_RETURN
typedef struct {
    int index;
} glFlushVertexArrayRangeNV_PACKED;
#endif
#ifndef glFogCoordFormatNV_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
} glFogCoordFormatNV_ARGS;
typedef struct {
    int index;
    glFogCoordFormatNV_ARGS args;
} glFogCoordFormatNV_PACKED;
#endif
#ifndef glFogCoordPointer_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glFogCoordPointer_ARGS;
typedef struct {
    int index;
    glFogCoordPointer_ARGS args;
} glFogCoordPointer_PACKED;
#endif
#ifndef glFogCoordPointerEXT_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glFogCoordPointerEXT_ARGS;
typedef struct {
    int index;
    glFogCoordPointerEXT_ARGS args;
} glFogCoordPointerEXT_PACKED;
#endif
#ifndef glFogCoordPointerListIBM_RETURN
typedef struct {
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} glFogCoordPointerListIBM_ARGS;
typedef struct {
    int index;
    glFogCoordPointerListIBM_ARGS args;
} glFogCoordPointerListIBM_PACKED;
#endif
#ifndef glFogCoordd_RETURN
typedef struct {
    GLdouble coord __attribute__ ((aligned(8)));
} glFogCoordd_ARGS;
typedef struct {
    int index;
    glFogCoordd_ARGS args;
} glFogCoordd_PACKED;
#endif
#ifndef glFogCoorddEXT_RETURN
typedef struct {
    GLdouble coord __attribute__ ((aligned(8)));
} glFogCoorddEXT_ARGS;
typedef struct {
    int index;
    glFogCoorddEXT_ARGS args;
} glFogCoorddEXT_PACKED;
#endif
#ifndef glFogCoorddv_RETURN
typedef struct {
    GLdouble * coord;
} glFogCoorddv_ARGS;
typedef struct {
    int index;
    glFogCoorddv_ARGS args;
} glFogCoorddv_PACKED;
#endif
#ifndef glFogCoorddvEXT_RETURN
typedef struct {
    GLdouble * coord;
} glFogCoorddvEXT_ARGS;
typedef struct {
    int index;
    glFogCoorddvEXT_ARGS args;
} glFogCoorddvEXT_PACKED;
#endif
#ifndef glFogCoordf_RETURN
typedef struct {
    GLfloat coord;
} glFogCoordf_ARGS;
typedef struct {
    int index;
    glFogCoordf_ARGS args;
} glFogCoordf_PACKED;
#endif
#ifndef glFogCoordfEXT_RETURN
typedef struct {
    GLfloat coord;
} glFogCoordfEXT_ARGS;
typedef struct {
    int index;
    glFogCoordfEXT_ARGS args;
} glFogCoordfEXT_PACKED;
#endif
#ifndef glFogCoordfv_RETURN
typedef struct {
    GLfloat * coord;
} glFogCoordfv_ARGS;
typedef struct {
    int index;
    glFogCoordfv_ARGS args;
} glFogCoordfv_PACKED;
#endif
#ifndef glFogCoordfvEXT_RETURN
typedef struct {
    GLfloat * coord;
} glFogCoordfvEXT_ARGS;
typedef struct {
    int index;
    glFogCoordfvEXT_ARGS args;
} glFogCoordfvEXT_PACKED;
#endif
#ifndef glFogCoordhNV_RETURN
typedef struct {
    GLhalfNV fog;
} glFogCoordhNV_ARGS;
typedef struct {
    int index;
    glFogCoordhNV_ARGS args;
} glFogCoordhNV_PACKED;
#endif
#ifndef glFogCoordhvNV_RETURN
typedef struct {
    GLhalfNV * fog;
} glFogCoordhvNV_ARGS;
typedef struct {
    int index;
    glFogCoordhvNV_ARGS args;
} glFogCoordhvNV_PACKED;
#endif
#ifndef glFogFuncSGIS_RETURN
typedef struct {
    GLsizei n;
    GLfloat * points;
} glFogFuncSGIS_ARGS;
typedef struct {
    int index;
    glFogFuncSGIS_ARGS args;
} glFogFuncSGIS_PACKED;
#endif
#ifndef glFogf_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glFogf_ARGS;
typedef struct {
    int index;
    glFogf_ARGS args;
} glFogf_PACKED;
#endif
#ifndef glFogfv_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glFogfv_ARGS;
typedef struct {
    int index;
    glFogfv_ARGS args;
} glFogfv_PACKED;
#endif
#ifndef glFogi_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glFogi_ARGS;
typedef struct {
    int index;
    glFogi_ARGS args;
} glFogi_PACKED;
#endif
#ifndef glFogiv_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glFogiv_ARGS;
typedef struct {
    int index;
    glFogiv_ARGS args;
} glFogiv_PACKED;
#endif
#ifndef glFogxOES_RETURN
typedef struct {
    GLenum pname;
    GLfixed param;
} glFogxOES_ARGS;
typedef struct {
    int index;
    glFogxOES_ARGS args;
} glFogxOES_PACKED;
#endif
#ifndef glFogxvOES_RETURN
typedef struct {
    GLenum pname;
    GLfixed * param;
} glFogxvOES_ARGS;
typedef struct {
    int index;
    glFogxvOES_ARGS args;
} glFogxvOES_PACKED;
#endif
#ifndef glFragmentColorMaterialSGIX_RETURN
typedef struct {
    GLenum face;
    GLenum mode;
} glFragmentColorMaterialSGIX_ARGS;
typedef struct {
    int index;
    glFragmentColorMaterialSGIX_ARGS args;
} glFragmentColorMaterialSGIX_PACKED;
#endif
#ifndef glFragmentLightModelfSGIX_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glFragmentLightModelfSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightModelfSGIX_ARGS args;
} glFragmentLightModelfSGIX_PACKED;
#endif
#ifndef glFragmentLightModelfvSGIX_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glFragmentLightModelfvSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightModelfvSGIX_ARGS args;
} glFragmentLightModelfvSGIX_PACKED;
#endif
#ifndef glFragmentLightModeliSGIX_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glFragmentLightModeliSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightModeliSGIX_ARGS args;
} glFragmentLightModeliSGIX_PACKED;
#endif
#ifndef glFragmentLightModelivSGIX_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glFragmentLightModelivSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightModelivSGIX_ARGS args;
} glFragmentLightModelivSGIX_PACKED;
#endif
#ifndef glFragmentLightfSGIX_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat param;
} glFragmentLightfSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightfSGIX_ARGS args;
} glFragmentLightfSGIX_PACKED;
#endif
#ifndef glFragmentLightfvSGIX_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} glFragmentLightfvSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightfvSGIX_ARGS args;
} glFragmentLightfvSGIX_PACKED;
#endif
#ifndef glFragmentLightiSGIX_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLint param;
} glFragmentLightiSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightiSGIX_ARGS args;
} glFragmentLightiSGIX_PACKED;
#endif
#ifndef glFragmentLightivSGIX_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} glFragmentLightivSGIX_ARGS;
typedef struct {
    int index;
    glFragmentLightivSGIX_ARGS args;
} glFragmentLightivSGIX_PACKED;
#endif
#ifndef glFragmentMaterialfSGIX_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat param;
} glFragmentMaterialfSGIX_ARGS;
typedef struct {
    int index;
    glFragmentMaterialfSGIX_ARGS args;
} glFragmentMaterialfSGIX_PACKED;
#endif
#ifndef glFragmentMaterialfvSGIX_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} glFragmentMaterialfvSGIX_ARGS;
typedef struct {
    int index;
    glFragmentMaterialfvSGIX_ARGS args;
} glFragmentMaterialfvSGIX_PACKED;
#endif
#ifndef glFragmentMaterialiSGIX_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLint param;
} glFragmentMaterialiSGIX_ARGS;
typedef struct {
    int index;
    glFragmentMaterialiSGIX_ARGS args;
} glFragmentMaterialiSGIX_PACKED;
#endif
#ifndef glFragmentMaterialivSGIX_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} glFragmentMaterialivSGIX_ARGS;
typedef struct {
    int index;
    glFragmentMaterialivSGIX_ARGS args;
} glFragmentMaterialivSGIX_PACKED;
#endif
#ifndef glFrameTerminatorGREMEDY_RETURN
typedef struct {
    int index;
} glFrameTerminatorGREMEDY_PACKED;
#endif
#ifndef glFrameZoomSGIX_RETURN
typedef struct {
    GLint factor;
} glFrameZoomSGIX_ARGS;
typedef struct {
    int index;
    glFrameZoomSGIX_ARGS args;
} glFrameZoomSGIX_PACKED;
#endif
#ifndef glFramebufferDrawBufferEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum mode;
} glFramebufferDrawBufferEXT_ARGS;
typedef struct {
    int index;
    glFramebufferDrawBufferEXT_ARGS args;
} glFramebufferDrawBufferEXT_PACKED;
#endif
#ifndef glFramebufferDrawBuffersEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLsizei n;
    GLenum * bufs;
} glFramebufferDrawBuffersEXT_ARGS;
typedef struct {
    int index;
    glFramebufferDrawBuffersEXT_ARGS args;
} glFramebufferDrawBuffersEXT_PACKED;
#endif
#ifndef glFramebufferParameteri_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} glFramebufferParameteri_ARGS;
typedef struct {
    int index;
    glFramebufferParameteri_ARGS args;
} glFramebufferParameteri_PACKED;
#endif
#ifndef glFramebufferReadBufferEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum mode;
} glFramebufferReadBufferEXT_ARGS;
typedef struct {
    int index;
    glFramebufferReadBufferEXT_ARGS args;
} glFramebufferReadBufferEXT_PACKED;
#endif
#ifndef glFramebufferRenderbuffer_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum renderbuffertarget;
    GLuint renderbuffer;
} glFramebufferRenderbuffer_ARGS;
typedef struct {
    int index;
    glFramebufferRenderbuffer_ARGS args;
} glFramebufferRenderbuffer_PACKED;
#endif
#ifndef glFramebufferRenderbufferEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum renderbuffertarget;
    GLuint renderbuffer;
} glFramebufferRenderbufferEXT_ARGS;
typedef struct {
    int index;
    glFramebufferRenderbufferEXT_ARGS args;
} glFramebufferRenderbufferEXT_PACKED;
#endif
#ifndef glFramebufferTexture_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
} glFramebufferTexture_ARGS;
typedef struct {
    int index;
    glFramebufferTexture_ARGS args;
} glFramebufferTexture_PACKED;
#endif
#ifndef glFramebufferTexture1D_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} glFramebufferTexture1D_ARGS;
typedef struct {
    int index;
    glFramebufferTexture1D_ARGS args;
} glFramebufferTexture1D_PACKED;
#endif
#ifndef glFramebufferTexture1DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} glFramebufferTexture1DEXT_ARGS;
typedef struct {
    int index;
    glFramebufferTexture1DEXT_ARGS args;
} glFramebufferTexture1DEXT_PACKED;
#endif
#ifndef glFramebufferTexture2D_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} glFramebufferTexture2D_ARGS;
typedef struct {
    int index;
    glFramebufferTexture2D_ARGS args;
} glFramebufferTexture2D_PACKED;
#endif
#ifndef glFramebufferTexture2DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} glFramebufferTexture2DEXT_ARGS;
typedef struct {
    int index;
    glFramebufferTexture2DEXT_ARGS args;
} glFramebufferTexture2DEXT_PACKED;
#endif
#ifndef glFramebufferTexture3D_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
    GLint zoffset;
} glFramebufferTexture3D_ARGS;
typedef struct {
    int index;
    glFramebufferTexture3D_ARGS args;
} glFramebufferTexture3D_PACKED;
#endif
#ifndef glFramebufferTexture3DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
    GLint zoffset;
} glFramebufferTexture3DEXT_ARGS;
typedef struct {
    int index;
    glFramebufferTexture3DEXT_ARGS args;
} glFramebufferTexture3DEXT_PACKED;
#endif
#ifndef glFramebufferTextureARB_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
} glFramebufferTextureARB_ARGS;
typedef struct {
    int index;
    glFramebufferTextureARB_ARGS args;
} glFramebufferTextureARB_PACKED;
#endif
#ifndef glFramebufferTextureEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
} glFramebufferTextureEXT_ARGS;
typedef struct {
    int index;
    glFramebufferTextureEXT_ARGS args;
} glFramebufferTextureEXT_PACKED;
#endif
#ifndef glFramebufferTextureFaceARB_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLenum face;
} glFramebufferTextureFaceARB_ARGS;
typedef struct {
    int index;
    glFramebufferTextureFaceARB_ARGS args;
} glFramebufferTextureFaceARB_PACKED;
#endif
#ifndef glFramebufferTextureFaceEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLenum face;
} glFramebufferTextureFaceEXT_ARGS;
typedef struct {
    int index;
    glFramebufferTextureFaceEXT_ARGS args;
} glFramebufferTextureFaceEXT_PACKED;
#endif
#ifndef glFramebufferTextureLayer_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} glFramebufferTextureLayer_ARGS;
typedef struct {
    int index;
    glFramebufferTextureLayer_ARGS args;
} glFramebufferTextureLayer_PACKED;
#endif
#ifndef glFramebufferTextureLayerARB_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} glFramebufferTextureLayerARB_ARGS;
typedef struct {
    int index;
    glFramebufferTextureLayerARB_ARGS args;
} glFramebufferTextureLayerARB_PACKED;
#endif
#ifndef glFramebufferTextureLayerEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} glFramebufferTextureLayerEXT_ARGS;
typedef struct {
    int index;
    glFramebufferTextureLayerEXT_ARGS args;
} glFramebufferTextureLayerEXT_PACKED;
#endif
#ifndef glFreeObjectBufferATI_RETURN
typedef struct {
    GLuint buffer;
} glFreeObjectBufferATI_ARGS;
typedef struct {
    int index;
    glFreeObjectBufferATI_ARGS args;
} glFreeObjectBufferATI_PACKED;
#endif
#ifndef glFrontFace_RETURN
typedef struct {
    GLenum mode;
} glFrontFace_ARGS;
typedef struct {
    int index;
    glFrontFace_ARGS args;
} glFrontFace_PACKED;
#endif
#ifndef glFrustum_RETURN
typedef struct {
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} glFrustum_ARGS;
typedef struct {
    int index;
    glFrustum_ARGS args;
} glFrustum_PACKED;
#endif
#ifndef glFrustumfOES_RETURN
typedef struct {
    GLfloat l;
    GLfloat r;
    GLfloat b;
    GLfloat t;
    GLfloat n;
    GLfloat f;
} glFrustumfOES_ARGS;
typedef struct {
    int index;
    glFrustumfOES_ARGS args;
} glFrustumfOES_PACKED;
#endif
#ifndef glFrustumxOES_RETURN
typedef struct {
    GLfixed l;
    GLfixed r;
    GLfixed b;
    GLfixed t;
    GLfixed n;
    GLfixed f;
} glFrustumxOES_ARGS;
typedef struct {
    int index;
    glFrustumxOES_ARGS args;
} glFrustumxOES_PACKED;
#endif
#ifndef glGenAsyncMarkersSGIX_RETURN
typedef struct {
    GLsizei range;
} glGenAsyncMarkersSGIX_ARGS;
typedef struct {
    int index;
    glGenAsyncMarkersSGIX_ARGS args;
} glGenAsyncMarkersSGIX_PACKED;
#endif
#ifndef glGenBuffers_RETURN
typedef struct {
    GLsizei n;
    GLuint * buffers;
} glGenBuffers_ARGS;
typedef struct {
    int index;
    glGenBuffers_ARGS args;
} glGenBuffers_PACKED;
#endif
#ifndef glGenBuffersARB_RETURN
typedef struct {
    GLsizei n;
    GLuint * buffers;
} glGenBuffersARB_ARGS;
typedef struct {
    int index;
    glGenBuffersARB_ARGS args;
} glGenBuffersARB_PACKED;
#endif
#ifndef glGenFencesAPPLE_RETURN
typedef struct {
    GLsizei n;
    GLuint * fences;
} glGenFencesAPPLE_ARGS;
typedef struct {
    int index;
    glGenFencesAPPLE_ARGS args;
} glGenFencesAPPLE_PACKED;
#endif
#ifndef glGenFencesNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * fences;
} glGenFencesNV_ARGS;
typedef struct {
    int index;
    glGenFencesNV_ARGS args;
} glGenFencesNV_PACKED;
#endif
#ifndef glGenFragmentShadersATI_RETURN
typedef struct {
    GLuint range;
} glGenFragmentShadersATI_ARGS;
typedef struct {
    int index;
    glGenFragmentShadersATI_ARGS args;
} glGenFragmentShadersATI_PACKED;
#endif
#ifndef glGenFramebuffers_RETURN
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} glGenFramebuffers_ARGS;
typedef struct {
    int index;
    glGenFramebuffers_ARGS args;
} glGenFramebuffers_PACKED;
#endif
#ifndef glGenFramebuffersEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} glGenFramebuffersEXT_ARGS;
typedef struct {
    int index;
    glGenFramebuffersEXT_ARGS args;
} glGenFramebuffersEXT_PACKED;
#endif
#ifndef glGenLists_RETURN
typedef struct {
    GLsizei range;
} glGenLists_ARGS;
typedef struct {
    int index;
    glGenLists_ARGS args;
} glGenLists_PACKED;
#endif
#ifndef glGenNamesAMD_RETURN
typedef struct {
    GLenum identifier;
    GLuint num;
    GLuint * names;
} glGenNamesAMD_ARGS;
typedef struct {
    int index;
    glGenNamesAMD_ARGS args;
} glGenNamesAMD_PACKED;
#endif
#ifndef glGenOcclusionQueriesNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glGenOcclusionQueriesNV_ARGS;
typedef struct {
    int index;
    glGenOcclusionQueriesNV_ARGS args;
} glGenOcclusionQueriesNV_PACKED;
#endif
#ifndef glGenPathsNV_RETURN
typedef struct {
    GLsizei range;
} glGenPathsNV_ARGS;
typedef struct {
    int index;
    glGenPathsNV_ARGS args;
} glGenPathsNV_PACKED;
#endif
#ifndef glGenPerfMonitorsAMD_RETURN
typedef struct {
    GLsizei n;
    GLuint * monitors;
} glGenPerfMonitorsAMD_ARGS;
typedef struct {
    int index;
    glGenPerfMonitorsAMD_ARGS args;
} glGenPerfMonitorsAMD_PACKED;
#endif
#ifndef glGenProgramPipelines_RETURN
typedef struct {
    GLsizei n;
    GLuint * pipelines;
} glGenProgramPipelines_ARGS;
typedef struct {
    int index;
    glGenProgramPipelines_ARGS args;
} glGenProgramPipelines_PACKED;
#endif
#ifndef glGenProgramsARB_RETURN
typedef struct {
    GLsizei n;
    GLuint * programs;
} glGenProgramsARB_ARGS;
typedef struct {
    int index;
    glGenProgramsARB_ARGS args;
} glGenProgramsARB_PACKED;
#endif
#ifndef glGenProgramsNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * programs;
} glGenProgramsNV_ARGS;
typedef struct {
    int index;
    glGenProgramsNV_ARGS args;
} glGenProgramsNV_PACKED;
#endif
#ifndef glGenQueries_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glGenQueries_ARGS;
typedef struct {
    int index;
    glGenQueries_ARGS args;
} glGenQueries_PACKED;
#endif
#ifndef glGenQueriesARB_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glGenQueriesARB_ARGS;
typedef struct {
    int index;
    glGenQueriesARB_ARGS args;
} glGenQueriesARB_PACKED;
#endif
#ifndef glGenRenderbuffers_RETURN
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} glGenRenderbuffers_ARGS;
typedef struct {
    int index;
    glGenRenderbuffers_ARGS args;
} glGenRenderbuffers_PACKED;
#endif
#ifndef glGenRenderbuffersEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} glGenRenderbuffersEXT_ARGS;
typedef struct {
    int index;
    glGenRenderbuffersEXT_ARGS args;
} glGenRenderbuffersEXT_PACKED;
#endif
#ifndef glGenSamplers_RETURN
typedef struct {
    GLsizei count;
    GLuint * samplers;
} glGenSamplers_ARGS;
typedef struct {
    int index;
    glGenSamplers_ARGS args;
} glGenSamplers_PACKED;
#endif
#ifndef glGenSymbolsEXT_RETURN
typedef struct {
    GLenum datatype;
    GLenum storagetype;
    GLenum range;
    GLuint components;
} glGenSymbolsEXT_ARGS;
typedef struct {
    int index;
    glGenSymbolsEXT_ARGS args;
} glGenSymbolsEXT_PACKED;
#endif
#ifndef glGenTextures_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
} glGenTextures_ARGS;
typedef struct {
    int index;
    glGenTextures_ARGS args;
} glGenTextures_PACKED;
#endif
#ifndef glGenTexturesEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
} glGenTexturesEXT_ARGS;
typedef struct {
    int index;
    glGenTexturesEXT_ARGS args;
} glGenTexturesEXT_PACKED;
#endif
#ifndef glGenTransformFeedbacks_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glGenTransformFeedbacks_ARGS;
typedef struct {
    int index;
    glGenTransformFeedbacks_ARGS args;
} glGenTransformFeedbacks_PACKED;
#endif
#ifndef glGenTransformFeedbacksNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * ids;
} glGenTransformFeedbacksNV_ARGS;
typedef struct {
    int index;
    glGenTransformFeedbacksNV_ARGS args;
} glGenTransformFeedbacksNV_PACKED;
#endif
#ifndef glGenVertexArrays_RETURN
typedef struct {
    GLsizei n;
    GLuint * arrays;
} glGenVertexArrays_ARGS;
typedef struct {
    int index;
    glGenVertexArrays_ARGS args;
} glGenVertexArrays_PACKED;
#endif
#ifndef glGenVertexArraysAPPLE_RETURN
typedef struct {
    GLsizei n;
    GLuint * arrays;
} glGenVertexArraysAPPLE_ARGS;
typedef struct {
    int index;
    glGenVertexArraysAPPLE_ARGS args;
} glGenVertexArraysAPPLE_PACKED;
#endif
#ifndef glGenVertexShadersEXT_RETURN
typedef struct {
    GLuint range;
} glGenVertexShadersEXT_ARGS;
typedef struct {
    int index;
    glGenVertexShadersEXT_ARGS args;
} glGenVertexShadersEXT_PACKED;
#endif
#ifndef glGenerateMipmap_RETURN
typedef struct {
    GLenum target;
} glGenerateMipmap_ARGS;
typedef struct {
    int index;
    glGenerateMipmap_ARGS args;
} glGenerateMipmap_PACKED;
#endif
#ifndef glGenerateMipmapEXT_RETURN
typedef struct {
    GLenum target;
} glGenerateMipmapEXT_ARGS;
typedef struct {
    int index;
    glGenerateMipmapEXT_ARGS args;
} glGenerateMipmapEXT_PACKED;
#endif
#ifndef glGenerateMultiTexMipmapEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
} glGenerateMultiTexMipmapEXT_ARGS;
typedef struct {
    int index;
    glGenerateMultiTexMipmapEXT_ARGS args;
} glGenerateMultiTexMipmapEXT_PACKED;
#endif
#ifndef glGenerateTextureMipmapEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
} glGenerateTextureMipmapEXT_ARGS;
typedef struct {
    int index;
    glGenerateTextureMipmapEXT_ARGS args;
} glGenerateTextureMipmapEXT_PACKED;
#endif
#ifndef glGetActiveAtomicCounterBufferiv_RETURN
typedef struct {
    GLuint program;
    GLuint bufferIndex;
    GLenum pname;
    GLint * params;
} glGetActiveAtomicCounterBufferiv_ARGS;
typedef struct {
    int index;
    glGetActiveAtomicCounterBufferiv_ARGS args;
} glGetActiveAtomicCounterBufferiv_PACKED;
#endif
#ifndef glGetActiveAttrib_RETURN
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLchar * name;
} glGetActiveAttrib_ARGS;
typedef struct {
    int index;
    glGetActiveAttrib_ARGS args;
} glGetActiveAttrib_PACKED;
#endif
#ifndef glGetActiveAttribARB_RETURN
typedef struct {
    GLhandleARB programObj;
    GLuint index;
    GLsizei maxLength;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLcharARB * name;
} glGetActiveAttribARB_ARGS;
typedef struct {
    int index;
    glGetActiveAttribARB_ARGS args;
} glGetActiveAttribARB_PACKED;
#endif
#ifndef glGetActiveSubroutineName_RETURN
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLuint index;
    GLsizei bufsize;
    GLsizei * length;
    GLchar * name;
} glGetActiveSubroutineName_ARGS;
typedef struct {
    int index;
    glGetActiveSubroutineName_ARGS args;
} glGetActiveSubroutineName_PACKED;
#endif
#ifndef glGetActiveSubroutineUniformName_RETURN
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLuint index;
    GLsizei bufsize;
    GLsizei * length;
    GLchar * name;
} glGetActiveSubroutineUniformName_ARGS;
typedef struct {
    int index;
    glGetActiveSubroutineUniformName_ARGS args;
} glGetActiveSubroutineUniformName_PACKED;
#endif
#ifndef glGetActiveSubroutineUniformiv_RETURN
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLuint index;
    GLenum pname;
    GLint * values;
} glGetActiveSubroutineUniformiv_ARGS;
typedef struct {
    int index;
    glGetActiveSubroutineUniformiv_ARGS args;
} glGetActiveSubroutineUniformiv_PACKED;
#endif
#ifndef glGetActiveUniform_RETURN
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLchar * name;
} glGetActiveUniform_ARGS;
typedef struct {
    int index;
    glGetActiveUniform_ARGS args;
} glGetActiveUniform_PACKED;
#endif
#ifndef glGetActiveUniformARB_RETURN
typedef struct {
    GLhandleARB programObj;
    GLuint index;
    GLsizei maxLength;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLcharARB * name;
} glGetActiveUniformARB_ARGS;
typedef struct {
    int index;
    glGetActiveUniformARB_ARGS args;
} glGetActiveUniformARB_PACKED;
#endif
#ifndef glGetActiveUniformBlockName_RETURN
typedef struct {
    GLuint program;
    GLuint uniformBlockIndex;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * uniformBlockName;
} glGetActiveUniformBlockName_ARGS;
typedef struct {
    int index;
    glGetActiveUniformBlockName_ARGS args;
} glGetActiveUniformBlockName_PACKED;
#endif
#ifndef glGetActiveUniformBlockiv_RETURN
typedef struct {
    GLuint program;
    GLuint uniformBlockIndex;
    GLenum pname;
    GLint * params;
} glGetActiveUniformBlockiv_ARGS;
typedef struct {
    int index;
    glGetActiveUniformBlockiv_ARGS args;
} glGetActiveUniformBlockiv_PACKED;
#endif
#ifndef glGetActiveUniformName_RETURN
typedef struct {
    GLuint program;
    GLuint uniformIndex;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * uniformName;
} glGetActiveUniformName_ARGS;
typedef struct {
    int index;
    glGetActiveUniformName_ARGS args;
} glGetActiveUniformName_PACKED;
#endif
#ifndef glGetActiveUniformsiv_RETURN
typedef struct {
    GLuint program;
    GLsizei uniformCount;
    GLuint * uniformIndices;
    GLenum pname;
    GLint * params;
} glGetActiveUniformsiv_ARGS;
typedef struct {
    int index;
    glGetActiveUniformsiv_ARGS args;
} glGetActiveUniformsiv_PACKED;
#endif
#ifndef glGetActiveVaryingNV_RETURN
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLsizei * size;
    GLenum * type;
    GLchar * name;
} glGetActiveVaryingNV_ARGS;
typedef struct {
    int index;
    glGetActiveVaryingNV_ARGS args;
} glGetActiveVaryingNV_PACKED;
#endif
#ifndef glGetArrayObjectfvATI_RETURN
typedef struct {
    GLenum array;
    GLenum pname;
    GLfloat * params;
} glGetArrayObjectfvATI_ARGS;
typedef struct {
    int index;
    glGetArrayObjectfvATI_ARGS args;
} glGetArrayObjectfvATI_PACKED;
#endif
#ifndef glGetArrayObjectivATI_RETURN
typedef struct {
    GLenum array;
    GLenum pname;
    GLint * params;
} glGetArrayObjectivATI_ARGS;
typedef struct {
    int index;
    glGetArrayObjectivATI_ARGS args;
} glGetArrayObjectivATI_PACKED;
#endif
#ifndef glGetAttachedObjectsARB_RETURN
typedef struct {
    GLhandleARB containerObj;
    GLsizei maxCount;
    GLsizei * count;
    GLhandleARB * obj;
} glGetAttachedObjectsARB_ARGS;
typedef struct {
    int index;
    glGetAttachedObjectsARB_ARGS args;
} glGetAttachedObjectsARB_PACKED;
#endif
#ifndef glGetAttachedShaders_RETURN
typedef struct {
    GLuint program;
    GLsizei maxCount;
    GLsizei * count;
    GLuint * obj;
} glGetAttachedShaders_ARGS;
typedef struct {
    int index;
    glGetAttachedShaders_ARGS args;
} glGetAttachedShaders_PACKED;
#endif
#ifndef glGetAttribLocation_RETURN
typedef struct {
    GLuint program;
    GLchar * name;
} glGetAttribLocation_ARGS;
typedef struct {
    int index;
    glGetAttribLocation_ARGS args;
} glGetAttribLocation_PACKED;
#endif
#ifndef glGetAttribLocationARB_RETURN
typedef struct {
    GLhandleARB programObj;
    GLcharARB * name;
} glGetAttribLocationARB_ARGS;
typedef struct {
    int index;
    glGetAttribLocationARB_ARGS args;
} glGetAttribLocationARB_PACKED;
#endif
#ifndef glGetBooleanIndexedvEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLboolean * data;
} glGetBooleanIndexedvEXT_ARGS;
typedef struct {
    int index;
    glGetBooleanIndexedvEXT_ARGS args;
} glGetBooleanIndexedvEXT_PACKED;
#endif
#ifndef glGetBooleani_v_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLboolean * data;
} glGetBooleani_v_ARGS;
typedef struct {
    int index;
    glGetBooleani_v_ARGS args;
} glGetBooleani_v_PACKED;
#endif
#ifndef glGetBooleanv_RETURN
typedef struct {
    GLenum pname;
    GLboolean * params;
} glGetBooleanv_ARGS;
typedef struct {
    int index;
    glGetBooleanv_ARGS args;
} glGetBooleanv_PACKED;
#endif
#ifndef glGetBufferParameteri64v_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint64 * params;
} glGetBufferParameteri64v_ARGS;
typedef struct {
    int index;
    glGetBufferParameteri64v_ARGS args;
} glGetBufferParameteri64v_PACKED;
#endif
#ifndef glGetBufferParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetBufferParameteriv_ARGS;
typedef struct {
    int index;
    glGetBufferParameteriv_ARGS args;
} glGetBufferParameteriv_PACKED;
#endif
#ifndef glGetBufferParameterivARB_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetBufferParameterivARB_ARGS;
typedef struct {
    int index;
    glGetBufferParameterivARB_ARGS args;
} glGetBufferParameterivARB_PACKED;
#endif
#ifndef glGetBufferParameterui64vNV_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint64EXT * params;
} glGetBufferParameterui64vNV_ARGS;
typedef struct {
    int index;
    glGetBufferParameterui64vNV_ARGS args;
} glGetBufferParameterui64vNV_PACKED;
#endif
#ifndef glGetBufferPointerv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * params;
} glGetBufferPointerv_ARGS;
typedef struct {
    int index;
    glGetBufferPointerv_ARGS args;
} glGetBufferPointerv_PACKED;
#endif
#ifndef glGetBufferPointervARB_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * params;
} glGetBufferPointervARB_ARGS;
typedef struct {
    int index;
    glGetBufferPointervARB_ARGS args;
} glGetBufferPointervARB_PACKED;
#endif
#ifndef glGetBufferSubData_RETURN
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} glGetBufferSubData_ARGS;
typedef struct {
    int index;
    glGetBufferSubData_ARGS args;
} glGetBufferSubData_PACKED;
#endif
#ifndef glGetBufferSubDataARB_RETURN
typedef struct {
    GLenum target;
    GLintptrARB offset;
    GLsizeiptrARB size;
    GLvoid * data;
} glGetBufferSubDataARB_ARGS;
typedef struct {
    int index;
    glGetBufferSubDataARB_ARGS args;
} glGetBufferSubDataARB_PACKED;
#endif
#ifndef glGetClipPlane_RETURN
typedef struct {
    GLenum plane;
    GLdouble * equation;
} glGetClipPlane_ARGS;
typedef struct {
    int index;
    glGetClipPlane_ARGS args;
} glGetClipPlane_PACKED;
#endif
#ifndef glGetClipPlanefOES_RETURN
typedef struct {
    GLenum plane;
    GLfloat * equation;
} glGetClipPlanefOES_ARGS;
typedef struct {
    int index;
    glGetClipPlanefOES_ARGS args;
} glGetClipPlanefOES_PACKED;
#endif
#ifndef glGetClipPlanexOES_RETURN
typedef struct {
    GLenum plane;
    GLfixed * equation;
} glGetClipPlanexOES_ARGS;
typedef struct {
    int index;
    glGetClipPlanexOES_ARGS args;
} glGetClipPlanexOES_PACKED;
#endif
#ifndef glGetColorTable_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * table;
} glGetColorTable_ARGS;
typedef struct {
    int index;
    glGetColorTable_ARGS args;
} glGetColorTable_PACKED;
#endif
#ifndef glGetColorTableEXT_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * data;
} glGetColorTableEXT_ARGS;
typedef struct {
    int index;
    glGetColorTableEXT_ARGS args;
} glGetColorTableEXT_PACKED;
#endif
#ifndef glGetColorTableParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetColorTableParameterfv_ARGS;
typedef struct {
    int index;
    glGetColorTableParameterfv_ARGS args;
} glGetColorTableParameterfv_PACKED;
#endif
#ifndef glGetColorTableParameterfvEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetColorTableParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetColorTableParameterfvEXT_ARGS args;
} glGetColorTableParameterfvEXT_PACKED;
#endif
#ifndef glGetColorTableParameterfvSGI_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetColorTableParameterfvSGI_ARGS;
typedef struct {
    int index;
    glGetColorTableParameterfvSGI_ARGS args;
} glGetColorTableParameterfvSGI_PACKED;
#endif
#ifndef glGetColorTableParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetColorTableParameteriv_ARGS;
typedef struct {
    int index;
    glGetColorTableParameteriv_ARGS args;
} glGetColorTableParameteriv_PACKED;
#endif
#ifndef glGetColorTableParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetColorTableParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetColorTableParameterivEXT_ARGS args;
} glGetColorTableParameterivEXT_PACKED;
#endif
#ifndef glGetColorTableParameterivSGI_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetColorTableParameterivSGI_ARGS;
typedef struct {
    int index;
    glGetColorTableParameterivSGI_ARGS args;
} glGetColorTableParameterivSGI_PACKED;
#endif
#ifndef glGetColorTableSGI_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * table;
} glGetColorTableSGI_ARGS;
typedef struct {
    int index;
    glGetColorTableSGI_ARGS args;
} glGetColorTableSGI_PACKED;
#endif
#ifndef glGetCombinerInputParameterfvNV_RETURN
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum variable;
    GLenum pname;
    GLfloat * params;
} glGetCombinerInputParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetCombinerInputParameterfvNV_ARGS args;
} glGetCombinerInputParameterfvNV_PACKED;
#endif
#ifndef glGetCombinerInputParameterivNV_RETURN
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum variable;
    GLenum pname;
    GLint * params;
} glGetCombinerInputParameterivNV_ARGS;
typedef struct {
    int index;
    glGetCombinerInputParameterivNV_ARGS args;
} glGetCombinerInputParameterivNV_PACKED;
#endif
#ifndef glGetCombinerOutputParameterfvNV_RETURN
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum pname;
    GLfloat * params;
} glGetCombinerOutputParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetCombinerOutputParameterfvNV_ARGS args;
} glGetCombinerOutputParameterfvNV_PACKED;
#endif
#ifndef glGetCombinerOutputParameterivNV_RETURN
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum pname;
    GLint * params;
} glGetCombinerOutputParameterivNV_ARGS;
typedef struct {
    int index;
    glGetCombinerOutputParameterivNV_ARGS args;
} glGetCombinerOutputParameterivNV_PACKED;
#endif
#ifndef glGetCombinerStageParameterfvNV_RETURN
typedef struct {
    GLenum stage;
    GLenum pname;
    GLfloat * params;
} glGetCombinerStageParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetCombinerStageParameterfvNV_ARGS args;
} glGetCombinerStageParameterfvNV_PACKED;
#endif
#ifndef glGetCompressedMultiTexImageEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint lod;
    GLvoid * img;
} glGetCompressedMultiTexImageEXT_ARGS;
typedef struct {
    int index;
    glGetCompressedMultiTexImageEXT_ARGS args;
} glGetCompressedMultiTexImageEXT_PACKED;
#endif
#ifndef glGetCompressedTexImage_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLvoid * img;
} glGetCompressedTexImage_ARGS;
typedef struct {
    int index;
    glGetCompressedTexImage_ARGS args;
} glGetCompressedTexImage_PACKED;
#endif
#ifndef glGetCompressedTexImageARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLvoid * img;
} glGetCompressedTexImageARB_ARGS;
typedef struct {
    int index;
    glGetCompressedTexImageARB_ARGS args;
} glGetCompressedTexImageARB_PACKED;
#endif
#ifndef glGetCompressedTextureImageEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint lod;
    GLvoid * img;
} glGetCompressedTextureImageEXT_ARGS;
typedef struct {
    int index;
    glGetCompressedTextureImageEXT_ARGS args;
} glGetCompressedTextureImageEXT_PACKED;
#endif
#ifndef glGetConvolutionFilter_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * image;
} glGetConvolutionFilter_ARGS;
typedef struct {
    int index;
    glGetConvolutionFilter_ARGS args;
} glGetConvolutionFilter_PACKED;
#endif
#ifndef glGetConvolutionFilterEXT_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * image;
} glGetConvolutionFilterEXT_ARGS;
typedef struct {
    int index;
    glGetConvolutionFilterEXT_ARGS args;
} glGetConvolutionFilterEXT_PACKED;
#endif
#ifndef glGetConvolutionParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetConvolutionParameterfv_ARGS;
typedef struct {
    int index;
    glGetConvolutionParameterfv_ARGS args;
} glGetConvolutionParameterfv_PACKED;
#endif
#ifndef glGetConvolutionParameterfvEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetConvolutionParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetConvolutionParameterfvEXT_ARGS args;
} glGetConvolutionParameterfvEXT_PACKED;
#endif
#ifndef glGetConvolutionParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetConvolutionParameteriv_ARGS;
typedef struct {
    int index;
    glGetConvolutionParameteriv_ARGS args;
} glGetConvolutionParameteriv_PACKED;
#endif
#ifndef glGetConvolutionParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetConvolutionParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetConvolutionParameterivEXT_ARGS args;
} glGetConvolutionParameterivEXT_PACKED;
#endif
#ifndef glGetConvolutionParameterxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} glGetConvolutionParameterxvOES_ARGS;
typedef struct {
    int index;
    glGetConvolutionParameterxvOES_ARGS args;
} glGetConvolutionParameterxvOES_PACKED;
#endif
#ifndef glGetDebugMessageLog_RETURN
typedef struct {
    GLuint count;
    GLsizei bufsize;
    GLenum * sources;
    GLenum * types;
    GLuint * ids;
    GLenum * severities;
    GLsizei * lengths;
    GLchar * messageLog;
} glGetDebugMessageLog_ARGS;
typedef struct {
    int index;
    glGetDebugMessageLog_ARGS args;
} glGetDebugMessageLog_PACKED;
#endif
#ifndef glGetDebugMessageLogAMD_RETURN
typedef struct {
    GLuint count;
    GLsizei bufsize;
    GLenum * categories;
    GLuint * severities;
    GLuint * ids;
    GLsizei * lengths;
    GLchar * message;
} glGetDebugMessageLogAMD_ARGS;
typedef struct {
    int index;
    glGetDebugMessageLogAMD_ARGS args;
} glGetDebugMessageLogAMD_PACKED;
#endif
#ifndef glGetDebugMessageLogARB_RETURN
typedef struct {
    GLuint count;
    GLsizei bufsize;
    GLenum * sources;
    GLenum * types;
    GLuint * ids;
    GLenum * severities;
    GLsizei * lengths;
    GLchar * messageLog;
} glGetDebugMessageLogARB_ARGS;
typedef struct {
    int index;
    glGetDebugMessageLogARB_ARGS args;
} glGetDebugMessageLogARB_PACKED;
#endif
#ifndef glGetDetailTexFuncSGIS_RETURN
typedef struct {
    GLenum target;
    GLfloat * points;
} glGetDetailTexFuncSGIS_ARGS;
typedef struct {
    int index;
    glGetDetailTexFuncSGIS_ARGS args;
} glGetDetailTexFuncSGIS_PACKED;
#endif
#ifndef glGetDoubleIndexedvEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * data;
} glGetDoubleIndexedvEXT_ARGS;
typedef struct {
    int index;
    glGetDoubleIndexedvEXT_ARGS args;
} glGetDoubleIndexedvEXT_PACKED;
#endif
#ifndef glGetDoublei_v_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * data;
} glGetDoublei_v_ARGS;
typedef struct {
    int index;
    glGetDoublei_v_ARGS args;
} glGetDoublei_v_PACKED;
#endif
#ifndef glGetDoublei_vEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * data;
} glGetDoublei_vEXT_ARGS;
typedef struct {
    int index;
    glGetDoublei_vEXT_ARGS args;
} glGetDoublei_vEXT_PACKED;
#endif
#ifndef glGetDoublev_RETURN
typedef struct {
    GLenum pname;
    GLdouble * params;
} glGetDoublev_ARGS;
typedef struct {
    int index;
    glGetDoublev_ARGS args;
} glGetDoublev_PACKED;
#endif
#ifndef glGetError_RETURN
typedef struct {
    int index;
} glGetError_PACKED;
#endif
#ifndef glGetFenceivNV_RETURN
typedef struct {
    GLuint fence;
    GLenum pname;
    GLint * params;
} glGetFenceivNV_ARGS;
typedef struct {
    int index;
    glGetFenceivNV_ARGS args;
} glGetFenceivNV_PACKED;
#endif
#ifndef glGetFinalCombinerInputParameterfvNV_RETURN
typedef struct {
    GLenum variable;
    GLenum pname;
    GLfloat * params;
} glGetFinalCombinerInputParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetFinalCombinerInputParameterfvNV_ARGS args;
} glGetFinalCombinerInputParameterfvNV_PACKED;
#endif
#ifndef glGetFinalCombinerInputParameterivNV_RETURN
typedef struct {
    GLenum variable;
    GLenum pname;
    GLint * params;
} glGetFinalCombinerInputParameterivNV_ARGS;
typedef struct {
    int index;
    glGetFinalCombinerInputParameterivNV_ARGS args;
} glGetFinalCombinerInputParameterivNV_PACKED;
#endif
#ifndef glGetFixedvOES_RETURN
typedef struct {
    GLenum pname;
    GLfixed * params;
} glGetFixedvOES_ARGS;
typedef struct {
    int index;
    glGetFixedvOES_ARGS args;
} glGetFixedvOES_PACKED;
#endif
#ifndef glGetFloatIndexedvEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * data;
} glGetFloatIndexedvEXT_ARGS;
typedef struct {
    int index;
    glGetFloatIndexedvEXT_ARGS args;
} glGetFloatIndexedvEXT_PACKED;
#endif
#ifndef glGetFloati_v_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * data;
} glGetFloati_v_ARGS;
typedef struct {
    int index;
    glGetFloati_v_ARGS args;
} glGetFloati_v_PACKED;
#endif
#ifndef glGetFloati_vEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * data;
} glGetFloati_vEXT_ARGS;
typedef struct {
    int index;
    glGetFloati_vEXT_ARGS args;
} glGetFloati_vEXT_PACKED;
#endif
#ifndef glGetFloatv_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glGetFloatv_ARGS;
typedef struct {
    int index;
    glGetFloatv_ARGS args;
} glGetFloatv_PACKED;
#endif
#ifndef glGetFogFuncSGIS_RETURN
typedef struct {
    GLfloat * points;
} glGetFogFuncSGIS_ARGS;
typedef struct {
    int index;
    glGetFogFuncSGIS_ARGS args;
} glGetFogFuncSGIS_PACKED;
#endif
#ifndef glGetFragDataIndex_RETURN
typedef struct {
    GLuint program;
    GLchar * name;
} glGetFragDataIndex_ARGS;
typedef struct {
    int index;
    glGetFragDataIndex_ARGS args;
} glGetFragDataIndex_PACKED;
#endif
#ifndef glGetFragDataLocation_RETURN
typedef struct {
    GLuint program;
    GLchar * name;
} glGetFragDataLocation_ARGS;
typedef struct {
    int index;
    glGetFragDataLocation_ARGS args;
} glGetFragDataLocation_PACKED;
#endif
#ifndef glGetFragDataLocationEXT_RETURN
typedef struct {
    GLuint program;
    GLchar * name;
} glGetFragDataLocationEXT_ARGS;
typedef struct {
    int index;
    glGetFragDataLocationEXT_ARGS args;
} glGetFragDataLocationEXT_PACKED;
#endif
#ifndef glGetFragmentLightfvSGIX_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} glGetFragmentLightfvSGIX_ARGS;
typedef struct {
    int index;
    glGetFragmentLightfvSGIX_ARGS args;
} glGetFragmentLightfvSGIX_PACKED;
#endif
#ifndef glGetFragmentLightivSGIX_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} glGetFragmentLightivSGIX_ARGS;
typedef struct {
    int index;
    glGetFragmentLightivSGIX_ARGS args;
} glGetFragmentLightivSGIX_PACKED;
#endif
#ifndef glGetFragmentMaterialfvSGIX_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} glGetFragmentMaterialfvSGIX_ARGS;
typedef struct {
    int index;
    glGetFragmentMaterialfvSGIX_ARGS args;
} glGetFragmentMaterialfvSGIX_PACKED;
#endif
#ifndef glGetFragmentMaterialivSGIX_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} glGetFragmentMaterialivSGIX_ARGS;
typedef struct {
    int index;
    glGetFragmentMaterialivSGIX_ARGS args;
} glGetFragmentMaterialivSGIX_PACKED;
#endif
#ifndef glGetFramebufferAttachmentParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum pname;
    GLint * params;
} glGetFramebufferAttachmentParameteriv_ARGS;
typedef struct {
    int index;
    glGetFramebufferAttachmentParameteriv_ARGS args;
} glGetFramebufferAttachmentParameteriv_PACKED;
#endif
#ifndef glGetFramebufferAttachmentParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum pname;
    GLint * params;
} glGetFramebufferAttachmentParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetFramebufferAttachmentParameterivEXT_ARGS args;
} glGetFramebufferAttachmentParameterivEXT_PACKED;
#endif
#ifndef glGetFramebufferParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetFramebufferParameteriv_ARGS;
typedef struct {
    int index;
    glGetFramebufferParameteriv_ARGS args;
} glGetFramebufferParameteriv_PACKED;
#endif
#ifndef glGetFramebufferParameterivEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum pname;
    GLint * params;
} glGetFramebufferParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetFramebufferParameterivEXT_ARGS args;
} glGetFramebufferParameterivEXT_PACKED;
#endif
#ifndef glGetGraphicsResetStatusARB_RETURN
typedef struct {
    int index;
} glGetGraphicsResetStatusARB_PACKED;
#endif
#ifndef glGetHandleARB_RETURN
typedef struct {
    GLenum pname;
} glGetHandleARB_ARGS;
typedef struct {
    int index;
    glGetHandleARB_ARGS args;
} glGetHandleARB_PACKED;
#endif
#ifndef glGetHistogram_RETURN
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} glGetHistogram_ARGS;
typedef struct {
    int index;
    glGetHistogram_ARGS args;
} glGetHistogram_PACKED;
#endif
#ifndef glGetHistogramEXT_RETURN
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} glGetHistogramEXT_ARGS;
typedef struct {
    int index;
    glGetHistogramEXT_ARGS args;
} glGetHistogramEXT_PACKED;
#endif
#ifndef glGetHistogramParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetHistogramParameterfv_ARGS;
typedef struct {
    int index;
    glGetHistogramParameterfv_ARGS args;
} glGetHistogramParameterfv_PACKED;
#endif
#ifndef glGetHistogramParameterfvEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetHistogramParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetHistogramParameterfvEXT_ARGS args;
} glGetHistogramParameterfvEXT_PACKED;
#endif
#ifndef glGetHistogramParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetHistogramParameteriv_ARGS;
typedef struct {
    int index;
    glGetHistogramParameteriv_ARGS args;
} glGetHistogramParameteriv_PACKED;
#endif
#ifndef glGetHistogramParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetHistogramParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetHistogramParameterivEXT_ARGS args;
} glGetHistogramParameterivEXT_PACKED;
#endif
#ifndef glGetHistogramParameterxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} glGetHistogramParameterxvOES_ARGS;
typedef struct {
    int index;
    glGetHistogramParameterxvOES_ARGS args;
} glGetHistogramParameterxvOES_PACKED;
#endif
#ifndef glGetImageHandleNV_RETURN
typedef struct {
    GLuint texture;
    GLint level;
    GLboolean layered;
    GLint layer;
    GLenum format;
} glGetImageHandleNV_ARGS;
typedef struct {
    int index;
    glGetImageHandleNV_ARGS args;
} glGetImageHandleNV_PACKED;
#endif
#ifndef glGetImageTransformParameterfvHP_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetImageTransformParameterfvHP_ARGS;
typedef struct {
    int index;
    glGetImageTransformParameterfvHP_ARGS args;
} glGetImageTransformParameterfvHP_PACKED;
#endif
#ifndef glGetImageTransformParameterivHP_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetImageTransformParameterivHP_ARGS;
typedef struct {
    int index;
    glGetImageTransformParameterivHP_ARGS args;
} glGetImageTransformParameterivHP_PACKED;
#endif
#ifndef glGetInfoLogARB_RETURN
typedef struct {
    GLhandleARB obj;
    GLsizei maxLength;
    GLsizei * length;
    GLcharARB * infoLog;
} glGetInfoLogARB_ARGS;
typedef struct {
    int index;
    glGetInfoLogARB_ARGS args;
} glGetInfoLogARB_PACKED;
#endif
#ifndef glGetInstrumentsSGIX_RETURN
typedef struct {
    int index;
} glGetInstrumentsSGIX_PACKED;
#endif
#ifndef glGetInteger64i_v_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint64 * data;
} glGetInteger64i_v_ARGS;
typedef struct {
    int index;
    glGetInteger64i_v_ARGS args;
} glGetInteger64i_v_PACKED;
#endif
#ifndef glGetInteger64v_RETURN
typedef struct {
    GLenum pname;
    GLint64 * params;
} glGetInteger64v_ARGS;
typedef struct {
    int index;
    glGetInteger64v_ARGS args;
} glGetInteger64v_PACKED;
#endif
#ifndef glGetIntegerIndexedvEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint * data;
} glGetIntegerIndexedvEXT_ARGS;
typedef struct {
    int index;
    glGetIntegerIndexedvEXT_ARGS args;
} glGetIntegerIndexedvEXT_PACKED;
#endif
#ifndef glGetIntegeri_v_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint * data;
} glGetIntegeri_v_ARGS;
typedef struct {
    int index;
    glGetIntegeri_v_ARGS args;
} glGetIntegeri_v_PACKED;
#endif
#ifndef glGetIntegerui64i_vNV_RETURN
typedef struct {
    GLenum value;
    GLuint index;
    GLuint64EXT * result;
} glGetIntegerui64i_vNV_ARGS;
typedef struct {
    int index;
    glGetIntegerui64i_vNV_ARGS args;
} glGetIntegerui64i_vNV_PACKED;
#endif
#ifndef glGetIntegerui64vNV_RETURN
typedef struct {
    GLenum value;
    GLuint64EXT * result;
} glGetIntegerui64vNV_ARGS;
typedef struct {
    int index;
    glGetIntegerui64vNV_ARGS args;
} glGetIntegerui64vNV_PACKED;
#endif
#ifndef glGetIntegerv_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glGetIntegerv_ARGS;
typedef struct {
    int index;
    glGetIntegerv_ARGS args;
} glGetIntegerv_PACKED;
#endif
#ifndef glGetInternalformati64v_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLenum pname;
    GLsizei bufSize;
    GLint64 * params;
} glGetInternalformati64v_ARGS;
typedef struct {
    int index;
    glGetInternalformati64v_ARGS args;
} glGetInternalformati64v_PACKED;
#endif
#ifndef glGetInternalformativ_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLenum pname;
    GLsizei bufSize;
    GLint * params;
} glGetInternalformativ_ARGS;
typedef struct {
    int index;
    glGetInternalformativ_ARGS args;
} glGetInternalformativ_PACKED;
#endif
#ifndef glGetInvariantBooleanvEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLboolean * data;
} glGetInvariantBooleanvEXT_ARGS;
typedef struct {
    int index;
    glGetInvariantBooleanvEXT_ARGS args;
} glGetInvariantBooleanvEXT_PACKED;
#endif
#ifndef glGetInvariantFloatvEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLfloat * data;
} glGetInvariantFloatvEXT_ARGS;
typedef struct {
    int index;
    glGetInvariantFloatvEXT_ARGS args;
} glGetInvariantFloatvEXT_PACKED;
#endif
#ifndef glGetInvariantIntegervEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLint * data;
} glGetInvariantIntegervEXT_ARGS;
typedef struct {
    int index;
    glGetInvariantIntegervEXT_ARGS args;
} glGetInvariantIntegervEXT_PACKED;
#endif
#ifndef glGetLightfv_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} glGetLightfv_ARGS;
typedef struct {
    int index;
    glGetLightfv_ARGS args;
} glGetLightfv_PACKED;
#endif
#ifndef glGetLightiv_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} glGetLightiv_ARGS;
typedef struct {
    int index;
    glGetLightiv_ARGS args;
} glGetLightiv_PACKED;
#endif
#ifndef glGetLightxOES_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed * params;
} glGetLightxOES_ARGS;
typedef struct {
    int index;
    glGetLightxOES_ARGS args;
} glGetLightxOES_PACKED;
#endif
#ifndef glGetListParameterfvSGIX_RETURN
typedef struct {
    GLuint list;
    GLenum pname;
    GLfloat * params;
} glGetListParameterfvSGIX_ARGS;
typedef struct {
    int index;
    glGetListParameterfvSGIX_ARGS args;
} glGetListParameterfvSGIX_PACKED;
#endif
#ifndef glGetListParameterivSGIX_RETURN
typedef struct {
    GLuint list;
    GLenum pname;
    GLint * params;
} glGetListParameterivSGIX_ARGS;
typedef struct {
    int index;
    glGetListParameterivSGIX_ARGS args;
} glGetListParameterivSGIX_PACKED;
#endif
#ifndef glGetLocalConstantBooleanvEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLboolean * data;
} glGetLocalConstantBooleanvEXT_ARGS;
typedef struct {
    int index;
    glGetLocalConstantBooleanvEXT_ARGS args;
} glGetLocalConstantBooleanvEXT_PACKED;
#endif
#ifndef glGetLocalConstantFloatvEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLfloat * data;
} glGetLocalConstantFloatvEXT_ARGS;
typedef struct {
    int index;
    glGetLocalConstantFloatvEXT_ARGS args;
} glGetLocalConstantFloatvEXT_PACKED;
#endif
#ifndef glGetLocalConstantIntegervEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLint * data;
} glGetLocalConstantIntegervEXT_ARGS;
typedef struct {
    int index;
    glGetLocalConstantIntegervEXT_ARGS args;
} glGetLocalConstantIntegervEXT_PACKED;
#endif
#ifndef glGetMapAttribParameterfvNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLfloat * params;
} glGetMapAttribParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetMapAttribParameterfvNV_ARGS args;
} glGetMapAttribParameterfvNV_PACKED;
#endif
#ifndef glGetMapAttribParameterivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetMapAttribParameterivNV_ARGS;
typedef struct {
    int index;
    glGetMapAttribParameterivNV_ARGS args;
} glGetMapAttribParameterivNV_PACKED;
#endif
#ifndef glGetMapControlPointsNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLenum type;
    GLsizei ustride;
    GLsizei vstride;
    GLboolean packed;
    GLvoid * points;
} glGetMapControlPointsNV_ARGS;
typedef struct {
    int index;
    glGetMapControlPointsNV_ARGS args;
} glGetMapControlPointsNV_PACKED;
#endif
#ifndef glGetMapParameterfvNV_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetMapParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetMapParameterfvNV_ARGS args;
} glGetMapParameterfvNV_PACKED;
#endif
#ifndef glGetMapParameterivNV_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetMapParameterivNV_ARGS;
typedef struct {
    int index;
    glGetMapParameterivNV_ARGS args;
} glGetMapParameterivNV_PACKED;
#endif
#ifndef glGetMapdv_RETURN
typedef struct {
    GLenum target;
    GLenum query;
    GLdouble * v;
} glGetMapdv_ARGS;
typedef struct {
    int index;
    glGetMapdv_ARGS args;
} glGetMapdv_PACKED;
#endif
#ifndef glGetMapfv_RETURN
typedef struct {
    GLenum target;
    GLenum query;
    GLfloat * v;
} glGetMapfv_ARGS;
typedef struct {
    int index;
    glGetMapfv_ARGS args;
} glGetMapfv_PACKED;
#endif
#ifndef glGetMapiv_RETURN
typedef struct {
    GLenum target;
    GLenum query;
    GLint * v;
} glGetMapiv_ARGS;
typedef struct {
    int index;
    glGetMapiv_ARGS args;
} glGetMapiv_PACKED;
#endif
#ifndef glGetMapxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum query;
    GLfixed * v;
} glGetMapxvOES_ARGS;
typedef struct {
    int index;
    glGetMapxvOES_ARGS args;
} glGetMapxvOES_PACKED;
#endif
#ifndef glGetMaterialfv_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} glGetMaterialfv_ARGS;
typedef struct {
    int index;
    glGetMaterialfv_ARGS args;
} glGetMaterialfv_PACKED;
#endif
#ifndef glGetMaterialiv_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} glGetMaterialiv_ARGS;
typedef struct {
    int index;
    glGetMaterialiv_ARGS args;
} glGetMaterialiv_PACKED;
#endif
#ifndef glGetMaterialxOES_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed param;
} glGetMaterialxOES_ARGS;
typedef struct {
    int index;
    glGetMaterialxOES_ARGS args;
} glGetMaterialxOES_PACKED;
#endif
#ifndef glGetMinmax_RETURN
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} glGetMinmax_ARGS;
typedef struct {
    int index;
    glGetMinmax_ARGS args;
} glGetMinmax_PACKED;
#endif
#ifndef glGetMinmaxEXT_RETURN
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} glGetMinmaxEXT_ARGS;
typedef struct {
    int index;
    glGetMinmaxEXT_ARGS args;
} glGetMinmaxEXT_PACKED;
#endif
#ifndef glGetMinmaxParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetMinmaxParameterfv_ARGS;
typedef struct {
    int index;
    glGetMinmaxParameterfv_ARGS args;
} glGetMinmaxParameterfv_PACKED;
#endif
#ifndef glGetMinmaxParameterfvEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetMinmaxParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetMinmaxParameterfvEXT_ARGS args;
} glGetMinmaxParameterfvEXT_PACKED;
#endif
#ifndef glGetMinmaxParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetMinmaxParameteriv_ARGS;
typedef struct {
    int index;
    glGetMinmaxParameteriv_ARGS args;
} glGetMinmaxParameteriv_PACKED;
#endif
#ifndef glGetMinmaxParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetMinmaxParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetMinmaxParameterivEXT_ARGS args;
} glGetMinmaxParameterivEXT_PACKED;
#endif
#ifndef glGetMultiTexEnvfvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetMultiTexEnvfvEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexEnvfvEXT_ARGS args;
} glGetMultiTexEnvfvEXT_PACKED;
#endif
#ifndef glGetMultiTexEnvivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetMultiTexEnvivEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexEnvivEXT_ARGS args;
} glGetMultiTexEnvivEXT_PACKED;
#endif
#ifndef glGetMultiTexGendvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} glGetMultiTexGendvEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexGendvEXT_ARGS args;
} glGetMultiTexGendvEXT_PACKED;
#endif
#ifndef glGetMultiTexGenfvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} glGetMultiTexGenfvEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexGenfvEXT_ARGS args;
} glGetMultiTexGenfvEXT_PACKED;
#endif
#ifndef glGetMultiTexGenivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLint * params;
} glGetMultiTexGenivEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexGenivEXT_ARGS args;
} glGetMultiTexGenivEXT_PACKED;
#endif
#ifndef glGetMultiTexImageEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glGetMultiTexImageEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexImageEXT_ARGS args;
} glGetMultiTexImageEXT_PACKED;
#endif
#ifndef glGetMultiTexLevelParameterfvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum pname;
    GLfloat * params;
} glGetMultiTexLevelParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexLevelParameterfvEXT_ARGS args;
} glGetMultiTexLevelParameterfvEXT_PACKED;
#endif
#ifndef glGetMultiTexLevelParameterivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum pname;
    GLint * params;
} glGetMultiTexLevelParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexLevelParameterivEXT_ARGS args;
} glGetMultiTexLevelParameterivEXT_PACKED;
#endif
#ifndef glGetMultiTexParameterIivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetMultiTexParameterIivEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexParameterIivEXT_ARGS args;
} glGetMultiTexParameterIivEXT_PACKED;
#endif
#ifndef glGetMultiTexParameterIuivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLuint * params;
} glGetMultiTexParameterIuivEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexParameterIuivEXT_ARGS args;
} glGetMultiTexParameterIuivEXT_PACKED;
#endif
#ifndef glGetMultiTexParameterfvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetMultiTexParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexParameterfvEXT_ARGS args;
} glGetMultiTexParameterfvEXT_PACKED;
#endif
#ifndef glGetMultiTexParameterivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetMultiTexParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetMultiTexParameterivEXT_ARGS args;
} glGetMultiTexParameterivEXT_PACKED;
#endif
#ifndef glGetMultisamplefv_RETURN
typedef struct {
    GLenum pname;
    GLuint index;
    GLfloat * val;
} glGetMultisamplefv_ARGS;
typedef struct {
    int index;
    glGetMultisamplefv_ARGS args;
} glGetMultisamplefv_PACKED;
#endif
#ifndef glGetMultisamplefvNV_RETURN
typedef struct {
    GLenum pname;
    GLuint index;
    GLfloat * val;
} glGetMultisamplefvNV_ARGS;
typedef struct {
    int index;
    glGetMultisamplefvNV_ARGS args;
} glGetMultisamplefvNV_PACKED;
#endif
#ifndef glGetNamedBufferParameterivEXT_RETURN
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLint * params;
} glGetNamedBufferParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetNamedBufferParameterivEXT_ARGS args;
} glGetNamedBufferParameterivEXT_PACKED;
#endif
#ifndef glGetNamedBufferParameterui64vNV_RETURN
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLuint64EXT * params;
} glGetNamedBufferParameterui64vNV_ARGS;
typedef struct {
    int index;
    glGetNamedBufferParameterui64vNV_ARGS args;
} glGetNamedBufferParameterui64vNV_PACKED;
#endif
#ifndef glGetNamedBufferPointervEXT_RETURN
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLvoid * params;
} glGetNamedBufferPointervEXT_ARGS;
typedef struct {
    int index;
    glGetNamedBufferPointervEXT_ARGS args;
} glGetNamedBufferPointervEXT_PACKED;
#endif
#ifndef glGetNamedBufferSubDataEXT_RETURN
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} glGetNamedBufferSubDataEXT_ARGS;
typedef struct {
    int index;
    glGetNamedBufferSubDataEXT_ARGS args;
} glGetNamedBufferSubDataEXT_PACKED;
#endif
#ifndef glGetNamedFramebufferAttachmentParameterivEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum pname;
    GLint * params;
} glGetNamedFramebufferAttachmentParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetNamedFramebufferAttachmentParameterivEXT_ARGS args;
} glGetNamedFramebufferAttachmentParameterivEXT_PACKED;
#endif
#ifndef glGetNamedFramebufferParameterivEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum pname;
    GLint * params;
} glGetNamedFramebufferParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetNamedFramebufferParameterivEXT_ARGS args;
} glGetNamedFramebufferParameterivEXT_PACKED;
#endif
#ifndef glGetNamedProgramLocalParameterIivEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLint * params;
} glGetNamedProgramLocalParameterIivEXT_ARGS;
typedef struct {
    int index;
    glGetNamedProgramLocalParameterIivEXT_ARGS args;
} glGetNamedProgramLocalParameterIivEXT_PACKED;
#endif
#ifndef glGetNamedProgramLocalParameterIuivEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLuint * params;
} glGetNamedProgramLocalParameterIuivEXT_ARGS;
typedef struct {
    int index;
    glGetNamedProgramLocalParameterIuivEXT_ARGS args;
} glGetNamedProgramLocalParameterIuivEXT_PACKED;
#endif
#ifndef glGetNamedProgramLocalParameterdvEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLdouble * params;
} glGetNamedProgramLocalParameterdvEXT_ARGS;
typedef struct {
    int index;
    glGetNamedProgramLocalParameterdvEXT_ARGS args;
} glGetNamedProgramLocalParameterdvEXT_PACKED;
#endif
#ifndef glGetNamedProgramLocalParameterfvEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLfloat * params;
} glGetNamedProgramLocalParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetNamedProgramLocalParameterfvEXT_ARGS args;
} glGetNamedProgramLocalParameterfvEXT_PACKED;
#endif
#ifndef glGetNamedProgramStringEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLenum pname;
    GLvoid * string;
} glGetNamedProgramStringEXT_ARGS;
typedef struct {
    int index;
    glGetNamedProgramStringEXT_ARGS args;
} glGetNamedProgramStringEXT_PACKED;
#endif
#ifndef glGetNamedProgramivEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetNamedProgramivEXT_ARGS;
typedef struct {
    int index;
    glGetNamedProgramivEXT_ARGS args;
} glGetNamedProgramivEXT_PACKED;
#endif
#ifndef glGetNamedRenderbufferParameterivEXT_RETURN
typedef struct {
    GLuint renderbuffer;
    GLenum pname;
    GLint * params;
} glGetNamedRenderbufferParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetNamedRenderbufferParameterivEXT_ARGS args;
} glGetNamedRenderbufferParameterivEXT_PACKED;
#endif
#ifndef glGetNamedStringARB_RETURN
typedef struct {
    GLint namelen;
    GLchar * name;
    GLsizei bufSize;
    GLint * stringlen;
    GLchar * string;
} glGetNamedStringARB_ARGS;
typedef struct {
    int index;
    glGetNamedStringARB_ARGS args;
} glGetNamedStringARB_PACKED;
#endif
#ifndef glGetNamedStringivARB_RETURN
typedef struct {
    GLint namelen;
    GLchar * name;
    GLenum pname;
    GLint * params;
} glGetNamedStringivARB_ARGS;
typedef struct {
    int index;
    glGetNamedStringivARB_ARGS args;
} glGetNamedStringivARB_PACKED;
#endif
#ifndef glGetObjectBufferfvATI_RETURN
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLfloat * params;
} glGetObjectBufferfvATI_ARGS;
typedef struct {
    int index;
    glGetObjectBufferfvATI_ARGS args;
} glGetObjectBufferfvATI_PACKED;
#endif
#ifndef glGetObjectBufferivATI_RETURN
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLint * params;
} glGetObjectBufferivATI_ARGS;
typedef struct {
    int index;
    glGetObjectBufferivATI_ARGS args;
} glGetObjectBufferivATI_PACKED;
#endif
#ifndef glGetObjectLabel_RETURN
typedef struct {
    GLenum identifier;
    GLuint name;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * label;
} glGetObjectLabel_ARGS;
typedef struct {
    int index;
    glGetObjectLabel_ARGS args;
} glGetObjectLabel_PACKED;
#endif
#ifndef glGetObjectParameterfvARB_RETURN
typedef struct {
    GLhandleARB obj;
    GLenum pname;
    GLfloat * params;
} glGetObjectParameterfvARB_ARGS;
typedef struct {
    int index;
    glGetObjectParameterfvARB_ARGS args;
} glGetObjectParameterfvARB_PACKED;
#endif
#ifndef glGetObjectParameterivAPPLE_RETURN
typedef struct {
    GLenum objectType;
    GLuint name;
    GLenum pname;
    GLint * params;
} glGetObjectParameterivAPPLE_ARGS;
typedef struct {
    int index;
    glGetObjectParameterivAPPLE_ARGS args;
} glGetObjectParameterivAPPLE_PACKED;
#endif
#ifndef glGetObjectParameterivARB_RETURN
typedef struct {
    GLhandleARB obj;
    GLenum pname;
    GLint * params;
} glGetObjectParameterivARB_ARGS;
typedef struct {
    int index;
    glGetObjectParameterivARB_ARGS args;
} glGetObjectParameterivARB_PACKED;
#endif
#ifndef glGetObjectPtrLabel_RETURN
typedef struct {
    void * ptr;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * label;
} glGetObjectPtrLabel_ARGS;
typedef struct {
    int index;
    glGetObjectPtrLabel_ARGS args;
} glGetObjectPtrLabel_PACKED;
#endif
#ifndef glGetOcclusionQueryivNV_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} glGetOcclusionQueryivNV_ARGS;
typedef struct {
    int index;
    glGetOcclusionQueryivNV_ARGS args;
} glGetOcclusionQueryivNV_PACKED;
#endif
#ifndef glGetOcclusionQueryuivNV_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint * params;
} glGetOcclusionQueryuivNV_ARGS;
typedef struct {
    int index;
    glGetOcclusionQueryuivNV_ARGS args;
} glGetOcclusionQueryuivNV_PACKED;
#endif
#ifndef glGetPathColorGenfvNV_RETURN
typedef struct {
    GLenum color;
    GLenum pname;
    GLfloat * value;
} glGetPathColorGenfvNV_ARGS;
typedef struct {
    int index;
    glGetPathColorGenfvNV_ARGS args;
} glGetPathColorGenfvNV_PACKED;
#endif
#ifndef glGetPathColorGenivNV_RETURN
typedef struct {
    GLenum color;
    GLenum pname;
    GLint * value;
} glGetPathColorGenivNV_ARGS;
typedef struct {
    int index;
    glGetPathColorGenivNV_ARGS args;
} glGetPathColorGenivNV_PACKED;
#endif
#ifndef glGetPathCommandsNV_RETURN
typedef struct {
    GLuint path;
    GLubyte * commands;
} glGetPathCommandsNV_ARGS;
typedef struct {
    int index;
    glGetPathCommandsNV_ARGS args;
} glGetPathCommandsNV_PACKED;
#endif
#ifndef glGetPathCoordsNV_RETURN
typedef struct {
    GLuint path;
    GLfloat * coords;
} glGetPathCoordsNV_ARGS;
typedef struct {
    int index;
    glGetPathCoordsNV_ARGS args;
} glGetPathCoordsNV_PACKED;
#endif
#ifndef glGetPathDashArrayNV_RETURN
typedef struct {
    GLuint path;
    GLfloat * dashArray;
} glGetPathDashArrayNV_ARGS;
typedef struct {
    int index;
    glGetPathDashArrayNV_ARGS args;
} glGetPathDashArrayNV_PACKED;
#endif
#ifndef glGetPathLengthNV_RETURN
typedef struct {
    GLuint path;
    GLsizei startSegment;
    GLsizei numSegments;
} glGetPathLengthNV_ARGS;
typedef struct {
    int index;
    glGetPathLengthNV_ARGS args;
} glGetPathLengthNV_PACKED;
#endif
#ifndef glGetPathMetricRangeNV_RETURN
typedef struct {
    GLbitfield metricQueryMask;
    GLuint firstPathName;
    GLsizei numPaths;
    GLsizei stride;
    GLfloat * metrics;
} glGetPathMetricRangeNV_ARGS;
typedef struct {
    int index;
    glGetPathMetricRangeNV_ARGS args;
} glGetPathMetricRangeNV_PACKED;
#endif
#ifndef glGetPathMetricsNV_RETURN
typedef struct {
    GLbitfield metricQueryMask;
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLsizei stride;
    GLfloat * metrics;
} glGetPathMetricsNV_ARGS;
typedef struct {
    int index;
    glGetPathMetricsNV_ARGS args;
} glGetPathMetricsNV_PACKED;
#endif
#ifndef glGetPathParameterfvNV_RETURN
typedef struct {
    GLuint path;
    GLenum pname;
    GLfloat * value;
} glGetPathParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetPathParameterfvNV_ARGS args;
} glGetPathParameterfvNV_PACKED;
#endif
#ifndef glGetPathParameterivNV_RETURN
typedef struct {
    GLuint path;
    GLenum pname;
    GLint * value;
} glGetPathParameterivNV_ARGS;
typedef struct {
    int index;
    glGetPathParameterivNV_ARGS args;
} glGetPathParameterivNV_PACKED;
#endif
#ifndef glGetPathSpacingNV_RETURN
typedef struct {
    GLenum pathListMode;
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLfloat advanceScale;
    GLfloat kerningScale;
    GLenum transformType;
    GLfloat * returnedSpacing;
} glGetPathSpacingNV_ARGS;
typedef struct {
    int index;
    glGetPathSpacingNV_ARGS args;
} glGetPathSpacingNV_PACKED;
#endif
#ifndef glGetPathTexGenfvNV_RETURN
typedef struct {
    GLenum texCoordSet;
    GLenum pname;
    GLfloat * value;
} glGetPathTexGenfvNV_ARGS;
typedef struct {
    int index;
    glGetPathTexGenfvNV_ARGS args;
} glGetPathTexGenfvNV_PACKED;
#endif
#ifndef glGetPathTexGenivNV_RETURN
typedef struct {
    GLenum texCoordSet;
    GLenum pname;
    GLint * value;
} glGetPathTexGenivNV_ARGS;
typedef struct {
    int index;
    glGetPathTexGenivNV_ARGS args;
} glGetPathTexGenivNV_PACKED;
#endif
#ifndef glGetPerfMonitorCounterDataAMD_RETURN
typedef struct {
    GLuint monitor;
    GLenum pname;
    GLsizei dataSize;
    GLuint * data;
    GLint * bytesWritten;
} glGetPerfMonitorCounterDataAMD_ARGS;
typedef struct {
    int index;
    glGetPerfMonitorCounterDataAMD_ARGS args;
} glGetPerfMonitorCounterDataAMD_PACKED;
#endif
#ifndef glGetPerfMonitorCounterInfoAMD_RETURN
typedef struct {
    GLuint group;
    GLuint counter;
    GLenum pname;
    GLvoid * data;
} glGetPerfMonitorCounterInfoAMD_ARGS;
typedef struct {
    int index;
    glGetPerfMonitorCounterInfoAMD_ARGS args;
} glGetPerfMonitorCounterInfoAMD_PACKED;
#endif
#ifndef glGetPerfMonitorCounterStringAMD_RETURN
typedef struct {
    GLuint group;
    GLuint counter;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * counterString;
} glGetPerfMonitorCounterStringAMD_ARGS;
typedef struct {
    int index;
    glGetPerfMonitorCounterStringAMD_ARGS args;
} glGetPerfMonitorCounterStringAMD_PACKED;
#endif
#ifndef glGetPerfMonitorCountersAMD_RETURN
typedef struct {
    GLuint group;
    GLint * numCounters;
    GLint * maxActiveCounters;
    GLsizei counterSize;
    GLuint * counters;
} glGetPerfMonitorCountersAMD_ARGS;
typedef struct {
    int index;
    glGetPerfMonitorCountersAMD_ARGS args;
} glGetPerfMonitorCountersAMD_PACKED;
#endif
#ifndef glGetPerfMonitorGroupStringAMD_RETURN
typedef struct {
    GLuint group;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * groupString;
} glGetPerfMonitorGroupStringAMD_ARGS;
typedef struct {
    int index;
    glGetPerfMonitorGroupStringAMD_ARGS args;
} glGetPerfMonitorGroupStringAMD_PACKED;
#endif
#ifndef glGetPerfMonitorGroupsAMD_RETURN
typedef struct {
    GLint * numGroups;
    GLsizei groupsSize;
    GLuint * groups;
} glGetPerfMonitorGroupsAMD_ARGS;
typedef struct {
    int index;
    glGetPerfMonitorGroupsAMD_ARGS args;
} glGetPerfMonitorGroupsAMD_PACKED;
#endif
#ifndef glGetPixelMapfv_RETURN
typedef struct {
    GLenum map;
    GLfloat * values;
} glGetPixelMapfv_ARGS;
typedef struct {
    int index;
    glGetPixelMapfv_ARGS args;
} glGetPixelMapfv_PACKED;
#endif
#ifndef glGetPixelMapuiv_RETURN
typedef struct {
    GLenum map;
    GLuint * values;
} glGetPixelMapuiv_ARGS;
typedef struct {
    int index;
    glGetPixelMapuiv_ARGS args;
} glGetPixelMapuiv_PACKED;
#endif
#ifndef glGetPixelMapusv_RETURN
typedef struct {
    GLenum map;
    GLushort * values;
} glGetPixelMapusv_ARGS;
typedef struct {
    int index;
    glGetPixelMapusv_ARGS args;
} glGetPixelMapusv_PACKED;
#endif
#ifndef glGetPixelMapxv_RETURN
typedef struct {
    GLenum map;
    GLint size;
    GLfixed * values;
} glGetPixelMapxv_ARGS;
typedef struct {
    int index;
    glGetPixelMapxv_ARGS args;
} glGetPixelMapxv_PACKED;
#endif
#ifndef glGetPixelTexGenParameterfvSGIS_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glGetPixelTexGenParameterfvSGIS_ARGS;
typedef struct {
    int index;
    glGetPixelTexGenParameterfvSGIS_ARGS args;
} glGetPixelTexGenParameterfvSGIS_PACKED;
#endif
#ifndef glGetPixelTexGenParameterivSGIS_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glGetPixelTexGenParameterivSGIS_ARGS;
typedef struct {
    int index;
    glGetPixelTexGenParameterivSGIS_ARGS args;
} glGetPixelTexGenParameterivSGIS_PACKED;
#endif
#ifndef glGetPixelTransformParameterfvEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetPixelTransformParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetPixelTransformParameterfvEXT_ARGS args;
} glGetPixelTransformParameterfvEXT_PACKED;
#endif
#ifndef glGetPixelTransformParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetPixelTransformParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetPixelTransformParameterivEXT_ARGS args;
} glGetPixelTransformParameterivEXT_PACKED;
#endif
#ifndef glGetPointerIndexedvEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLvoid * data;
} glGetPointerIndexedvEXT_ARGS;
typedef struct {
    int index;
    glGetPointerIndexedvEXT_ARGS args;
} glGetPointerIndexedvEXT_PACKED;
#endif
#ifndef glGetPointeri_vEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLvoid * data;
} glGetPointeri_vEXT_ARGS;
typedef struct {
    int index;
    glGetPointeri_vEXT_ARGS args;
} glGetPointeri_vEXT_PACKED;
#endif
#ifndef glGetPointerv_RETURN
typedef struct {
    GLenum pname;
    GLvoid ** params;
} glGetPointerv_ARGS;
typedef struct {
    int index;
    glGetPointerv_ARGS args;
} glGetPointerv_PACKED;
#endif
#ifndef glGetPointervEXT_RETURN
typedef struct {
    GLenum pname;
    GLvoid * params;
} glGetPointervEXT_ARGS;
typedef struct {
    int index;
    glGetPointervEXT_ARGS args;
} glGetPointervEXT_PACKED;
#endif
#ifndef glGetPolygonStipple_RETURN
typedef struct {
    GLubyte * mask;
} glGetPolygonStipple_ARGS;
typedef struct {
    int index;
    glGetPolygonStipple_ARGS args;
} glGetPolygonStipple_PACKED;
#endif
#ifndef glGetProgramBinary_RETURN
typedef struct {
    GLuint program;
    GLsizei bufSize;
    GLsizei * length;
    GLenum * binaryFormat;
    GLvoid * binary;
} glGetProgramBinary_ARGS;
typedef struct {
    int index;
    glGetProgramBinary_ARGS args;
} glGetProgramBinary_PACKED;
#endif
#ifndef glGetProgramEnvParameterIivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} glGetProgramEnvParameterIivNV_ARGS;
typedef struct {
    int index;
    glGetProgramEnvParameterIivNV_ARGS args;
} glGetProgramEnvParameterIivNV_PACKED;
#endif
#ifndef glGetProgramEnvParameterIuivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} glGetProgramEnvParameterIuivNV_ARGS;
typedef struct {
    int index;
    glGetProgramEnvParameterIuivNV_ARGS args;
} glGetProgramEnvParameterIuivNV_PACKED;
#endif
#ifndef glGetProgramEnvParameterdvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} glGetProgramEnvParameterdvARB_ARGS;
typedef struct {
    int index;
    glGetProgramEnvParameterdvARB_ARGS args;
} glGetProgramEnvParameterdvARB_PACKED;
#endif
#ifndef glGetProgramEnvParameterfvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} glGetProgramEnvParameterfvARB_ARGS;
typedef struct {
    int index;
    glGetProgramEnvParameterfvARB_ARGS args;
} glGetProgramEnvParameterfvARB_PACKED;
#endif
#ifndef glGetProgramInfoLog_RETURN
typedef struct {
    GLuint program;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * infoLog;
} glGetProgramInfoLog_ARGS;
typedef struct {
    int index;
    glGetProgramInfoLog_ARGS args;
} glGetProgramInfoLog_PACKED;
#endif
#ifndef glGetProgramInterfaceiv_RETURN
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLenum pname;
    GLint * params;
} glGetProgramInterfaceiv_ARGS;
typedef struct {
    int index;
    glGetProgramInterfaceiv_ARGS args;
} glGetProgramInterfaceiv_PACKED;
#endif
#ifndef glGetProgramLocalParameterIivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} glGetProgramLocalParameterIivNV_ARGS;
typedef struct {
    int index;
    glGetProgramLocalParameterIivNV_ARGS args;
} glGetProgramLocalParameterIivNV_PACKED;
#endif
#ifndef glGetProgramLocalParameterIuivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} glGetProgramLocalParameterIuivNV_ARGS;
typedef struct {
    int index;
    glGetProgramLocalParameterIuivNV_ARGS args;
} glGetProgramLocalParameterIuivNV_PACKED;
#endif
#ifndef glGetProgramLocalParameterdvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} glGetProgramLocalParameterdvARB_ARGS;
typedef struct {
    int index;
    glGetProgramLocalParameterdvARB_ARGS args;
} glGetProgramLocalParameterdvARB_PACKED;
#endif
#ifndef glGetProgramLocalParameterfvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} glGetProgramLocalParameterfvARB_ARGS;
typedef struct {
    int index;
    glGetProgramLocalParameterfvARB_ARGS args;
} glGetProgramLocalParameterfvARB_PACKED;
#endif
#ifndef glGetProgramNamedParameterdvNV_RETURN
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLdouble * params;
} glGetProgramNamedParameterdvNV_ARGS;
typedef struct {
    int index;
    glGetProgramNamedParameterdvNV_ARGS args;
} glGetProgramNamedParameterdvNV_PACKED;
#endif
#ifndef glGetProgramNamedParameterfvNV_RETURN
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLfloat * params;
} glGetProgramNamedParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetProgramNamedParameterfvNV_ARGS args;
} glGetProgramNamedParameterfvNV_PACKED;
#endif
#ifndef glGetProgramParameterdvNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLdouble * params;
} glGetProgramParameterdvNV_ARGS;
typedef struct {
    int index;
    glGetProgramParameterdvNV_ARGS args;
} glGetProgramParameterdvNV_PACKED;
#endif
#ifndef glGetProgramParameterfvNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLfloat * params;
} glGetProgramParameterfvNV_ARGS;
typedef struct {
    int index;
    glGetProgramParameterfvNV_ARGS args;
} glGetProgramParameterfvNV_PACKED;
#endif
#ifndef glGetProgramPipelineInfoLog_RETURN
typedef struct {
    GLuint pipeline;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * infoLog;
} glGetProgramPipelineInfoLog_ARGS;
typedef struct {
    int index;
    glGetProgramPipelineInfoLog_ARGS args;
} glGetProgramPipelineInfoLog_PACKED;
#endif
#ifndef glGetProgramPipelineiv_RETURN
typedef struct {
    GLuint pipeline;
    GLenum pname;
    GLint * params;
} glGetProgramPipelineiv_ARGS;
typedef struct {
    int index;
    glGetProgramPipelineiv_ARGS args;
} glGetProgramPipelineiv_PACKED;
#endif
#ifndef glGetProgramResourceIndex_RETURN
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLchar * name;
} glGetProgramResourceIndex_ARGS;
typedef struct {
    int index;
    glGetProgramResourceIndex_ARGS args;
} glGetProgramResourceIndex_PACKED;
#endif
#ifndef glGetProgramResourceLocation_RETURN
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLchar * name;
} glGetProgramResourceLocation_ARGS;
typedef struct {
    int index;
    glGetProgramResourceLocation_ARGS args;
} glGetProgramResourceLocation_PACKED;
#endif
#ifndef glGetProgramResourceLocationIndex_RETURN
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLchar * name;
} glGetProgramResourceLocationIndex_ARGS;
typedef struct {
    int index;
    glGetProgramResourceLocationIndex_ARGS args;
} glGetProgramResourceLocationIndex_PACKED;
#endif
#ifndef glGetProgramResourceName_RETURN
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * name;
} glGetProgramResourceName_ARGS;
typedef struct {
    int index;
    glGetProgramResourceName_ARGS args;
} glGetProgramResourceName_PACKED;
#endif
#ifndef glGetProgramResourceiv_RETURN
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLuint index;
    GLsizei propCount;
    GLenum * props;
    GLsizei bufSize;
    GLsizei * length;
    GLint * params;
} glGetProgramResourceiv_ARGS;
typedef struct {
    int index;
    glGetProgramResourceiv_ARGS args;
} glGetProgramResourceiv_PACKED;
#endif
#ifndef glGetProgramStageiv_RETURN
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLenum pname;
    GLint * values;
} glGetProgramStageiv_ARGS;
typedef struct {
    int index;
    glGetProgramStageiv_ARGS args;
} glGetProgramStageiv_PACKED;
#endif
#ifndef glGetProgramStringARB_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * string;
} glGetProgramStringARB_ARGS;
typedef struct {
    int index;
    glGetProgramStringARB_ARGS args;
} glGetProgramStringARB_PACKED;
#endif
#ifndef glGetProgramStringNV_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLubyte * program;
} glGetProgramStringNV_ARGS;
typedef struct {
    int index;
    glGetProgramStringNV_ARGS args;
} glGetProgramStringNV_PACKED;
#endif
#ifndef glGetProgramSubroutineParameteruivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * param;
} glGetProgramSubroutineParameteruivNV_ARGS;
typedef struct {
    int index;
    glGetProgramSubroutineParameteruivNV_ARGS args;
} glGetProgramSubroutineParameteruivNV_PACKED;
#endif
#ifndef glGetProgramiv_RETURN
typedef struct {
    GLuint program;
    GLenum pname;
    GLint * params;
} glGetProgramiv_ARGS;
typedef struct {
    int index;
    glGetProgramiv_ARGS args;
} glGetProgramiv_PACKED;
#endif
#ifndef glGetProgramivARB_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetProgramivARB_ARGS;
typedef struct {
    int index;
    glGetProgramivARB_ARGS args;
} glGetProgramivARB_PACKED;
#endif
#ifndef glGetProgramivNV_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} glGetProgramivNV_ARGS;
typedef struct {
    int index;
    glGetProgramivNV_ARGS args;
} glGetProgramivNV_PACKED;
#endif
#ifndef glGetQueryIndexediv_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetQueryIndexediv_ARGS;
typedef struct {
    int index;
    glGetQueryIndexediv_ARGS args;
} glGetQueryIndexediv_PACKED;
#endif
#ifndef glGetQueryObjecti64v_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLint64 * params;
} glGetQueryObjecti64v_ARGS;
typedef struct {
    int index;
    glGetQueryObjecti64v_ARGS args;
} glGetQueryObjecti64v_PACKED;
#endif
#ifndef glGetQueryObjecti64vEXT_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLint64EXT * params;
} glGetQueryObjecti64vEXT_ARGS;
typedef struct {
    int index;
    glGetQueryObjecti64vEXT_ARGS args;
} glGetQueryObjecti64vEXT_PACKED;
#endif
#ifndef glGetQueryObjectiv_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} glGetQueryObjectiv_ARGS;
typedef struct {
    int index;
    glGetQueryObjectiv_ARGS args;
} glGetQueryObjectiv_PACKED;
#endif
#ifndef glGetQueryObjectivARB_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} glGetQueryObjectivARB_ARGS;
typedef struct {
    int index;
    glGetQueryObjectivARB_ARGS args;
} glGetQueryObjectivARB_PACKED;
#endif
#ifndef glGetQueryObjectui64v_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint64 * params;
} glGetQueryObjectui64v_ARGS;
typedef struct {
    int index;
    glGetQueryObjectui64v_ARGS args;
} glGetQueryObjectui64v_PACKED;
#endif
#ifndef glGetQueryObjectui64vEXT_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint64EXT * params;
} glGetQueryObjectui64vEXT_ARGS;
typedef struct {
    int index;
    glGetQueryObjectui64vEXT_ARGS args;
} glGetQueryObjectui64vEXT_PACKED;
#endif
#ifndef glGetQueryObjectuiv_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint * params;
} glGetQueryObjectuiv_ARGS;
typedef struct {
    int index;
    glGetQueryObjectuiv_ARGS args;
} glGetQueryObjectuiv_PACKED;
#endif
#ifndef glGetQueryObjectuivARB_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint * params;
} glGetQueryObjectuivARB_ARGS;
typedef struct {
    int index;
    glGetQueryObjectuivARB_ARGS args;
} glGetQueryObjectuivARB_PACKED;
#endif
#ifndef glGetQueryiv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetQueryiv_ARGS;
typedef struct {
    int index;
    glGetQueryiv_ARGS args;
} glGetQueryiv_PACKED;
#endif
#ifndef glGetQueryivARB_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetQueryivARB_ARGS;
typedef struct {
    int index;
    glGetQueryivARB_ARGS args;
} glGetQueryivARB_PACKED;
#endif
#ifndef glGetRenderbufferParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetRenderbufferParameteriv_ARGS;
typedef struct {
    int index;
    glGetRenderbufferParameteriv_ARGS args;
} glGetRenderbufferParameteriv_PACKED;
#endif
#ifndef glGetRenderbufferParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetRenderbufferParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetRenderbufferParameterivEXT_ARGS args;
} glGetRenderbufferParameterivEXT_PACKED;
#endif
#ifndef glGetSamplerParameterIiv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * params;
} glGetSamplerParameterIiv_ARGS;
typedef struct {
    int index;
    glGetSamplerParameterIiv_ARGS args;
} glGetSamplerParameterIiv_PACKED;
#endif
#ifndef glGetSamplerParameterIuiv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLuint * params;
} glGetSamplerParameterIuiv_ARGS;
typedef struct {
    int index;
    glGetSamplerParameterIuiv_ARGS args;
} glGetSamplerParameterIuiv_PACKED;
#endif
#ifndef glGetSamplerParameterfv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLfloat * params;
} glGetSamplerParameterfv_ARGS;
typedef struct {
    int index;
    glGetSamplerParameterfv_ARGS args;
} glGetSamplerParameterfv_PACKED;
#endif
#ifndef glGetSamplerParameteriv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * params;
} glGetSamplerParameteriv_ARGS;
typedef struct {
    int index;
    glGetSamplerParameteriv_ARGS args;
} glGetSamplerParameteriv_PACKED;
#endif
#ifndef glGetSeparableFilter_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
    GLvoid * span;
} glGetSeparableFilter_ARGS;
typedef struct {
    int index;
    glGetSeparableFilter_ARGS args;
} glGetSeparableFilter_PACKED;
#endif
#ifndef glGetSeparableFilterEXT_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
    GLvoid * span;
} glGetSeparableFilterEXT_ARGS;
typedef struct {
    int index;
    glGetSeparableFilterEXT_ARGS args;
} glGetSeparableFilterEXT_PACKED;
#endif
#ifndef glGetShaderInfoLog_RETURN
typedef struct {
    GLuint shader;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * infoLog;
} glGetShaderInfoLog_ARGS;
typedef struct {
    int index;
    glGetShaderInfoLog_ARGS args;
} glGetShaderInfoLog_PACKED;
#endif
#ifndef glGetShaderPrecisionFormat_RETURN
typedef struct {
    GLenum shadertype;
    GLenum precisiontype;
    GLint * range;
    GLint * precision;
} glGetShaderPrecisionFormat_ARGS;
typedef struct {
    int index;
    glGetShaderPrecisionFormat_ARGS args;
} glGetShaderPrecisionFormat_PACKED;
#endif
#ifndef glGetShaderSource_RETURN
typedef struct {
    GLuint shader;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * source;
} glGetShaderSource_ARGS;
typedef struct {
    int index;
    glGetShaderSource_ARGS args;
} glGetShaderSource_PACKED;
#endif
#ifndef glGetShaderSourceARB_RETURN
typedef struct {
    GLhandleARB obj;
    GLsizei maxLength;
    GLsizei * length;
    GLcharARB * source;
} glGetShaderSourceARB_ARGS;
typedef struct {
    int index;
    glGetShaderSourceARB_ARGS args;
} glGetShaderSourceARB_PACKED;
#endif
#ifndef glGetShaderiv_RETURN
typedef struct {
    GLuint shader;
    GLenum pname;
    GLint * params;
} glGetShaderiv_ARGS;
typedef struct {
    int index;
    glGetShaderiv_ARGS args;
} glGetShaderiv_PACKED;
#endif
#ifndef glGetSharpenTexFuncSGIS_RETURN
typedef struct {
    GLenum target;
    GLfloat * points;
} glGetSharpenTexFuncSGIS_ARGS;
typedef struct {
    int index;
    glGetSharpenTexFuncSGIS_ARGS args;
} glGetSharpenTexFuncSGIS_PACKED;
#endif
#ifndef glGetString_RETURN
typedef struct {
    GLenum name;
} glGetString_ARGS;
typedef struct {
    int index;
    glGetString_ARGS args;
} glGetString_PACKED;
#endif
#ifndef glGetStringi_RETURN
typedef struct {
    GLenum name;
    GLuint index;
} glGetStringi_ARGS;
typedef struct {
    int index;
    glGetStringi_ARGS args;
} glGetStringi_PACKED;
#endif
#ifndef glGetSubroutineIndex_RETURN
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLchar * name;
} glGetSubroutineIndex_ARGS;
typedef struct {
    int index;
    glGetSubroutineIndex_ARGS args;
} glGetSubroutineIndex_PACKED;
#endif
#ifndef glGetSubroutineUniformLocation_RETURN
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLchar * name;
} glGetSubroutineUniformLocation_ARGS;
typedef struct {
    int index;
    glGetSubroutineUniformLocation_ARGS args;
} glGetSubroutineUniformLocation_PACKED;
#endif
#ifndef glGetSynciv_RETURN
typedef struct {
    GLsync sync;
    GLenum pname;
    GLsizei bufSize;
    GLsizei * length;
    GLint * values;
} glGetSynciv_ARGS;
typedef struct {
    int index;
    glGetSynciv_ARGS args;
} glGetSynciv_PACKED;
#endif
#ifndef glGetTexBumpParameterfvATI_RETURN
typedef struct {
    GLenum pname;
    GLfloat * param;
} glGetTexBumpParameterfvATI_ARGS;
typedef struct {
    int index;
    glGetTexBumpParameterfvATI_ARGS args;
} glGetTexBumpParameterfvATI_PACKED;
#endif
#ifndef glGetTexBumpParameterivATI_RETURN
typedef struct {
    GLenum pname;
    GLint * param;
} glGetTexBumpParameterivATI_ARGS;
typedef struct {
    int index;
    glGetTexBumpParameterivATI_ARGS args;
} glGetTexBumpParameterivATI_PACKED;
#endif
#ifndef glGetTexEnvfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetTexEnvfv_ARGS;
typedef struct {
    int index;
    glGetTexEnvfv_ARGS args;
} glGetTexEnvfv_PACKED;
#endif
#ifndef glGetTexEnviv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetTexEnviv_ARGS;
typedef struct {
    int index;
    glGetTexEnviv_ARGS args;
} glGetTexEnviv_PACKED;
#endif
#ifndef glGetTexEnvxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} glGetTexEnvxvOES_ARGS;
typedef struct {
    int index;
    glGetTexEnvxvOES_ARGS args;
} glGetTexEnvxvOES_PACKED;
#endif
#ifndef glGetTexFilterFuncSGIS_RETURN
typedef struct {
    GLenum target;
    GLenum filter;
    GLfloat * weights;
} glGetTexFilterFuncSGIS_ARGS;
typedef struct {
    int index;
    glGetTexFilterFuncSGIS_ARGS args;
} glGetTexFilterFuncSGIS_PACKED;
#endif
#ifndef glGetTexGendv_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} glGetTexGendv_ARGS;
typedef struct {
    int index;
    glGetTexGendv_ARGS args;
} glGetTexGendv_PACKED;
#endif
#ifndef glGetTexGenfv_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} glGetTexGenfv_ARGS;
typedef struct {
    int index;
    glGetTexGenfv_ARGS args;
} glGetTexGenfv_PACKED;
#endif
#ifndef glGetTexGeniv_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLint * params;
} glGetTexGeniv_ARGS;
typedef struct {
    int index;
    glGetTexGeniv_ARGS args;
} glGetTexGeniv_PACKED;
#endif
#ifndef glGetTexGenxvOES_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfixed * params;
} glGetTexGenxvOES_ARGS;
typedef struct {
    int index;
    glGetTexGenxvOES_ARGS args;
} glGetTexGenxvOES_PACKED;
#endif
#ifndef glGetTexImage_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glGetTexImage_ARGS;
typedef struct {
    int index;
    glGetTexImage_ARGS args;
} glGetTexImage_PACKED;
#endif
#ifndef glGetTexLevelParameterfv_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum pname;
    GLfloat * params;
} glGetTexLevelParameterfv_ARGS;
typedef struct {
    int index;
    glGetTexLevelParameterfv_ARGS args;
} glGetTexLevelParameterfv_PACKED;
#endif
#ifndef glGetTexLevelParameteriv_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum pname;
    GLint * params;
} glGetTexLevelParameteriv_ARGS;
typedef struct {
    int index;
    glGetTexLevelParameteriv_ARGS args;
} glGetTexLevelParameteriv_PACKED;
#endif
#ifndef glGetTexLevelParameterxvOES_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum pname;
    GLfixed * params;
} glGetTexLevelParameterxvOES_ARGS;
typedef struct {
    int index;
    glGetTexLevelParameterxvOES_ARGS args;
} glGetTexLevelParameterxvOES_PACKED;
#endif
#ifndef glGetTexParameterIiv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetTexParameterIiv_ARGS;
typedef struct {
    int index;
    glGetTexParameterIiv_ARGS args;
} glGetTexParameterIiv_PACKED;
#endif
#ifndef glGetTexParameterIivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetTexParameterIivEXT_ARGS;
typedef struct {
    int index;
    glGetTexParameterIivEXT_ARGS args;
} glGetTexParameterIivEXT_PACKED;
#endif
#ifndef glGetTexParameterIuiv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} glGetTexParameterIuiv_ARGS;
typedef struct {
    int index;
    glGetTexParameterIuiv_ARGS args;
} glGetTexParameterIuiv_PACKED;
#endif
#ifndef glGetTexParameterIuivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} glGetTexParameterIuivEXT_ARGS;
typedef struct {
    int index;
    glGetTexParameterIuivEXT_ARGS args;
} glGetTexParameterIuivEXT_PACKED;
#endif
#ifndef glGetTexParameterPointervAPPLE_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * params;
} glGetTexParameterPointervAPPLE_ARGS;
typedef struct {
    int index;
    glGetTexParameterPointervAPPLE_ARGS args;
} glGetTexParameterPointervAPPLE_PACKED;
#endif
#ifndef glGetTexParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetTexParameterfv_ARGS;
typedef struct {
    int index;
    glGetTexParameterfv_ARGS args;
} glGetTexParameterfv_PACKED;
#endif
#ifndef glGetTexParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetTexParameteriv_ARGS;
typedef struct {
    int index;
    glGetTexParameteriv_ARGS args;
} glGetTexParameteriv_PACKED;
#endif
#ifndef glGetTexParameterxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} glGetTexParameterxvOES_ARGS;
typedef struct {
    int index;
    glGetTexParameterxvOES_ARGS args;
} glGetTexParameterxvOES_PACKED;
#endif
#ifndef glGetTextureHandleNV_RETURN
typedef struct {
    GLuint texture;
} glGetTextureHandleNV_ARGS;
typedef struct {
    int index;
    glGetTextureHandleNV_ARGS args;
} glGetTextureHandleNV_PACKED;
#endif
#ifndef glGetTextureImageEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glGetTextureImageEXT_ARGS;
typedef struct {
    int index;
    glGetTextureImageEXT_ARGS args;
} glGetTextureImageEXT_PACKED;
#endif
#ifndef glGetTextureLevelParameterfvEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum pname;
    GLfloat * params;
} glGetTextureLevelParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetTextureLevelParameterfvEXT_ARGS args;
} glGetTextureLevelParameterfvEXT_PACKED;
#endif
#ifndef glGetTextureLevelParameterivEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum pname;
    GLint * params;
} glGetTextureLevelParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetTextureLevelParameterivEXT_ARGS args;
} glGetTextureLevelParameterivEXT_PACKED;
#endif
#ifndef glGetTextureParameterIivEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetTextureParameterIivEXT_ARGS;
typedef struct {
    int index;
    glGetTextureParameterIivEXT_ARGS args;
} glGetTextureParameterIivEXT_PACKED;
#endif
#ifndef glGetTextureParameterIuivEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLuint * params;
} glGetTextureParameterIuivEXT_ARGS;
typedef struct {
    int index;
    glGetTextureParameterIuivEXT_ARGS args;
} glGetTextureParameterIuivEXT_PACKED;
#endif
#ifndef glGetTextureParameterfvEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glGetTextureParameterfvEXT_ARGS;
typedef struct {
    int index;
    glGetTextureParameterfvEXT_ARGS args;
} glGetTextureParameterfvEXT_PACKED;
#endif
#ifndef glGetTextureParameterivEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} glGetTextureParameterivEXT_ARGS;
typedef struct {
    int index;
    glGetTextureParameterivEXT_ARGS args;
} glGetTextureParameterivEXT_PACKED;
#endif
#ifndef glGetTextureSamplerHandleNV_RETURN
typedef struct {
    GLuint texture;
    GLuint sampler;
} glGetTextureSamplerHandleNV_ARGS;
typedef struct {
    int index;
    glGetTextureSamplerHandleNV_ARGS args;
} glGetTextureSamplerHandleNV_PACKED;
#endif
#ifndef glGetTrackMatrixivNV_RETURN
typedef struct {
    GLenum target;
    GLuint address;
    GLenum pname;
    GLint * params;
} glGetTrackMatrixivNV_ARGS;
typedef struct {
    int index;
    glGetTrackMatrixivNV_ARGS args;
} glGetTrackMatrixivNV_PACKED;
#endif
#ifndef glGetTransformFeedbackVarying_RETURN
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLsizei * size;
    GLenum * type;
    GLchar * name;
} glGetTransformFeedbackVarying_ARGS;
typedef struct {
    int index;
    glGetTransformFeedbackVarying_ARGS args;
} glGetTransformFeedbackVarying_PACKED;
#endif
#ifndef glGetTransformFeedbackVaryingEXT_RETURN
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLsizei * size;
    GLenum * type;
    GLchar * name;
} glGetTransformFeedbackVaryingEXT_ARGS;
typedef struct {
    int index;
    glGetTransformFeedbackVaryingEXT_ARGS args;
} glGetTransformFeedbackVaryingEXT_PACKED;
#endif
#ifndef glGetTransformFeedbackVaryingNV_RETURN
typedef struct {
    GLuint program;
    GLuint index;
    GLint * location;
} glGetTransformFeedbackVaryingNV_ARGS;
typedef struct {
    int index;
    glGetTransformFeedbackVaryingNV_ARGS args;
} glGetTransformFeedbackVaryingNV_PACKED;
#endif
#ifndef glGetUniformBlockIndex_RETURN
typedef struct {
    GLuint program;
    GLchar * uniformBlockName;
} glGetUniformBlockIndex_ARGS;
typedef struct {
    int index;
    glGetUniformBlockIndex_ARGS args;
} glGetUniformBlockIndex_PACKED;
#endif
#ifndef glGetUniformBufferSizeEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
} glGetUniformBufferSizeEXT_ARGS;
typedef struct {
    int index;
    glGetUniformBufferSizeEXT_ARGS args;
} glGetUniformBufferSizeEXT_PACKED;
#endif
#ifndef glGetUniformIndices_RETURN
typedef struct {
    GLuint program;
    GLsizei uniformCount;
    GLchar*const * uniformNames;
    GLuint * uniformIndices;
} glGetUniformIndices_ARGS;
typedef struct {
    int index;
    glGetUniformIndices_ARGS args;
} glGetUniformIndices_PACKED;
#endif
#ifndef glGetUniformLocation_RETURN
typedef struct {
    GLuint program;
    GLchar * name;
} glGetUniformLocation_ARGS;
typedef struct {
    int index;
    glGetUniformLocation_ARGS args;
} glGetUniformLocation_PACKED;
#endif
#ifndef glGetUniformLocationARB_RETURN
typedef struct {
    GLhandleARB programObj;
    GLcharARB * name;
} glGetUniformLocationARB_ARGS;
typedef struct {
    int index;
    glGetUniformLocationARB_ARGS args;
} glGetUniformLocationARB_PACKED;
#endif
#ifndef glGetUniformOffsetEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
} glGetUniformOffsetEXT_ARGS;
typedef struct {
    int index;
    glGetUniformOffsetEXT_ARGS args;
} glGetUniformOffsetEXT_PACKED;
#endif
#ifndef glGetUniformSubroutineuiv_RETURN
typedef struct {
    GLenum shadertype;
    GLint location;
    GLuint * params;
} glGetUniformSubroutineuiv_ARGS;
typedef struct {
    int index;
    glGetUniformSubroutineuiv_ARGS args;
} glGetUniformSubroutineuiv_PACKED;
#endif
#ifndef glGetUniformdv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble * params;
} glGetUniformdv_ARGS;
typedef struct {
    int index;
    glGetUniformdv_ARGS args;
} glGetUniformdv_PACKED;
#endif
#ifndef glGetUniformfv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat * params;
} glGetUniformfv_ARGS;
typedef struct {
    int index;
    glGetUniformfv_ARGS args;
} glGetUniformfv_PACKED;
#endif
#ifndef glGetUniformfvARB_RETURN
typedef struct {
    GLhandleARB programObj;
    GLint location;
    GLfloat * params;
} glGetUniformfvARB_ARGS;
typedef struct {
    int index;
    glGetUniformfvARB_ARGS args;
} glGetUniformfvARB_PACKED;
#endif
#ifndef glGetUniformi64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT * params;
} glGetUniformi64vNV_ARGS;
typedef struct {
    int index;
    glGetUniformi64vNV_ARGS args;
} glGetUniformi64vNV_PACKED;
#endif
#ifndef glGetUniformiv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint * params;
} glGetUniformiv_ARGS;
typedef struct {
    int index;
    glGetUniformiv_ARGS args;
} glGetUniformiv_PACKED;
#endif
#ifndef glGetUniformivARB_RETURN
typedef struct {
    GLhandleARB programObj;
    GLint location;
    GLint * params;
} glGetUniformivARB_ARGS;
typedef struct {
    int index;
    glGetUniformivARB_ARGS args;
} glGetUniformivARB_PACKED;
#endif
#ifndef glGetUniformui64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT * params;
} glGetUniformui64vNV_ARGS;
typedef struct {
    int index;
    glGetUniformui64vNV_ARGS args;
} glGetUniformui64vNV_PACKED;
#endif
#ifndef glGetUniformuiv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint * params;
} glGetUniformuiv_ARGS;
typedef struct {
    int index;
    glGetUniformuiv_ARGS args;
} glGetUniformuiv_PACKED;
#endif
#ifndef glGetUniformuivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint * params;
} glGetUniformuivEXT_ARGS;
typedef struct {
    int index;
    glGetUniformuivEXT_ARGS args;
} glGetUniformuivEXT_PACKED;
#endif
#ifndef glGetVariantArrayObjectfvATI_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLfloat * params;
} glGetVariantArrayObjectfvATI_ARGS;
typedef struct {
    int index;
    glGetVariantArrayObjectfvATI_ARGS args;
} glGetVariantArrayObjectfvATI_PACKED;
#endif
#ifndef glGetVariantArrayObjectivATI_RETURN
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} glGetVariantArrayObjectivATI_ARGS;
typedef struct {
    int index;
    glGetVariantArrayObjectivATI_ARGS args;
} glGetVariantArrayObjectivATI_PACKED;
#endif
#ifndef glGetVariantBooleanvEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLboolean * data;
} glGetVariantBooleanvEXT_ARGS;
typedef struct {
    int index;
    glGetVariantBooleanvEXT_ARGS args;
} glGetVariantBooleanvEXT_PACKED;
#endif
#ifndef glGetVariantFloatvEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLfloat * data;
} glGetVariantFloatvEXT_ARGS;
typedef struct {
    int index;
    glGetVariantFloatvEXT_ARGS args;
} glGetVariantFloatvEXT_PACKED;
#endif
#ifndef glGetVariantIntegervEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLint * data;
} glGetVariantIntegervEXT_ARGS;
typedef struct {
    int index;
    glGetVariantIntegervEXT_ARGS args;
} glGetVariantIntegervEXT_PACKED;
#endif
#ifndef glGetVariantPointervEXT_RETURN
typedef struct {
    GLuint id;
    GLenum value;
    GLvoid * data;
} glGetVariantPointervEXT_ARGS;
typedef struct {
    int index;
    glGetVariantPointervEXT_ARGS args;
} glGetVariantPointervEXT_PACKED;
#endif
#ifndef glGetVaryingLocationNV_RETURN
typedef struct {
    GLuint program;
    GLchar * name;
} glGetVaryingLocationNV_ARGS;
typedef struct {
    int index;
    glGetVaryingLocationNV_ARGS args;
} glGetVaryingLocationNV_PACKED;
#endif
#ifndef glGetVertexArrayIntegeri_vEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint index;
    GLenum pname;
    GLint * param;
} glGetVertexArrayIntegeri_vEXT_ARGS;
typedef struct {
    int index;
    glGetVertexArrayIntegeri_vEXT_ARGS args;
} glGetVertexArrayIntegeri_vEXT_PACKED;
#endif
#ifndef glGetVertexArrayIntegervEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLenum pname;
    GLint * param;
} glGetVertexArrayIntegervEXT_ARGS;
typedef struct {
    int index;
    glGetVertexArrayIntegervEXT_ARGS args;
} glGetVertexArrayIntegervEXT_PACKED;
#endif
#ifndef glGetVertexArrayPointeri_vEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint index;
    GLenum pname;
    GLvoid * param;
} glGetVertexArrayPointeri_vEXT_ARGS;
typedef struct {
    int index;
    glGetVertexArrayPointeri_vEXT_ARGS args;
} glGetVertexArrayPointeri_vEXT_PACKED;
#endif
#ifndef glGetVertexArrayPointervEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLenum pname;
    GLvoid * param;
} glGetVertexArrayPointervEXT_ARGS;
typedef struct {
    int index;
    glGetVertexArrayPointervEXT_ARGS args;
} glGetVertexArrayPointervEXT_PACKED;
#endif
#ifndef glGetVertexAttribArrayObjectfvATI_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} glGetVertexAttribArrayObjectfvATI_ARGS;
typedef struct {
    int index;
    glGetVertexAttribArrayObjectfvATI_ARGS args;
} glGetVertexAttribArrayObjectfvATI_PACKED;
#endif
#ifndef glGetVertexAttribArrayObjectivATI_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetVertexAttribArrayObjectivATI_ARGS;
typedef struct {
    int index;
    glGetVertexAttribArrayObjectivATI_ARGS args;
} glGetVertexAttribArrayObjectivATI_PACKED;
#endif
#ifndef glGetVertexAttribIiv_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetVertexAttribIiv_ARGS;
typedef struct {
    int index;
    glGetVertexAttribIiv_ARGS args;
} glGetVertexAttribIiv_PACKED;
#endif
#ifndef glGetVertexAttribIivEXT_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetVertexAttribIivEXT_ARGS;
typedef struct {
    int index;
    glGetVertexAttribIivEXT_ARGS args;
} glGetVertexAttribIivEXT_PACKED;
#endif
#ifndef glGetVertexAttribIuiv_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLuint * params;
} glGetVertexAttribIuiv_ARGS;
typedef struct {
    int index;
    glGetVertexAttribIuiv_ARGS args;
} glGetVertexAttribIuiv_PACKED;
#endif
#ifndef glGetVertexAttribIuivEXT_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLuint * params;
} glGetVertexAttribIuivEXT_ARGS;
typedef struct {
    int index;
    glGetVertexAttribIuivEXT_ARGS args;
} glGetVertexAttribIuivEXT_PACKED;
#endif
#ifndef glGetVertexAttribLdv_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} glGetVertexAttribLdv_ARGS;
typedef struct {
    int index;
    glGetVertexAttribLdv_ARGS args;
} glGetVertexAttribLdv_PACKED;
#endif
#ifndef glGetVertexAttribLdvEXT_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} glGetVertexAttribLdvEXT_ARGS;
typedef struct {
    int index;
    glGetVertexAttribLdvEXT_ARGS args;
} glGetVertexAttribLdvEXT_PACKED;
#endif
#ifndef glGetVertexAttribLi64vNV_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLint64EXT * params;
} glGetVertexAttribLi64vNV_ARGS;
typedef struct {
    int index;
    glGetVertexAttribLi64vNV_ARGS args;
} glGetVertexAttribLi64vNV_PACKED;
#endif
#ifndef glGetVertexAttribLui64vNV_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLuint64EXT * params;
} glGetVertexAttribLui64vNV_ARGS;
typedef struct {
    int index;
    glGetVertexAttribLui64vNV_ARGS args;
} glGetVertexAttribLui64vNV_PACKED;
#endif
#ifndef glGetVertexAttribPointerv_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLvoid ** pointer;
} glGetVertexAttribPointerv_ARGS;
typedef struct {
    int index;
    glGetVertexAttribPointerv_ARGS args;
} glGetVertexAttribPointerv_PACKED;
#endif
#ifndef glGetVertexAttribPointervARB_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLvoid ** pointer;
} glGetVertexAttribPointervARB_ARGS;
typedef struct {
    int index;
    glGetVertexAttribPointervARB_ARGS args;
} glGetVertexAttribPointervARB_PACKED;
#endif
#ifndef glGetVertexAttribPointervNV_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLvoid ** pointer;
} glGetVertexAttribPointervNV_ARGS;
typedef struct {
    int index;
    glGetVertexAttribPointervNV_ARGS args;
} glGetVertexAttribPointervNV_PACKED;
#endif
#ifndef glGetVertexAttribdv_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} glGetVertexAttribdv_ARGS;
typedef struct {
    int index;
    glGetVertexAttribdv_ARGS args;
} glGetVertexAttribdv_PACKED;
#endif
#ifndef glGetVertexAttribdvARB_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} glGetVertexAttribdvARB_ARGS;
typedef struct {
    int index;
    glGetVertexAttribdvARB_ARGS args;
} glGetVertexAttribdvARB_PACKED;
#endif
#ifndef glGetVertexAttribdvNV_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} glGetVertexAttribdvNV_ARGS;
typedef struct {
    int index;
    glGetVertexAttribdvNV_ARGS args;
} glGetVertexAttribdvNV_PACKED;
#endif
#ifndef glGetVertexAttribfv_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} glGetVertexAttribfv_ARGS;
typedef struct {
    int index;
    glGetVertexAttribfv_ARGS args;
} glGetVertexAttribfv_PACKED;
#endif
#ifndef glGetVertexAttribfvARB_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} glGetVertexAttribfvARB_ARGS;
typedef struct {
    int index;
    glGetVertexAttribfvARB_ARGS args;
} glGetVertexAttribfvARB_PACKED;
#endif
#ifndef glGetVertexAttribfvNV_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} glGetVertexAttribfvNV_ARGS;
typedef struct {
    int index;
    glGetVertexAttribfvNV_ARGS args;
} glGetVertexAttribfvNV_PACKED;
#endif
#ifndef glGetVertexAttribiv_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetVertexAttribiv_ARGS;
typedef struct {
    int index;
    glGetVertexAttribiv_ARGS args;
} glGetVertexAttribiv_PACKED;
#endif
#ifndef glGetVertexAttribivARB_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetVertexAttribivARB_ARGS;
typedef struct {
    int index;
    glGetVertexAttribivARB_ARGS args;
} glGetVertexAttribivARB_PACKED;
#endif
#ifndef glGetVertexAttribivNV_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} glGetVertexAttribivNV_ARGS;
typedef struct {
    int index;
    glGetVertexAttribivNV_ARGS args;
} glGetVertexAttribivNV_PACKED;
#endif
#ifndef glGetVideoCaptureStreamdvNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLdouble * params;
} glGetVideoCaptureStreamdvNV_ARGS;
typedef struct {
    int index;
    glGetVideoCaptureStreamdvNV_ARGS args;
} glGetVideoCaptureStreamdvNV_PACKED;
#endif
#ifndef glGetVideoCaptureStreamfvNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLfloat * params;
} glGetVideoCaptureStreamfvNV_ARGS;
typedef struct {
    int index;
    glGetVideoCaptureStreamfvNV_ARGS args;
} glGetVideoCaptureStreamfvNV_PACKED;
#endif
#ifndef glGetVideoCaptureStreamivNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLint * params;
} glGetVideoCaptureStreamivNV_ARGS;
typedef struct {
    int index;
    glGetVideoCaptureStreamivNV_ARGS args;
} glGetVideoCaptureStreamivNV_PACKED;
#endif
#ifndef glGetVideoCaptureivNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLenum pname;
    GLint * params;
} glGetVideoCaptureivNV_ARGS;
typedef struct {
    int index;
    glGetVideoCaptureivNV_ARGS args;
} glGetVideoCaptureivNV_PACKED;
#endif
#ifndef glGetVideoi64vNV_RETURN
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLint64EXT * params;
} glGetVideoi64vNV_ARGS;
typedef struct {
    int index;
    glGetVideoi64vNV_ARGS args;
} glGetVideoi64vNV_PACKED;
#endif
#ifndef glGetVideoivNV_RETURN
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLint * params;
} glGetVideoivNV_ARGS;
typedef struct {
    int index;
    glGetVideoivNV_ARGS args;
} glGetVideoivNV_PACKED;
#endif
#ifndef glGetVideoui64vNV_RETURN
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLuint64EXT * params;
} glGetVideoui64vNV_ARGS;
typedef struct {
    int index;
    glGetVideoui64vNV_ARGS args;
} glGetVideoui64vNV_PACKED;
#endif
#ifndef glGetVideouivNV_RETURN
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLuint * params;
} glGetVideouivNV_ARGS;
typedef struct {
    int index;
    glGetVideouivNV_ARGS args;
} glGetVideouivNV_PACKED;
#endif
#ifndef glGetnColorTableARB_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * table;
} glGetnColorTableARB_ARGS;
typedef struct {
    int index;
    glGetnColorTableARB_ARGS args;
} glGetnColorTableARB_PACKED;
#endif
#ifndef glGetnCompressedTexImageARB_RETURN
typedef struct {
    GLenum target;
    GLint lod;
    GLsizei bufSize;
    GLvoid * img;
} glGetnCompressedTexImageARB_ARGS;
typedef struct {
    int index;
    glGetnCompressedTexImageARB_ARGS args;
} glGetnCompressedTexImageARB_PACKED;
#endif
#ifndef glGetnConvolutionFilterARB_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * image;
} glGetnConvolutionFilterARB_ARGS;
typedef struct {
    int index;
    glGetnConvolutionFilterARB_ARGS args;
} glGetnConvolutionFilterARB_PACKED;
#endif
#ifndef glGetnHistogramARB_RETURN
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * values;
} glGetnHistogramARB_ARGS;
typedef struct {
    int index;
    glGetnHistogramARB_ARGS args;
} glGetnHistogramARB_PACKED;
#endif
#ifndef glGetnMapdvARB_RETURN
typedef struct {
    GLenum target;
    GLenum query;
    GLsizei bufSize;
    GLdouble * v;
} glGetnMapdvARB_ARGS;
typedef struct {
    int index;
    glGetnMapdvARB_ARGS args;
} glGetnMapdvARB_PACKED;
#endif
#ifndef glGetnMapfvARB_RETURN
typedef struct {
    GLenum target;
    GLenum query;
    GLsizei bufSize;
    GLfloat * v;
} glGetnMapfvARB_ARGS;
typedef struct {
    int index;
    glGetnMapfvARB_ARGS args;
} glGetnMapfvARB_PACKED;
#endif
#ifndef glGetnMapivARB_RETURN
typedef struct {
    GLenum target;
    GLenum query;
    GLsizei bufSize;
    GLint * v;
} glGetnMapivARB_ARGS;
typedef struct {
    int index;
    glGetnMapivARB_ARGS args;
} glGetnMapivARB_PACKED;
#endif
#ifndef glGetnMinmaxARB_RETURN
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * values;
} glGetnMinmaxARB_ARGS;
typedef struct {
    int index;
    glGetnMinmaxARB_ARGS args;
} glGetnMinmaxARB_PACKED;
#endif
#ifndef glGetnPixelMapfvARB_RETURN
typedef struct {
    GLenum map;
    GLsizei bufSize;
    GLfloat * values;
} glGetnPixelMapfvARB_ARGS;
typedef struct {
    int index;
    glGetnPixelMapfvARB_ARGS args;
} glGetnPixelMapfvARB_PACKED;
#endif
#ifndef glGetnPixelMapuivARB_RETURN
typedef struct {
    GLenum map;
    GLsizei bufSize;
    GLuint * values;
} glGetnPixelMapuivARB_ARGS;
typedef struct {
    int index;
    glGetnPixelMapuivARB_ARGS args;
} glGetnPixelMapuivARB_PACKED;
#endif
#ifndef glGetnPixelMapusvARB_RETURN
typedef struct {
    GLenum map;
    GLsizei bufSize;
    GLushort * values;
} glGetnPixelMapusvARB_ARGS;
typedef struct {
    int index;
    glGetnPixelMapusvARB_ARGS args;
} glGetnPixelMapusvARB_PACKED;
#endif
#ifndef glGetnPolygonStippleARB_RETURN
typedef struct {
    GLsizei bufSize;
    GLubyte * pattern;
} glGetnPolygonStippleARB_ARGS;
typedef struct {
    int index;
    glGetnPolygonStippleARB_ARGS args;
} glGetnPolygonStippleARB_PACKED;
#endif
#ifndef glGetnSeparableFilterARB_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLsizei rowBufSize;
    GLvoid * row;
    GLsizei columnBufSize;
    GLvoid * column;
    GLvoid * span;
} glGetnSeparableFilterARB_ARGS;
typedef struct {
    int index;
    glGetnSeparableFilterARB_ARGS args;
} glGetnSeparableFilterARB_PACKED;
#endif
#ifndef glGetnTexImageARB_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * img;
} glGetnTexImageARB_ARGS;
typedef struct {
    int index;
    glGetnTexImageARB_ARGS args;
} glGetnTexImageARB_PACKED;
#endif
#ifndef glGetnUniformdvARB_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLdouble * params;
} glGetnUniformdvARB_ARGS;
typedef struct {
    int index;
    glGetnUniformdvARB_ARGS args;
} glGetnUniformdvARB_PACKED;
#endif
#ifndef glGetnUniformfvARB_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLfloat * params;
} glGetnUniformfvARB_ARGS;
typedef struct {
    int index;
    glGetnUniformfvARB_ARGS args;
} glGetnUniformfvARB_PACKED;
#endif
#ifndef glGetnUniformivARB_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLint * params;
} glGetnUniformivARB_ARGS;
typedef struct {
    int index;
    glGetnUniformivARB_ARGS args;
} glGetnUniformivARB_PACKED;
#endif
#ifndef glGetnUniformuivARB_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLuint * params;
} glGetnUniformuivARB_ARGS;
typedef struct {
    int index;
    glGetnUniformuivARB_ARGS args;
} glGetnUniformuivARB_PACKED;
#endif
#ifndef glGlobalAlphaFactorbSUN_RETURN
typedef struct {
    GLbyte factor;
} glGlobalAlphaFactorbSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactorbSUN_ARGS args;
} glGlobalAlphaFactorbSUN_PACKED;
#endif
#ifndef glGlobalAlphaFactordSUN_RETURN
typedef struct {
    GLdouble factor __attribute__ ((aligned(8)));
} glGlobalAlphaFactordSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactordSUN_ARGS args;
} glGlobalAlphaFactordSUN_PACKED;
#endif
#ifndef glGlobalAlphaFactorfSUN_RETURN
typedef struct {
    GLfloat factor;
} glGlobalAlphaFactorfSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactorfSUN_ARGS args;
} glGlobalAlphaFactorfSUN_PACKED;
#endif
#ifndef glGlobalAlphaFactoriSUN_RETURN
typedef struct {
    GLint factor;
} glGlobalAlphaFactoriSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactoriSUN_ARGS args;
} glGlobalAlphaFactoriSUN_PACKED;
#endif
#ifndef glGlobalAlphaFactorsSUN_RETURN
typedef struct {
    GLshort factor;
} glGlobalAlphaFactorsSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactorsSUN_ARGS args;
} glGlobalAlphaFactorsSUN_PACKED;
#endif
#ifndef glGlobalAlphaFactorubSUN_RETURN
typedef struct {
    GLubyte factor;
} glGlobalAlphaFactorubSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactorubSUN_ARGS args;
} glGlobalAlphaFactorubSUN_PACKED;
#endif
#ifndef glGlobalAlphaFactoruiSUN_RETURN
typedef struct {
    GLuint factor;
} glGlobalAlphaFactoruiSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactoruiSUN_ARGS args;
} glGlobalAlphaFactoruiSUN_PACKED;
#endif
#ifndef glGlobalAlphaFactorusSUN_RETURN
typedef struct {
    GLushort factor;
} glGlobalAlphaFactorusSUN_ARGS;
typedef struct {
    int index;
    glGlobalAlphaFactorusSUN_ARGS args;
} glGlobalAlphaFactorusSUN_PACKED;
#endif
#ifndef glHint_RETURN
typedef struct {
    GLenum target;
    GLenum mode;
} glHint_ARGS;
typedef struct {
    int index;
    glHint_ARGS args;
} glHint_PACKED;
#endif
#ifndef glHintPGI_RETURN
typedef struct {
    GLenum target;
    GLint mode;
} glHintPGI_ARGS;
typedef struct {
    int index;
    glHintPGI_ARGS args;
} glHintPGI_PACKED;
#endif
#ifndef glHistogram_RETURN
typedef struct {
    GLenum target;
    GLsizei width;
    GLenum internalformat;
    GLboolean sink;
} glHistogram_ARGS;
typedef struct {
    int index;
    glHistogram_ARGS args;
} glHistogram_PACKED;
#endif
#ifndef glHistogramEXT_RETURN
typedef struct {
    GLenum target;
    GLsizei width;
    GLenum internalformat;
    GLboolean sink;
} glHistogramEXT_ARGS;
typedef struct {
    int index;
    glHistogramEXT_ARGS args;
} glHistogramEXT_PACKED;
#endif
#ifndef glIglooInterfaceSGIX_RETURN
typedef struct {
    GLenum pname;
    GLvoid * params;
} glIglooInterfaceSGIX_ARGS;
typedef struct {
    int index;
    glIglooInterfaceSGIX_ARGS args;
} glIglooInterfaceSGIX_PACKED;
#endif
#ifndef glImageTransformParameterfHP_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} glImageTransformParameterfHP_ARGS;
typedef struct {
    int index;
    glImageTransformParameterfHP_ARGS args;
} glImageTransformParameterfHP_PACKED;
#endif
#ifndef glImageTransformParameterfvHP_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glImageTransformParameterfvHP_ARGS;
typedef struct {
    int index;
    glImageTransformParameterfvHP_ARGS args;
} glImageTransformParameterfvHP_PACKED;
#endif
#ifndef glImageTransformParameteriHP_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} glImageTransformParameteriHP_ARGS;
typedef struct {
    int index;
    glImageTransformParameteriHP_ARGS args;
} glImageTransformParameteriHP_PACKED;
#endif
#ifndef glImageTransformParameterivHP_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glImageTransformParameterivHP_ARGS;
typedef struct {
    int index;
    glImageTransformParameterivHP_ARGS args;
} glImageTransformParameterivHP_PACKED;
#endif
#ifndef glImportSyncEXT_RETURN
typedef struct {
    GLenum external_sync_type;
    GLintptr external_sync;
    GLbitfield flags;
} glImportSyncEXT_ARGS;
typedef struct {
    int index;
    glImportSyncEXT_ARGS args;
} glImportSyncEXT_PACKED;
#endif
#ifndef glIndexFormatNV_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
} glIndexFormatNV_ARGS;
typedef struct {
    int index;
    glIndexFormatNV_ARGS args;
} glIndexFormatNV_PACKED;
#endif
#ifndef glIndexFuncEXT_RETURN
typedef struct {
    GLenum func;
    GLclampf ref;
} glIndexFuncEXT_ARGS;
typedef struct {
    int index;
    glIndexFuncEXT_ARGS args;
} glIndexFuncEXT_PACKED;
#endif
#ifndef glIndexMask_RETURN
typedef struct {
    GLuint mask;
} glIndexMask_ARGS;
typedef struct {
    int index;
    glIndexMask_ARGS args;
} glIndexMask_PACKED;
#endif
#ifndef glIndexMaterialEXT_RETURN
typedef struct {
    GLenum face;
    GLenum mode;
} glIndexMaterialEXT_ARGS;
typedef struct {
    int index;
    glIndexMaterialEXT_ARGS args;
} glIndexMaterialEXT_PACKED;
#endif
#ifndef glIndexPointer_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glIndexPointer_ARGS;
typedef struct {
    int index;
    glIndexPointer_ARGS args;
} glIndexPointer_PACKED;
#endif
#ifndef glIndexPointerEXT_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} glIndexPointerEXT_ARGS;
typedef struct {
    int index;
    glIndexPointerEXT_ARGS args;
} glIndexPointerEXT_PACKED;
#endif
#ifndef glIndexPointerListIBM_RETURN
typedef struct {
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} glIndexPointerListIBM_ARGS;
typedef struct {
    int index;
    glIndexPointerListIBM_ARGS args;
} glIndexPointerListIBM_PACKED;
#endif
#ifndef glIndexd_RETURN
typedef struct {
    GLdouble c __attribute__ ((aligned(8)));
} glIndexd_ARGS;
typedef struct {
    int index;
    glIndexd_ARGS args;
} glIndexd_PACKED;
#endif
#ifndef glIndexdv_RETURN
typedef struct {
    GLdouble * c;
} glIndexdv_ARGS;
typedef struct {
    int index;
    glIndexdv_ARGS args;
} glIndexdv_PACKED;
#endif
#ifndef glIndexf_RETURN
typedef struct {
    GLfloat c;
} glIndexf_ARGS;
typedef struct {
    int index;
    glIndexf_ARGS args;
} glIndexf_PACKED;
#endif
#ifndef glIndexfv_RETURN
typedef struct {
    GLfloat * c;
} glIndexfv_ARGS;
typedef struct {
    int index;
    glIndexfv_ARGS args;
} glIndexfv_PACKED;
#endif
#ifndef glIndexi_RETURN
typedef struct {
    GLint c;
} glIndexi_ARGS;
typedef struct {
    int index;
    glIndexi_ARGS args;
} glIndexi_PACKED;
#endif
#ifndef glIndexiv_RETURN
typedef struct {
    GLint * c;
} glIndexiv_ARGS;
typedef struct {
    int index;
    glIndexiv_ARGS args;
} glIndexiv_PACKED;
#endif
#ifndef glIndexs_RETURN
typedef struct {
    GLshort c;
} glIndexs_ARGS;
typedef struct {
    int index;
    glIndexs_ARGS args;
} glIndexs_PACKED;
#endif
#ifndef glIndexsv_RETURN
typedef struct {
    GLshort * c;
} glIndexsv_ARGS;
typedef struct {
    int index;
    glIndexsv_ARGS args;
} glIndexsv_PACKED;
#endif
#ifndef glIndexub_RETURN
typedef struct {
    GLubyte c;
} glIndexub_ARGS;
typedef struct {
    int index;
    glIndexub_ARGS args;
} glIndexub_PACKED;
#endif
#ifndef glIndexubv_RETURN
typedef struct {
    GLubyte * c;
} glIndexubv_ARGS;
typedef struct {
    int index;
    glIndexubv_ARGS args;
} glIndexubv_PACKED;
#endif
#ifndef glIndexxOES_RETURN
typedef struct {
    GLfixed component;
} glIndexxOES_ARGS;
typedef struct {
    int index;
    glIndexxOES_ARGS args;
} glIndexxOES_PACKED;
#endif
#ifndef glIndexxvOES_RETURN
typedef struct {
    GLfixed * component;
} glIndexxvOES_ARGS;
typedef struct {
    int index;
    glIndexxvOES_ARGS args;
} glIndexxvOES_PACKED;
#endif
#ifndef glInitNames_RETURN
typedef struct {
    int index;
} glInitNames_PACKED;
#endif
#ifndef glInsertComponentEXT_RETURN
typedef struct {
    GLuint res;
    GLuint src;
    GLuint num;
} glInsertComponentEXT_ARGS;
typedef struct {
    int index;
    glInsertComponentEXT_ARGS args;
} glInsertComponentEXT_PACKED;
#endif
#ifndef glInstrumentsBufferSGIX_RETURN
typedef struct {
    GLsizei size;
    GLint * buffer;
} glInstrumentsBufferSGIX_ARGS;
typedef struct {
    int index;
    glInstrumentsBufferSGIX_ARGS args;
} glInstrumentsBufferSGIX_PACKED;
#endif
#ifndef glInterleavedArrays_RETURN
typedef struct {
    GLenum format;
    GLsizei stride;
    GLvoid * pointer;
} glInterleavedArrays_ARGS;
typedef struct {
    int index;
    glInterleavedArrays_ARGS args;
} glInterleavedArrays_PACKED;
#endif
#ifndef glInterpolatePathsNV_RETURN
typedef struct {
    GLuint resultPath;
    GLuint pathA;
    GLuint pathB;
    GLfloat weight;
} glInterpolatePathsNV_ARGS;
typedef struct {
    int index;
    glInterpolatePathsNV_ARGS args;
} glInterpolatePathsNV_PACKED;
#endif
#ifndef glInvalidateBufferData_RETURN
typedef struct {
    GLuint buffer;
} glInvalidateBufferData_ARGS;
typedef struct {
    int index;
    glInvalidateBufferData_ARGS args;
} glInvalidateBufferData_PACKED;
#endif
#ifndef glInvalidateBufferSubData_RETURN
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr length;
} glInvalidateBufferSubData_ARGS;
typedef struct {
    int index;
    glInvalidateBufferSubData_ARGS args;
} glInvalidateBufferSubData_PACKED;
#endif
#ifndef glInvalidateFramebuffer_RETURN
typedef struct {
    GLenum target;
    GLsizei numAttachments;
    GLenum * attachments;
} glInvalidateFramebuffer_ARGS;
typedef struct {
    int index;
    glInvalidateFramebuffer_ARGS args;
} glInvalidateFramebuffer_PACKED;
#endif
#ifndef glInvalidateSubFramebuffer_RETURN
typedef struct {
    GLenum target;
    GLsizei numAttachments;
    GLenum * attachments;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glInvalidateSubFramebuffer_ARGS;
typedef struct {
    int index;
    glInvalidateSubFramebuffer_ARGS args;
} glInvalidateSubFramebuffer_PACKED;
#endif
#ifndef glInvalidateTexImage_RETURN
typedef struct {
    GLuint texture;
    GLint level;
} glInvalidateTexImage_ARGS;
typedef struct {
    int index;
    glInvalidateTexImage_ARGS args;
} glInvalidateTexImage_PACKED;
#endif
#ifndef glInvalidateTexSubImage_RETURN
typedef struct {
    GLuint texture;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} glInvalidateTexSubImage_ARGS;
typedef struct {
    int index;
    glInvalidateTexSubImage_ARGS args;
} glInvalidateTexSubImage_PACKED;
#endif
#ifndef glIsAsyncMarkerSGIX_RETURN
typedef struct {
    GLuint marker;
} glIsAsyncMarkerSGIX_ARGS;
typedef struct {
    int index;
    glIsAsyncMarkerSGIX_ARGS args;
} glIsAsyncMarkerSGIX_PACKED;
#endif
#ifndef glIsBuffer_RETURN
typedef struct {
    GLuint buffer;
} glIsBuffer_ARGS;
typedef struct {
    int index;
    glIsBuffer_ARGS args;
} glIsBuffer_PACKED;
#endif
#ifndef glIsBufferARB_RETURN
typedef struct {
    GLuint buffer;
} glIsBufferARB_ARGS;
typedef struct {
    int index;
    glIsBufferARB_ARGS args;
} glIsBufferARB_PACKED;
#endif
#ifndef glIsBufferResidentNV_RETURN
typedef struct {
    GLenum target;
} glIsBufferResidentNV_ARGS;
typedef struct {
    int index;
    glIsBufferResidentNV_ARGS args;
} glIsBufferResidentNV_PACKED;
#endif
#ifndef glIsEnabled_RETURN
typedef struct {
    GLenum cap;
} glIsEnabled_ARGS;
typedef struct {
    int index;
    glIsEnabled_ARGS args;
} glIsEnabled_PACKED;
#endif
#ifndef glIsEnabledIndexedEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
} glIsEnabledIndexedEXT_ARGS;
typedef struct {
    int index;
    glIsEnabledIndexedEXT_ARGS args;
} glIsEnabledIndexedEXT_PACKED;
#endif
#ifndef glIsEnabledi_RETURN
typedef struct {
    GLenum target;
    GLuint index;
} glIsEnabledi_ARGS;
typedef struct {
    int index;
    glIsEnabledi_ARGS args;
} glIsEnabledi_PACKED;
#endif
#ifndef glIsFenceAPPLE_RETURN
typedef struct {
    GLuint fence;
} glIsFenceAPPLE_ARGS;
typedef struct {
    int index;
    glIsFenceAPPLE_ARGS args;
} glIsFenceAPPLE_PACKED;
#endif
#ifndef glIsFenceNV_RETURN
typedef struct {
    GLuint fence;
} glIsFenceNV_ARGS;
typedef struct {
    int index;
    glIsFenceNV_ARGS args;
} glIsFenceNV_PACKED;
#endif
#ifndef glIsFramebuffer_RETURN
typedef struct {
    GLuint framebuffer;
} glIsFramebuffer_ARGS;
typedef struct {
    int index;
    glIsFramebuffer_ARGS args;
} glIsFramebuffer_PACKED;
#endif
#ifndef glIsFramebufferEXT_RETURN
typedef struct {
    GLuint framebuffer;
} glIsFramebufferEXT_ARGS;
typedef struct {
    int index;
    glIsFramebufferEXT_ARGS args;
} glIsFramebufferEXT_PACKED;
#endif
#ifndef glIsImageHandleResidentNV_RETURN
typedef struct {
    GLuint64 handle;
} glIsImageHandleResidentNV_ARGS;
typedef struct {
    int index;
    glIsImageHandleResidentNV_ARGS args;
} glIsImageHandleResidentNV_PACKED;
#endif
#ifndef glIsList_RETURN
typedef struct {
    GLuint list;
} glIsList_ARGS;
typedef struct {
    int index;
    glIsList_ARGS args;
} glIsList_PACKED;
#endif
#ifndef glIsNameAMD_RETURN
typedef struct {
    GLenum identifier;
    GLuint name;
} glIsNameAMD_ARGS;
typedef struct {
    int index;
    glIsNameAMD_ARGS args;
} glIsNameAMD_PACKED;
#endif
#ifndef glIsNamedBufferResidentNV_RETURN
typedef struct {
    GLuint buffer;
} glIsNamedBufferResidentNV_ARGS;
typedef struct {
    int index;
    glIsNamedBufferResidentNV_ARGS args;
} glIsNamedBufferResidentNV_PACKED;
#endif
#ifndef glIsNamedStringARB_RETURN
typedef struct {
    GLint namelen;
    GLchar * name;
} glIsNamedStringARB_ARGS;
typedef struct {
    int index;
    glIsNamedStringARB_ARGS args;
} glIsNamedStringARB_PACKED;
#endif
#ifndef glIsObjectBufferATI_RETURN
typedef struct {
    GLuint buffer;
} glIsObjectBufferATI_ARGS;
typedef struct {
    int index;
    glIsObjectBufferATI_ARGS args;
} glIsObjectBufferATI_PACKED;
#endif
#ifndef glIsOcclusionQueryNV_RETURN
typedef struct {
    GLuint id;
} glIsOcclusionQueryNV_ARGS;
typedef struct {
    int index;
    glIsOcclusionQueryNV_ARGS args;
} glIsOcclusionQueryNV_PACKED;
#endif
#ifndef glIsPathNV_RETURN
typedef struct {
    GLuint path;
} glIsPathNV_ARGS;
typedef struct {
    int index;
    glIsPathNV_ARGS args;
} glIsPathNV_PACKED;
#endif
#ifndef glIsPointInFillPathNV_RETURN
typedef struct {
    GLuint path;
    GLuint mask;
    GLfloat x;
    GLfloat y;
} glIsPointInFillPathNV_ARGS;
typedef struct {
    int index;
    glIsPointInFillPathNV_ARGS args;
} glIsPointInFillPathNV_PACKED;
#endif
#ifndef glIsPointInStrokePathNV_RETURN
typedef struct {
    GLuint path;
    GLfloat x;
    GLfloat y;
} glIsPointInStrokePathNV_ARGS;
typedef struct {
    int index;
    glIsPointInStrokePathNV_ARGS args;
} glIsPointInStrokePathNV_PACKED;
#endif
#ifndef glIsProgram_RETURN
typedef struct {
    GLuint program;
} glIsProgram_ARGS;
typedef struct {
    int index;
    glIsProgram_ARGS args;
} glIsProgram_PACKED;
#endif
#ifndef glIsProgramARB_RETURN
typedef struct {
    GLuint program;
} glIsProgramARB_ARGS;
typedef struct {
    int index;
    glIsProgramARB_ARGS args;
} glIsProgramARB_PACKED;
#endif
#ifndef glIsProgramNV_RETURN
typedef struct {
    GLuint id;
} glIsProgramNV_ARGS;
typedef struct {
    int index;
    glIsProgramNV_ARGS args;
} glIsProgramNV_PACKED;
#endif
#ifndef glIsProgramPipeline_RETURN
typedef struct {
    GLuint pipeline;
} glIsProgramPipeline_ARGS;
typedef struct {
    int index;
    glIsProgramPipeline_ARGS args;
} glIsProgramPipeline_PACKED;
#endif
#ifndef glIsQuery_RETURN
typedef struct {
    GLuint id;
} glIsQuery_ARGS;
typedef struct {
    int index;
    glIsQuery_ARGS args;
} glIsQuery_PACKED;
#endif
#ifndef glIsQueryARB_RETURN
typedef struct {
    GLuint id;
} glIsQueryARB_ARGS;
typedef struct {
    int index;
    glIsQueryARB_ARGS args;
} glIsQueryARB_PACKED;
#endif
#ifndef glIsRenderbuffer_RETURN
typedef struct {
    GLuint renderbuffer;
} glIsRenderbuffer_ARGS;
typedef struct {
    int index;
    glIsRenderbuffer_ARGS args;
} glIsRenderbuffer_PACKED;
#endif
#ifndef glIsRenderbufferEXT_RETURN
typedef struct {
    GLuint renderbuffer;
} glIsRenderbufferEXT_ARGS;
typedef struct {
    int index;
    glIsRenderbufferEXT_ARGS args;
} glIsRenderbufferEXT_PACKED;
#endif
#ifndef glIsSampler_RETURN
typedef struct {
    GLuint sampler;
} glIsSampler_ARGS;
typedef struct {
    int index;
    glIsSampler_ARGS args;
} glIsSampler_PACKED;
#endif
#ifndef glIsShader_RETURN
typedef struct {
    GLuint shader;
} glIsShader_ARGS;
typedef struct {
    int index;
    glIsShader_ARGS args;
} glIsShader_PACKED;
#endif
#ifndef glIsSync_RETURN
typedef struct {
    GLsync sync;
} glIsSync_ARGS;
typedef struct {
    int index;
    glIsSync_ARGS args;
} glIsSync_PACKED;
#endif
#ifndef glIsTexture_RETURN
typedef struct {
    GLuint texture;
} glIsTexture_ARGS;
typedef struct {
    int index;
    glIsTexture_ARGS args;
} glIsTexture_PACKED;
#endif
#ifndef glIsTextureEXT_RETURN
typedef struct {
    GLuint texture;
} glIsTextureEXT_ARGS;
typedef struct {
    int index;
    glIsTextureEXT_ARGS args;
} glIsTextureEXT_PACKED;
#endif
#ifndef glIsTextureHandleResidentNV_RETURN
typedef struct {
    GLuint64 handle;
} glIsTextureHandleResidentNV_ARGS;
typedef struct {
    int index;
    glIsTextureHandleResidentNV_ARGS args;
} glIsTextureHandleResidentNV_PACKED;
#endif
#ifndef glIsTransformFeedback_RETURN
typedef struct {
    GLuint id;
} glIsTransformFeedback_ARGS;
typedef struct {
    int index;
    glIsTransformFeedback_ARGS args;
} glIsTransformFeedback_PACKED;
#endif
#ifndef glIsTransformFeedbackNV_RETURN
typedef struct {
    GLuint id;
} glIsTransformFeedbackNV_ARGS;
typedef struct {
    int index;
    glIsTransformFeedbackNV_ARGS args;
} glIsTransformFeedbackNV_PACKED;
#endif
#ifndef glIsVariantEnabledEXT_RETURN
typedef struct {
    GLuint id;
    GLenum cap;
} glIsVariantEnabledEXT_ARGS;
typedef struct {
    int index;
    glIsVariantEnabledEXT_ARGS args;
} glIsVariantEnabledEXT_PACKED;
#endif
#ifndef glIsVertexArray_RETURN
typedef struct {
    GLuint array;
} glIsVertexArray_ARGS;
typedef struct {
    int index;
    glIsVertexArray_ARGS args;
} glIsVertexArray_PACKED;
#endif
#ifndef glIsVertexArrayAPPLE_RETURN
typedef struct {
    GLuint array;
} glIsVertexArrayAPPLE_ARGS;
typedef struct {
    int index;
    glIsVertexArrayAPPLE_ARGS args;
} glIsVertexArrayAPPLE_PACKED;
#endif
#ifndef glIsVertexAttribEnabledAPPLE_RETURN
typedef struct {
    GLuint index;
    GLenum pname;
} glIsVertexAttribEnabledAPPLE_ARGS;
typedef struct {
    int index;
    glIsVertexAttribEnabledAPPLE_ARGS args;
} glIsVertexAttribEnabledAPPLE_PACKED;
#endif
#ifndef glLightEnviSGIX_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glLightEnviSGIX_ARGS;
typedef struct {
    int index;
    glLightEnviSGIX_ARGS args;
} glLightEnviSGIX_PACKED;
#endif
#ifndef glLightModelf_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glLightModelf_ARGS;
typedef struct {
    int index;
    glLightModelf_ARGS args;
} glLightModelf_PACKED;
#endif
#ifndef glLightModelfv_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glLightModelfv_ARGS;
typedef struct {
    int index;
    glLightModelfv_ARGS args;
} glLightModelfv_PACKED;
#endif
#ifndef glLightModeli_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glLightModeli_ARGS;
typedef struct {
    int index;
    glLightModeli_ARGS args;
} glLightModeli_PACKED;
#endif
#ifndef glLightModeliv_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glLightModeliv_ARGS;
typedef struct {
    int index;
    glLightModeliv_ARGS args;
} glLightModeliv_PACKED;
#endif
#ifndef glLightModelxOES_RETURN
typedef struct {
    GLenum pname;
    GLfixed param;
} glLightModelxOES_ARGS;
typedef struct {
    int index;
    glLightModelxOES_ARGS args;
} glLightModelxOES_PACKED;
#endif
#ifndef glLightModelxvOES_RETURN
typedef struct {
    GLenum pname;
    GLfixed * param;
} glLightModelxvOES_ARGS;
typedef struct {
    int index;
    glLightModelxvOES_ARGS args;
} glLightModelxvOES_PACKED;
#endif
#ifndef glLightf_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat param;
} glLightf_ARGS;
typedef struct {
    int index;
    glLightf_ARGS args;
} glLightf_PACKED;
#endif
#ifndef glLightfv_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} glLightfv_ARGS;
typedef struct {
    int index;
    glLightfv_ARGS args;
} glLightfv_PACKED;
#endif
#ifndef glLighti_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLint param;
} glLighti_ARGS;
typedef struct {
    int index;
    glLighti_ARGS args;
} glLighti_PACKED;
#endif
#ifndef glLightiv_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} glLightiv_ARGS;
typedef struct {
    int index;
    glLightiv_ARGS args;
} glLightiv_PACKED;
#endif
#ifndef glLightxOES_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed param;
} glLightxOES_ARGS;
typedef struct {
    int index;
    glLightxOES_ARGS args;
} glLightxOES_PACKED;
#endif
#ifndef glLightxvOES_RETURN
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed * params;
} glLightxvOES_ARGS;
typedef struct {
    int index;
    glLightxvOES_ARGS args;
} glLightxvOES_PACKED;
#endif
#ifndef glLineStipple_RETURN
typedef struct {
    GLint factor;
    GLushort pattern;
} glLineStipple_ARGS;
typedef struct {
    int index;
    glLineStipple_ARGS args;
} glLineStipple_PACKED;
#endif
#ifndef glLineWidth_RETURN
typedef struct {
    GLfloat width;
} glLineWidth_ARGS;
typedef struct {
    int index;
    glLineWidth_ARGS args;
} glLineWidth_PACKED;
#endif
#ifndef glLineWidthxOES_RETURN
typedef struct {
    GLfixed width;
} glLineWidthxOES_ARGS;
typedef struct {
    int index;
    glLineWidthxOES_ARGS args;
} glLineWidthxOES_PACKED;
#endif
#ifndef glLinkProgram_RETURN
typedef struct {
    GLuint program;
} glLinkProgram_ARGS;
typedef struct {
    int index;
    glLinkProgram_ARGS args;
} glLinkProgram_PACKED;
#endif
#ifndef glLinkProgramARB_RETURN
typedef struct {
    GLhandleARB programObj;
} glLinkProgramARB_ARGS;
typedef struct {
    int index;
    glLinkProgramARB_ARGS args;
} glLinkProgramARB_PACKED;
#endif
#ifndef glListBase_RETURN
typedef struct {
    GLuint base;
} glListBase_ARGS;
typedef struct {
    int index;
    glListBase_ARGS args;
} glListBase_PACKED;
#endif
#ifndef glListParameterfSGIX_RETURN
typedef struct {
    GLuint list;
    GLenum pname;
    GLfloat param;
} glListParameterfSGIX_ARGS;
typedef struct {
    int index;
    glListParameterfSGIX_ARGS args;
} glListParameterfSGIX_PACKED;
#endif
#ifndef glListParameterfvSGIX_RETURN
typedef struct {
    GLuint list;
    GLenum pname;
    GLfloat * params;
} glListParameterfvSGIX_ARGS;
typedef struct {
    int index;
    glListParameterfvSGIX_ARGS args;
} glListParameterfvSGIX_PACKED;
#endif
#ifndef glListParameteriSGIX_RETURN
typedef struct {
    GLuint list;
    GLenum pname;
    GLint param;
} glListParameteriSGIX_ARGS;
typedef struct {
    int index;
    glListParameteriSGIX_ARGS args;
} glListParameteriSGIX_PACKED;
#endif
#ifndef glListParameterivSGIX_RETURN
typedef struct {
    GLuint list;
    GLenum pname;
    GLint * params;
} glListParameterivSGIX_ARGS;
typedef struct {
    int index;
    glListParameterivSGIX_ARGS args;
} glListParameterivSGIX_PACKED;
#endif
#ifndef glLoadIdentity_RETURN
typedef struct {
    int index;
} glLoadIdentity_PACKED;
#endif
#ifndef glLoadIdentityDeformationMapSGIX_RETURN
typedef struct {
    GLbitfield mask;
} glLoadIdentityDeformationMapSGIX_ARGS;
typedef struct {
    int index;
    glLoadIdentityDeformationMapSGIX_ARGS args;
} glLoadIdentityDeformationMapSGIX_PACKED;
#endif
#ifndef glLoadMatrixd_RETURN
typedef struct {
    GLdouble * m;
} glLoadMatrixd_ARGS;
typedef struct {
    int index;
    glLoadMatrixd_ARGS args;
} glLoadMatrixd_PACKED;
#endif
#ifndef glLoadMatrixf_RETURN
typedef struct {
    GLfloat * m;
} glLoadMatrixf_ARGS;
typedef struct {
    int index;
    glLoadMatrixf_ARGS args;
} glLoadMatrixf_PACKED;
#endif
#ifndef glLoadMatrixxOES_RETURN
typedef struct {
    GLfixed * m;
} glLoadMatrixxOES_ARGS;
typedef struct {
    int index;
    glLoadMatrixxOES_ARGS args;
} glLoadMatrixxOES_PACKED;
#endif
#ifndef glLoadName_RETURN
typedef struct {
    GLuint name;
} glLoadName_ARGS;
typedef struct {
    int index;
    glLoadName_ARGS args;
} glLoadName_PACKED;
#endif
#ifndef glLoadProgramNV_RETURN
typedef struct {
    GLenum target;
    GLuint id;
    GLsizei len;
    GLubyte * program;
} glLoadProgramNV_ARGS;
typedef struct {
    int index;
    glLoadProgramNV_ARGS args;
} glLoadProgramNV_PACKED;
#endif
#ifndef glLoadTransposeMatrixd_RETURN
typedef struct {
    GLdouble * m;
} glLoadTransposeMatrixd_ARGS;
typedef struct {
    int index;
    glLoadTransposeMatrixd_ARGS args;
} glLoadTransposeMatrixd_PACKED;
#endif
#ifndef glLoadTransposeMatrixdARB_RETURN
typedef struct {
    GLdouble * m;
} glLoadTransposeMatrixdARB_ARGS;
typedef struct {
    int index;
    glLoadTransposeMatrixdARB_ARGS args;
} glLoadTransposeMatrixdARB_PACKED;
#endif
#ifndef glLoadTransposeMatrixf_RETURN
typedef struct {
    GLfloat * m;
} glLoadTransposeMatrixf_ARGS;
typedef struct {
    int index;
    glLoadTransposeMatrixf_ARGS args;
} glLoadTransposeMatrixf_PACKED;
#endif
#ifndef glLoadTransposeMatrixfARB_RETURN
typedef struct {
    GLfloat * m;
} glLoadTransposeMatrixfARB_ARGS;
typedef struct {
    int index;
    glLoadTransposeMatrixfARB_ARGS args;
} glLoadTransposeMatrixfARB_PACKED;
#endif
#ifndef glLoadTransposeMatrixxOES_RETURN
typedef struct {
    GLfixed * m;
} glLoadTransposeMatrixxOES_ARGS;
typedef struct {
    int index;
    glLoadTransposeMatrixxOES_ARGS args;
} glLoadTransposeMatrixxOES_PACKED;
#endif
#ifndef glLockArraysEXT_RETURN
typedef struct {
    GLint first;
    GLsizei count;
} glLockArraysEXT_ARGS;
typedef struct {
    int index;
    glLockArraysEXT_ARGS args;
} glLockArraysEXT_PACKED;
#endif
#ifndef glLogicOp_RETURN
typedef struct {
    GLenum opcode;
} glLogicOp_ARGS;
typedef struct {
    int index;
    glLogicOp_ARGS args;
} glLogicOp_PACKED;
#endif
#ifndef glMakeBufferNonResidentNV_RETURN
typedef struct {
    GLenum target;
} glMakeBufferNonResidentNV_ARGS;
typedef struct {
    int index;
    glMakeBufferNonResidentNV_ARGS args;
} glMakeBufferNonResidentNV_PACKED;
#endif
#ifndef glMakeBufferResidentNV_RETURN
typedef struct {
    GLenum target;
    GLenum access;
} glMakeBufferResidentNV_ARGS;
typedef struct {
    int index;
    glMakeBufferResidentNV_ARGS args;
} glMakeBufferResidentNV_PACKED;
#endif
#ifndef glMakeImageHandleNonResidentNV_RETURN
typedef struct {
    GLuint64 handle;
} glMakeImageHandleNonResidentNV_ARGS;
typedef struct {
    int index;
    glMakeImageHandleNonResidentNV_ARGS args;
} glMakeImageHandleNonResidentNV_PACKED;
#endif
#ifndef glMakeImageHandleResidentNV_RETURN
typedef struct {
    GLuint64 handle;
    GLenum access;
} glMakeImageHandleResidentNV_ARGS;
typedef struct {
    int index;
    glMakeImageHandleResidentNV_ARGS args;
} glMakeImageHandleResidentNV_PACKED;
#endif
#ifndef glMakeNamedBufferNonResidentNV_RETURN
typedef struct {
    GLuint buffer;
} glMakeNamedBufferNonResidentNV_ARGS;
typedef struct {
    int index;
    glMakeNamedBufferNonResidentNV_ARGS args;
} glMakeNamedBufferNonResidentNV_PACKED;
#endif
#ifndef glMakeNamedBufferResidentNV_RETURN
typedef struct {
    GLuint buffer;
    GLenum access;
} glMakeNamedBufferResidentNV_ARGS;
typedef struct {
    int index;
    glMakeNamedBufferResidentNV_ARGS args;
} glMakeNamedBufferResidentNV_PACKED;
#endif
#ifndef glMakeTextureHandleNonResidentNV_RETURN
typedef struct {
    GLuint64 handle;
} glMakeTextureHandleNonResidentNV_ARGS;
typedef struct {
    int index;
    glMakeTextureHandleNonResidentNV_ARGS args;
} glMakeTextureHandleNonResidentNV_PACKED;
#endif
#ifndef glMakeTextureHandleResidentNV_RETURN
typedef struct {
    GLuint64 handle;
} glMakeTextureHandleResidentNV_ARGS;
typedef struct {
    int index;
    glMakeTextureHandleResidentNV_ARGS args;
} glMakeTextureHandleResidentNV_PACKED;
#endif
#ifndef glMap1d_RETURN
typedef struct {
    GLenum target;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint stride;
    GLint order;
    GLdouble * points;
} glMap1d_ARGS;
typedef struct {
    int index;
    glMap1d_ARGS args;
} glMap1d_PACKED;
#endif
#ifndef glMap1f_RETURN
typedef struct {
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
    GLfloat * points;
} glMap1f_ARGS;
typedef struct {
    int index;
    glMap1f_ARGS args;
} glMap1f_PACKED;
#endif
#ifndef glMap1xOES_RETURN
typedef struct {
    GLenum target;
    GLfixed u1;
    GLfixed u2;
    GLint stride;
    GLint order;
    GLfixed points;
} glMap1xOES_ARGS;
typedef struct {
    int index;
    glMap1xOES_ARGS args;
} glMap1xOES_PACKED;
#endif
#ifndef glMap2d_RETURN
typedef struct {
    GLenum target;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint ustride;
    GLint uorder;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLint vstride;
    GLint vorder;
    GLdouble * points;
} glMap2d_ARGS;
typedef struct {
    int index;
    glMap2d_ARGS args;
} glMap2d_PACKED;
#endif
#ifndef glMap2f_RETURN
typedef struct {
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLfloat * points;
} glMap2f_ARGS;
typedef struct {
    int index;
    glMap2f_ARGS args;
} glMap2f_PACKED;
#endif
#ifndef glMap2xOES_RETURN
typedef struct {
    GLenum target;
    GLfixed u1;
    GLfixed u2;
    GLint ustride;
    GLint uorder;
    GLfixed v1;
    GLfixed v2;
    GLint vstride;
    GLint vorder;
    GLfixed points;
} glMap2xOES_ARGS;
typedef struct {
    int index;
    glMap2xOES_ARGS args;
} glMap2xOES_PACKED;
#endif
#ifndef glMapBuffer_RETURN
typedef struct {
    GLenum target;
    GLenum access;
} glMapBuffer_ARGS;
typedef struct {
    int index;
    glMapBuffer_ARGS args;
} glMapBuffer_PACKED;
#endif
#ifndef glMapBufferARB_RETURN
typedef struct {
    GLenum target;
    GLenum access;
} glMapBufferARB_ARGS;
typedef struct {
    int index;
    glMapBufferARB_ARGS args;
} glMapBufferARB_PACKED;
#endif
#ifndef glMapBufferRange_RETURN
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr length;
    GLbitfield access;
} glMapBufferRange_ARGS;
typedef struct {
    int index;
    glMapBufferRange_ARGS args;
} glMapBufferRange_PACKED;
#endif
#ifndef glMapControlPointsNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLenum type;
    GLsizei ustride;
    GLsizei vstride;
    GLint uorder;
    GLint vorder;
    GLboolean packed;
    GLvoid * points;
} glMapControlPointsNV_ARGS;
typedef struct {
    int index;
    glMapControlPointsNV_ARGS args;
} glMapControlPointsNV_PACKED;
#endif
#ifndef glMapGrid1d_RETURN
typedef struct {
    GLint un;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
} glMapGrid1d_ARGS;
typedef struct {
    int index;
    glMapGrid1d_ARGS args;
} glMapGrid1d_PACKED;
#endif
#ifndef glMapGrid1f_RETURN
typedef struct {
    GLint un;
    GLfloat u1;
    GLfloat u2;
} glMapGrid1f_ARGS;
typedef struct {
    int index;
    glMapGrid1f_ARGS args;
} glMapGrid1f_PACKED;
#endif
#ifndef glMapGrid1xOES_RETURN
typedef struct {
    GLint n;
    GLfixed u1;
    GLfixed u2;
} glMapGrid1xOES_ARGS;
typedef struct {
    int index;
    glMapGrid1xOES_ARGS args;
} glMapGrid1xOES_PACKED;
#endif
#ifndef glMapGrid2d_RETURN
typedef struct {
    GLint un;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint vn;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
} glMapGrid2d_ARGS;
typedef struct {
    int index;
    glMapGrid2d_ARGS args;
} glMapGrid2d_PACKED;
#endif
#ifndef glMapGrid2f_RETURN
typedef struct {
    GLint un;
    GLfloat u1;
    GLfloat u2;
    GLint vn;
    GLfloat v1;
    GLfloat v2;
} glMapGrid2f_ARGS;
typedef struct {
    int index;
    glMapGrid2f_ARGS args;
} glMapGrid2f_PACKED;
#endif
#ifndef glMapGrid2xOES_RETURN
typedef struct {
    GLint n;
    GLfixed u1;
    GLfixed u2;
    GLfixed v1;
    GLfixed v2;
} glMapGrid2xOES_ARGS;
typedef struct {
    int index;
    glMapGrid2xOES_ARGS args;
} glMapGrid2xOES_PACKED;
#endif
#ifndef glMapNamedBufferEXT_RETURN
typedef struct {
    GLuint buffer;
    GLenum access;
} glMapNamedBufferEXT_ARGS;
typedef struct {
    int index;
    glMapNamedBufferEXT_ARGS args;
} glMapNamedBufferEXT_PACKED;
#endif
#ifndef glMapNamedBufferRangeEXT_RETURN
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr length;
    GLbitfield access;
} glMapNamedBufferRangeEXT_ARGS;
typedef struct {
    int index;
    glMapNamedBufferRangeEXT_ARGS args;
} glMapNamedBufferRangeEXT_PACKED;
#endif
#ifndef glMapObjectBufferATI_RETURN
typedef struct {
    GLuint buffer;
} glMapObjectBufferATI_ARGS;
typedef struct {
    int index;
    glMapObjectBufferATI_ARGS args;
} glMapObjectBufferATI_PACKED;
#endif
#ifndef glMapParameterfvNV_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glMapParameterfvNV_ARGS;
typedef struct {
    int index;
    glMapParameterfvNV_ARGS args;
} glMapParameterfvNV_PACKED;
#endif
#ifndef glMapParameterivNV_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glMapParameterivNV_ARGS;
typedef struct {
    int index;
    glMapParameterivNV_ARGS args;
} glMapParameterivNV_PACKED;
#endif
#ifndef glMapTexture2DINTEL_RETURN
typedef struct {
    GLuint texture;
    GLint level;
    GLbitfield access;
    GLint * stride;
    GLenum * layout;
} glMapTexture2DINTEL_ARGS;
typedef struct {
    int index;
    glMapTexture2DINTEL_ARGS args;
} glMapTexture2DINTEL_PACKED;
#endif
#ifndef glMapVertexAttrib1dAPPLE_RETURN
typedef struct {
    GLuint index;
    GLuint size;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint stride;
    GLint order;
    GLdouble * points;
} glMapVertexAttrib1dAPPLE_ARGS;
typedef struct {
    int index;
    glMapVertexAttrib1dAPPLE_ARGS args;
} glMapVertexAttrib1dAPPLE_PACKED;
#endif
#ifndef glMapVertexAttrib1fAPPLE_RETURN
typedef struct {
    GLuint index;
    GLuint size;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
    GLfloat * points;
} glMapVertexAttrib1fAPPLE_ARGS;
typedef struct {
    int index;
    glMapVertexAttrib1fAPPLE_ARGS args;
} glMapVertexAttrib1fAPPLE_PACKED;
#endif
#ifndef glMapVertexAttrib2dAPPLE_RETURN
typedef struct {
    GLuint index;
    GLuint size;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint ustride;
    GLint uorder;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLint vstride;
    GLint vorder;
    GLdouble * points;
} glMapVertexAttrib2dAPPLE_ARGS;
typedef struct {
    int index;
    glMapVertexAttrib2dAPPLE_ARGS args;
} glMapVertexAttrib2dAPPLE_PACKED;
#endif
#ifndef glMapVertexAttrib2fAPPLE_RETURN
typedef struct {
    GLuint index;
    GLuint size;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLfloat * points;
} glMapVertexAttrib2fAPPLE_ARGS;
typedef struct {
    int index;
    glMapVertexAttrib2fAPPLE_ARGS args;
} glMapVertexAttrib2fAPPLE_PACKED;
#endif
#ifndef glMaterialf_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat param;
} glMaterialf_ARGS;
typedef struct {
    int index;
    glMaterialf_ARGS args;
} glMaterialf_PACKED;
#endif
#ifndef glMaterialfv_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} glMaterialfv_ARGS;
typedef struct {
    int index;
    glMaterialfv_ARGS args;
} glMaterialfv_PACKED;
#endif
#ifndef glMateriali_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLint param;
} glMateriali_ARGS;
typedef struct {
    int index;
    glMateriali_ARGS args;
} glMateriali_PACKED;
#endif
#ifndef glMaterialiv_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} glMaterialiv_ARGS;
typedef struct {
    int index;
    glMaterialiv_ARGS args;
} glMaterialiv_PACKED;
#endif
#ifndef glMaterialxOES_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed param;
} glMaterialxOES_ARGS;
typedef struct {
    int index;
    glMaterialxOES_ARGS args;
} glMaterialxOES_PACKED;
#endif
#ifndef glMaterialxvOES_RETURN
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed * param;
} glMaterialxvOES_ARGS;
typedef struct {
    int index;
    glMaterialxvOES_ARGS args;
} glMaterialxvOES_PACKED;
#endif
#ifndef glMatrixFrustumEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} glMatrixFrustumEXT_ARGS;
typedef struct {
    int index;
    glMatrixFrustumEXT_ARGS args;
} glMatrixFrustumEXT_PACKED;
#endif
#ifndef glMatrixIndexPointerARB_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glMatrixIndexPointerARB_ARGS;
typedef struct {
    int index;
    glMatrixIndexPointerARB_ARGS args;
} glMatrixIndexPointerARB_PACKED;
#endif
#ifndef glMatrixIndexubvARB_RETURN
typedef struct {
    GLint size;
    GLubyte * indices;
} glMatrixIndexubvARB_ARGS;
typedef struct {
    int index;
    glMatrixIndexubvARB_ARGS args;
} glMatrixIndexubvARB_PACKED;
#endif
#ifndef glMatrixIndexuivARB_RETURN
typedef struct {
    GLint size;
    GLuint * indices;
} glMatrixIndexuivARB_ARGS;
typedef struct {
    int index;
    glMatrixIndexuivARB_ARGS args;
} glMatrixIndexuivARB_PACKED;
#endif
#ifndef glMatrixIndexusvARB_RETURN
typedef struct {
    GLint size;
    GLushort * indices;
} glMatrixIndexusvARB_ARGS;
typedef struct {
    int index;
    glMatrixIndexusvARB_ARGS args;
} glMatrixIndexusvARB_PACKED;
#endif
#ifndef glMatrixLoadIdentityEXT_RETURN
typedef struct {
    GLenum mode;
} glMatrixLoadIdentityEXT_ARGS;
typedef struct {
    int index;
    glMatrixLoadIdentityEXT_ARGS args;
} glMatrixLoadIdentityEXT_PACKED;
#endif
#ifndef glMatrixLoadTransposedEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble * m;
} glMatrixLoadTransposedEXT_ARGS;
typedef struct {
    int index;
    glMatrixLoadTransposedEXT_ARGS args;
} glMatrixLoadTransposedEXT_PACKED;
#endif
#ifndef glMatrixLoadTransposefEXT_RETURN
typedef struct {
    GLenum mode;
    GLfloat * m;
} glMatrixLoadTransposefEXT_ARGS;
typedef struct {
    int index;
    glMatrixLoadTransposefEXT_ARGS args;
} glMatrixLoadTransposefEXT_PACKED;
#endif
#ifndef glMatrixLoaddEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble * m;
} glMatrixLoaddEXT_ARGS;
typedef struct {
    int index;
    glMatrixLoaddEXT_ARGS args;
} glMatrixLoaddEXT_PACKED;
#endif
#ifndef glMatrixLoadfEXT_RETURN
typedef struct {
    GLenum mode;
    GLfloat * m;
} glMatrixLoadfEXT_ARGS;
typedef struct {
    int index;
    glMatrixLoadfEXT_ARGS args;
} glMatrixLoadfEXT_PACKED;
#endif
#ifndef glMatrixMode_RETURN
typedef struct {
    GLenum mode;
} glMatrixMode_ARGS;
typedef struct {
    int index;
    glMatrixMode_ARGS args;
} glMatrixMode_PACKED;
#endif
#ifndef glMatrixMultTransposedEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble * m;
} glMatrixMultTransposedEXT_ARGS;
typedef struct {
    int index;
    glMatrixMultTransposedEXT_ARGS args;
} glMatrixMultTransposedEXT_PACKED;
#endif
#ifndef glMatrixMultTransposefEXT_RETURN
typedef struct {
    GLenum mode;
    GLfloat * m;
} glMatrixMultTransposefEXT_ARGS;
typedef struct {
    int index;
    glMatrixMultTransposefEXT_ARGS args;
} glMatrixMultTransposefEXT_PACKED;
#endif
#ifndef glMatrixMultdEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble * m;
} glMatrixMultdEXT_ARGS;
typedef struct {
    int index;
    glMatrixMultdEXT_ARGS args;
} glMatrixMultdEXT_PACKED;
#endif
#ifndef glMatrixMultfEXT_RETURN
typedef struct {
    GLenum mode;
    GLfloat * m;
} glMatrixMultfEXT_ARGS;
typedef struct {
    int index;
    glMatrixMultfEXT_ARGS args;
} glMatrixMultfEXT_PACKED;
#endif
#ifndef glMatrixOrthoEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} glMatrixOrthoEXT_ARGS;
typedef struct {
    int index;
    glMatrixOrthoEXT_ARGS args;
} glMatrixOrthoEXT_PACKED;
#endif
#ifndef glMatrixPopEXT_RETURN
typedef struct {
    GLenum mode;
} glMatrixPopEXT_ARGS;
typedef struct {
    int index;
    glMatrixPopEXT_ARGS args;
} glMatrixPopEXT_PACKED;
#endif
#ifndef glMatrixPushEXT_RETURN
typedef struct {
    GLenum mode;
} glMatrixPushEXT_ARGS;
typedef struct {
    int index;
    glMatrixPushEXT_ARGS args;
} glMatrixPushEXT_PACKED;
#endif
#ifndef glMatrixRotatedEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble angle __attribute__ ((aligned(8)));
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glMatrixRotatedEXT_ARGS;
typedef struct {
    int index;
    glMatrixRotatedEXT_ARGS args;
} glMatrixRotatedEXT_PACKED;
#endif
#ifndef glMatrixRotatefEXT_RETURN
typedef struct {
    GLenum mode;
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glMatrixRotatefEXT_ARGS;
typedef struct {
    int index;
    glMatrixRotatefEXT_ARGS args;
} glMatrixRotatefEXT_PACKED;
#endif
#ifndef glMatrixScaledEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glMatrixScaledEXT_ARGS;
typedef struct {
    int index;
    glMatrixScaledEXT_ARGS args;
} glMatrixScaledEXT_PACKED;
#endif
#ifndef glMatrixScalefEXT_RETURN
typedef struct {
    GLenum mode;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glMatrixScalefEXT_ARGS;
typedef struct {
    int index;
    glMatrixScalefEXT_ARGS args;
} glMatrixScalefEXT_PACKED;
#endif
#ifndef glMatrixTranslatedEXT_RETURN
typedef struct {
    GLenum mode;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glMatrixTranslatedEXT_ARGS;
typedef struct {
    int index;
    glMatrixTranslatedEXT_ARGS args;
} glMatrixTranslatedEXT_PACKED;
#endif
#ifndef glMatrixTranslatefEXT_RETURN
typedef struct {
    GLenum mode;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glMatrixTranslatefEXT_ARGS;
typedef struct {
    int index;
    glMatrixTranslatefEXT_ARGS args;
} glMatrixTranslatefEXT_PACKED;
#endif
#ifndef glMemoryBarrier_RETURN
typedef struct {
    GLbitfield barriers;
} glMemoryBarrier_ARGS;
typedef struct {
    int index;
    glMemoryBarrier_ARGS args;
} glMemoryBarrier_PACKED;
#endif
#ifndef glMemoryBarrierEXT_RETURN
typedef struct {
    GLbitfield barriers;
} glMemoryBarrierEXT_ARGS;
typedef struct {
    int index;
    glMemoryBarrierEXT_ARGS args;
} glMemoryBarrierEXT_PACKED;
#endif
#ifndef glMinSampleShading_RETURN
typedef struct {
    GLfloat value;
} glMinSampleShading_ARGS;
typedef struct {
    int index;
    glMinSampleShading_ARGS args;
} glMinSampleShading_PACKED;
#endif
#ifndef glMinSampleShadingARB_RETURN
typedef struct {
    GLfloat value;
} glMinSampleShadingARB_ARGS;
typedef struct {
    int index;
    glMinSampleShadingARB_ARGS args;
} glMinSampleShadingARB_PACKED;
#endif
#ifndef glMinmax_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLboolean sink;
} glMinmax_ARGS;
typedef struct {
    int index;
    glMinmax_ARGS args;
} glMinmax_PACKED;
#endif
#ifndef glMinmaxEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLboolean sink;
} glMinmaxEXT_ARGS;
typedef struct {
    int index;
    glMinmaxEXT_ARGS args;
} glMinmaxEXT_PACKED;
#endif
#ifndef glMultMatrixd_RETURN
typedef struct {
    GLdouble * m;
} glMultMatrixd_ARGS;
typedef struct {
    int index;
    glMultMatrixd_ARGS args;
} glMultMatrixd_PACKED;
#endif
#ifndef glMultMatrixf_RETURN
typedef struct {
    GLfloat * m;
} glMultMatrixf_ARGS;
typedef struct {
    int index;
    glMultMatrixf_ARGS args;
} glMultMatrixf_PACKED;
#endif
#ifndef glMultMatrixxOES_RETURN
typedef struct {
    GLfixed * m;
} glMultMatrixxOES_ARGS;
typedef struct {
    int index;
    glMultMatrixxOES_ARGS args;
} glMultMatrixxOES_PACKED;
#endif
#ifndef glMultTransposeMatrixd_RETURN
typedef struct {
    GLdouble * m;
} glMultTransposeMatrixd_ARGS;
typedef struct {
    int index;
    glMultTransposeMatrixd_ARGS args;
} glMultTransposeMatrixd_PACKED;
#endif
#ifndef glMultTransposeMatrixdARB_RETURN
typedef struct {
    GLdouble * m;
} glMultTransposeMatrixdARB_ARGS;
typedef struct {
    int index;
    glMultTransposeMatrixdARB_ARGS args;
} glMultTransposeMatrixdARB_PACKED;
#endif
#ifndef glMultTransposeMatrixf_RETURN
typedef struct {
    GLfloat * m;
} glMultTransposeMatrixf_ARGS;
typedef struct {
    int index;
    glMultTransposeMatrixf_ARGS args;
} glMultTransposeMatrixf_PACKED;
#endif
#ifndef glMultTransposeMatrixfARB_RETURN
typedef struct {
    GLfloat * m;
} glMultTransposeMatrixfARB_ARGS;
typedef struct {
    int index;
    glMultTransposeMatrixfARB_ARGS args;
} glMultTransposeMatrixfARB_PACKED;
#endif
#ifndef glMultTransposeMatrixxOES_RETURN
typedef struct {
    GLfixed * m;
} glMultTransposeMatrixxOES_ARGS;
typedef struct {
    int index;
    glMultTransposeMatrixxOES_ARGS args;
} glMultTransposeMatrixxOES_PACKED;
#endif
#ifndef glMultiDrawArrays_RETURN
typedef struct {
    GLenum mode;
    GLint * first;
    GLsizei * count;
    GLsizei drawcount;
} glMultiDrawArrays_ARGS;
typedef struct {
    int index;
    glMultiDrawArrays_ARGS args;
} glMultiDrawArrays_PACKED;
#endif
#ifndef glMultiDrawArraysEXT_RETURN
typedef struct {
    GLenum mode;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
} glMultiDrawArraysEXT_ARGS;
typedef struct {
    int index;
    glMultiDrawArraysEXT_ARGS args;
} glMultiDrawArraysEXT_PACKED;
#endif
#ifndef glMultiDrawArraysIndirect_RETURN
typedef struct {
    GLenum mode;
    void * indirect;
    GLsizei drawcount;
    GLsizei stride;
} glMultiDrawArraysIndirect_ARGS;
typedef struct {
    int index;
    glMultiDrawArraysIndirect_ARGS args;
} glMultiDrawArraysIndirect_PACKED;
#endif
#ifndef glMultiDrawArraysIndirectAMD_RETURN
typedef struct {
    GLenum mode;
    GLvoid * indirect;
    GLsizei primcount;
    GLsizei stride;
} glMultiDrawArraysIndirectAMD_ARGS;
typedef struct {
    int index;
    glMultiDrawArraysIndirectAMD_ARGS args;
} glMultiDrawArraysIndirectAMD_PACKED;
#endif
#ifndef glMultiDrawElementArrayAPPLE_RETURN
typedef struct {
    GLenum mode;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
} glMultiDrawElementArrayAPPLE_ARGS;
typedef struct {
    int index;
    glMultiDrawElementArrayAPPLE_ARGS args;
} glMultiDrawElementArrayAPPLE_PACKED;
#endif
#ifndef glMultiDrawElements_RETURN
typedef struct {
    GLenum mode;
    GLsizei * count;
    GLenum type;
    GLvoid*const * indices;
    GLsizei drawcount;
} glMultiDrawElements_ARGS;
typedef struct {
    int index;
    glMultiDrawElements_ARGS args;
} glMultiDrawElements_PACKED;
#endif
#ifndef glMultiDrawElementsBaseVertex_RETURN
typedef struct {
    GLenum mode;
    GLsizei * count;
    GLenum type;
    GLvoid*const * indices;
    GLsizei drawcount;
    GLint * basevertex;
} glMultiDrawElementsBaseVertex_ARGS;
typedef struct {
    int index;
    glMultiDrawElementsBaseVertex_ARGS args;
} glMultiDrawElementsBaseVertex_PACKED;
#endif
#ifndef glMultiDrawElementsEXT_RETURN
typedef struct {
    GLenum mode;
    GLsizei * count;
    GLenum type;
    GLvoid * indices;
    GLsizei primcount;
} glMultiDrawElementsEXT_ARGS;
typedef struct {
    int index;
    glMultiDrawElementsEXT_ARGS args;
} glMultiDrawElementsEXT_PACKED;
#endif
#ifndef glMultiDrawElementsIndirect_RETURN
typedef struct {
    GLenum mode;
    GLenum type;
    void * indirect;
    GLsizei drawcount;
    GLsizei stride;
} glMultiDrawElementsIndirect_ARGS;
typedef struct {
    int index;
    glMultiDrawElementsIndirect_ARGS args;
} glMultiDrawElementsIndirect_PACKED;
#endif
#ifndef glMultiDrawElementsIndirectAMD_RETURN
typedef struct {
    GLenum mode;
    GLenum type;
    GLvoid * indirect;
    GLsizei primcount;
    GLsizei stride;
} glMultiDrawElementsIndirectAMD_ARGS;
typedef struct {
    int index;
    glMultiDrawElementsIndirectAMD_ARGS args;
} glMultiDrawElementsIndirectAMD_PACKED;
#endif
#ifndef glMultiDrawRangeElementArrayAPPLE_RETURN
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
} glMultiDrawRangeElementArrayAPPLE_ARGS;
typedef struct {
    int index;
    glMultiDrawRangeElementArrayAPPLE_ARGS args;
} glMultiDrawRangeElementArrayAPPLE_PACKED;
#endif
#ifndef glMultiModeDrawArraysIBM_RETURN
typedef struct {
    GLenum * mode;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
    GLint modestride;
} glMultiModeDrawArraysIBM_ARGS;
typedef struct {
    int index;
    glMultiModeDrawArraysIBM_ARGS args;
} glMultiModeDrawArraysIBM_PACKED;
#endif
#ifndef glMultiModeDrawElementsIBM_RETURN
typedef struct {
    GLenum * mode;
    GLsizei * count;
    GLenum type;
    GLvoid*const * indices;
    GLsizei primcount;
    GLint modestride;
} glMultiModeDrawElementsIBM_ARGS;
typedef struct {
    int index;
    glMultiModeDrawElementsIBM_ARGS args;
} glMultiModeDrawElementsIBM_PACKED;
#endif
#ifndef glMultiTexBufferEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} glMultiTexBufferEXT_ARGS;
typedef struct {
    int index;
    glMultiTexBufferEXT_ARGS args;
} glMultiTexBufferEXT_PACKED;
#endif
#ifndef glMultiTexCoord1bOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte s;
} glMultiTexCoord1bOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1bOES_ARGS args;
} glMultiTexCoord1bOES_PACKED;
#endif
#ifndef glMultiTexCoord1bvOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte * coords;
} glMultiTexCoord1bvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1bvOES_ARGS args;
} glMultiTexCoord1bvOES_PACKED;
#endif
#ifndef glMultiTexCoord1d_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
} glMultiTexCoord1d_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1d_ARGS args;
} glMultiTexCoord1d_PACKED;
#endif
#ifndef glMultiTexCoord1dARB_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
} glMultiTexCoord1dARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1dARB_ARGS args;
} glMultiTexCoord1dARB_PACKED;
#endif
#ifndef glMultiTexCoord1dv_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord1dv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1dv_ARGS args;
} glMultiTexCoord1dv_PACKED;
#endif
#ifndef glMultiTexCoord1dvARB_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord1dvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1dvARB_ARGS args;
} glMultiTexCoord1dvARB_PACKED;
#endif
#ifndef glMultiTexCoord1f_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
} glMultiTexCoord1f_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1f_ARGS args;
} glMultiTexCoord1f_PACKED;
#endif
#ifndef glMultiTexCoord1fARB_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
} glMultiTexCoord1fARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1fARB_ARGS args;
} glMultiTexCoord1fARB_PACKED;
#endif
#ifndef glMultiTexCoord1fv_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord1fv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1fv_ARGS args;
} glMultiTexCoord1fv_PACKED;
#endif
#ifndef glMultiTexCoord1fvARB_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord1fvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1fvARB_ARGS args;
} glMultiTexCoord1fvARB_PACKED;
#endif
#ifndef glMultiTexCoord1hNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV s;
} glMultiTexCoord1hNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1hNV_ARGS args;
} glMultiTexCoord1hNV_PACKED;
#endif
#ifndef glMultiTexCoord1hvNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV * v;
} glMultiTexCoord1hvNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1hvNV_ARGS args;
} glMultiTexCoord1hvNV_PACKED;
#endif
#ifndef glMultiTexCoord1i_RETURN
typedef struct {
    GLenum target;
    GLint s;
} glMultiTexCoord1i_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1i_ARGS args;
} glMultiTexCoord1i_PACKED;
#endif
#ifndef glMultiTexCoord1iARB_RETURN
typedef struct {
    GLenum target;
    GLint s;
} glMultiTexCoord1iARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1iARB_ARGS args;
} glMultiTexCoord1iARB_PACKED;
#endif
#ifndef glMultiTexCoord1iv_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord1iv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1iv_ARGS args;
} glMultiTexCoord1iv_PACKED;
#endif
#ifndef glMultiTexCoord1ivARB_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord1ivARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1ivARB_ARGS args;
} glMultiTexCoord1ivARB_PACKED;
#endif
#ifndef glMultiTexCoord1s_RETURN
typedef struct {
    GLenum target;
    GLshort s;
} glMultiTexCoord1s_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1s_ARGS args;
} glMultiTexCoord1s_PACKED;
#endif
#ifndef glMultiTexCoord1sARB_RETURN
typedef struct {
    GLenum target;
    GLshort s;
} glMultiTexCoord1sARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1sARB_ARGS args;
} glMultiTexCoord1sARB_PACKED;
#endif
#ifndef glMultiTexCoord1sv_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord1sv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1sv_ARGS args;
} glMultiTexCoord1sv_PACKED;
#endif
#ifndef glMultiTexCoord1svARB_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord1svARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1svARB_ARGS args;
} glMultiTexCoord1svARB_PACKED;
#endif
#ifndef glMultiTexCoord1xOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed s;
} glMultiTexCoord1xOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1xOES_ARGS args;
} glMultiTexCoord1xOES_PACKED;
#endif
#ifndef glMultiTexCoord1xvOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed * coords;
} glMultiTexCoord1xvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord1xvOES_ARGS args;
} glMultiTexCoord1xvOES_PACKED;
#endif
#ifndef glMultiTexCoord2bOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte s;
    GLbyte t;
} glMultiTexCoord2bOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2bOES_ARGS args;
} glMultiTexCoord2bOES_PACKED;
#endif
#ifndef glMultiTexCoord2bvOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte * coords;
} glMultiTexCoord2bvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2bvOES_ARGS args;
} glMultiTexCoord2bvOES_PACKED;
#endif
#ifndef glMultiTexCoord2d_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
} glMultiTexCoord2d_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2d_ARGS args;
} glMultiTexCoord2d_PACKED;
#endif
#ifndef glMultiTexCoord2dARB_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
} glMultiTexCoord2dARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2dARB_ARGS args;
} glMultiTexCoord2dARB_PACKED;
#endif
#ifndef glMultiTexCoord2dv_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord2dv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2dv_ARGS args;
} glMultiTexCoord2dv_PACKED;
#endif
#ifndef glMultiTexCoord2dvARB_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord2dvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2dvARB_ARGS args;
} glMultiTexCoord2dvARB_PACKED;
#endif
#ifndef glMultiTexCoord2f_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
} glMultiTexCoord2f_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2f_ARGS args;
} glMultiTexCoord2f_PACKED;
#endif
#ifndef glMultiTexCoord2fARB_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
} glMultiTexCoord2fARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2fARB_ARGS args;
} glMultiTexCoord2fARB_PACKED;
#endif
#ifndef glMultiTexCoord2fv_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord2fv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2fv_ARGS args;
} glMultiTexCoord2fv_PACKED;
#endif
#ifndef glMultiTexCoord2fvARB_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord2fvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2fvARB_ARGS args;
} glMultiTexCoord2fvARB_PACKED;
#endif
#ifndef glMultiTexCoord2hNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV s;
    GLhalfNV t;
} glMultiTexCoord2hNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2hNV_ARGS args;
} glMultiTexCoord2hNV_PACKED;
#endif
#ifndef glMultiTexCoord2hvNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV * v;
} glMultiTexCoord2hvNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2hvNV_ARGS args;
} glMultiTexCoord2hvNV_PACKED;
#endif
#ifndef glMultiTexCoord2i_RETURN
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
} glMultiTexCoord2i_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2i_ARGS args;
} glMultiTexCoord2i_PACKED;
#endif
#ifndef glMultiTexCoord2iARB_RETURN
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
} glMultiTexCoord2iARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2iARB_ARGS args;
} glMultiTexCoord2iARB_PACKED;
#endif
#ifndef glMultiTexCoord2iv_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord2iv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2iv_ARGS args;
} glMultiTexCoord2iv_PACKED;
#endif
#ifndef glMultiTexCoord2ivARB_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord2ivARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2ivARB_ARGS args;
} glMultiTexCoord2ivARB_PACKED;
#endif
#ifndef glMultiTexCoord2s_RETURN
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
} glMultiTexCoord2s_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2s_ARGS args;
} glMultiTexCoord2s_PACKED;
#endif
#ifndef glMultiTexCoord2sARB_RETURN
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
} glMultiTexCoord2sARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2sARB_ARGS args;
} glMultiTexCoord2sARB_PACKED;
#endif
#ifndef glMultiTexCoord2sv_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord2sv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2sv_ARGS args;
} glMultiTexCoord2sv_PACKED;
#endif
#ifndef glMultiTexCoord2svARB_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord2svARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2svARB_ARGS args;
} glMultiTexCoord2svARB_PACKED;
#endif
#ifndef glMultiTexCoord2xOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed s;
    GLfixed t;
} glMultiTexCoord2xOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2xOES_ARGS args;
} glMultiTexCoord2xOES_PACKED;
#endif
#ifndef glMultiTexCoord2xvOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed * coords;
} glMultiTexCoord2xvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord2xvOES_ARGS args;
} glMultiTexCoord2xvOES_PACKED;
#endif
#ifndef glMultiTexCoord3bOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte s;
    GLbyte t;
    GLbyte r;
} glMultiTexCoord3bOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3bOES_ARGS args;
} glMultiTexCoord3bOES_PACKED;
#endif
#ifndef glMultiTexCoord3bvOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte * coords;
} glMultiTexCoord3bvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3bvOES_ARGS args;
} glMultiTexCoord3bvOES_PACKED;
#endif
#ifndef glMultiTexCoord3d_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
} glMultiTexCoord3d_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3d_ARGS args;
} glMultiTexCoord3d_PACKED;
#endif
#ifndef glMultiTexCoord3dARB_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
} glMultiTexCoord3dARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3dARB_ARGS args;
} glMultiTexCoord3dARB_PACKED;
#endif
#ifndef glMultiTexCoord3dv_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord3dv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3dv_ARGS args;
} glMultiTexCoord3dv_PACKED;
#endif
#ifndef glMultiTexCoord3dvARB_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord3dvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3dvARB_ARGS args;
} glMultiTexCoord3dvARB_PACKED;
#endif
#ifndef glMultiTexCoord3f_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
} glMultiTexCoord3f_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3f_ARGS args;
} glMultiTexCoord3f_PACKED;
#endif
#ifndef glMultiTexCoord3fARB_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
} glMultiTexCoord3fARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3fARB_ARGS args;
} glMultiTexCoord3fARB_PACKED;
#endif
#ifndef glMultiTexCoord3fv_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord3fv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3fv_ARGS args;
} glMultiTexCoord3fv_PACKED;
#endif
#ifndef glMultiTexCoord3fvARB_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord3fvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3fvARB_ARGS args;
} glMultiTexCoord3fvARB_PACKED;
#endif
#ifndef glMultiTexCoord3hNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
} glMultiTexCoord3hNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3hNV_ARGS args;
} glMultiTexCoord3hNV_PACKED;
#endif
#ifndef glMultiTexCoord3hvNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV * v;
} glMultiTexCoord3hvNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3hvNV_ARGS args;
} glMultiTexCoord3hvNV_PACKED;
#endif
#ifndef glMultiTexCoord3i_RETURN
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
} glMultiTexCoord3i_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3i_ARGS args;
} glMultiTexCoord3i_PACKED;
#endif
#ifndef glMultiTexCoord3iARB_RETURN
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
} glMultiTexCoord3iARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3iARB_ARGS args;
} glMultiTexCoord3iARB_PACKED;
#endif
#ifndef glMultiTexCoord3iv_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord3iv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3iv_ARGS args;
} glMultiTexCoord3iv_PACKED;
#endif
#ifndef glMultiTexCoord3ivARB_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord3ivARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3ivARB_ARGS args;
} glMultiTexCoord3ivARB_PACKED;
#endif
#ifndef glMultiTexCoord3s_RETURN
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
} glMultiTexCoord3s_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3s_ARGS args;
} glMultiTexCoord3s_PACKED;
#endif
#ifndef glMultiTexCoord3sARB_RETURN
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
} glMultiTexCoord3sARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3sARB_ARGS args;
} glMultiTexCoord3sARB_PACKED;
#endif
#ifndef glMultiTexCoord3sv_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord3sv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3sv_ARGS args;
} glMultiTexCoord3sv_PACKED;
#endif
#ifndef glMultiTexCoord3svARB_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord3svARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3svARB_ARGS args;
} glMultiTexCoord3svARB_PACKED;
#endif
#ifndef glMultiTexCoord3xOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed s;
    GLfixed t;
    GLfixed r;
} glMultiTexCoord3xOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3xOES_ARGS args;
} glMultiTexCoord3xOES_PACKED;
#endif
#ifndef glMultiTexCoord3xvOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed * coords;
} glMultiTexCoord3xvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord3xvOES_ARGS args;
} glMultiTexCoord3xvOES_PACKED;
#endif
#ifndef glMultiTexCoord4bOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte s;
    GLbyte t;
    GLbyte r;
    GLbyte q;
} glMultiTexCoord4bOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4bOES_ARGS args;
} glMultiTexCoord4bOES_PACKED;
#endif
#ifndef glMultiTexCoord4bvOES_RETURN
typedef struct {
    GLenum texture;
    GLbyte * coords;
} glMultiTexCoord4bvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4bvOES_ARGS args;
} glMultiTexCoord4bvOES_PACKED;
#endif
#ifndef glMultiTexCoord4d_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
    GLdouble q __attribute__ ((aligned(8)));
} glMultiTexCoord4d_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4d_ARGS args;
} glMultiTexCoord4d_PACKED;
#endif
#ifndef glMultiTexCoord4dARB_RETURN
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
    GLdouble q __attribute__ ((aligned(8)));
} glMultiTexCoord4dARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4dARB_ARGS args;
} glMultiTexCoord4dARB_PACKED;
#endif
#ifndef glMultiTexCoord4dv_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord4dv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4dv_ARGS args;
} glMultiTexCoord4dv_PACKED;
#endif
#ifndef glMultiTexCoord4dvARB_RETURN
typedef struct {
    GLenum target;
    GLdouble * v;
} glMultiTexCoord4dvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4dvARB_ARGS args;
} glMultiTexCoord4dvARB_PACKED;
#endif
#ifndef glMultiTexCoord4f_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
} glMultiTexCoord4f_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4f_ARGS args;
} glMultiTexCoord4f_PACKED;
#endif
#ifndef glMultiTexCoord4fARB_RETURN
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
} glMultiTexCoord4fARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4fARB_ARGS args;
} glMultiTexCoord4fARB_PACKED;
#endif
#ifndef glMultiTexCoord4fv_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord4fv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4fv_ARGS args;
} glMultiTexCoord4fv_PACKED;
#endif
#ifndef glMultiTexCoord4fvARB_RETURN
typedef struct {
    GLenum target;
    GLfloat * v;
} glMultiTexCoord4fvARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4fvARB_ARGS args;
} glMultiTexCoord4fvARB_PACKED;
#endif
#ifndef glMultiTexCoord4hNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
    GLhalfNV q;
} glMultiTexCoord4hNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4hNV_ARGS args;
} glMultiTexCoord4hNV_PACKED;
#endif
#ifndef glMultiTexCoord4hvNV_RETURN
typedef struct {
    GLenum target;
    GLhalfNV * v;
} glMultiTexCoord4hvNV_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4hvNV_ARGS args;
} glMultiTexCoord4hvNV_PACKED;
#endif
#ifndef glMultiTexCoord4i_RETURN
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
    GLint q;
} glMultiTexCoord4i_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4i_ARGS args;
} glMultiTexCoord4i_PACKED;
#endif
#ifndef glMultiTexCoord4iARB_RETURN
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
    GLint q;
} glMultiTexCoord4iARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4iARB_ARGS args;
} glMultiTexCoord4iARB_PACKED;
#endif
#ifndef glMultiTexCoord4iv_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord4iv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4iv_ARGS args;
} glMultiTexCoord4iv_PACKED;
#endif
#ifndef glMultiTexCoord4ivARB_RETURN
typedef struct {
    GLenum target;
    GLint * v;
} glMultiTexCoord4ivARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4ivARB_ARGS args;
} glMultiTexCoord4ivARB_PACKED;
#endif
#ifndef glMultiTexCoord4s_RETURN
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
} glMultiTexCoord4s_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4s_ARGS args;
} glMultiTexCoord4s_PACKED;
#endif
#ifndef glMultiTexCoord4sARB_RETURN
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
} glMultiTexCoord4sARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4sARB_ARGS args;
} glMultiTexCoord4sARB_PACKED;
#endif
#ifndef glMultiTexCoord4sv_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord4sv_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4sv_ARGS args;
} glMultiTexCoord4sv_PACKED;
#endif
#ifndef glMultiTexCoord4svARB_RETURN
typedef struct {
    GLenum target;
    GLshort * v;
} glMultiTexCoord4svARB_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4svARB_ARGS args;
} glMultiTexCoord4svARB_PACKED;
#endif
#ifndef glMultiTexCoord4xOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed s;
    GLfixed t;
    GLfixed r;
    GLfixed q;
} glMultiTexCoord4xOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4xOES_ARGS args;
} glMultiTexCoord4xOES_PACKED;
#endif
#ifndef glMultiTexCoord4xvOES_RETURN
typedef struct {
    GLenum texture;
    GLfixed * coords;
} glMultiTexCoord4xvOES_ARGS;
typedef struct {
    int index;
    glMultiTexCoord4xvOES_ARGS args;
} glMultiTexCoord4xvOES_PACKED;
#endif
#ifndef glMultiTexCoordP1ui_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} glMultiTexCoordP1ui_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP1ui_ARGS args;
} glMultiTexCoordP1ui_PACKED;
#endif
#ifndef glMultiTexCoordP1uiv_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} glMultiTexCoordP1uiv_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP1uiv_ARGS args;
} glMultiTexCoordP1uiv_PACKED;
#endif
#ifndef glMultiTexCoordP2ui_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} glMultiTexCoordP2ui_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP2ui_ARGS args;
} glMultiTexCoordP2ui_PACKED;
#endif
#ifndef glMultiTexCoordP2uiv_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} glMultiTexCoordP2uiv_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP2uiv_ARGS args;
} glMultiTexCoordP2uiv_PACKED;
#endif
#ifndef glMultiTexCoordP3ui_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} glMultiTexCoordP3ui_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP3ui_ARGS args;
} glMultiTexCoordP3ui_PACKED;
#endif
#ifndef glMultiTexCoordP3uiv_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} glMultiTexCoordP3uiv_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP3uiv_ARGS args;
} glMultiTexCoordP3uiv_PACKED;
#endif
#ifndef glMultiTexCoordP4ui_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} glMultiTexCoordP4ui_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP4ui_ARGS args;
} glMultiTexCoordP4ui_PACKED;
#endif
#ifndef glMultiTexCoordP4uiv_RETURN
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} glMultiTexCoordP4uiv_ARGS;
typedef struct {
    int index;
    glMultiTexCoordP4uiv_ARGS args;
} glMultiTexCoordP4uiv_PACKED;
#endif
#ifndef glMultiTexCoordPointerEXT_RETURN
typedef struct {
    GLenum texunit;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glMultiTexCoordPointerEXT_ARGS;
typedef struct {
    int index;
    glMultiTexCoordPointerEXT_ARGS args;
} glMultiTexCoordPointerEXT_PACKED;
#endif
#ifndef glMultiTexEnvfEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat param;
} glMultiTexEnvfEXT_ARGS;
typedef struct {
    int index;
    glMultiTexEnvfEXT_ARGS args;
} glMultiTexEnvfEXT_PACKED;
#endif
#ifndef glMultiTexEnvfvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glMultiTexEnvfvEXT_ARGS;
typedef struct {
    int index;
    glMultiTexEnvfvEXT_ARGS args;
} glMultiTexEnvfvEXT_PACKED;
#endif
#ifndef glMultiTexEnviEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint param;
} glMultiTexEnviEXT_ARGS;
typedef struct {
    int index;
    glMultiTexEnviEXT_ARGS args;
} glMultiTexEnviEXT_PACKED;
#endif
#ifndef glMultiTexEnvivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} glMultiTexEnvivEXT_ARGS;
typedef struct {
    int index;
    glMultiTexEnvivEXT_ARGS args;
} glMultiTexEnvivEXT_PACKED;
#endif
#ifndef glMultiTexGendEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLdouble param __attribute__ ((aligned(8)));
} glMultiTexGendEXT_ARGS;
typedef struct {
    int index;
    glMultiTexGendEXT_ARGS args;
} glMultiTexGendEXT_PACKED;
#endif
#ifndef glMultiTexGendvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} glMultiTexGendvEXT_ARGS;
typedef struct {
    int index;
    glMultiTexGendvEXT_ARGS args;
} glMultiTexGendvEXT_PACKED;
#endif
#ifndef glMultiTexGenfEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLfloat param;
} glMultiTexGenfEXT_ARGS;
typedef struct {
    int index;
    glMultiTexGenfEXT_ARGS args;
} glMultiTexGenfEXT_PACKED;
#endif
#ifndef glMultiTexGenfvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} glMultiTexGenfvEXT_ARGS;
typedef struct {
    int index;
    glMultiTexGenfvEXT_ARGS args;
} glMultiTexGenfvEXT_PACKED;
#endif
#ifndef glMultiTexGeniEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLint param;
} glMultiTexGeniEXT_ARGS;
typedef struct {
    int index;
    glMultiTexGeniEXT_ARGS args;
} glMultiTexGeniEXT_PACKED;
#endif
#ifndef glMultiTexGenivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLint * params;
} glMultiTexGenivEXT_ARGS;
typedef struct {
    int index;
    glMultiTexGenivEXT_ARGS args;
} glMultiTexGenivEXT_PACKED;
#endif
#ifndef glMultiTexImage1DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glMultiTexImage1DEXT_ARGS;
typedef struct {
    int index;
    glMultiTexImage1DEXT_ARGS args;
} glMultiTexImage1DEXT_PACKED;
#endif
#ifndef glMultiTexImage2DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glMultiTexImage2DEXT_ARGS;
typedef struct {
    int index;
    glMultiTexImage2DEXT_ARGS args;
} glMultiTexImage2DEXT_PACKED;
#endif
#ifndef glMultiTexImage3DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glMultiTexImage3DEXT_ARGS;
typedef struct {
    int index;
    glMultiTexImage3DEXT_ARGS args;
} glMultiTexImage3DEXT_PACKED;
#endif
#ifndef glMultiTexParameterIivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} glMultiTexParameterIivEXT_ARGS;
typedef struct {
    int index;
    glMultiTexParameterIivEXT_ARGS args;
} glMultiTexParameterIivEXT_PACKED;
#endif
#ifndef glMultiTexParameterIuivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLuint * params;
} glMultiTexParameterIuivEXT_ARGS;
typedef struct {
    int index;
    glMultiTexParameterIuivEXT_ARGS args;
} glMultiTexParameterIuivEXT_PACKED;
#endif
#ifndef glMultiTexParameterfEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat param;
} glMultiTexParameterfEXT_ARGS;
typedef struct {
    int index;
    glMultiTexParameterfEXT_ARGS args;
} glMultiTexParameterfEXT_PACKED;
#endif
#ifndef glMultiTexParameterfvEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glMultiTexParameterfvEXT_ARGS;
typedef struct {
    int index;
    glMultiTexParameterfvEXT_ARGS args;
} glMultiTexParameterfvEXT_PACKED;
#endif
#ifndef glMultiTexParameteriEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint param;
} glMultiTexParameteriEXT_ARGS;
typedef struct {
    int index;
    glMultiTexParameteriEXT_ARGS args;
} glMultiTexParameteriEXT_PACKED;
#endif
#ifndef glMultiTexParameterivEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} glMultiTexParameterivEXT_ARGS;
typedef struct {
    int index;
    glMultiTexParameterivEXT_ARGS args;
} glMultiTexParameterivEXT_PACKED;
#endif
#ifndef glMultiTexRenderbufferEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLuint renderbuffer;
} glMultiTexRenderbufferEXT_ARGS;
typedef struct {
    int index;
    glMultiTexRenderbufferEXT_ARGS args;
} glMultiTexRenderbufferEXT_PACKED;
#endif
#ifndef glMultiTexSubImage1DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glMultiTexSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glMultiTexSubImage1DEXT_ARGS args;
} glMultiTexSubImage1DEXT_PACKED;
#endif
#ifndef glMultiTexSubImage2DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glMultiTexSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glMultiTexSubImage2DEXT_ARGS args;
} glMultiTexSubImage2DEXT_PACKED;
#endif
#ifndef glMultiTexSubImage3DEXT_RETURN
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glMultiTexSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glMultiTexSubImage3DEXT_ARGS args;
} glMultiTexSubImage3DEXT_PACKED;
#endif
#ifndef glNamedBufferDataEXT_RETURN
typedef struct {
    GLuint buffer;
    GLsizeiptr size;
    GLvoid * data;
    GLenum usage;
} glNamedBufferDataEXT_ARGS;
typedef struct {
    int index;
    glNamedBufferDataEXT_ARGS args;
} glNamedBufferDataEXT_PACKED;
#endif
#ifndef glNamedBufferSubDataEXT_RETURN
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} glNamedBufferSubDataEXT_ARGS;
typedef struct {
    int index;
    glNamedBufferSubDataEXT_ARGS args;
} glNamedBufferSubDataEXT_PACKED;
#endif
#ifndef glNamedCopyBufferSubDataEXT_RETURN
typedef struct {
    GLuint readBuffer;
    GLuint writeBuffer;
    GLintptr readOffset;
    GLintptr writeOffset;
    GLsizeiptr size;
} glNamedCopyBufferSubDataEXT_ARGS;
typedef struct {
    int index;
    glNamedCopyBufferSubDataEXT_ARGS args;
} glNamedCopyBufferSubDataEXT_PACKED;
#endif
#ifndef glNamedFramebufferParameteriEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum pname;
    GLint param;
} glNamedFramebufferParameteriEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferParameteriEXT_ARGS args;
} glNamedFramebufferParameteriEXT_PACKED;
#endif
#ifndef glNamedFramebufferRenderbufferEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum renderbuffertarget;
    GLuint renderbuffer;
} glNamedFramebufferRenderbufferEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferRenderbufferEXT_ARGS args;
} glNamedFramebufferRenderbufferEXT_PACKED;
#endif
#ifndef glNamedFramebufferTexture1DEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} glNamedFramebufferTexture1DEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferTexture1DEXT_ARGS args;
} glNamedFramebufferTexture1DEXT_PACKED;
#endif
#ifndef glNamedFramebufferTexture2DEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} glNamedFramebufferTexture2DEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferTexture2DEXT_ARGS args;
} glNamedFramebufferTexture2DEXT_PACKED;
#endif
#ifndef glNamedFramebufferTexture3DEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
    GLint zoffset;
} glNamedFramebufferTexture3DEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferTexture3DEXT_ARGS args;
} glNamedFramebufferTexture3DEXT_PACKED;
#endif
#ifndef glNamedFramebufferTextureEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLuint texture;
    GLint level;
} glNamedFramebufferTextureEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferTextureEXT_ARGS args;
} glNamedFramebufferTextureEXT_PACKED;
#endif
#ifndef glNamedFramebufferTextureFaceEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLenum face;
} glNamedFramebufferTextureFaceEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferTextureFaceEXT_ARGS args;
} glNamedFramebufferTextureFaceEXT_PACKED;
#endif
#ifndef glNamedFramebufferTextureLayerEXT_RETURN
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} glNamedFramebufferTextureLayerEXT_ARGS;
typedef struct {
    int index;
    glNamedFramebufferTextureLayerEXT_ARGS args;
} glNamedFramebufferTextureLayerEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameter4dEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glNamedProgramLocalParameter4dEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameter4dEXT_ARGS args;
} glNamedProgramLocalParameter4dEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameter4dvEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLdouble * params;
} glNamedProgramLocalParameter4dvEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameter4dvEXT_ARGS args;
} glNamedProgramLocalParameter4dvEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameter4fEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glNamedProgramLocalParameter4fEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameter4fEXT_ARGS args;
} glNamedProgramLocalParameter4fEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameter4fvEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLfloat * params;
} glNamedProgramLocalParameter4fvEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameter4fvEXT_ARGS args;
} glNamedProgramLocalParameter4fvEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameterI4iEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glNamedProgramLocalParameterI4iEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameterI4iEXT_ARGS args;
} glNamedProgramLocalParameterI4iEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameterI4ivEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLint * params;
} glNamedProgramLocalParameterI4ivEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameterI4ivEXT_ARGS args;
} glNamedProgramLocalParameterI4ivEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameterI4uiEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} glNamedProgramLocalParameterI4uiEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameterI4uiEXT_ARGS args;
} glNamedProgramLocalParameterI4uiEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameterI4uivEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLuint * params;
} glNamedProgramLocalParameterI4uivEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameterI4uivEXT_ARGS args;
} glNamedProgramLocalParameterI4uivEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParameters4fvEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * params;
} glNamedProgramLocalParameters4fvEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParameters4fvEXT_ARGS args;
} glNamedProgramLocalParameters4fvEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParametersI4ivEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLsizei count;
    GLint * params;
} glNamedProgramLocalParametersI4ivEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParametersI4ivEXT_ARGS args;
} glNamedProgramLocalParametersI4ivEXT_PACKED;
#endif
#ifndef glNamedProgramLocalParametersI4uivEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLsizei count;
    GLuint * params;
} glNamedProgramLocalParametersI4uivEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramLocalParametersI4uivEXT_ARGS args;
} glNamedProgramLocalParametersI4uivEXT_PACKED;
#endif
#ifndef glNamedProgramStringEXT_RETURN
typedef struct {
    GLuint program;
    GLenum target;
    GLenum format;
    GLsizei len;
    GLvoid * string;
} glNamedProgramStringEXT_ARGS;
typedef struct {
    int index;
    glNamedProgramStringEXT_ARGS args;
} glNamedProgramStringEXT_PACKED;
#endif
#ifndef glNamedRenderbufferStorageEXT_RETURN
typedef struct {
    GLuint renderbuffer;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glNamedRenderbufferStorageEXT_ARGS;
typedef struct {
    int index;
    glNamedRenderbufferStorageEXT_ARGS args;
} glNamedRenderbufferStorageEXT_PACKED;
#endif
#ifndef glNamedRenderbufferStorageMultisampleCoverageEXT_RETURN
typedef struct {
    GLuint renderbuffer;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glNamedRenderbufferStorageMultisampleCoverageEXT_ARGS;
typedef struct {
    int index;
    glNamedRenderbufferStorageMultisampleCoverageEXT_ARGS args;
} glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED;
#endif
#ifndef glNamedRenderbufferStorageMultisampleEXT_RETURN
typedef struct {
    GLuint renderbuffer;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glNamedRenderbufferStorageMultisampleEXT_ARGS;
typedef struct {
    int index;
    glNamedRenderbufferStorageMultisampleEXT_ARGS args;
} glNamedRenderbufferStorageMultisampleEXT_PACKED;
#endif
#ifndef glNamedStringARB_RETURN
typedef struct {
    GLenum type;
    GLint namelen;
    GLchar * name;
    GLint stringlen;
    GLchar * string;
} glNamedStringARB_ARGS;
typedef struct {
    int index;
    glNamedStringARB_ARGS args;
} glNamedStringARB_PACKED;
#endif
#ifndef glNewList_RETURN
typedef struct {
    GLuint list;
    GLenum mode;
} glNewList_ARGS;
typedef struct {
    int index;
    glNewList_ARGS args;
} glNewList_PACKED;
#endif
#ifndef glNewObjectBufferATI_RETURN
typedef struct {
    GLsizei size;
    GLvoid * pointer;
    GLenum usage;
} glNewObjectBufferATI_ARGS;
typedef struct {
    int index;
    glNewObjectBufferATI_ARGS args;
} glNewObjectBufferATI_PACKED;
#endif
#ifndef glNormal3b_RETURN
typedef struct {
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;
} glNormal3b_ARGS;
typedef struct {
    int index;
    glNormal3b_ARGS args;
} glNormal3b_PACKED;
#endif
#ifndef glNormal3bv_RETURN
typedef struct {
    GLbyte * v;
} glNormal3bv_ARGS;
typedef struct {
    int index;
    glNormal3bv_ARGS args;
} glNormal3bv_PACKED;
#endif
#ifndef glNormal3d_RETURN
typedef struct {
    GLdouble nx __attribute__ ((aligned(8)));
    GLdouble ny __attribute__ ((aligned(8)));
    GLdouble nz __attribute__ ((aligned(8)));
} glNormal3d_ARGS;
typedef struct {
    int index;
    glNormal3d_ARGS args;
} glNormal3d_PACKED;
#endif
#ifndef glNormal3dv_RETURN
typedef struct {
    GLdouble * v;
} glNormal3dv_ARGS;
typedef struct {
    int index;
    glNormal3dv_ARGS args;
} glNormal3dv_PACKED;
#endif
#ifndef glNormal3f_RETURN
typedef struct {
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
} glNormal3f_ARGS;
typedef struct {
    int index;
    glNormal3f_ARGS args;
} glNormal3f_PACKED;
#endif
#ifndef glNormal3fVertex3fSUN_RETURN
typedef struct {
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glNormal3fVertex3fSUN_ARGS args;
} glNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLfloat * n;
    GLfloat * v;
} glNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glNormal3fVertex3fvSUN_ARGS args;
} glNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glNormal3fv_RETURN
typedef struct {
    GLfloat * v;
} glNormal3fv_ARGS;
typedef struct {
    int index;
    glNormal3fv_ARGS args;
} glNormal3fv_PACKED;
#endif
#ifndef glNormal3hNV_RETURN
typedef struct {
    GLhalfNV nx;
    GLhalfNV ny;
    GLhalfNV nz;
} glNormal3hNV_ARGS;
typedef struct {
    int index;
    glNormal3hNV_ARGS args;
} glNormal3hNV_PACKED;
#endif
#ifndef glNormal3hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glNormal3hvNV_ARGS;
typedef struct {
    int index;
    glNormal3hvNV_ARGS args;
} glNormal3hvNV_PACKED;
#endif
#ifndef glNormal3i_RETURN
typedef struct {
    GLint nx;
    GLint ny;
    GLint nz;
} glNormal3i_ARGS;
typedef struct {
    int index;
    glNormal3i_ARGS args;
} glNormal3i_PACKED;
#endif
#ifndef glNormal3iv_RETURN
typedef struct {
    GLint * v;
} glNormal3iv_ARGS;
typedef struct {
    int index;
    glNormal3iv_ARGS args;
} glNormal3iv_PACKED;
#endif
#ifndef glNormal3s_RETURN
typedef struct {
    GLshort nx;
    GLshort ny;
    GLshort nz;
} glNormal3s_ARGS;
typedef struct {
    int index;
    glNormal3s_ARGS args;
} glNormal3s_PACKED;
#endif
#ifndef glNormal3sv_RETURN
typedef struct {
    GLshort * v;
} glNormal3sv_ARGS;
typedef struct {
    int index;
    glNormal3sv_ARGS args;
} glNormal3sv_PACKED;
#endif
#ifndef glNormal3xOES_RETURN
typedef struct {
    GLfixed nx;
    GLfixed ny;
    GLfixed nz;
} glNormal3xOES_ARGS;
typedef struct {
    int index;
    glNormal3xOES_ARGS args;
} glNormal3xOES_PACKED;
#endif
#ifndef glNormal3xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glNormal3xvOES_ARGS;
typedef struct {
    int index;
    glNormal3xvOES_ARGS args;
} glNormal3xvOES_PACKED;
#endif
#ifndef glNormalFormatNV_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
} glNormalFormatNV_ARGS;
typedef struct {
    int index;
    glNormalFormatNV_ARGS args;
} glNormalFormatNV_PACKED;
#endif
#ifndef glNormalP3ui_RETURN
typedef struct {
    GLenum type;
    GLuint coords;
} glNormalP3ui_ARGS;
typedef struct {
    int index;
    glNormalP3ui_ARGS args;
} glNormalP3ui_PACKED;
#endif
#ifndef glNormalP3uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * coords;
} glNormalP3uiv_ARGS;
typedef struct {
    int index;
    glNormalP3uiv_ARGS args;
} glNormalP3uiv_PACKED;
#endif
#ifndef glNormalPointer_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glNormalPointer_ARGS;
typedef struct {
    int index;
    glNormalPointer_ARGS args;
} glNormalPointer_PACKED;
#endif
#ifndef glNormalPointerEXT_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} glNormalPointerEXT_ARGS;
typedef struct {
    int index;
    glNormalPointerEXT_ARGS args;
} glNormalPointerEXT_PACKED;
#endif
#ifndef glNormalPointerListIBM_RETURN
typedef struct {
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} glNormalPointerListIBM_ARGS;
typedef struct {
    int index;
    glNormalPointerListIBM_ARGS args;
} glNormalPointerListIBM_PACKED;
#endif
#ifndef glNormalPointervINTEL_RETURN
typedef struct {
    GLenum type;
    GLvoid * pointer;
} glNormalPointervINTEL_ARGS;
typedef struct {
    int index;
    glNormalPointervINTEL_ARGS args;
} glNormalPointervINTEL_PACKED;
#endif
#ifndef glNormalStream3bATI_RETURN
typedef struct {
    GLenum stream;
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;
} glNormalStream3bATI_ARGS;
typedef struct {
    int index;
    glNormalStream3bATI_ARGS args;
} glNormalStream3bATI_PACKED;
#endif
#ifndef glNormalStream3bvATI_RETURN
typedef struct {
    GLenum stream;
    GLbyte * coords;
} glNormalStream3bvATI_ARGS;
typedef struct {
    int index;
    glNormalStream3bvATI_ARGS args;
} glNormalStream3bvATI_PACKED;
#endif
#ifndef glNormalStream3dATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble nx __attribute__ ((aligned(8)));
    GLdouble ny __attribute__ ((aligned(8)));
    GLdouble nz __attribute__ ((aligned(8)));
} glNormalStream3dATI_ARGS;
typedef struct {
    int index;
    glNormalStream3dATI_ARGS args;
} glNormalStream3dATI_PACKED;
#endif
#ifndef glNormalStream3dvATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble * coords;
} glNormalStream3dvATI_ARGS;
typedef struct {
    int index;
    glNormalStream3dvATI_ARGS args;
} glNormalStream3dvATI_PACKED;
#endif
#ifndef glNormalStream3fATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
} glNormalStream3fATI_ARGS;
typedef struct {
    int index;
    glNormalStream3fATI_ARGS args;
} glNormalStream3fATI_PACKED;
#endif
#ifndef glNormalStream3fvATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat * coords;
} glNormalStream3fvATI_ARGS;
typedef struct {
    int index;
    glNormalStream3fvATI_ARGS args;
} glNormalStream3fvATI_PACKED;
#endif
#ifndef glNormalStream3iATI_RETURN
typedef struct {
    GLenum stream;
    GLint nx;
    GLint ny;
    GLint nz;
} glNormalStream3iATI_ARGS;
typedef struct {
    int index;
    glNormalStream3iATI_ARGS args;
} glNormalStream3iATI_PACKED;
#endif
#ifndef glNormalStream3ivATI_RETURN
typedef struct {
    GLenum stream;
    GLint * coords;
} glNormalStream3ivATI_ARGS;
typedef struct {
    int index;
    glNormalStream3ivATI_ARGS args;
} glNormalStream3ivATI_PACKED;
#endif
#ifndef glNormalStream3sATI_RETURN
typedef struct {
    GLenum stream;
    GLshort nx;
    GLshort ny;
    GLshort nz;
} glNormalStream3sATI_ARGS;
typedef struct {
    int index;
    glNormalStream3sATI_ARGS args;
} glNormalStream3sATI_PACKED;
#endif
#ifndef glNormalStream3svATI_RETURN
typedef struct {
    GLenum stream;
    GLshort * coords;
} glNormalStream3svATI_ARGS;
typedef struct {
    int index;
    glNormalStream3svATI_ARGS args;
} glNormalStream3svATI_PACKED;
#endif
#ifndef glObjectLabel_RETURN
typedef struct {
    GLenum identifier;
    GLuint name;
    GLsizei length;
    GLchar * label;
} glObjectLabel_ARGS;
typedef struct {
    int index;
    glObjectLabel_ARGS args;
} glObjectLabel_PACKED;
#endif
#ifndef glObjectPtrLabel_RETURN
typedef struct {
    void * ptr;
    GLsizei length;
    GLchar * label;
} glObjectPtrLabel_ARGS;
typedef struct {
    int index;
    glObjectPtrLabel_ARGS args;
} glObjectPtrLabel_PACKED;
#endif
#ifndef glObjectPurgeableAPPLE_RETURN
typedef struct {
    GLenum objectType;
    GLuint name;
    GLenum option;
} glObjectPurgeableAPPLE_ARGS;
typedef struct {
    int index;
    glObjectPurgeableAPPLE_ARGS args;
} glObjectPurgeableAPPLE_PACKED;
#endif
#ifndef glObjectUnpurgeableAPPLE_RETURN
typedef struct {
    GLenum objectType;
    GLuint name;
    GLenum option;
} glObjectUnpurgeableAPPLE_ARGS;
typedef struct {
    int index;
    glObjectUnpurgeableAPPLE_ARGS args;
} glObjectUnpurgeableAPPLE_PACKED;
#endif
#ifndef glOrtho_RETURN
typedef struct {
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} glOrtho_ARGS;
typedef struct {
    int index;
    glOrtho_ARGS args;
} glOrtho_PACKED;
#endif
#ifndef glOrthofOES_RETURN
typedef struct {
    GLfloat l;
    GLfloat r;
    GLfloat b;
    GLfloat t;
    GLfloat n;
    GLfloat f;
} glOrthofOES_ARGS;
typedef struct {
    int index;
    glOrthofOES_ARGS args;
} glOrthofOES_PACKED;
#endif
#ifndef glOrthoxOES_RETURN
typedef struct {
    GLfixed l;
    GLfixed r;
    GLfixed b;
    GLfixed t;
    GLfixed n;
    GLfixed f;
} glOrthoxOES_ARGS;
typedef struct {
    int index;
    glOrthoxOES_ARGS args;
} glOrthoxOES_PACKED;
#endif
#ifndef glPNTrianglesfATI_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPNTrianglesfATI_ARGS;
typedef struct {
    int index;
    glPNTrianglesfATI_ARGS args;
} glPNTrianglesfATI_PACKED;
#endif
#ifndef glPNTrianglesiATI_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glPNTrianglesiATI_ARGS;
typedef struct {
    int index;
    glPNTrianglesiATI_ARGS args;
} glPNTrianglesiATI_PACKED;
#endif
#ifndef glPassTexCoordATI_RETURN
typedef struct {
    GLuint dst;
    GLuint coord;
    GLenum swizzle;
} glPassTexCoordATI_ARGS;
typedef struct {
    int index;
    glPassTexCoordATI_ARGS args;
} glPassTexCoordATI_PACKED;
#endif
#ifndef glPassThrough_RETURN
typedef struct {
    GLfloat token;
} glPassThrough_ARGS;
typedef struct {
    int index;
    glPassThrough_ARGS args;
} glPassThrough_PACKED;
#endif
#ifndef glPassThroughxOES_RETURN
typedef struct {
    GLfixed token;
} glPassThroughxOES_ARGS;
typedef struct {
    int index;
    glPassThroughxOES_ARGS args;
} glPassThroughxOES_PACKED;
#endif
#ifndef glPatchParameterfv_RETURN
typedef struct {
    GLenum pname;
    GLfloat * values;
} glPatchParameterfv_ARGS;
typedef struct {
    int index;
    glPatchParameterfv_ARGS args;
} glPatchParameterfv_PACKED;
#endif
#ifndef glPatchParameteri_RETURN
typedef struct {
    GLenum pname;
    GLint value;
} glPatchParameteri_ARGS;
typedef struct {
    int index;
    glPatchParameteri_ARGS args;
} glPatchParameteri_PACKED;
#endif
#ifndef glPathColorGenNV_RETURN
typedef struct {
    GLenum color;
    GLenum genMode;
    GLenum colorFormat;
    GLfloat * coeffs;
} glPathColorGenNV_ARGS;
typedef struct {
    int index;
    glPathColorGenNV_ARGS args;
} glPathColorGenNV_PACKED;
#endif
#ifndef glPathCommandsNV_RETURN
typedef struct {
    GLuint path;
    GLsizei numCommands;
    GLubyte * commands;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} glPathCommandsNV_ARGS;
typedef struct {
    int index;
    glPathCommandsNV_ARGS args;
} glPathCommandsNV_PACKED;
#endif
#ifndef glPathCoordsNV_RETURN
typedef struct {
    GLuint path;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} glPathCoordsNV_ARGS;
typedef struct {
    int index;
    glPathCoordsNV_ARGS args;
} glPathCoordsNV_PACKED;
#endif
#ifndef glPathCoverDepthFuncNV_RETURN
typedef struct {
    GLenum func;
} glPathCoverDepthFuncNV_ARGS;
typedef struct {
    int index;
    glPathCoverDepthFuncNV_ARGS args;
} glPathCoverDepthFuncNV_PACKED;
#endif
#ifndef glPathDashArrayNV_RETURN
typedef struct {
    GLuint path;
    GLsizei dashCount;
    GLfloat * dashArray;
} glPathDashArrayNV_ARGS;
typedef struct {
    int index;
    glPathDashArrayNV_ARGS args;
} glPathDashArrayNV_PACKED;
#endif
#ifndef glPathFogGenNV_RETURN
typedef struct {
    GLenum genMode;
} glPathFogGenNV_ARGS;
typedef struct {
    int index;
    glPathFogGenNV_ARGS args;
} glPathFogGenNV_PACKED;
#endif
#ifndef glPathGlyphRangeNV_RETURN
typedef struct {
    GLuint firstPathName;
    GLenum fontTarget;
    GLvoid * fontName;
    GLbitfield fontStyle;
    GLuint firstGlyph;
    GLsizei numGlyphs;
    GLenum handleMissingGlyphs;
    GLuint pathParameterTemplate;
    GLfloat emScale;
} glPathGlyphRangeNV_ARGS;
typedef struct {
    int index;
    glPathGlyphRangeNV_ARGS args;
} glPathGlyphRangeNV_PACKED;
#endif
#ifndef glPathGlyphsNV_RETURN
typedef struct {
    GLuint firstPathName;
    GLenum fontTarget;
    GLvoid * fontName;
    GLbitfield fontStyle;
    GLsizei numGlyphs;
    GLenum type;
    GLvoid * charcodes;
    GLenum handleMissingGlyphs;
    GLuint pathParameterTemplate;
    GLfloat emScale;
} glPathGlyphsNV_ARGS;
typedef struct {
    int index;
    glPathGlyphsNV_ARGS args;
} glPathGlyphsNV_PACKED;
#endif
#ifndef glPathParameterfNV_RETURN
typedef struct {
    GLuint path;
    GLenum pname;
    GLfloat value;
} glPathParameterfNV_ARGS;
typedef struct {
    int index;
    glPathParameterfNV_ARGS args;
} glPathParameterfNV_PACKED;
#endif
#ifndef glPathParameterfvNV_RETURN
typedef struct {
    GLuint path;
    GLenum pname;
    GLfloat * value;
} glPathParameterfvNV_ARGS;
typedef struct {
    int index;
    glPathParameterfvNV_ARGS args;
} glPathParameterfvNV_PACKED;
#endif
#ifndef glPathParameteriNV_RETURN
typedef struct {
    GLuint path;
    GLenum pname;
    GLint value;
} glPathParameteriNV_ARGS;
typedef struct {
    int index;
    glPathParameteriNV_ARGS args;
} glPathParameteriNV_PACKED;
#endif
#ifndef glPathParameterivNV_RETURN
typedef struct {
    GLuint path;
    GLenum pname;
    GLint * value;
} glPathParameterivNV_ARGS;
typedef struct {
    int index;
    glPathParameterivNV_ARGS args;
} glPathParameterivNV_PACKED;
#endif
#ifndef glPathStencilDepthOffsetNV_RETURN
typedef struct {
    GLfloat factor;
    GLfloat units;
} glPathStencilDepthOffsetNV_ARGS;
typedef struct {
    int index;
    glPathStencilDepthOffsetNV_ARGS args;
} glPathStencilDepthOffsetNV_PACKED;
#endif
#ifndef glPathStencilFuncNV_RETURN
typedef struct {
    GLenum func;
    GLint ref;
    GLuint mask;
} glPathStencilFuncNV_ARGS;
typedef struct {
    int index;
    glPathStencilFuncNV_ARGS args;
} glPathStencilFuncNV_PACKED;
#endif
#ifndef glPathStringNV_RETURN
typedef struct {
    GLuint path;
    GLenum format;
    GLsizei length;
    GLvoid * pathString;
} glPathStringNV_ARGS;
typedef struct {
    int index;
    glPathStringNV_ARGS args;
} glPathStringNV_PACKED;
#endif
#ifndef glPathSubCommandsNV_RETURN
typedef struct {
    GLuint path;
    GLsizei commandStart;
    GLsizei commandsToDelete;
    GLsizei numCommands;
    GLubyte * commands;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} glPathSubCommandsNV_ARGS;
typedef struct {
    int index;
    glPathSubCommandsNV_ARGS args;
} glPathSubCommandsNV_PACKED;
#endif
#ifndef glPathSubCoordsNV_RETURN
typedef struct {
    GLuint path;
    GLsizei coordStart;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} glPathSubCoordsNV_ARGS;
typedef struct {
    int index;
    glPathSubCoordsNV_ARGS args;
} glPathSubCoordsNV_PACKED;
#endif
#ifndef glPathTexGenNV_RETURN
typedef struct {
    GLenum texCoordSet;
    GLenum genMode;
    GLint components;
    GLfloat * coeffs;
} glPathTexGenNV_ARGS;
typedef struct {
    int index;
    glPathTexGenNV_ARGS args;
} glPathTexGenNV_PACKED;
#endif
#ifndef glPauseTransformFeedback_RETURN
typedef struct {
    int index;
} glPauseTransformFeedback_PACKED;
#endif
#ifndef glPauseTransformFeedbackNV_RETURN
typedef struct {
    int index;
} glPauseTransformFeedbackNV_PACKED;
#endif
#ifndef glPixelDataRangeNV_RETURN
typedef struct {
    GLenum target;
    GLsizei length;
    GLvoid * pointer;
} glPixelDataRangeNV_ARGS;
typedef struct {
    int index;
    glPixelDataRangeNV_ARGS args;
} glPixelDataRangeNV_PACKED;
#endif
#ifndef glPixelMapfv_RETURN
typedef struct {
    GLenum map;
    GLsizei mapsize;
    GLfloat * values;
} glPixelMapfv_ARGS;
typedef struct {
    int index;
    glPixelMapfv_ARGS args;
} glPixelMapfv_PACKED;
#endif
#ifndef glPixelMapuiv_RETURN
typedef struct {
    GLenum map;
    GLsizei mapsize;
    GLuint * values;
} glPixelMapuiv_ARGS;
typedef struct {
    int index;
    glPixelMapuiv_ARGS args;
} glPixelMapuiv_PACKED;
#endif
#ifndef glPixelMapusv_RETURN
typedef struct {
    GLenum map;
    GLsizei mapsize;
    GLushort * values;
} glPixelMapusv_ARGS;
typedef struct {
    int index;
    glPixelMapusv_ARGS args;
} glPixelMapusv_PACKED;
#endif
#ifndef glPixelMapx_RETURN
typedef struct {
    GLenum map;
    GLint size;
    GLfixed * values;
} glPixelMapx_ARGS;
typedef struct {
    int index;
    glPixelMapx_ARGS args;
} glPixelMapx_PACKED;
#endif
#ifndef glPixelStoref_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPixelStoref_ARGS;
typedef struct {
    int index;
    glPixelStoref_ARGS args;
} glPixelStoref_PACKED;
#endif
#ifndef glPixelStorei_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glPixelStorei_ARGS;
typedef struct {
    int index;
    glPixelStorei_ARGS args;
} glPixelStorei_PACKED;
#endif
#ifndef glPixelStorex_RETURN
typedef struct {
    GLenum pname;
    GLfixed param;
} glPixelStorex_ARGS;
typedef struct {
    int index;
    glPixelStorex_ARGS args;
} glPixelStorex_PACKED;
#endif
#ifndef glPixelTexGenParameterfSGIS_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPixelTexGenParameterfSGIS_ARGS;
typedef struct {
    int index;
    glPixelTexGenParameterfSGIS_ARGS args;
} glPixelTexGenParameterfSGIS_PACKED;
#endif
#ifndef glPixelTexGenParameterfvSGIS_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glPixelTexGenParameterfvSGIS_ARGS;
typedef struct {
    int index;
    glPixelTexGenParameterfvSGIS_ARGS args;
} glPixelTexGenParameterfvSGIS_PACKED;
#endif
#ifndef glPixelTexGenParameteriSGIS_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glPixelTexGenParameteriSGIS_ARGS;
typedef struct {
    int index;
    glPixelTexGenParameteriSGIS_ARGS args;
} glPixelTexGenParameteriSGIS_PACKED;
#endif
#ifndef glPixelTexGenParameterivSGIS_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glPixelTexGenParameterivSGIS_ARGS;
typedef struct {
    int index;
    glPixelTexGenParameterivSGIS_ARGS args;
} glPixelTexGenParameterivSGIS_PACKED;
#endif
#ifndef glPixelTexGenSGIX_RETURN
typedef struct {
    GLenum mode;
} glPixelTexGenSGIX_ARGS;
typedef struct {
    int index;
    glPixelTexGenSGIX_ARGS args;
} glPixelTexGenSGIX_PACKED;
#endif
#ifndef glPixelTransferf_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPixelTransferf_ARGS;
typedef struct {
    int index;
    glPixelTransferf_ARGS args;
} glPixelTransferf_PACKED;
#endif
#ifndef glPixelTransferi_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glPixelTransferi_ARGS;
typedef struct {
    int index;
    glPixelTransferi_ARGS args;
} glPixelTransferi_PACKED;
#endif
#ifndef glPixelTransferxOES_RETURN
typedef struct {
    GLenum pname;
    GLfixed param;
} glPixelTransferxOES_ARGS;
typedef struct {
    int index;
    glPixelTransferxOES_ARGS args;
} glPixelTransferxOES_PACKED;
#endif
#ifndef glPixelTransformParameterfEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} glPixelTransformParameterfEXT_ARGS;
typedef struct {
    int index;
    glPixelTransformParameterfEXT_ARGS args;
} glPixelTransformParameterfEXT_PACKED;
#endif
#ifndef glPixelTransformParameterfvEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glPixelTransformParameterfvEXT_ARGS;
typedef struct {
    int index;
    glPixelTransformParameterfvEXT_ARGS args;
} glPixelTransformParameterfvEXT_PACKED;
#endif
#ifndef glPixelTransformParameteriEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} glPixelTransformParameteriEXT_ARGS;
typedef struct {
    int index;
    glPixelTransformParameteriEXT_ARGS args;
} glPixelTransformParameteriEXT_PACKED;
#endif
#ifndef glPixelTransformParameterivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glPixelTransformParameterivEXT_ARGS;
typedef struct {
    int index;
    glPixelTransformParameterivEXT_ARGS args;
} glPixelTransformParameterivEXT_PACKED;
#endif
#ifndef glPixelZoom_RETURN
typedef struct {
    GLfloat xfactor;
    GLfloat yfactor;
} glPixelZoom_ARGS;
typedef struct {
    int index;
    glPixelZoom_ARGS args;
} glPixelZoom_PACKED;
#endif
#ifndef glPixelZoomxOES_RETURN
typedef struct {
    GLfixed xfactor;
    GLfixed yfactor;
} glPixelZoomxOES_ARGS;
typedef struct {
    int index;
    glPixelZoomxOES_ARGS args;
} glPixelZoomxOES_PACKED;
#endif
#ifndef glPointAlongPathNV_RETURN
typedef struct {
    GLuint path;
    GLsizei startSegment;
    GLsizei numSegments;
    GLfloat distance;
    GLfloat * x;
    GLfloat * y;
    GLfloat * tangentX;
    GLfloat * tangentY;
} glPointAlongPathNV_ARGS;
typedef struct {
    int index;
    glPointAlongPathNV_ARGS args;
} glPointAlongPathNV_PACKED;
#endif
#ifndef glPointParameterf_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPointParameterf_ARGS;
typedef struct {
    int index;
    glPointParameterf_ARGS args;
} glPointParameterf_PACKED;
#endif
#ifndef glPointParameterfARB_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPointParameterfARB_ARGS;
typedef struct {
    int index;
    glPointParameterfARB_ARGS args;
} glPointParameterfARB_PACKED;
#endif
#ifndef glPointParameterfEXT_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPointParameterfEXT_ARGS;
typedef struct {
    int index;
    glPointParameterfEXT_ARGS args;
} glPointParameterfEXT_PACKED;
#endif
#ifndef glPointParameterfSGIS_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glPointParameterfSGIS_ARGS;
typedef struct {
    int index;
    glPointParameterfSGIS_ARGS args;
} glPointParameterfSGIS_PACKED;
#endif
#ifndef glPointParameterfv_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glPointParameterfv_ARGS;
typedef struct {
    int index;
    glPointParameterfv_ARGS args;
} glPointParameterfv_PACKED;
#endif
#ifndef glPointParameterfvARB_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glPointParameterfvARB_ARGS;
typedef struct {
    int index;
    glPointParameterfvARB_ARGS args;
} glPointParameterfvARB_PACKED;
#endif
#ifndef glPointParameterfvEXT_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glPointParameterfvEXT_ARGS;
typedef struct {
    int index;
    glPointParameterfvEXT_ARGS args;
} glPointParameterfvEXT_PACKED;
#endif
#ifndef glPointParameterfvSGIS_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glPointParameterfvSGIS_ARGS;
typedef struct {
    int index;
    glPointParameterfvSGIS_ARGS args;
} glPointParameterfvSGIS_PACKED;
#endif
#ifndef glPointParameteri_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glPointParameteri_ARGS;
typedef struct {
    int index;
    glPointParameteri_ARGS args;
} glPointParameteri_PACKED;
#endif
#ifndef glPointParameteriNV_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glPointParameteriNV_ARGS;
typedef struct {
    int index;
    glPointParameteriNV_ARGS args;
} glPointParameteriNV_PACKED;
#endif
#ifndef glPointParameteriv_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glPointParameteriv_ARGS;
typedef struct {
    int index;
    glPointParameteriv_ARGS args;
} glPointParameteriv_PACKED;
#endif
#ifndef glPointParameterivNV_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glPointParameterivNV_ARGS;
typedef struct {
    int index;
    glPointParameterivNV_ARGS args;
} glPointParameterivNV_PACKED;
#endif
#ifndef glPointParameterxvOES_RETURN
typedef struct {
    GLenum pname;
    GLfixed * params;
} glPointParameterxvOES_ARGS;
typedef struct {
    int index;
    glPointParameterxvOES_ARGS args;
} glPointParameterxvOES_PACKED;
#endif
#ifndef glPointSize_RETURN
typedef struct {
    GLfloat size;
} glPointSize_ARGS;
typedef struct {
    int index;
    glPointSize_ARGS args;
} glPointSize_PACKED;
#endif
#ifndef glPointSizexOES_RETURN
typedef struct {
    GLfixed size;
} glPointSizexOES_ARGS;
typedef struct {
    int index;
    glPointSizexOES_ARGS args;
} glPointSizexOES_PACKED;
#endif
#ifndef glPollAsyncSGIX_RETURN
typedef struct {
    GLuint * markerp;
} glPollAsyncSGIX_ARGS;
typedef struct {
    int index;
    glPollAsyncSGIX_ARGS args;
} glPollAsyncSGIX_PACKED;
#endif
#ifndef glPollInstrumentsSGIX_RETURN
typedef struct {
    GLint * marker_p;
} glPollInstrumentsSGIX_ARGS;
typedef struct {
    int index;
    glPollInstrumentsSGIX_ARGS args;
} glPollInstrumentsSGIX_PACKED;
#endif
#ifndef glPolygonMode_RETURN
typedef struct {
    GLenum face;
    GLenum mode;
} glPolygonMode_ARGS;
typedef struct {
    int index;
    glPolygonMode_ARGS args;
} glPolygonMode_PACKED;
#endif
#ifndef glPolygonOffset_RETURN
typedef struct {
    GLfloat factor;
    GLfloat units;
} glPolygonOffset_ARGS;
typedef struct {
    int index;
    glPolygonOffset_ARGS args;
} glPolygonOffset_PACKED;
#endif
#ifndef glPolygonOffsetEXT_RETURN
typedef struct {
    GLfloat factor;
    GLfloat bias;
} glPolygonOffsetEXT_ARGS;
typedef struct {
    int index;
    glPolygonOffsetEXT_ARGS args;
} glPolygonOffsetEXT_PACKED;
#endif
#ifndef glPolygonOffsetxOES_RETURN
typedef struct {
    GLfixed factor;
    GLfixed units;
} glPolygonOffsetxOES_ARGS;
typedef struct {
    int index;
    glPolygonOffsetxOES_ARGS args;
} glPolygonOffsetxOES_PACKED;
#endif
#ifndef glPolygonStipple_RETURN
typedef struct {
    GLubyte * mask;
} glPolygonStipple_ARGS;
typedef struct {
    int index;
    glPolygonStipple_ARGS args;
} glPolygonStipple_PACKED;
#endif
#ifndef glPopAttrib_RETURN
typedef struct {
    int index;
} glPopAttrib_PACKED;
#endif
#ifndef glPopClientAttrib_RETURN
typedef struct {
    int index;
} glPopClientAttrib_PACKED;
#endif
#ifndef glPopDebugGroup_RETURN
typedef struct {
    int index;
} glPopDebugGroup_PACKED;
#endif
#ifndef glPopMatrix_RETURN
typedef struct {
    int index;
} glPopMatrix_PACKED;
#endif
#ifndef glPopName_RETURN
typedef struct {
    int index;
} glPopName_PACKED;
#endif
#ifndef glPresentFrameDualFillNV_RETURN
typedef struct {
    GLuint video_slot;
    GLuint64EXT minPresentTime;
    GLuint beginPresentTimeId;
    GLuint presentDurationId;
    GLenum type;
    GLenum target0;
    GLuint fill0;
    GLenum target1;
    GLuint fill1;
    GLenum target2;
    GLuint fill2;
    GLenum target3;
    GLuint fill3;
} glPresentFrameDualFillNV_ARGS;
typedef struct {
    int index;
    glPresentFrameDualFillNV_ARGS args;
} glPresentFrameDualFillNV_PACKED;
#endif
#ifndef glPresentFrameKeyedNV_RETURN
typedef struct {
    GLuint video_slot;
    GLuint64EXT minPresentTime;
    GLuint beginPresentTimeId;
    GLuint presentDurationId;
    GLenum type;
    GLenum target0;
    GLuint fill0;
    GLuint key0;
    GLenum target1;
    GLuint fill1;
    GLuint key1;
} glPresentFrameKeyedNV_ARGS;
typedef struct {
    int index;
    glPresentFrameKeyedNV_ARGS args;
} glPresentFrameKeyedNV_PACKED;
#endif
#ifndef glPrimitiveRestartIndex_RETURN
typedef struct {
    GLuint index;
} glPrimitiveRestartIndex_ARGS;
typedef struct {
    int index;
    glPrimitiveRestartIndex_ARGS args;
} glPrimitiveRestartIndex_PACKED;
#endif
#ifndef glPrimitiveRestartIndexNV_RETURN
typedef struct {
    GLuint index;
} glPrimitiveRestartIndexNV_ARGS;
typedef struct {
    int index;
    glPrimitiveRestartIndexNV_ARGS args;
} glPrimitiveRestartIndexNV_PACKED;
#endif
#ifndef glPrimitiveRestartNV_RETURN
typedef struct {
    int index;
} glPrimitiveRestartNV_PACKED;
#endif
#ifndef glPrioritizeTextures_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLfloat * priorities;
} glPrioritizeTextures_ARGS;
typedef struct {
    int index;
    glPrioritizeTextures_ARGS args;
} glPrioritizeTextures_PACKED;
#endif
#ifndef glPrioritizeTexturesEXT_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLclampf * priorities;
} glPrioritizeTexturesEXT_ARGS;
typedef struct {
    int index;
    glPrioritizeTexturesEXT_ARGS args;
} glPrioritizeTexturesEXT_PACKED;
#endif
#ifndef glPrioritizeTexturesxOES_RETURN
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLfixed * priorities;
} glPrioritizeTexturesxOES_ARGS;
typedef struct {
    int index;
    glPrioritizeTexturesxOES_ARGS args;
} glPrioritizeTexturesxOES_PACKED;
#endif
#ifndef glProgramBinary_RETURN
typedef struct {
    GLuint program;
    GLenum binaryFormat;
    GLvoid * binary;
    GLsizei length;
} glProgramBinary_ARGS;
typedef struct {
    int index;
    glProgramBinary_ARGS args;
} glProgramBinary_PACKED;
#endif
#ifndef glProgramBufferParametersIivNV_RETURN
typedef struct {
    GLenum target;
    GLuint bindingIndex;
    GLuint wordIndex;
    GLsizei count;
    GLint * params;
} glProgramBufferParametersIivNV_ARGS;
typedef struct {
    int index;
    glProgramBufferParametersIivNV_ARGS args;
} glProgramBufferParametersIivNV_PACKED;
#endif
#ifndef glProgramBufferParametersIuivNV_RETURN
typedef struct {
    GLenum target;
    GLuint bindingIndex;
    GLuint wordIndex;
    GLsizei count;
    GLuint * params;
} glProgramBufferParametersIuivNV_ARGS;
typedef struct {
    int index;
    glProgramBufferParametersIuivNV_ARGS args;
} glProgramBufferParametersIuivNV_PACKED;
#endif
#ifndef glProgramBufferParametersfvNV_RETURN
typedef struct {
    GLenum target;
    GLuint bindingIndex;
    GLuint wordIndex;
    GLsizei count;
    GLfloat * params;
} glProgramBufferParametersfvNV_ARGS;
typedef struct {
    int index;
    glProgramBufferParametersfvNV_ARGS args;
} glProgramBufferParametersfvNV_PACKED;
#endif
#ifndef glProgramEnvParameter4dARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glProgramEnvParameter4dARB_ARGS;
typedef struct {
    int index;
    glProgramEnvParameter4dARB_ARGS args;
} glProgramEnvParameter4dARB_PACKED;
#endif
#ifndef glProgramEnvParameter4dvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} glProgramEnvParameter4dvARB_ARGS;
typedef struct {
    int index;
    glProgramEnvParameter4dvARB_ARGS args;
} glProgramEnvParameter4dvARB_PACKED;
#endif
#ifndef glProgramEnvParameter4fARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glProgramEnvParameter4fARB_ARGS;
typedef struct {
    int index;
    glProgramEnvParameter4fARB_ARGS args;
} glProgramEnvParameter4fARB_PACKED;
#endif
#ifndef glProgramEnvParameter4fvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} glProgramEnvParameter4fvARB_ARGS;
typedef struct {
    int index;
    glProgramEnvParameter4fvARB_ARGS args;
} glProgramEnvParameter4fvARB_PACKED;
#endif
#ifndef glProgramEnvParameterI4iNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glProgramEnvParameterI4iNV_ARGS;
typedef struct {
    int index;
    glProgramEnvParameterI4iNV_ARGS args;
} glProgramEnvParameterI4iNV_PACKED;
#endif
#ifndef glProgramEnvParameterI4ivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} glProgramEnvParameterI4ivNV_ARGS;
typedef struct {
    int index;
    glProgramEnvParameterI4ivNV_ARGS args;
} glProgramEnvParameterI4ivNV_PACKED;
#endif
#ifndef glProgramEnvParameterI4uiNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} glProgramEnvParameterI4uiNV_ARGS;
typedef struct {
    int index;
    glProgramEnvParameterI4uiNV_ARGS args;
} glProgramEnvParameterI4uiNV_PACKED;
#endif
#ifndef glProgramEnvParameterI4uivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} glProgramEnvParameterI4uivNV_ARGS;
typedef struct {
    int index;
    glProgramEnvParameterI4uivNV_ARGS args;
} glProgramEnvParameterI4uivNV_PACKED;
#endif
#ifndef glProgramEnvParameters4fvEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * params;
} glProgramEnvParameters4fvEXT_ARGS;
typedef struct {
    int index;
    glProgramEnvParameters4fvEXT_ARGS args;
} glProgramEnvParameters4fvEXT_PACKED;
#endif
#ifndef glProgramEnvParametersI4ivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLint * params;
} glProgramEnvParametersI4ivNV_ARGS;
typedef struct {
    int index;
    glProgramEnvParametersI4ivNV_ARGS args;
} glProgramEnvParametersI4ivNV_PACKED;
#endif
#ifndef glProgramEnvParametersI4uivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLuint * params;
} glProgramEnvParametersI4uivNV_ARGS;
typedef struct {
    int index;
    glProgramEnvParametersI4uivNV_ARGS args;
} glProgramEnvParametersI4uivNV_PACKED;
#endif
#ifndef glProgramLocalParameter4dARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glProgramLocalParameter4dARB_ARGS;
typedef struct {
    int index;
    glProgramLocalParameter4dARB_ARGS args;
} glProgramLocalParameter4dARB_PACKED;
#endif
#ifndef glProgramLocalParameter4dvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} glProgramLocalParameter4dvARB_ARGS;
typedef struct {
    int index;
    glProgramLocalParameter4dvARB_ARGS args;
} glProgramLocalParameter4dvARB_PACKED;
#endif
#ifndef glProgramLocalParameter4fARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glProgramLocalParameter4fARB_ARGS;
typedef struct {
    int index;
    glProgramLocalParameter4fARB_ARGS args;
} glProgramLocalParameter4fARB_PACKED;
#endif
#ifndef glProgramLocalParameter4fvARB_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} glProgramLocalParameter4fvARB_ARGS;
typedef struct {
    int index;
    glProgramLocalParameter4fvARB_ARGS args;
} glProgramLocalParameter4fvARB_PACKED;
#endif
#ifndef glProgramLocalParameterI4iNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glProgramLocalParameterI4iNV_ARGS;
typedef struct {
    int index;
    glProgramLocalParameterI4iNV_ARGS args;
} glProgramLocalParameterI4iNV_PACKED;
#endif
#ifndef glProgramLocalParameterI4ivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} glProgramLocalParameterI4ivNV_ARGS;
typedef struct {
    int index;
    glProgramLocalParameterI4ivNV_ARGS args;
} glProgramLocalParameterI4ivNV_PACKED;
#endif
#ifndef glProgramLocalParameterI4uiNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} glProgramLocalParameterI4uiNV_ARGS;
typedef struct {
    int index;
    glProgramLocalParameterI4uiNV_ARGS args;
} glProgramLocalParameterI4uiNV_PACKED;
#endif
#ifndef glProgramLocalParameterI4uivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} glProgramLocalParameterI4uivNV_ARGS;
typedef struct {
    int index;
    glProgramLocalParameterI4uivNV_ARGS args;
} glProgramLocalParameterI4uivNV_PACKED;
#endif
#ifndef glProgramLocalParameters4fvEXT_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * params;
} glProgramLocalParameters4fvEXT_ARGS;
typedef struct {
    int index;
    glProgramLocalParameters4fvEXT_ARGS args;
} glProgramLocalParameters4fvEXT_PACKED;
#endif
#ifndef glProgramLocalParametersI4ivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLint * params;
} glProgramLocalParametersI4ivNV_ARGS;
typedef struct {
    int index;
    glProgramLocalParametersI4ivNV_ARGS args;
} glProgramLocalParametersI4ivNV_PACKED;
#endif
#ifndef glProgramLocalParametersI4uivNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLuint * params;
} glProgramLocalParametersI4uivNV_ARGS;
typedef struct {
    int index;
    glProgramLocalParametersI4uivNV_ARGS args;
} glProgramLocalParametersI4uivNV_PACKED;
#endif
#ifndef glProgramNamedParameter4dNV_RETURN
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glProgramNamedParameter4dNV_ARGS;
typedef struct {
    int index;
    glProgramNamedParameter4dNV_ARGS args;
} glProgramNamedParameter4dNV_PACKED;
#endif
#ifndef glProgramNamedParameter4dvNV_RETURN
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLdouble * v;
} glProgramNamedParameter4dvNV_ARGS;
typedef struct {
    int index;
    glProgramNamedParameter4dvNV_ARGS args;
} glProgramNamedParameter4dvNV_PACKED;
#endif
#ifndef glProgramNamedParameter4fNV_RETURN
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glProgramNamedParameter4fNV_ARGS;
typedef struct {
    int index;
    glProgramNamedParameter4fNV_ARGS args;
} glProgramNamedParameter4fNV_PACKED;
#endif
#ifndef glProgramNamedParameter4fvNV_RETURN
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLfloat * v;
} glProgramNamedParameter4fvNV_ARGS;
typedef struct {
    int index;
    glProgramNamedParameter4fvNV_ARGS args;
} glProgramNamedParameter4fvNV_PACKED;
#endif
#ifndef glProgramParameter4dNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glProgramParameter4dNV_ARGS;
typedef struct {
    int index;
    glProgramParameter4dNV_ARGS args;
} glProgramParameter4dNV_PACKED;
#endif
#ifndef glProgramParameter4dvNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * v;
} glProgramParameter4dvNV_ARGS;
typedef struct {
    int index;
    glProgramParameter4dvNV_ARGS args;
} glProgramParameter4dvNV_PACKED;
#endif
#ifndef glProgramParameter4fNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glProgramParameter4fNV_ARGS;
typedef struct {
    int index;
    glProgramParameter4fNV_ARGS args;
} glProgramParameter4fNV_PACKED;
#endif
#ifndef glProgramParameter4fvNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * v;
} glProgramParameter4fvNV_ARGS;
typedef struct {
    int index;
    glProgramParameter4fvNV_ARGS args;
} glProgramParameter4fvNV_PACKED;
#endif
#ifndef glProgramParameteri_RETURN
typedef struct {
    GLuint program;
    GLenum pname;
    GLint value;
} glProgramParameteri_ARGS;
typedef struct {
    int index;
    glProgramParameteri_ARGS args;
} glProgramParameteri_PACKED;
#endif
#ifndef glProgramParameteriARB_RETURN
typedef struct {
    GLuint program;
    GLenum pname;
    GLint value;
} glProgramParameteriARB_ARGS;
typedef struct {
    int index;
    glProgramParameteriARB_ARGS args;
} glProgramParameteriARB_PACKED;
#endif
#ifndef glProgramParameteriEXT_RETURN
typedef struct {
    GLuint program;
    GLenum pname;
    GLint value;
} glProgramParameteriEXT_ARGS;
typedef struct {
    int index;
    glProgramParameteriEXT_ARGS args;
} glProgramParameteriEXT_PACKED;
#endif
#ifndef glProgramParameters4dvNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLdouble * v;
} glProgramParameters4dvNV_ARGS;
typedef struct {
    int index;
    glProgramParameters4dvNV_ARGS args;
} glProgramParameters4dvNV_PACKED;
#endif
#ifndef glProgramParameters4fvNV_RETURN
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * v;
} glProgramParameters4fvNV_ARGS;
typedef struct {
    int index;
    glProgramParameters4fvNV_ARGS args;
} glProgramParameters4fvNV_PACKED;
#endif
#ifndef glProgramStringARB_RETURN
typedef struct {
    GLenum target;
    GLenum format;
    GLsizei len;
    GLvoid * string;
} glProgramStringARB_ARGS;
typedef struct {
    int index;
    glProgramStringARB_ARGS args;
} glProgramStringARB_PACKED;
#endif
#ifndef glProgramSubroutineParametersuivNV_RETURN
typedef struct {
    GLenum target;
    GLsizei count;
    GLuint * params;
} glProgramSubroutineParametersuivNV_ARGS;
typedef struct {
    int index;
    glProgramSubroutineParametersuivNV_ARGS args;
} glProgramSubroutineParametersuivNV_PACKED;
#endif
#ifndef glProgramUniform1d_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
} glProgramUniform1d_ARGS;
typedef struct {
    int index;
    glProgramUniform1d_ARGS args;
} glProgramUniform1d_PACKED;
#endif
#ifndef glProgramUniform1dEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
} glProgramUniform1dEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1dEXT_ARGS args;
} glProgramUniform1dEXT_PACKED;
#endif
#ifndef glProgramUniform1dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform1dv_ARGS;
typedef struct {
    int index;
    glProgramUniform1dv_ARGS args;
} glProgramUniform1dv_PACKED;
#endif
#ifndef glProgramUniform1dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform1dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1dvEXT_ARGS args;
} glProgramUniform1dvEXT_PACKED;
#endif
#ifndef glProgramUniform1f_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
} glProgramUniform1f_ARGS;
typedef struct {
    int index;
    glProgramUniform1f_ARGS args;
} glProgramUniform1f_PACKED;
#endif
#ifndef glProgramUniform1fEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
} glProgramUniform1fEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1fEXT_ARGS args;
} glProgramUniform1fEXT_PACKED;
#endif
#ifndef glProgramUniform1fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform1fv_ARGS;
typedef struct {
    int index;
    glProgramUniform1fv_ARGS args;
} glProgramUniform1fv_PACKED;
#endif
#ifndef glProgramUniform1fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform1fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1fvEXT_ARGS args;
} glProgramUniform1fvEXT_PACKED;
#endif
#ifndef glProgramUniform1i_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
} glProgramUniform1i_ARGS;
typedef struct {
    int index;
    glProgramUniform1i_ARGS args;
} glProgramUniform1i_PACKED;
#endif
#ifndef glProgramUniform1i64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
} glProgramUniform1i64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform1i64NV_ARGS args;
} glProgramUniform1i64NV_PACKED;
#endif
#ifndef glProgramUniform1i64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glProgramUniform1i64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform1i64vNV_ARGS args;
} glProgramUniform1i64vNV_PACKED;
#endif
#ifndef glProgramUniform1iEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
} glProgramUniform1iEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1iEXT_ARGS args;
} glProgramUniform1iEXT_PACKED;
#endif
#ifndef glProgramUniform1iv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform1iv_ARGS;
typedef struct {
    int index;
    glProgramUniform1iv_ARGS args;
} glProgramUniform1iv_PACKED;
#endif
#ifndef glProgramUniform1ivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform1ivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1ivEXT_ARGS args;
} glProgramUniform1ivEXT_PACKED;
#endif
#ifndef glProgramUniform1ui_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
} glProgramUniform1ui_ARGS;
typedef struct {
    int index;
    glProgramUniform1ui_ARGS args;
} glProgramUniform1ui_PACKED;
#endif
#ifndef glProgramUniform1ui64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
} glProgramUniform1ui64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform1ui64NV_ARGS args;
} glProgramUniform1ui64NV_PACKED;
#endif
#ifndef glProgramUniform1ui64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glProgramUniform1ui64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform1ui64vNV_ARGS args;
} glProgramUniform1ui64vNV_PACKED;
#endif
#ifndef glProgramUniform1uiEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
} glProgramUniform1uiEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1uiEXT_ARGS args;
} glProgramUniform1uiEXT_PACKED;
#endif
#ifndef glProgramUniform1uiv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform1uiv_ARGS;
typedef struct {
    int index;
    glProgramUniform1uiv_ARGS args;
} glProgramUniform1uiv_PACKED;
#endif
#ifndef glProgramUniform1uivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform1uivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform1uivEXT_ARGS args;
} glProgramUniform1uivEXT_PACKED;
#endif
#ifndef glProgramUniform2d_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
    GLdouble v1 __attribute__ ((aligned(8)));
} glProgramUniform2d_ARGS;
typedef struct {
    int index;
    glProgramUniform2d_ARGS args;
} glProgramUniform2d_PACKED;
#endif
#ifndef glProgramUniform2dEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glProgramUniform2dEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2dEXT_ARGS args;
} glProgramUniform2dEXT_PACKED;
#endif
#ifndef glProgramUniform2dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform2dv_ARGS;
typedef struct {
    int index;
    glProgramUniform2dv_ARGS args;
} glProgramUniform2dv_PACKED;
#endif
#ifndef glProgramUniform2dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform2dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2dvEXT_ARGS args;
} glProgramUniform2dvEXT_PACKED;
#endif
#ifndef glProgramUniform2f_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
} glProgramUniform2f_ARGS;
typedef struct {
    int index;
    glProgramUniform2f_ARGS args;
} glProgramUniform2f_PACKED;
#endif
#ifndef glProgramUniform2fEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
} glProgramUniform2fEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2fEXT_ARGS args;
} glProgramUniform2fEXT_PACKED;
#endif
#ifndef glProgramUniform2fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform2fv_ARGS;
typedef struct {
    int index;
    glProgramUniform2fv_ARGS args;
} glProgramUniform2fv_PACKED;
#endif
#ifndef glProgramUniform2fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform2fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2fvEXT_ARGS args;
} glProgramUniform2fvEXT_PACKED;
#endif
#ifndef glProgramUniform2i_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
} glProgramUniform2i_ARGS;
typedef struct {
    int index;
    glProgramUniform2i_ARGS args;
} glProgramUniform2i_PACKED;
#endif
#ifndef glProgramUniform2i64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
} glProgramUniform2i64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform2i64NV_ARGS args;
} glProgramUniform2i64NV_PACKED;
#endif
#ifndef glProgramUniform2i64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glProgramUniform2i64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform2i64vNV_ARGS args;
} glProgramUniform2i64vNV_PACKED;
#endif
#ifndef glProgramUniform2iEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
} glProgramUniform2iEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2iEXT_ARGS args;
} glProgramUniform2iEXT_PACKED;
#endif
#ifndef glProgramUniform2iv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform2iv_ARGS;
typedef struct {
    int index;
    glProgramUniform2iv_ARGS args;
} glProgramUniform2iv_PACKED;
#endif
#ifndef glProgramUniform2ivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform2ivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2ivEXT_ARGS args;
} glProgramUniform2ivEXT_PACKED;
#endif
#ifndef glProgramUniform2ui_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
} glProgramUniform2ui_ARGS;
typedef struct {
    int index;
    glProgramUniform2ui_ARGS args;
} glProgramUniform2ui_PACKED;
#endif
#ifndef glProgramUniform2ui64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
} glProgramUniform2ui64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform2ui64NV_ARGS args;
} glProgramUniform2ui64NV_PACKED;
#endif
#ifndef glProgramUniform2ui64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glProgramUniform2ui64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform2ui64vNV_ARGS args;
} glProgramUniform2ui64vNV_PACKED;
#endif
#ifndef glProgramUniform2uiEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
} glProgramUniform2uiEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2uiEXT_ARGS args;
} glProgramUniform2uiEXT_PACKED;
#endif
#ifndef glProgramUniform2uiv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform2uiv_ARGS;
typedef struct {
    int index;
    glProgramUniform2uiv_ARGS args;
} glProgramUniform2uiv_PACKED;
#endif
#ifndef glProgramUniform2uivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform2uivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform2uivEXT_ARGS args;
} glProgramUniform2uivEXT_PACKED;
#endif
#ifndef glProgramUniform3d_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
} glProgramUniform3d_ARGS;
typedef struct {
    int index;
    glProgramUniform3d_ARGS args;
} glProgramUniform3d_PACKED;
#endif
#ifndef glProgramUniform3dEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glProgramUniform3dEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3dEXT_ARGS args;
} glProgramUniform3dEXT_PACKED;
#endif
#ifndef glProgramUniform3dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform3dv_ARGS;
typedef struct {
    int index;
    glProgramUniform3dv_ARGS args;
} glProgramUniform3dv_PACKED;
#endif
#ifndef glProgramUniform3dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform3dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3dvEXT_ARGS args;
} glProgramUniform3dvEXT_PACKED;
#endif
#ifndef glProgramUniform3f_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} glProgramUniform3f_ARGS;
typedef struct {
    int index;
    glProgramUniform3f_ARGS args;
} glProgramUniform3f_PACKED;
#endif
#ifndef glProgramUniform3fEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} glProgramUniform3fEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3fEXT_ARGS args;
} glProgramUniform3fEXT_PACKED;
#endif
#ifndef glProgramUniform3fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform3fv_ARGS;
typedef struct {
    int index;
    glProgramUniform3fv_ARGS args;
} glProgramUniform3fv_PACKED;
#endif
#ifndef glProgramUniform3fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform3fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3fvEXT_ARGS args;
} glProgramUniform3fvEXT_PACKED;
#endif
#ifndef glProgramUniform3i_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} glProgramUniform3i_ARGS;
typedef struct {
    int index;
    glProgramUniform3i_ARGS args;
} glProgramUniform3i_PACKED;
#endif
#ifndef glProgramUniform3i64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
} glProgramUniform3i64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform3i64NV_ARGS args;
} glProgramUniform3i64NV_PACKED;
#endif
#ifndef glProgramUniform3i64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glProgramUniform3i64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform3i64vNV_ARGS args;
} glProgramUniform3i64vNV_PACKED;
#endif
#ifndef glProgramUniform3iEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} glProgramUniform3iEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3iEXT_ARGS args;
} glProgramUniform3iEXT_PACKED;
#endif
#ifndef glProgramUniform3iv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform3iv_ARGS;
typedef struct {
    int index;
    glProgramUniform3iv_ARGS args;
} glProgramUniform3iv_PACKED;
#endif
#ifndef glProgramUniform3ivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform3ivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3ivEXT_ARGS args;
} glProgramUniform3ivEXT_PACKED;
#endif
#ifndef glProgramUniform3ui_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} glProgramUniform3ui_ARGS;
typedef struct {
    int index;
    glProgramUniform3ui_ARGS args;
} glProgramUniform3ui_PACKED;
#endif
#ifndef glProgramUniform3ui64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
} glProgramUniform3ui64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform3ui64NV_ARGS args;
} glProgramUniform3ui64NV_PACKED;
#endif
#ifndef glProgramUniform3ui64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glProgramUniform3ui64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform3ui64vNV_ARGS args;
} glProgramUniform3ui64vNV_PACKED;
#endif
#ifndef glProgramUniform3uiEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} glProgramUniform3uiEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3uiEXT_ARGS args;
} glProgramUniform3uiEXT_PACKED;
#endif
#ifndef glProgramUniform3uiv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform3uiv_ARGS;
typedef struct {
    int index;
    glProgramUniform3uiv_ARGS args;
} glProgramUniform3uiv_PACKED;
#endif
#ifndef glProgramUniform3uivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform3uivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform3uivEXT_ARGS args;
} glProgramUniform3uivEXT_PACKED;
#endif
#ifndef glProgramUniform4d_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLdouble v3 __attribute__ ((aligned(8)));
} glProgramUniform4d_ARGS;
typedef struct {
    int index;
    glProgramUniform4d_ARGS args;
} glProgramUniform4d_PACKED;
#endif
#ifndef glProgramUniform4dEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glProgramUniform4dEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4dEXT_ARGS args;
} glProgramUniform4dEXT_PACKED;
#endif
#ifndef glProgramUniform4dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform4dv_ARGS;
typedef struct {
    int index;
    glProgramUniform4dv_ARGS args;
} glProgramUniform4dv_PACKED;
#endif
#ifndef glProgramUniform4dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} glProgramUniform4dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4dvEXT_ARGS args;
} glProgramUniform4dvEXT_PACKED;
#endif
#ifndef glProgramUniform4f_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} glProgramUniform4f_ARGS;
typedef struct {
    int index;
    glProgramUniform4f_ARGS args;
} glProgramUniform4f_PACKED;
#endif
#ifndef glProgramUniform4fEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} glProgramUniform4fEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4fEXT_ARGS args;
} glProgramUniform4fEXT_PACKED;
#endif
#ifndef glProgramUniform4fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform4fv_ARGS;
typedef struct {
    int index;
    glProgramUniform4fv_ARGS args;
} glProgramUniform4fv_PACKED;
#endif
#ifndef glProgramUniform4fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} glProgramUniform4fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4fvEXT_ARGS args;
} glProgramUniform4fvEXT_PACKED;
#endif
#ifndef glProgramUniform4i_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} glProgramUniform4i_ARGS;
typedef struct {
    int index;
    glProgramUniform4i_ARGS args;
} glProgramUniform4i_PACKED;
#endif
#ifndef glProgramUniform4i64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
    GLint64EXT w;
} glProgramUniform4i64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform4i64NV_ARGS args;
} glProgramUniform4i64NV_PACKED;
#endif
#ifndef glProgramUniform4i64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glProgramUniform4i64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform4i64vNV_ARGS args;
} glProgramUniform4i64vNV_PACKED;
#endif
#ifndef glProgramUniform4iEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} glProgramUniform4iEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4iEXT_ARGS args;
} glProgramUniform4iEXT_PACKED;
#endif
#ifndef glProgramUniform4iv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform4iv_ARGS;
typedef struct {
    int index;
    glProgramUniform4iv_ARGS args;
} glProgramUniform4iv_PACKED;
#endif
#ifndef glProgramUniform4ivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} glProgramUniform4ivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4ivEXT_ARGS args;
} glProgramUniform4ivEXT_PACKED;
#endif
#ifndef glProgramUniform4ui_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} glProgramUniform4ui_ARGS;
typedef struct {
    int index;
    glProgramUniform4ui_ARGS args;
} glProgramUniform4ui_PACKED;
#endif
#ifndef glProgramUniform4ui64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
    GLuint64EXT w;
} glProgramUniform4ui64NV_ARGS;
typedef struct {
    int index;
    glProgramUniform4ui64NV_ARGS args;
} glProgramUniform4ui64NV_PACKED;
#endif
#ifndef glProgramUniform4ui64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glProgramUniform4ui64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniform4ui64vNV_ARGS args;
} glProgramUniform4ui64vNV_PACKED;
#endif
#ifndef glProgramUniform4uiEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} glProgramUniform4uiEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4uiEXT_ARGS args;
} glProgramUniform4uiEXT_PACKED;
#endif
#ifndef glProgramUniform4uiv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform4uiv_ARGS;
typedef struct {
    int index;
    glProgramUniform4uiv_ARGS args;
} glProgramUniform4uiv_PACKED;
#endif
#ifndef glProgramUniform4uivEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} glProgramUniform4uivEXT_ARGS;
typedef struct {
    int index;
    glProgramUniform4uivEXT_ARGS args;
} glProgramUniform4uivEXT_PACKED;
#endif
#ifndef glProgramUniformHandleui64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint64 value;
} glProgramUniformHandleui64NV_ARGS;
typedef struct {
    int index;
    glProgramUniformHandleui64NV_ARGS args;
} glProgramUniformHandleui64NV_PACKED;
#endif
#ifndef glProgramUniformHandleui64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64 * values;
} glProgramUniformHandleui64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniformHandleui64vNV_ARGS args;
} glProgramUniformHandleui64vNV_PACKED;
#endif
#ifndef glProgramUniformMatrix2dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix2dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2dv_ARGS args;
} glProgramUniformMatrix2dv_PACKED;
#endif
#ifndef glProgramUniformMatrix2dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix2dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2dvEXT_ARGS args;
} glProgramUniformMatrix2dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix2fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix2fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2fv_ARGS args;
} glProgramUniformMatrix2fv_PACKED;
#endif
#ifndef glProgramUniformMatrix2fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix2fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2fvEXT_ARGS args;
} glProgramUniformMatrix2fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix2x3dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix2x3dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x3dv_ARGS args;
} glProgramUniformMatrix2x3dv_PACKED;
#endif
#ifndef glProgramUniformMatrix2x3dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix2x3dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x3dvEXT_ARGS args;
} glProgramUniformMatrix2x3dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix2x3fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix2x3fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x3fv_ARGS args;
} glProgramUniformMatrix2x3fv_PACKED;
#endif
#ifndef glProgramUniformMatrix2x3fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix2x3fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x3fvEXT_ARGS args;
} glProgramUniformMatrix2x3fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix2x4dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix2x4dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x4dv_ARGS args;
} glProgramUniformMatrix2x4dv_PACKED;
#endif
#ifndef glProgramUniformMatrix2x4dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix2x4dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x4dvEXT_ARGS args;
} glProgramUniformMatrix2x4dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix2x4fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix2x4fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x4fv_ARGS args;
} glProgramUniformMatrix2x4fv_PACKED;
#endif
#ifndef glProgramUniformMatrix2x4fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix2x4fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix2x4fvEXT_ARGS args;
} glProgramUniformMatrix2x4fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix3dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix3dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3dv_ARGS args;
} glProgramUniformMatrix3dv_PACKED;
#endif
#ifndef glProgramUniformMatrix3dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix3dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3dvEXT_ARGS args;
} glProgramUniformMatrix3dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix3fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix3fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3fv_ARGS args;
} glProgramUniformMatrix3fv_PACKED;
#endif
#ifndef glProgramUniformMatrix3fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix3fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3fvEXT_ARGS args;
} glProgramUniformMatrix3fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix3x2dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix3x2dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x2dv_ARGS args;
} glProgramUniformMatrix3x2dv_PACKED;
#endif
#ifndef glProgramUniformMatrix3x2dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix3x2dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x2dvEXT_ARGS args;
} glProgramUniformMatrix3x2dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix3x2fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix3x2fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x2fv_ARGS args;
} glProgramUniformMatrix3x2fv_PACKED;
#endif
#ifndef glProgramUniformMatrix3x2fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix3x2fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x2fvEXT_ARGS args;
} glProgramUniformMatrix3x2fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix3x4dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix3x4dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x4dv_ARGS args;
} glProgramUniformMatrix3x4dv_PACKED;
#endif
#ifndef glProgramUniformMatrix3x4dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix3x4dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x4dvEXT_ARGS args;
} glProgramUniformMatrix3x4dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix3x4fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix3x4fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x4fv_ARGS args;
} glProgramUniformMatrix3x4fv_PACKED;
#endif
#ifndef glProgramUniformMatrix3x4fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix3x4fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix3x4fvEXT_ARGS args;
} glProgramUniformMatrix3x4fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix4dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix4dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4dv_ARGS args;
} glProgramUniformMatrix4dv_PACKED;
#endif
#ifndef glProgramUniformMatrix4dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix4dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4dvEXT_ARGS args;
} glProgramUniformMatrix4dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix4fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix4fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4fv_ARGS args;
} glProgramUniformMatrix4fv_PACKED;
#endif
#ifndef glProgramUniformMatrix4fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix4fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4fvEXT_ARGS args;
} glProgramUniformMatrix4fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix4x2dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix4x2dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x2dv_ARGS args;
} glProgramUniformMatrix4x2dv_PACKED;
#endif
#ifndef glProgramUniformMatrix4x2dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix4x2dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x2dvEXT_ARGS args;
} glProgramUniformMatrix4x2dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix4x2fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix4x2fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x2fv_ARGS args;
} glProgramUniformMatrix4x2fv_PACKED;
#endif
#ifndef glProgramUniformMatrix4x2fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix4x2fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x2fvEXT_ARGS args;
} glProgramUniformMatrix4x2fvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix4x3dv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix4x3dv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x3dv_ARGS args;
} glProgramUniformMatrix4x3dv_PACKED;
#endif
#ifndef glProgramUniformMatrix4x3dvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glProgramUniformMatrix4x3dvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x3dvEXT_ARGS args;
} glProgramUniformMatrix4x3dvEXT_PACKED;
#endif
#ifndef glProgramUniformMatrix4x3fv_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix4x3fv_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x3fv_ARGS args;
} glProgramUniformMatrix4x3fv_PACKED;
#endif
#ifndef glProgramUniformMatrix4x3fvEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glProgramUniformMatrix4x3fvEXT_ARGS;
typedef struct {
    int index;
    glProgramUniformMatrix4x3fvEXT_ARGS args;
} glProgramUniformMatrix4x3fvEXT_PACKED;
#endif
#ifndef glProgramUniformui64NV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT value;
} glProgramUniformui64NV_ARGS;
typedef struct {
    int index;
    glProgramUniformui64NV_ARGS args;
} glProgramUniformui64NV_PACKED;
#endif
#ifndef glProgramUniformui64vNV_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glProgramUniformui64vNV_ARGS;
typedef struct {
    int index;
    glProgramUniformui64vNV_ARGS args;
} glProgramUniformui64vNV_PACKED;
#endif
#ifndef glProgramVertexLimitNV_RETURN
typedef struct {
    GLenum target;
    GLint limit;
} glProgramVertexLimitNV_ARGS;
typedef struct {
    int index;
    glProgramVertexLimitNV_ARGS args;
} glProgramVertexLimitNV_PACKED;
#endif
#ifndef glProvokingVertex_RETURN
typedef struct {
    GLenum mode;
} glProvokingVertex_ARGS;
typedef struct {
    int index;
    glProvokingVertex_ARGS args;
} glProvokingVertex_PACKED;
#endif
#ifndef glProvokingVertexEXT_RETURN
typedef struct {
    GLenum mode;
} glProvokingVertexEXT_ARGS;
typedef struct {
    int index;
    glProvokingVertexEXT_ARGS args;
} glProvokingVertexEXT_PACKED;
#endif
#ifndef glPushAttrib_RETURN
typedef struct {
    GLbitfield mask;
} glPushAttrib_ARGS;
typedef struct {
    int index;
    glPushAttrib_ARGS args;
} glPushAttrib_PACKED;
#endif
#ifndef glPushClientAttrib_RETURN
typedef struct {
    GLbitfield mask;
} glPushClientAttrib_ARGS;
typedef struct {
    int index;
    glPushClientAttrib_ARGS args;
} glPushClientAttrib_PACKED;
#endif
#ifndef glPushClientAttribDefaultEXT_RETURN
typedef struct {
    GLbitfield mask;
} glPushClientAttribDefaultEXT_ARGS;
typedef struct {
    int index;
    glPushClientAttribDefaultEXT_ARGS args;
} glPushClientAttribDefaultEXT_PACKED;
#endif
#ifndef glPushDebugGroup_RETURN
typedef struct {
    GLenum source;
    GLuint id;
    GLsizei length;
    GLchar * message;
} glPushDebugGroup_ARGS;
typedef struct {
    int index;
    glPushDebugGroup_ARGS args;
} glPushDebugGroup_PACKED;
#endif
#ifndef glPushMatrix_RETURN
typedef struct {
    int index;
} glPushMatrix_PACKED;
#endif
#ifndef glPushName_RETURN
typedef struct {
    GLuint name;
} glPushName_ARGS;
typedef struct {
    int index;
    glPushName_ARGS args;
} glPushName_PACKED;
#endif
#ifndef glQueryCounter_RETURN
typedef struct {
    GLuint id;
    GLenum target;
} glQueryCounter_ARGS;
typedef struct {
    int index;
    glQueryCounter_ARGS args;
} glQueryCounter_PACKED;
#endif
#ifndef glQueryMatrixxOES_RETURN
typedef struct {
    GLfixed * mantissa;
    GLint * exponent;
} glQueryMatrixxOES_ARGS;
typedef struct {
    int index;
    glQueryMatrixxOES_ARGS args;
} glQueryMatrixxOES_PACKED;
#endif
#ifndef glRasterPos2d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glRasterPos2d_ARGS;
typedef struct {
    int index;
    glRasterPos2d_ARGS args;
} glRasterPos2d_PACKED;
#endif
#ifndef glRasterPos2dv_RETURN
typedef struct {
    GLdouble * v;
} glRasterPos2dv_ARGS;
typedef struct {
    int index;
    glRasterPos2dv_ARGS args;
} glRasterPos2dv_PACKED;
#endif
#ifndef glRasterPos2f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
} glRasterPos2f_ARGS;
typedef struct {
    int index;
    glRasterPos2f_ARGS args;
} glRasterPos2f_PACKED;
#endif
#ifndef glRasterPos2fv_RETURN
typedef struct {
    GLfloat * v;
} glRasterPos2fv_ARGS;
typedef struct {
    int index;
    glRasterPos2fv_ARGS args;
} glRasterPos2fv_PACKED;
#endif
#ifndef glRasterPos2i_RETURN
typedef struct {
    GLint x;
    GLint y;
} glRasterPos2i_ARGS;
typedef struct {
    int index;
    glRasterPos2i_ARGS args;
} glRasterPos2i_PACKED;
#endif
#ifndef glRasterPos2iv_RETURN
typedef struct {
    GLint * v;
} glRasterPos2iv_ARGS;
typedef struct {
    int index;
    glRasterPos2iv_ARGS args;
} glRasterPos2iv_PACKED;
#endif
#ifndef glRasterPos2s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
} glRasterPos2s_ARGS;
typedef struct {
    int index;
    glRasterPos2s_ARGS args;
} glRasterPos2s_PACKED;
#endif
#ifndef glRasterPos2sv_RETURN
typedef struct {
    GLshort * v;
} glRasterPos2sv_ARGS;
typedef struct {
    int index;
    glRasterPos2sv_ARGS args;
} glRasterPos2sv_PACKED;
#endif
#ifndef glRasterPos2xOES_RETURN
typedef struct {
    GLfixed x;
    GLfixed y;
} glRasterPos2xOES_ARGS;
typedef struct {
    int index;
    glRasterPos2xOES_ARGS args;
} glRasterPos2xOES_PACKED;
#endif
#ifndef glRasterPos2xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glRasterPos2xvOES_ARGS;
typedef struct {
    int index;
    glRasterPos2xvOES_ARGS args;
} glRasterPos2xvOES_PACKED;
#endif
#ifndef glRasterPos3d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glRasterPos3d_ARGS;
typedef struct {
    int index;
    glRasterPos3d_ARGS args;
} glRasterPos3d_PACKED;
#endif
#ifndef glRasterPos3dv_RETURN
typedef struct {
    GLdouble * v;
} glRasterPos3dv_ARGS;
typedef struct {
    int index;
    glRasterPos3dv_ARGS args;
} glRasterPos3dv_PACKED;
#endif
#ifndef glRasterPos3f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glRasterPos3f_ARGS;
typedef struct {
    int index;
    glRasterPos3f_ARGS args;
} glRasterPos3f_PACKED;
#endif
#ifndef glRasterPos3fv_RETURN
typedef struct {
    GLfloat * v;
} glRasterPos3fv_ARGS;
typedef struct {
    int index;
    glRasterPos3fv_ARGS args;
} glRasterPos3fv_PACKED;
#endif
#ifndef glRasterPos3i_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} glRasterPos3i_ARGS;
typedef struct {
    int index;
    glRasterPos3i_ARGS args;
} glRasterPos3i_PACKED;
#endif
#ifndef glRasterPos3iv_RETURN
typedef struct {
    GLint * v;
} glRasterPos3iv_ARGS;
typedef struct {
    int index;
    glRasterPos3iv_ARGS args;
} glRasterPos3iv_PACKED;
#endif
#ifndef glRasterPos3s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} glRasterPos3s_ARGS;
typedef struct {
    int index;
    glRasterPos3s_ARGS args;
} glRasterPos3s_PACKED;
#endif
#ifndef glRasterPos3sv_RETURN
typedef struct {
    GLshort * v;
} glRasterPos3sv_ARGS;
typedef struct {
    int index;
    glRasterPos3sv_ARGS args;
} glRasterPos3sv_PACKED;
#endif
#ifndef glRasterPos3xOES_RETURN
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} glRasterPos3xOES_ARGS;
typedef struct {
    int index;
    glRasterPos3xOES_ARGS args;
} glRasterPos3xOES_PACKED;
#endif
#ifndef glRasterPos3xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glRasterPos3xvOES_ARGS;
typedef struct {
    int index;
    glRasterPos3xvOES_ARGS args;
} glRasterPos3xvOES_PACKED;
#endif
#ifndef glRasterPos4d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glRasterPos4d_ARGS;
typedef struct {
    int index;
    glRasterPos4d_ARGS args;
} glRasterPos4d_PACKED;
#endif
#ifndef glRasterPos4dv_RETURN
typedef struct {
    GLdouble * v;
} glRasterPos4dv_ARGS;
typedef struct {
    int index;
    glRasterPos4dv_ARGS args;
} glRasterPos4dv_PACKED;
#endif
#ifndef glRasterPos4f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glRasterPos4f_ARGS;
typedef struct {
    int index;
    glRasterPos4f_ARGS args;
} glRasterPos4f_PACKED;
#endif
#ifndef glRasterPos4fv_RETURN
typedef struct {
    GLfloat * v;
} glRasterPos4fv_ARGS;
typedef struct {
    int index;
    glRasterPos4fv_ARGS args;
} glRasterPos4fv_PACKED;
#endif
#ifndef glRasterPos4i_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glRasterPos4i_ARGS;
typedef struct {
    int index;
    glRasterPos4i_ARGS args;
} glRasterPos4i_PACKED;
#endif
#ifndef glRasterPos4iv_RETURN
typedef struct {
    GLint * v;
} glRasterPos4iv_ARGS;
typedef struct {
    int index;
    glRasterPos4iv_ARGS args;
} glRasterPos4iv_PACKED;
#endif
#ifndef glRasterPos4s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} glRasterPos4s_ARGS;
typedef struct {
    int index;
    glRasterPos4s_ARGS args;
} glRasterPos4s_PACKED;
#endif
#ifndef glRasterPos4sv_RETURN
typedef struct {
    GLshort * v;
} glRasterPos4sv_ARGS;
typedef struct {
    int index;
    glRasterPos4sv_ARGS args;
} glRasterPos4sv_PACKED;
#endif
#ifndef glRasterPos4xOES_RETURN
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
    GLfixed w;
} glRasterPos4xOES_ARGS;
typedef struct {
    int index;
    glRasterPos4xOES_ARGS args;
} glRasterPos4xOES_PACKED;
#endif
#ifndef glRasterPos4xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glRasterPos4xvOES_ARGS;
typedef struct {
    int index;
    glRasterPos4xvOES_ARGS args;
} glRasterPos4xvOES_PACKED;
#endif
#ifndef glReadBuffer_RETURN
typedef struct {
    GLenum mode;
} glReadBuffer_ARGS;
typedef struct {
    int index;
    glReadBuffer_ARGS args;
} glReadBuffer_PACKED;
#endif
#ifndef glReadInstrumentsSGIX_RETURN
typedef struct {
    GLint marker;
} glReadInstrumentsSGIX_ARGS;
typedef struct {
    int index;
    glReadInstrumentsSGIX_ARGS args;
} glReadInstrumentsSGIX_PACKED;
#endif
#ifndef glReadPixels_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glReadPixels_ARGS;
typedef struct {
    int index;
    glReadPixels_ARGS args;
} glReadPixels_PACKED;
#endif
#ifndef glReadnPixelsARB_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * data;
} glReadnPixelsARB_ARGS;
typedef struct {
    int index;
    glReadnPixelsARB_ARGS args;
} glReadnPixelsARB_PACKED;
#endif
#ifndef glRectd_RETURN
typedef struct {
    GLdouble x1 __attribute__ ((aligned(8)));
    GLdouble y1 __attribute__ ((aligned(8)));
    GLdouble x2 __attribute__ ((aligned(8)));
    GLdouble y2 __attribute__ ((aligned(8)));
} glRectd_ARGS;
typedef struct {
    int index;
    glRectd_ARGS args;
} glRectd_PACKED;
#endif
#ifndef glRectdv_RETURN
typedef struct {
    GLdouble * v1;
    GLdouble * v2;
} glRectdv_ARGS;
typedef struct {
    int index;
    glRectdv_ARGS args;
} glRectdv_PACKED;
#endif
#ifndef glRectf_RETURN
typedef struct {
    GLfloat x1;
    GLfloat y1;
    GLfloat x2;
    GLfloat y2;
} glRectf_ARGS;
typedef struct {
    int index;
    glRectf_ARGS args;
} glRectf_PACKED;
#endif
#ifndef glRectfv_RETURN
typedef struct {
    GLfloat * v1;
    GLfloat * v2;
} glRectfv_ARGS;
typedef struct {
    int index;
    glRectfv_ARGS args;
} glRectfv_PACKED;
#endif
#ifndef glRecti_RETURN
typedef struct {
    GLint x1;
    GLint y1;
    GLint x2;
    GLint y2;
} glRecti_ARGS;
typedef struct {
    int index;
    glRecti_ARGS args;
} glRecti_PACKED;
#endif
#ifndef glRectiv_RETURN
typedef struct {
    GLint * v1;
    GLint * v2;
} glRectiv_ARGS;
typedef struct {
    int index;
    glRectiv_ARGS args;
} glRectiv_PACKED;
#endif
#ifndef glRects_RETURN
typedef struct {
    GLshort x1;
    GLshort y1;
    GLshort x2;
    GLshort y2;
} glRects_ARGS;
typedef struct {
    int index;
    glRects_ARGS args;
} glRects_PACKED;
#endif
#ifndef glRectsv_RETURN
typedef struct {
    GLshort * v1;
    GLshort * v2;
} glRectsv_ARGS;
typedef struct {
    int index;
    glRectsv_ARGS args;
} glRectsv_PACKED;
#endif
#ifndef glRectxOES_RETURN
typedef struct {
    GLfixed x1;
    GLfixed y1;
    GLfixed x2;
    GLfixed y2;
} glRectxOES_ARGS;
typedef struct {
    int index;
    glRectxOES_ARGS args;
} glRectxOES_PACKED;
#endif
#ifndef glRectxvOES_RETURN
typedef struct {
    GLfixed * v1;
    GLfixed * v2;
} glRectxvOES_ARGS;
typedef struct {
    int index;
    glRectxvOES_ARGS args;
} glRectxvOES_PACKED;
#endif
#ifndef glReferencePlaneSGIX_RETURN
typedef struct {
    GLdouble * equation;
} glReferencePlaneSGIX_ARGS;
typedef struct {
    int index;
    glReferencePlaneSGIX_ARGS args;
} glReferencePlaneSGIX_PACKED;
#endif
#ifndef glReleaseShaderCompiler_RETURN
typedef struct {
    int index;
} glReleaseShaderCompiler_PACKED;
#endif
#ifndef glRenderMode_RETURN
typedef struct {
    GLenum mode;
} glRenderMode_ARGS;
typedef struct {
    int index;
    glRenderMode_ARGS args;
} glRenderMode_PACKED;
#endif
#ifndef glRenderbufferStorage_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glRenderbufferStorage_ARGS;
typedef struct {
    int index;
    glRenderbufferStorage_ARGS args;
} glRenderbufferStorage_PACKED;
#endif
#ifndef glRenderbufferStorageEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glRenderbufferStorageEXT_ARGS;
typedef struct {
    int index;
    glRenderbufferStorageEXT_ARGS args;
} glRenderbufferStorageEXT_PACKED;
#endif
#ifndef glRenderbufferStorageMultisample_RETURN
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glRenderbufferStorageMultisample_ARGS;
typedef struct {
    int index;
    glRenderbufferStorageMultisample_ARGS args;
} glRenderbufferStorageMultisample_PACKED;
#endif
#ifndef glRenderbufferStorageMultisampleCoverageNV_RETURN
typedef struct {
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glRenderbufferStorageMultisampleCoverageNV_ARGS;
typedef struct {
    int index;
    glRenderbufferStorageMultisampleCoverageNV_ARGS args;
} glRenderbufferStorageMultisampleCoverageNV_PACKED;
#endif
#ifndef glRenderbufferStorageMultisampleEXT_RETURN
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glRenderbufferStorageMultisampleEXT_ARGS;
typedef struct {
    int index;
    glRenderbufferStorageMultisampleEXT_ARGS args;
} glRenderbufferStorageMultisampleEXT_PACKED;
#endif
#ifndef glReplacementCodePointerSUN_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glReplacementCodePointerSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodePointerSUN_ARGS args;
} glReplacementCodePointerSUN_PACKED;
#endif
#ifndef glReplacementCodeubSUN_RETURN
typedef struct {
    GLubyte code;
} glReplacementCodeubSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeubSUN_ARGS args;
} glReplacementCodeubSUN_PACKED;
#endif
#ifndef glReplacementCodeubvSUN_RETURN
typedef struct {
    GLubyte * code;
} glReplacementCodeubvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeubvSUN_ARGS args;
} glReplacementCodeubvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiColor3fVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiColor3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiColor3fVertex3fSUN_ARGS args;
} glReplacementCodeuiColor3fVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiColor3fVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLfloat * c;
    GLfloat * v;
} glReplacementCodeuiColor3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiColor3fVertex3fvSUN_ARGS args;
} glReplacementCodeuiColor3fVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiColor4fNormal3fVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARGS args;
} glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiColor4fNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARGS args;
} glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiColor4ubVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiColor4ubVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiColor4ubVertex3fSUN_ARGS args;
} glReplacementCodeuiColor4ubVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiColor4ubVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLubyte * c;
    GLfloat * v;
} glReplacementCodeuiColor4ubVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiColor4ubVertex3fvSUN_ARGS args;
} glReplacementCodeuiColor4ubVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiNormal3fVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiNormal3fVertex3fSUN_ARGS args;
} glReplacementCodeuiNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLfloat * n;
    GLfloat * v;
} glReplacementCodeuiNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiNormal3fVertex3fvSUN_ARGS args;
} glReplacementCodeuiNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiSUN_RETURN
typedef struct {
    GLuint code;
} glReplacementCodeuiSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiSUN_ARGS args;
} glReplacementCodeuiSUN_PACKED;
#endif
#ifndef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARGS args;
} glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLfloat * tc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS args;
} glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLfloat s;
    GLfloat t;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARGS args;
} glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLfloat * tc;
    GLfloat * n;
    GLfloat * v;
} glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARGS args;
} glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiTexCoord2fVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLfloat s;
    GLfloat t;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiTexCoord2fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiTexCoord2fVertex3fSUN_ARGS args;
} glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiTexCoord2fVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLfloat * tc;
    GLfloat * v;
} glReplacementCodeuiTexCoord2fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiTexCoord2fVertex3fvSUN_ARGS args;
} glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuiVertex3fSUN_RETURN
typedef struct {
    GLuint rc;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glReplacementCodeuiVertex3fSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiVertex3fSUN_ARGS args;
} glReplacementCodeuiVertex3fSUN_PACKED;
#endif
#ifndef glReplacementCodeuiVertex3fvSUN_RETURN
typedef struct {
    GLuint * rc;
    GLfloat * v;
} glReplacementCodeuiVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuiVertex3fvSUN_ARGS args;
} glReplacementCodeuiVertex3fvSUN_PACKED;
#endif
#ifndef glReplacementCodeuivSUN_RETURN
typedef struct {
    GLuint * code;
} glReplacementCodeuivSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeuivSUN_ARGS args;
} glReplacementCodeuivSUN_PACKED;
#endif
#ifndef glReplacementCodeusSUN_RETURN
typedef struct {
    GLushort code;
} glReplacementCodeusSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeusSUN_ARGS args;
} glReplacementCodeusSUN_PACKED;
#endif
#ifndef glReplacementCodeusvSUN_RETURN
typedef struct {
    GLushort * code;
} glReplacementCodeusvSUN_ARGS;
typedef struct {
    int index;
    glReplacementCodeusvSUN_ARGS args;
} glReplacementCodeusvSUN_PACKED;
#endif
#ifndef glRequestResidentProgramsNV_RETURN
typedef struct {
    GLsizei n;
    GLuint * programs;
} glRequestResidentProgramsNV_ARGS;
typedef struct {
    int index;
    glRequestResidentProgramsNV_ARGS args;
} glRequestResidentProgramsNV_PACKED;
#endif
#ifndef glResetHistogram_RETURN
typedef struct {
    GLenum target;
} glResetHistogram_ARGS;
typedef struct {
    int index;
    glResetHistogram_ARGS args;
} glResetHistogram_PACKED;
#endif
#ifndef glResetHistogramEXT_RETURN
typedef struct {
    GLenum target;
} glResetHistogramEXT_ARGS;
typedef struct {
    int index;
    glResetHistogramEXT_ARGS args;
} glResetHistogramEXT_PACKED;
#endif
#ifndef glResetMinmax_RETURN
typedef struct {
    GLenum target;
} glResetMinmax_ARGS;
typedef struct {
    int index;
    glResetMinmax_ARGS args;
} glResetMinmax_PACKED;
#endif
#ifndef glResetMinmaxEXT_RETURN
typedef struct {
    GLenum target;
} glResetMinmaxEXT_ARGS;
typedef struct {
    int index;
    glResetMinmaxEXT_ARGS args;
} glResetMinmaxEXT_PACKED;
#endif
#ifndef glResizeBuffersMESA_RETURN
typedef struct {
    int index;
} glResizeBuffersMESA_PACKED;
#endif
#ifndef glResumeTransformFeedback_RETURN
typedef struct {
    int index;
} glResumeTransformFeedback_PACKED;
#endif
#ifndef glResumeTransformFeedbackNV_RETURN
typedef struct {
    int index;
} glResumeTransformFeedbackNV_PACKED;
#endif
#ifndef glRotated_RETURN
typedef struct {
    GLdouble angle __attribute__ ((aligned(8)));
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glRotated_ARGS;
typedef struct {
    int index;
    glRotated_ARGS args;
} glRotated_PACKED;
#endif
#ifndef glRotatef_RETURN
typedef struct {
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glRotatef_ARGS;
typedef struct {
    int index;
    glRotatef_ARGS args;
} glRotatef_PACKED;
#endif
#ifndef glRotatexOES_RETURN
typedef struct {
    GLfixed angle;
    GLfixed x;
    GLfixed y;
    GLfixed z;
} glRotatexOES_ARGS;
typedef struct {
    int index;
    glRotatexOES_ARGS args;
} glRotatexOES_PACKED;
#endif
#ifndef glSampleCoverage_RETURN
typedef struct {
    GLfloat value;
    GLboolean invert;
} glSampleCoverage_ARGS;
typedef struct {
    int index;
    glSampleCoverage_ARGS args;
} glSampleCoverage_PACKED;
#endif
#ifndef glSampleCoverageARB_RETURN
typedef struct {
    GLfloat value;
    GLboolean invert;
} glSampleCoverageARB_ARGS;
typedef struct {
    int index;
    glSampleCoverageARB_ARGS args;
} glSampleCoverageARB_PACKED;
#endif
#ifndef glSampleCoverageOES_RETURN
typedef struct {
    GLfixed value;
    GLboolean invert;
} glSampleCoverageOES_ARGS;
typedef struct {
    int index;
    glSampleCoverageOES_ARGS args;
} glSampleCoverageOES_PACKED;
#endif
#ifndef glSampleMapATI_RETURN
typedef struct {
    GLuint dst;
    GLuint interp;
    GLenum swizzle;
} glSampleMapATI_ARGS;
typedef struct {
    int index;
    glSampleMapATI_ARGS args;
} glSampleMapATI_PACKED;
#endif
#ifndef glSampleMaskEXT_RETURN
typedef struct {
    GLclampf value;
    GLboolean invert;
} glSampleMaskEXT_ARGS;
typedef struct {
    int index;
    glSampleMaskEXT_ARGS args;
} glSampleMaskEXT_PACKED;
#endif
#ifndef glSampleMaskIndexedNV_RETURN
typedef struct {
    GLuint index;
    GLbitfield mask;
} glSampleMaskIndexedNV_ARGS;
typedef struct {
    int index;
    glSampleMaskIndexedNV_ARGS args;
} glSampleMaskIndexedNV_PACKED;
#endif
#ifndef glSampleMaskSGIS_RETURN
typedef struct {
    GLclampf value;
    GLboolean invert;
} glSampleMaskSGIS_ARGS;
typedef struct {
    int index;
    glSampleMaskSGIS_ARGS args;
} glSampleMaskSGIS_PACKED;
#endif
#ifndef glSampleMaski_RETURN
typedef struct {
    GLuint index;
    GLbitfield mask;
} glSampleMaski_ARGS;
typedef struct {
    int index;
    glSampleMaski_ARGS args;
} glSampleMaski_PACKED;
#endif
#ifndef glSamplePatternEXT_RETURN
typedef struct {
    GLenum pattern;
} glSamplePatternEXT_ARGS;
typedef struct {
    int index;
    glSamplePatternEXT_ARGS args;
} glSamplePatternEXT_PACKED;
#endif
#ifndef glSamplePatternSGIS_RETURN
typedef struct {
    GLenum pattern;
} glSamplePatternSGIS_ARGS;
typedef struct {
    int index;
    glSamplePatternSGIS_ARGS args;
} glSamplePatternSGIS_PACKED;
#endif
#ifndef glSamplerParameterIiv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * param;
} glSamplerParameterIiv_ARGS;
typedef struct {
    int index;
    glSamplerParameterIiv_ARGS args;
} glSamplerParameterIiv_PACKED;
#endif
#ifndef glSamplerParameterIuiv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLuint * param;
} glSamplerParameterIuiv_ARGS;
typedef struct {
    int index;
    glSamplerParameterIuiv_ARGS args;
} glSamplerParameterIuiv_PACKED;
#endif
#ifndef glSamplerParameterf_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLfloat param;
} glSamplerParameterf_ARGS;
typedef struct {
    int index;
    glSamplerParameterf_ARGS args;
} glSamplerParameterf_PACKED;
#endif
#ifndef glSamplerParameterfv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLfloat * param;
} glSamplerParameterfv_ARGS;
typedef struct {
    int index;
    glSamplerParameterfv_ARGS args;
} glSamplerParameterfv_PACKED;
#endif
#ifndef glSamplerParameteri_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint param;
} glSamplerParameteri_ARGS;
typedef struct {
    int index;
    glSamplerParameteri_ARGS args;
} glSamplerParameteri_PACKED;
#endif
#ifndef glSamplerParameteriv_RETURN
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * param;
} glSamplerParameteriv_ARGS;
typedef struct {
    int index;
    glSamplerParameteriv_ARGS args;
} glSamplerParameteriv_PACKED;
#endif
#ifndef glScaled_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glScaled_ARGS;
typedef struct {
    int index;
    glScaled_ARGS args;
} glScaled_PACKED;
#endif
#ifndef glScalef_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glScalef_ARGS;
typedef struct {
    int index;
    glScalef_ARGS args;
} glScalef_PACKED;
#endif
#ifndef glScalexOES_RETURN
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} glScalexOES_ARGS;
typedef struct {
    int index;
    glScalexOES_ARGS args;
} glScalexOES_PACKED;
#endif
#ifndef glScissor_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glScissor_ARGS;
typedef struct {
    int index;
    glScissor_ARGS args;
} glScissor_PACKED;
#endif
#ifndef glScissorArrayv_RETURN
typedef struct {
    GLuint first;
    GLsizei count;
    GLint * v;
} glScissorArrayv_ARGS;
typedef struct {
    int index;
    glScissorArrayv_ARGS args;
} glScissorArrayv_PACKED;
#endif
#ifndef glScissorIndexed_RETURN
typedef struct {
    GLuint index;
    GLint left;
    GLint bottom;
    GLsizei width;
    GLsizei height;
} glScissorIndexed_ARGS;
typedef struct {
    int index;
    glScissorIndexed_ARGS args;
} glScissorIndexed_PACKED;
#endif
#ifndef glScissorIndexedv_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glScissorIndexedv_ARGS;
typedef struct {
    int index;
    glScissorIndexedv_ARGS args;
} glScissorIndexedv_PACKED;
#endif
#ifndef glSecondaryColor3b_RETURN
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
} glSecondaryColor3b_ARGS;
typedef struct {
    int index;
    glSecondaryColor3b_ARGS args;
} glSecondaryColor3b_PACKED;
#endif
#ifndef glSecondaryColor3bEXT_RETURN
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
} glSecondaryColor3bEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3bEXT_ARGS args;
} glSecondaryColor3bEXT_PACKED;
#endif
#ifndef glSecondaryColor3bv_RETURN
typedef struct {
    GLbyte * v;
} glSecondaryColor3bv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3bv_ARGS args;
} glSecondaryColor3bv_PACKED;
#endif
#ifndef glSecondaryColor3bvEXT_RETURN
typedef struct {
    GLbyte * v;
} glSecondaryColor3bvEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3bvEXT_ARGS args;
} glSecondaryColor3bvEXT_PACKED;
#endif
#ifndef glSecondaryColor3d_RETURN
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
} glSecondaryColor3d_ARGS;
typedef struct {
    int index;
    glSecondaryColor3d_ARGS args;
} glSecondaryColor3d_PACKED;
#endif
#ifndef glSecondaryColor3dEXT_RETURN
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
} glSecondaryColor3dEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3dEXT_ARGS args;
} glSecondaryColor3dEXT_PACKED;
#endif
#ifndef glSecondaryColor3dv_RETURN
typedef struct {
    GLdouble * v;
} glSecondaryColor3dv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3dv_ARGS args;
} glSecondaryColor3dv_PACKED;
#endif
#ifndef glSecondaryColor3dvEXT_RETURN
typedef struct {
    GLdouble * v;
} glSecondaryColor3dvEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3dvEXT_ARGS args;
} glSecondaryColor3dvEXT_PACKED;
#endif
#ifndef glSecondaryColor3f_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
} glSecondaryColor3f_ARGS;
typedef struct {
    int index;
    glSecondaryColor3f_ARGS args;
} glSecondaryColor3f_PACKED;
#endif
#ifndef glSecondaryColor3fEXT_RETURN
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
} glSecondaryColor3fEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3fEXT_ARGS args;
} glSecondaryColor3fEXT_PACKED;
#endif
#ifndef glSecondaryColor3fv_RETURN
typedef struct {
    GLfloat * v;
} glSecondaryColor3fv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3fv_ARGS args;
} glSecondaryColor3fv_PACKED;
#endif
#ifndef glSecondaryColor3fvEXT_RETURN
typedef struct {
    GLfloat * v;
} glSecondaryColor3fvEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3fvEXT_ARGS args;
} glSecondaryColor3fvEXT_PACKED;
#endif
#ifndef glSecondaryColor3hNV_RETURN
typedef struct {
    GLhalfNV red;
    GLhalfNV green;
    GLhalfNV blue;
} glSecondaryColor3hNV_ARGS;
typedef struct {
    int index;
    glSecondaryColor3hNV_ARGS args;
} glSecondaryColor3hNV_PACKED;
#endif
#ifndef glSecondaryColor3hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glSecondaryColor3hvNV_ARGS;
typedef struct {
    int index;
    glSecondaryColor3hvNV_ARGS args;
} glSecondaryColor3hvNV_PACKED;
#endif
#ifndef glSecondaryColor3i_RETURN
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
} glSecondaryColor3i_ARGS;
typedef struct {
    int index;
    glSecondaryColor3i_ARGS args;
} glSecondaryColor3i_PACKED;
#endif
#ifndef glSecondaryColor3iEXT_RETURN
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
} glSecondaryColor3iEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3iEXT_ARGS args;
} glSecondaryColor3iEXT_PACKED;
#endif
#ifndef glSecondaryColor3iv_RETURN
typedef struct {
    GLint * v;
} glSecondaryColor3iv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3iv_ARGS args;
} glSecondaryColor3iv_PACKED;
#endif
#ifndef glSecondaryColor3ivEXT_RETURN
typedef struct {
    GLint * v;
} glSecondaryColor3ivEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3ivEXT_ARGS args;
} glSecondaryColor3ivEXT_PACKED;
#endif
#ifndef glSecondaryColor3s_RETURN
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
} glSecondaryColor3s_ARGS;
typedef struct {
    int index;
    glSecondaryColor3s_ARGS args;
} glSecondaryColor3s_PACKED;
#endif
#ifndef glSecondaryColor3sEXT_RETURN
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
} glSecondaryColor3sEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3sEXT_ARGS args;
} glSecondaryColor3sEXT_PACKED;
#endif
#ifndef glSecondaryColor3sv_RETURN
typedef struct {
    GLshort * v;
} glSecondaryColor3sv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3sv_ARGS args;
} glSecondaryColor3sv_PACKED;
#endif
#ifndef glSecondaryColor3svEXT_RETURN
typedef struct {
    GLshort * v;
} glSecondaryColor3svEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3svEXT_ARGS args;
} glSecondaryColor3svEXT_PACKED;
#endif
#ifndef glSecondaryColor3ub_RETURN
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
} glSecondaryColor3ub_ARGS;
typedef struct {
    int index;
    glSecondaryColor3ub_ARGS args;
} glSecondaryColor3ub_PACKED;
#endif
#ifndef glSecondaryColor3ubEXT_RETURN
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
} glSecondaryColor3ubEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3ubEXT_ARGS args;
} glSecondaryColor3ubEXT_PACKED;
#endif
#ifndef glSecondaryColor3ubv_RETURN
typedef struct {
    GLubyte * v;
} glSecondaryColor3ubv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3ubv_ARGS args;
} glSecondaryColor3ubv_PACKED;
#endif
#ifndef glSecondaryColor3ubvEXT_RETURN
typedef struct {
    GLubyte * v;
} glSecondaryColor3ubvEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3ubvEXT_ARGS args;
} glSecondaryColor3ubvEXT_PACKED;
#endif
#ifndef glSecondaryColor3ui_RETURN
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
} glSecondaryColor3ui_ARGS;
typedef struct {
    int index;
    glSecondaryColor3ui_ARGS args;
} glSecondaryColor3ui_PACKED;
#endif
#ifndef glSecondaryColor3uiEXT_RETURN
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
} glSecondaryColor3uiEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3uiEXT_ARGS args;
} glSecondaryColor3uiEXT_PACKED;
#endif
#ifndef glSecondaryColor3uiv_RETURN
typedef struct {
    GLuint * v;
} glSecondaryColor3uiv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3uiv_ARGS args;
} glSecondaryColor3uiv_PACKED;
#endif
#ifndef glSecondaryColor3uivEXT_RETURN
typedef struct {
    GLuint * v;
} glSecondaryColor3uivEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3uivEXT_ARGS args;
} glSecondaryColor3uivEXT_PACKED;
#endif
#ifndef glSecondaryColor3us_RETURN
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
} glSecondaryColor3us_ARGS;
typedef struct {
    int index;
    glSecondaryColor3us_ARGS args;
} glSecondaryColor3us_PACKED;
#endif
#ifndef glSecondaryColor3usEXT_RETURN
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
} glSecondaryColor3usEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3usEXT_ARGS args;
} glSecondaryColor3usEXT_PACKED;
#endif
#ifndef glSecondaryColor3usv_RETURN
typedef struct {
    GLushort * v;
} glSecondaryColor3usv_ARGS;
typedef struct {
    int index;
    glSecondaryColor3usv_ARGS args;
} glSecondaryColor3usv_PACKED;
#endif
#ifndef glSecondaryColor3usvEXT_RETURN
typedef struct {
    GLushort * v;
} glSecondaryColor3usvEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColor3usvEXT_ARGS args;
} glSecondaryColor3usvEXT_PACKED;
#endif
#ifndef glSecondaryColorFormatNV_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} glSecondaryColorFormatNV_ARGS;
typedef struct {
    int index;
    glSecondaryColorFormatNV_ARGS args;
} glSecondaryColorFormatNV_PACKED;
#endif
#ifndef glSecondaryColorP3ui_RETURN
typedef struct {
    GLenum type;
    GLuint color;
} glSecondaryColorP3ui_ARGS;
typedef struct {
    int index;
    glSecondaryColorP3ui_ARGS args;
} glSecondaryColorP3ui_PACKED;
#endif
#ifndef glSecondaryColorP3uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * color;
} glSecondaryColorP3uiv_ARGS;
typedef struct {
    int index;
    glSecondaryColorP3uiv_ARGS args;
} glSecondaryColorP3uiv_PACKED;
#endif
#ifndef glSecondaryColorPointer_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glSecondaryColorPointer_ARGS;
typedef struct {
    int index;
    glSecondaryColorPointer_ARGS args;
} glSecondaryColorPointer_PACKED;
#endif
#ifndef glSecondaryColorPointerEXT_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glSecondaryColorPointerEXT_ARGS;
typedef struct {
    int index;
    glSecondaryColorPointerEXT_ARGS args;
} glSecondaryColorPointerEXT_PACKED;
#endif
#ifndef glSecondaryColorPointerListIBM_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} glSecondaryColorPointerListIBM_ARGS;
typedef struct {
    int index;
    glSecondaryColorPointerListIBM_ARGS args;
} glSecondaryColorPointerListIBM_PACKED;
#endif
#ifndef glSelectBuffer_RETURN
typedef struct {
    GLsizei size;
    GLuint * buffer;
} glSelectBuffer_ARGS;
typedef struct {
    int index;
    glSelectBuffer_ARGS args;
} glSelectBuffer_PACKED;
#endif
#ifndef glSelectPerfMonitorCountersAMD_RETURN
typedef struct {
    GLuint monitor;
    GLboolean enable;
    GLuint group;
    GLint numCounters;
    GLuint * counterList;
} glSelectPerfMonitorCountersAMD_ARGS;
typedef struct {
    int index;
    glSelectPerfMonitorCountersAMD_ARGS args;
} glSelectPerfMonitorCountersAMD_PACKED;
#endif
#ifndef glSeparableFilter2D_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
} glSeparableFilter2D_ARGS;
typedef struct {
    int index;
    glSeparableFilter2D_ARGS args;
} glSeparableFilter2D_PACKED;
#endif
#ifndef glSeparableFilter2DEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
} glSeparableFilter2DEXT_ARGS;
typedef struct {
    int index;
    glSeparableFilter2DEXT_ARGS args;
} glSeparableFilter2DEXT_PACKED;
#endif
#ifndef glSetFenceAPPLE_RETURN
typedef struct {
    GLuint fence;
} glSetFenceAPPLE_ARGS;
typedef struct {
    int index;
    glSetFenceAPPLE_ARGS args;
} glSetFenceAPPLE_PACKED;
#endif
#ifndef glSetFenceNV_RETURN
typedef struct {
    GLuint fence;
    GLenum condition;
} glSetFenceNV_ARGS;
typedef struct {
    int index;
    glSetFenceNV_ARGS args;
} glSetFenceNV_PACKED;
#endif
#ifndef glSetFragmentShaderConstantATI_RETURN
typedef struct {
    GLuint dst;
    GLfloat * value;
} glSetFragmentShaderConstantATI_ARGS;
typedef struct {
    int index;
    glSetFragmentShaderConstantATI_ARGS args;
} glSetFragmentShaderConstantATI_PACKED;
#endif
#ifndef glSetInvariantEXT_RETURN
typedef struct {
    GLuint id;
    GLenum type;
    GLvoid * addr;
} glSetInvariantEXT_ARGS;
typedef struct {
    int index;
    glSetInvariantEXT_ARGS args;
} glSetInvariantEXT_PACKED;
#endif
#ifndef glSetLocalConstantEXT_RETURN
typedef struct {
    GLuint id;
    GLenum type;
    GLvoid * addr;
} glSetLocalConstantEXT_ARGS;
typedef struct {
    int index;
    glSetLocalConstantEXT_ARGS args;
} glSetLocalConstantEXT_PACKED;
#endif
#ifndef glSetMultisamplefvAMD_RETURN
typedef struct {
    GLenum pname;
    GLuint index;
    GLfloat * val;
} glSetMultisamplefvAMD_ARGS;
typedef struct {
    int index;
    glSetMultisamplefvAMD_ARGS args;
} glSetMultisamplefvAMD_PACKED;
#endif
#ifndef glShadeModel_RETURN
typedef struct {
    GLenum mode;
} glShadeModel_ARGS;
typedef struct {
    int index;
    glShadeModel_ARGS args;
} glShadeModel_PACKED;
#endif
#ifndef glShaderBinary_RETURN
typedef struct {
    GLsizei count;
    GLuint * shaders;
    GLenum binaryformat;
    GLvoid * binary;
    GLsizei length;
} glShaderBinary_ARGS;
typedef struct {
    int index;
    glShaderBinary_ARGS args;
} glShaderBinary_PACKED;
#endif
#ifndef glShaderOp1EXT_RETURN
typedef struct {
    GLenum op;
    GLuint res;
    GLuint arg1;
} glShaderOp1EXT_ARGS;
typedef struct {
    int index;
    glShaderOp1EXT_ARGS args;
} glShaderOp1EXT_PACKED;
#endif
#ifndef glShaderOp2EXT_RETURN
typedef struct {
    GLenum op;
    GLuint res;
    GLuint arg1;
    GLuint arg2;
} glShaderOp2EXT_ARGS;
typedef struct {
    int index;
    glShaderOp2EXT_ARGS args;
} glShaderOp2EXT_PACKED;
#endif
#ifndef glShaderOp3EXT_RETURN
typedef struct {
    GLenum op;
    GLuint res;
    GLuint arg1;
    GLuint arg2;
    GLuint arg3;
} glShaderOp3EXT_ARGS;
typedef struct {
    int index;
    glShaderOp3EXT_ARGS args;
} glShaderOp3EXT_PACKED;
#endif
#ifndef glShaderSource_RETURN
typedef struct {
    GLuint shader;
    GLsizei count;
    GLchar * * string;
    GLint * length;
} glShaderSource_ARGS;
typedef struct {
    int index;
    glShaderSource_ARGS args;
} glShaderSource_PACKED;
#endif
#ifndef glShaderSourceARB_RETURN
typedef struct {
    GLhandleARB shaderObj;
    GLsizei count;
    GLcharARB * string;
    GLint * length;
} glShaderSourceARB_ARGS;
typedef struct {
    int index;
    glShaderSourceARB_ARGS args;
} glShaderSourceARB_PACKED;
#endif
#ifndef glShaderStorageBlockBinding_RETURN
typedef struct {
    GLuint program;
    GLuint storageBlockIndex;
    GLuint storageBlockBinding;
} glShaderStorageBlockBinding_ARGS;
typedef struct {
    int index;
    glShaderStorageBlockBinding_ARGS args;
} glShaderStorageBlockBinding_PACKED;
#endif
#ifndef glSharpenTexFuncSGIS_RETURN
typedef struct {
    GLenum target;
    GLsizei n;
    GLfloat * points;
} glSharpenTexFuncSGIS_ARGS;
typedef struct {
    int index;
    glSharpenTexFuncSGIS_ARGS args;
} glSharpenTexFuncSGIS_PACKED;
#endif
#ifndef glSpriteParameterfSGIX_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glSpriteParameterfSGIX_ARGS;
typedef struct {
    int index;
    glSpriteParameterfSGIX_ARGS args;
} glSpriteParameterfSGIX_PACKED;
#endif
#ifndef glSpriteParameterfvSGIX_RETURN
typedef struct {
    GLenum pname;
    GLfloat * params;
} glSpriteParameterfvSGIX_ARGS;
typedef struct {
    int index;
    glSpriteParameterfvSGIX_ARGS args;
} glSpriteParameterfvSGIX_PACKED;
#endif
#ifndef glSpriteParameteriSGIX_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glSpriteParameteriSGIX_ARGS;
typedef struct {
    int index;
    glSpriteParameteriSGIX_ARGS args;
} glSpriteParameteriSGIX_PACKED;
#endif
#ifndef glSpriteParameterivSGIX_RETURN
typedef struct {
    GLenum pname;
    GLint * params;
} glSpriteParameterivSGIX_ARGS;
typedef struct {
    int index;
    glSpriteParameterivSGIX_ARGS args;
} glSpriteParameterivSGIX_PACKED;
#endif
#ifndef glStartInstrumentsSGIX_RETURN
typedef struct {
    int index;
} glStartInstrumentsSGIX_PACKED;
#endif
#ifndef glStencilClearTagEXT_RETURN
typedef struct {
    GLsizei stencilTagBits;
    GLuint stencilClearTag;
} glStencilClearTagEXT_ARGS;
typedef struct {
    int index;
    glStencilClearTagEXT_ARGS args;
} glStencilClearTagEXT_PACKED;
#endif
#ifndef glStencilFillPathInstancedNV_RETURN
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLenum fillMode;
    GLuint mask;
    GLenum transformType;
    GLfloat * transformValues;
} glStencilFillPathInstancedNV_ARGS;
typedef struct {
    int index;
    glStencilFillPathInstancedNV_ARGS args;
} glStencilFillPathInstancedNV_PACKED;
#endif
#ifndef glStencilFillPathNV_RETURN
typedef struct {
    GLuint path;
    GLenum fillMode;
    GLuint mask;
} glStencilFillPathNV_ARGS;
typedef struct {
    int index;
    glStencilFillPathNV_ARGS args;
} glStencilFillPathNV_PACKED;
#endif
#ifndef glStencilFunc_RETURN
typedef struct {
    GLenum func;
    GLint ref;
    GLuint mask;
} glStencilFunc_ARGS;
typedef struct {
    int index;
    glStencilFunc_ARGS args;
} glStencilFunc_PACKED;
#endif
#ifndef glStencilFuncSeparate_RETURN
typedef struct {
    GLenum face;
    GLenum func;
    GLint ref;
    GLuint mask;
} glStencilFuncSeparate_ARGS;
typedef struct {
    int index;
    glStencilFuncSeparate_ARGS args;
} glStencilFuncSeparate_PACKED;
#endif
#ifndef glStencilFuncSeparateATI_RETURN
typedef struct {
    GLenum frontfunc;
    GLenum backfunc;
    GLint ref;
    GLuint mask;
} glStencilFuncSeparateATI_ARGS;
typedef struct {
    int index;
    glStencilFuncSeparateATI_ARGS args;
} glStencilFuncSeparateATI_PACKED;
#endif
#ifndef glStencilMask_RETURN
typedef struct {
    GLuint mask;
} glStencilMask_ARGS;
typedef struct {
    int index;
    glStencilMask_ARGS args;
} glStencilMask_PACKED;
#endif
#ifndef glStencilMaskSeparate_RETURN
typedef struct {
    GLenum face;
    GLuint mask;
} glStencilMaskSeparate_ARGS;
typedef struct {
    int index;
    glStencilMaskSeparate_ARGS args;
} glStencilMaskSeparate_PACKED;
#endif
#ifndef glStencilOp_RETURN
typedef struct {
    GLenum fail;
    GLenum zfail;
    GLenum zpass;
} glStencilOp_ARGS;
typedef struct {
    int index;
    glStencilOp_ARGS args;
} glStencilOp_PACKED;
#endif
#ifndef glStencilOpSeparate_RETURN
typedef struct {
    GLenum face;
    GLenum sfail;
    GLenum dpfail;
    GLenum dppass;
} glStencilOpSeparate_ARGS;
typedef struct {
    int index;
    glStencilOpSeparate_ARGS args;
} glStencilOpSeparate_PACKED;
#endif
#ifndef glStencilOpSeparateATI_RETURN
typedef struct {
    GLenum face;
    GLenum sfail;
    GLenum dpfail;
    GLenum dppass;
} glStencilOpSeparateATI_ARGS;
typedef struct {
    int index;
    glStencilOpSeparateATI_ARGS args;
} glStencilOpSeparateATI_PACKED;
#endif
#ifndef glStencilOpValueAMD_RETURN
typedef struct {
    GLenum face;
    GLuint value;
} glStencilOpValueAMD_ARGS;
typedef struct {
    int index;
    glStencilOpValueAMD_ARGS args;
} glStencilOpValueAMD_PACKED;
#endif
#ifndef glStencilStrokePathInstancedNV_RETURN
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLint reference;
    GLuint mask;
    GLenum transformType;
    GLfloat * transformValues;
} glStencilStrokePathInstancedNV_ARGS;
typedef struct {
    int index;
    glStencilStrokePathInstancedNV_ARGS args;
} glStencilStrokePathInstancedNV_PACKED;
#endif
#ifndef glStencilStrokePathNV_RETURN
typedef struct {
    GLuint path;
    GLint reference;
    GLuint mask;
} glStencilStrokePathNV_ARGS;
typedef struct {
    int index;
    glStencilStrokePathNV_ARGS args;
} glStencilStrokePathNV_PACKED;
#endif
#ifndef glStopInstrumentsSGIX_RETURN
typedef struct {
    GLint marker;
} glStopInstrumentsSGIX_ARGS;
typedef struct {
    int index;
    glStopInstrumentsSGIX_ARGS args;
} glStopInstrumentsSGIX_PACKED;
#endif
#ifndef glStringMarkerGREMEDY_RETURN
typedef struct {
    GLsizei len;
    GLvoid * string;
} glStringMarkerGREMEDY_ARGS;
typedef struct {
    int index;
    glStringMarkerGREMEDY_ARGS args;
} glStringMarkerGREMEDY_PACKED;
#endif
#ifndef glSwizzleEXT_RETURN
typedef struct {
    GLuint res;
    GLuint in;
    GLenum outX;
    GLenum outY;
    GLenum outZ;
    GLenum outW;
} glSwizzleEXT_ARGS;
typedef struct {
    int index;
    glSwizzleEXT_ARGS args;
} glSwizzleEXT_PACKED;
#endif
#ifndef glSyncTextureINTEL_RETURN
typedef struct {
    GLuint texture;
} glSyncTextureINTEL_ARGS;
typedef struct {
    int index;
    glSyncTextureINTEL_ARGS args;
} glSyncTextureINTEL_PACKED;
#endif
#ifndef glTagSampleBufferSGIX_RETURN
typedef struct {
    int index;
} glTagSampleBufferSGIX_PACKED;
#endif
#ifndef glTangent3bEXT_RETURN
typedef struct {
    GLbyte tx;
    GLbyte ty;
    GLbyte tz;
} glTangent3bEXT_ARGS;
typedef struct {
    int index;
    glTangent3bEXT_ARGS args;
} glTangent3bEXT_PACKED;
#endif
#ifndef glTangent3bvEXT_RETURN
typedef struct {
    GLbyte * v;
} glTangent3bvEXT_ARGS;
typedef struct {
    int index;
    glTangent3bvEXT_ARGS args;
} glTangent3bvEXT_PACKED;
#endif
#ifndef glTangent3dEXT_RETURN
typedef struct {
    GLdouble tx __attribute__ ((aligned(8)));
    GLdouble ty __attribute__ ((aligned(8)));
    GLdouble tz __attribute__ ((aligned(8)));
} glTangent3dEXT_ARGS;
typedef struct {
    int index;
    glTangent3dEXT_ARGS args;
} glTangent3dEXT_PACKED;
#endif
#ifndef glTangent3dvEXT_RETURN
typedef struct {
    GLdouble * v;
} glTangent3dvEXT_ARGS;
typedef struct {
    int index;
    glTangent3dvEXT_ARGS args;
} glTangent3dvEXT_PACKED;
#endif
#ifndef glTangent3fEXT_RETURN
typedef struct {
    GLfloat tx;
    GLfloat ty;
    GLfloat tz;
} glTangent3fEXT_ARGS;
typedef struct {
    int index;
    glTangent3fEXT_ARGS args;
} glTangent3fEXT_PACKED;
#endif
#ifndef glTangent3fvEXT_RETURN
typedef struct {
    GLfloat * v;
} glTangent3fvEXT_ARGS;
typedef struct {
    int index;
    glTangent3fvEXT_ARGS args;
} glTangent3fvEXT_PACKED;
#endif
#ifndef glTangent3iEXT_RETURN
typedef struct {
    GLint tx;
    GLint ty;
    GLint tz;
} glTangent3iEXT_ARGS;
typedef struct {
    int index;
    glTangent3iEXT_ARGS args;
} glTangent3iEXT_PACKED;
#endif
#ifndef glTangent3ivEXT_RETURN
typedef struct {
    GLint * v;
} glTangent3ivEXT_ARGS;
typedef struct {
    int index;
    glTangent3ivEXT_ARGS args;
} glTangent3ivEXT_PACKED;
#endif
#ifndef glTangent3sEXT_RETURN
typedef struct {
    GLshort tx;
    GLshort ty;
    GLshort tz;
} glTangent3sEXT_ARGS;
typedef struct {
    int index;
    glTangent3sEXT_ARGS args;
} glTangent3sEXT_PACKED;
#endif
#ifndef glTangent3svEXT_RETURN
typedef struct {
    GLshort * v;
} glTangent3svEXT_ARGS;
typedef struct {
    int index;
    glTangent3svEXT_ARGS args;
} glTangent3svEXT_PACKED;
#endif
#ifndef glTangentPointerEXT_RETURN
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glTangentPointerEXT_ARGS;
typedef struct {
    int index;
    glTangentPointerEXT_ARGS args;
} glTangentPointerEXT_PACKED;
#endif
#ifndef glTbufferMask3DFX_RETURN
typedef struct {
    GLuint mask;
} glTbufferMask3DFX_ARGS;
typedef struct {
    int index;
    glTbufferMask3DFX_ARGS args;
} glTbufferMask3DFX_PACKED;
#endif
#ifndef glTessellationFactorAMD_RETURN
typedef struct {
    GLfloat factor;
} glTessellationFactorAMD_ARGS;
typedef struct {
    int index;
    glTessellationFactorAMD_ARGS args;
} glTessellationFactorAMD_PACKED;
#endif
#ifndef glTessellationModeAMD_RETURN
typedef struct {
    GLenum mode;
} glTessellationModeAMD_ARGS;
typedef struct {
    int index;
    glTessellationModeAMD_ARGS args;
} glTessellationModeAMD_PACKED;
#endif
#ifndef glTestFenceAPPLE_RETURN
typedef struct {
    GLuint fence;
} glTestFenceAPPLE_ARGS;
typedef struct {
    int index;
    glTestFenceAPPLE_ARGS args;
} glTestFenceAPPLE_PACKED;
#endif
#ifndef glTestFenceNV_RETURN
typedef struct {
    GLuint fence;
} glTestFenceNV_ARGS;
typedef struct {
    int index;
    glTestFenceNV_ARGS args;
} glTestFenceNV_PACKED;
#endif
#ifndef glTestObjectAPPLE_RETURN
typedef struct {
    GLenum object;
    GLuint name;
} glTestObjectAPPLE_ARGS;
typedef struct {
    int index;
    glTestObjectAPPLE_ARGS args;
} glTestObjectAPPLE_PACKED;
#endif
#ifndef glTexBuffer_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} glTexBuffer_ARGS;
typedef struct {
    int index;
    glTexBuffer_ARGS args;
} glTexBuffer_PACKED;
#endif
#ifndef glTexBufferARB_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} glTexBufferARB_ARGS;
typedef struct {
    int index;
    glTexBufferARB_ARGS args;
} glTexBufferARB_PACKED;
#endif
#ifndef glTexBufferEXT_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} glTexBufferEXT_ARGS;
typedef struct {
    int index;
    glTexBufferEXT_ARGS args;
} glTexBufferEXT_PACKED;
#endif
#ifndef glTexBufferRange_RETURN
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} glTexBufferRange_ARGS;
typedef struct {
    int index;
    glTexBufferRange_ARGS args;
} glTexBufferRange_PACKED;
#endif
#ifndef glTexBumpParameterfvATI_RETURN
typedef struct {
    GLenum pname;
    GLfloat * param;
} glTexBumpParameterfvATI_ARGS;
typedef struct {
    int index;
    glTexBumpParameterfvATI_ARGS args;
} glTexBumpParameterfvATI_PACKED;
#endif
#ifndef glTexBumpParameterivATI_RETURN
typedef struct {
    GLenum pname;
    GLint * param;
} glTexBumpParameterivATI_ARGS;
typedef struct {
    int index;
    glTexBumpParameterivATI_ARGS args;
} glTexBumpParameterivATI_PACKED;
#endif
#ifndef glTexCoord1bOES_RETURN
typedef struct {
    GLbyte s;
} glTexCoord1bOES_ARGS;
typedef struct {
    int index;
    glTexCoord1bOES_ARGS args;
} glTexCoord1bOES_PACKED;
#endif
#ifndef glTexCoord1bvOES_RETURN
typedef struct {
    GLbyte * coords;
} glTexCoord1bvOES_ARGS;
typedef struct {
    int index;
    glTexCoord1bvOES_ARGS args;
} glTexCoord1bvOES_PACKED;
#endif
#ifndef glTexCoord1d_RETURN
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
} glTexCoord1d_ARGS;
typedef struct {
    int index;
    glTexCoord1d_ARGS args;
} glTexCoord1d_PACKED;
#endif
#ifndef glTexCoord1dv_RETURN
typedef struct {
    GLdouble * v;
} glTexCoord1dv_ARGS;
typedef struct {
    int index;
    glTexCoord1dv_ARGS args;
} glTexCoord1dv_PACKED;
#endif
#ifndef glTexCoord1f_RETURN
typedef struct {
    GLfloat s;
} glTexCoord1f_ARGS;
typedef struct {
    int index;
    glTexCoord1f_ARGS args;
} glTexCoord1f_PACKED;
#endif
#ifndef glTexCoord1fv_RETURN
typedef struct {
    GLfloat * v;
} glTexCoord1fv_ARGS;
typedef struct {
    int index;
    glTexCoord1fv_ARGS args;
} glTexCoord1fv_PACKED;
#endif
#ifndef glTexCoord1hNV_RETURN
typedef struct {
    GLhalfNV s;
} glTexCoord1hNV_ARGS;
typedef struct {
    int index;
    glTexCoord1hNV_ARGS args;
} glTexCoord1hNV_PACKED;
#endif
#ifndef glTexCoord1hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glTexCoord1hvNV_ARGS;
typedef struct {
    int index;
    glTexCoord1hvNV_ARGS args;
} glTexCoord1hvNV_PACKED;
#endif
#ifndef glTexCoord1i_RETURN
typedef struct {
    GLint s;
} glTexCoord1i_ARGS;
typedef struct {
    int index;
    glTexCoord1i_ARGS args;
} glTexCoord1i_PACKED;
#endif
#ifndef glTexCoord1iv_RETURN
typedef struct {
    GLint * v;
} glTexCoord1iv_ARGS;
typedef struct {
    int index;
    glTexCoord1iv_ARGS args;
} glTexCoord1iv_PACKED;
#endif
#ifndef glTexCoord1s_RETURN
typedef struct {
    GLshort s;
} glTexCoord1s_ARGS;
typedef struct {
    int index;
    glTexCoord1s_ARGS args;
} glTexCoord1s_PACKED;
#endif
#ifndef glTexCoord1sv_RETURN
typedef struct {
    GLshort * v;
} glTexCoord1sv_ARGS;
typedef struct {
    int index;
    glTexCoord1sv_ARGS args;
} glTexCoord1sv_PACKED;
#endif
#ifndef glTexCoord1xOES_RETURN
typedef struct {
    GLfixed s;
} glTexCoord1xOES_ARGS;
typedef struct {
    int index;
    glTexCoord1xOES_ARGS args;
} glTexCoord1xOES_PACKED;
#endif
#ifndef glTexCoord1xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glTexCoord1xvOES_ARGS;
typedef struct {
    int index;
    glTexCoord1xvOES_ARGS args;
} glTexCoord1xvOES_PACKED;
#endif
#ifndef glTexCoord2bOES_RETURN
typedef struct {
    GLbyte s;
    GLbyte t;
} glTexCoord2bOES_ARGS;
typedef struct {
    int index;
    glTexCoord2bOES_ARGS args;
} glTexCoord2bOES_PACKED;
#endif
#ifndef glTexCoord2bvOES_RETURN
typedef struct {
    GLbyte * coords;
} glTexCoord2bvOES_ARGS;
typedef struct {
    int index;
    glTexCoord2bvOES_ARGS args;
} glTexCoord2bvOES_PACKED;
#endif
#ifndef glTexCoord2d_RETURN
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
} glTexCoord2d_ARGS;
typedef struct {
    int index;
    glTexCoord2d_ARGS args;
} glTexCoord2d_PACKED;
#endif
#ifndef glTexCoord2dv_RETURN
typedef struct {
    GLdouble * v;
} glTexCoord2dv_ARGS;
typedef struct {
    int index;
    glTexCoord2dv_ARGS args;
} glTexCoord2dv_PACKED;
#endif
#ifndef glTexCoord2f_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
} glTexCoord2f_ARGS;
typedef struct {
    int index;
    glTexCoord2f_ARGS args;
} glTexCoord2f_PACKED;
#endif
#ifndef glTexCoord2fColor3fVertex3fSUN_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glTexCoord2fColor3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fColor3fVertex3fSUN_ARGS args;
} glTexCoord2fColor3fVertex3fSUN_PACKED;
#endif
#ifndef glTexCoord2fColor3fVertex3fvSUN_RETURN
typedef struct {
    GLfloat * tc;
    GLfloat * c;
    GLfloat * v;
} glTexCoord2fColor3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fColor3fVertex3fvSUN_ARGS args;
} glTexCoord2fColor3fVertex3fvSUN_PACKED;
#endif
#ifndef glTexCoord2fColor4fNormal3fVertex3fSUN_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glTexCoord2fColor4fNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fColor4fNormal3fVertex3fSUN_ARGS args;
} glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLfloat * tc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} glTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS args;
} glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glTexCoord2fColor4ubVertex3fSUN_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glTexCoord2fColor4ubVertex3fSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fColor4ubVertex3fSUN_ARGS args;
} glTexCoord2fColor4ubVertex3fSUN_PACKED;
#endif
#ifndef glTexCoord2fColor4ubVertex3fvSUN_RETURN
typedef struct {
    GLfloat * tc;
    GLubyte * c;
    GLfloat * v;
} glTexCoord2fColor4ubVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fColor4ubVertex3fvSUN_ARGS args;
} glTexCoord2fColor4ubVertex3fvSUN_PACKED;
#endif
#ifndef glTexCoord2fNormal3fVertex3fSUN_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glTexCoord2fNormal3fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fNormal3fVertex3fSUN_ARGS args;
} glTexCoord2fNormal3fVertex3fSUN_PACKED;
#endif
#ifndef glTexCoord2fNormal3fVertex3fvSUN_RETURN
typedef struct {
    GLfloat * tc;
    GLfloat * n;
    GLfloat * v;
} glTexCoord2fNormal3fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fNormal3fVertex3fvSUN_ARGS args;
} glTexCoord2fNormal3fVertex3fvSUN_PACKED;
#endif
#ifndef glTexCoord2fVertex3fSUN_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glTexCoord2fVertex3fSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fVertex3fSUN_ARGS args;
} glTexCoord2fVertex3fSUN_PACKED;
#endif
#ifndef glTexCoord2fVertex3fvSUN_RETURN
typedef struct {
    GLfloat * tc;
    GLfloat * v;
} glTexCoord2fVertex3fvSUN_ARGS;
typedef struct {
    int index;
    glTexCoord2fVertex3fvSUN_ARGS args;
} glTexCoord2fVertex3fvSUN_PACKED;
#endif
#ifndef glTexCoord2fv_RETURN
typedef struct {
    GLfloat * v;
} glTexCoord2fv_ARGS;
typedef struct {
    int index;
    glTexCoord2fv_ARGS args;
} glTexCoord2fv_PACKED;
#endif
#ifndef glTexCoord2hNV_RETURN
typedef struct {
    GLhalfNV s;
    GLhalfNV t;
} glTexCoord2hNV_ARGS;
typedef struct {
    int index;
    glTexCoord2hNV_ARGS args;
} glTexCoord2hNV_PACKED;
#endif
#ifndef glTexCoord2hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glTexCoord2hvNV_ARGS;
typedef struct {
    int index;
    glTexCoord2hvNV_ARGS args;
} glTexCoord2hvNV_PACKED;
#endif
#ifndef glTexCoord2i_RETURN
typedef struct {
    GLint s;
    GLint t;
} glTexCoord2i_ARGS;
typedef struct {
    int index;
    glTexCoord2i_ARGS args;
} glTexCoord2i_PACKED;
#endif
#ifndef glTexCoord2iv_RETURN
typedef struct {
    GLint * v;
} glTexCoord2iv_ARGS;
typedef struct {
    int index;
    glTexCoord2iv_ARGS args;
} glTexCoord2iv_PACKED;
#endif
#ifndef glTexCoord2s_RETURN
typedef struct {
    GLshort s;
    GLshort t;
} glTexCoord2s_ARGS;
typedef struct {
    int index;
    glTexCoord2s_ARGS args;
} glTexCoord2s_PACKED;
#endif
#ifndef glTexCoord2sv_RETURN
typedef struct {
    GLshort * v;
} glTexCoord2sv_ARGS;
typedef struct {
    int index;
    glTexCoord2sv_ARGS args;
} glTexCoord2sv_PACKED;
#endif
#ifndef glTexCoord2xOES_RETURN
typedef struct {
    GLfixed s;
    GLfixed t;
} glTexCoord2xOES_ARGS;
typedef struct {
    int index;
    glTexCoord2xOES_ARGS args;
} glTexCoord2xOES_PACKED;
#endif
#ifndef glTexCoord2xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glTexCoord2xvOES_ARGS;
typedef struct {
    int index;
    glTexCoord2xvOES_ARGS args;
} glTexCoord2xvOES_PACKED;
#endif
#ifndef glTexCoord3bOES_RETURN
typedef struct {
    GLbyte s;
    GLbyte t;
    GLbyte r;
} glTexCoord3bOES_ARGS;
typedef struct {
    int index;
    glTexCoord3bOES_ARGS args;
} glTexCoord3bOES_PACKED;
#endif
#ifndef glTexCoord3bvOES_RETURN
typedef struct {
    GLbyte * coords;
} glTexCoord3bvOES_ARGS;
typedef struct {
    int index;
    glTexCoord3bvOES_ARGS args;
} glTexCoord3bvOES_PACKED;
#endif
#ifndef glTexCoord3d_RETURN
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
} glTexCoord3d_ARGS;
typedef struct {
    int index;
    glTexCoord3d_ARGS args;
} glTexCoord3d_PACKED;
#endif
#ifndef glTexCoord3dv_RETURN
typedef struct {
    GLdouble * v;
} glTexCoord3dv_ARGS;
typedef struct {
    int index;
    glTexCoord3dv_ARGS args;
} glTexCoord3dv_PACKED;
#endif
#ifndef glTexCoord3f_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
} glTexCoord3f_ARGS;
typedef struct {
    int index;
    glTexCoord3f_ARGS args;
} glTexCoord3f_PACKED;
#endif
#ifndef glTexCoord3fv_RETURN
typedef struct {
    GLfloat * v;
} glTexCoord3fv_ARGS;
typedef struct {
    int index;
    glTexCoord3fv_ARGS args;
} glTexCoord3fv_PACKED;
#endif
#ifndef glTexCoord3hNV_RETURN
typedef struct {
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
} glTexCoord3hNV_ARGS;
typedef struct {
    int index;
    glTexCoord3hNV_ARGS args;
} glTexCoord3hNV_PACKED;
#endif
#ifndef glTexCoord3hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glTexCoord3hvNV_ARGS;
typedef struct {
    int index;
    glTexCoord3hvNV_ARGS args;
} glTexCoord3hvNV_PACKED;
#endif
#ifndef glTexCoord3i_RETURN
typedef struct {
    GLint s;
    GLint t;
    GLint r;
} glTexCoord3i_ARGS;
typedef struct {
    int index;
    glTexCoord3i_ARGS args;
} glTexCoord3i_PACKED;
#endif
#ifndef glTexCoord3iv_RETURN
typedef struct {
    GLint * v;
} glTexCoord3iv_ARGS;
typedef struct {
    int index;
    glTexCoord3iv_ARGS args;
} glTexCoord3iv_PACKED;
#endif
#ifndef glTexCoord3s_RETURN
typedef struct {
    GLshort s;
    GLshort t;
    GLshort r;
} glTexCoord3s_ARGS;
typedef struct {
    int index;
    glTexCoord3s_ARGS args;
} glTexCoord3s_PACKED;
#endif
#ifndef glTexCoord3sv_RETURN
typedef struct {
    GLshort * v;
} glTexCoord3sv_ARGS;
typedef struct {
    int index;
    glTexCoord3sv_ARGS args;
} glTexCoord3sv_PACKED;
#endif
#ifndef glTexCoord3xOES_RETURN
typedef struct {
    GLfixed s;
    GLfixed t;
    GLfixed r;
} glTexCoord3xOES_ARGS;
typedef struct {
    int index;
    glTexCoord3xOES_ARGS args;
} glTexCoord3xOES_PACKED;
#endif
#ifndef glTexCoord3xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glTexCoord3xvOES_ARGS;
typedef struct {
    int index;
    glTexCoord3xvOES_ARGS args;
} glTexCoord3xvOES_PACKED;
#endif
#ifndef glTexCoord4bOES_RETURN
typedef struct {
    GLbyte s;
    GLbyte t;
    GLbyte r;
    GLbyte q;
} glTexCoord4bOES_ARGS;
typedef struct {
    int index;
    glTexCoord4bOES_ARGS args;
} glTexCoord4bOES_PACKED;
#endif
#ifndef glTexCoord4bvOES_RETURN
typedef struct {
    GLbyte * coords;
} glTexCoord4bvOES_ARGS;
typedef struct {
    int index;
    glTexCoord4bvOES_ARGS args;
} glTexCoord4bvOES_PACKED;
#endif
#ifndef glTexCoord4d_RETURN
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
    GLdouble q __attribute__ ((aligned(8)));
} glTexCoord4d_ARGS;
typedef struct {
    int index;
    glTexCoord4d_ARGS args;
} glTexCoord4d_PACKED;
#endif
#ifndef glTexCoord4dv_RETURN
typedef struct {
    GLdouble * v;
} glTexCoord4dv_ARGS;
typedef struct {
    int index;
    glTexCoord4dv_ARGS args;
} glTexCoord4dv_PACKED;
#endif
#ifndef glTexCoord4f_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
} glTexCoord4f_ARGS;
typedef struct {
    int index;
    glTexCoord4f_ARGS args;
} glTexCoord4f_PACKED;
#endif
#ifndef glTexCoord4fColor4fNormal3fVertex4fSUN_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat p;
    GLfloat q;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glTexCoord4fColor4fNormal3fVertex4fSUN_ARGS;
typedef struct {
    int index;
    glTexCoord4fColor4fNormal3fVertex4fSUN_ARGS args;
} glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED;
#endif
#ifndef glTexCoord4fColor4fNormal3fVertex4fvSUN_RETURN
typedef struct {
    GLfloat * tc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} glTexCoord4fColor4fNormal3fVertex4fvSUN_ARGS;
typedef struct {
    int index;
    glTexCoord4fColor4fNormal3fVertex4fvSUN_ARGS args;
} glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED;
#endif
#ifndef glTexCoord4fVertex4fSUN_RETURN
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat p;
    GLfloat q;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glTexCoord4fVertex4fSUN_ARGS;
typedef struct {
    int index;
    glTexCoord4fVertex4fSUN_ARGS args;
} glTexCoord4fVertex4fSUN_PACKED;
#endif
#ifndef glTexCoord4fVertex4fvSUN_RETURN
typedef struct {
    GLfloat * tc;
    GLfloat * v;
} glTexCoord4fVertex4fvSUN_ARGS;
typedef struct {
    int index;
    glTexCoord4fVertex4fvSUN_ARGS args;
} glTexCoord4fVertex4fvSUN_PACKED;
#endif
#ifndef glTexCoord4fv_RETURN
typedef struct {
    GLfloat * v;
} glTexCoord4fv_ARGS;
typedef struct {
    int index;
    glTexCoord4fv_ARGS args;
} glTexCoord4fv_PACKED;
#endif
#ifndef glTexCoord4hNV_RETURN
typedef struct {
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
    GLhalfNV q;
} glTexCoord4hNV_ARGS;
typedef struct {
    int index;
    glTexCoord4hNV_ARGS args;
} glTexCoord4hNV_PACKED;
#endif
#ifndef glTexCoord4hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glTexCoord4hvNV_ARGS;
typedef struct {
    int index;
    glTexCoord4hvNV_ARGS args;
} glTexCoord4hvNV_PACKED;
#endif
#ifndef glTexCoord4i_RETURN
typedef struct {
    GLint s;
    GLint t;
    GLint r;
    GLint q;
} glTexCoord4i_ARGS;
typedef struct {
    int index;
    glTexCoord4i_ARGS args;
} glTexCoord4i_PACKED;
#endif
#ifndef glTexCoord4iv_RETURN
typedef struct {
    GLint * v;
} glTexCoord4iv_ARGS;
typedef struct {
    int index;
    glTexCoord4iv_ARGS args;
} glTexCoord4iv_PACKED;
#endif
#ifndef glTexCoord4s_RETURN
typedef struct {
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
} glTexCoord4s_ARGS;
typedef struct {
    int index;
    glTexCoord4s_ARGS args;
} glTexCoord4s_PACKED;
#endif
#ifndef glTexCoord4sv_RETURN
typedef struct {
    GLshort * v;
} glTexCoord4sv_ARGS;
typedef struct {
    int index;
    glTexCoord4sv_ARGS args;
} glTexCoord4sv_PACKED;
#endif
#ifndef glTexCoord4xOES_RETURN
typedef struct {
    GLfixed s;
    GLfixed t;
    GLfixed r;
    GLfixed q;
} glTexCoord4xOES_ARGS;
typedef struct {
    int index;
    glTexCoord4xOES_ARGS args;
} glTexCoord4xOES_PACKED;
#endif
#ifndef glTexCoord4xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glTexCoord4xvOES_ARGS;
typedef struct {
    int index;
    glTexCoord4xvOES_ARGS args;
} glTexCoord4xvOES_PACKED;
#endif
#ifndef glTexCoordFormatNV_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} glTexCoordFormatNV_ARGS;
typedef struct {
    int index;
    glTexCoordFormatNV_ARGS args;
} glTexCoordFormatNV_PACKED;
#endif
#ifndef glTexCoordP1ui_RETURN
typedef struct {
    GLenum type;
    GLuint coords;
} glTexCoordP1ui_ARGS;
typedef struct {
    int index;
    glTexCoordP1ui_ARGS args;
} glTexCoordP1ui_PACKED;
#endif
#ifndef glTexCoordP1uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * coords;
} glTexCoordP1uiv_ARGS;
typedef struct {
    int index;
    glTexCoordP1uiv_ARGS args;
} glTexCoordP1uiv_PACKED;
#endif
#ifndef glTexCoordP2ui_RETURN
typedef struct {
    GLenum type;
    GLuint coords;
} glTexCoordP2ui_ARGS;
typedef struct {
    int index;
    glTexCoordP2ui_ARGS args;
} glTexCoordP2ui_PACKED;
#endif
#ifndef glTexCoordP2uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * coords;
} glTexCoordP2uiv_ARGS;
typedef struct {
    int index;
    glTexCoordP2uiv_ARGS args;
} glTexCoordP2uiv_PACKED;
#endif
#ifndef glTexCoordP3ui_RETURN
typedef struct {
    GLenum type;
    GLuint coords;
} glTexCoordP3ui_ARGS;
typedef struct {
    int index;
    glTexCoordP3ui_ARGS args;
} glTexCoordP3ui_PACKED;
#endif
#ifndef glTexCoordP3uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * coords;
} glTexCoordP3uiv_ARGS;
typedef struct {
    int index;
    glTexCoordP3uiv_ARGS args;
} glTexCoordP3uiv_PACKED;
#endif
#ifndef glTexCoordP4ui_RETURN
typedef struct {
    GLenum type;
    GLuint coords;
} glTexCoordP4ui_ARGS;
typedef struct {
    int index;
    glTexCoordP4ui_ARGS args;
} glTexCoordP4ui_PACKED;
#endif
#ifndef glTexCoordP4uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * coords;
} glTexCoordP4uiv_ARGS;
typedef struct {
    int index;
    glTexCoordP4uiv_ARGS args;
} glTexCoordP4uiv_PACKED;
#endif
#ifndef glTexCoordPointer_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glTexCoordPointer_ARGS;
typedef struct {
    int index;
    glTexCoordPointer_ARGS args;
} glTexCoordPointer_PACKED;
#endif
#ifndef glTexCoordPointerEXT_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} glTexCoordPointerEXT_ARGS;
typedef struct {
    int index;
    glTexCoordPointerEXT_ARGS args;
} glTexCoordPointerEXT_PACKED;
#endif
#ifndef glTexCoordPointerListIBM_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} glTexCoordPointerListIBM_ARGS;
typedef struct {
    int index;
    glTexCoordPointerListIBM_ARGS args;
} glTexCoordPointerListIBM_PACKED;
#endif
#ifndef glTexCoordPointervINTEL_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLvoid * pointer;
} glTexCoordPointervINTEL_ARGS;
typedef struct {
    int index;
    glTexCoordPointervINTEL_ARGS args;
} glTexCoordPointervINTEL_PACKED;
#endif
#ifndef glTexEnvf_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} glTexEnvf_ARGS;
typedef struct {
    int index;
    glTexEnvf_ARGS args;
} glTexEnvf_PACKED;
#endif
#ifndef glTexEnvfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glTexEnvfv_ARGS;
typedef struct {
    int index;
    glTexEnvfv_ARGS args;
} glTexEnvfv_PACKED;
#endif
#ifndef glTexEnvi_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} glTexEnvi_ARGS;
typedef struct {
    int index;
    glTexEnvi_ARGS args;
} glTexEnvi_PACKED;
#endif
#ifndef glTexEnviv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glTexEnviv_ARGS;
typedef struct {
    int index;
    glTexEnviv_ARGS args;
} glTexEnviv_PACKED;
#endif
#ifndef glTexEnvxOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} glTexEnvxOES_ARGS;
typedef struct {
    int index;
    glTexEnvxOES_ARGS args;
} glTexEnvxOES_PACKED;
#endif
#ifndef glTexEnvxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} glTexEnvxvOES_ARGS;
typedef struct {
    int index;
    glTexEnvxvOES_ARGS args;
} glTexEnvxvOES_PACKED;
#endif
#ifndef glTexFilterFuncSGIS_RETURN
typedef struct {
    GLenum target;
    GLenum filter;
    GLsizei n;
    GLfloat * weights;
} glTexFilterFuncSGIS_ARGS;
typedef struct {
    int index;
    glTexFilterFuncSGIS_ARGS args;
} glTexFilterFuncSGIS_PACKED;
#endif
#ifndef glTexGend_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLdouble param __attribute__ ((aligned(8)));
} glTexGend_ARGS;
typedef struct {
    int index;
    glTexGend_ARGS args;
} glTexGend_PACKED;
#endif
#ifndef glTexGendv_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} glTexGendv_ARGS;
typedef struct {
    int index;
    glTexGendv_ARGS args;
} glTexGendv_PACKED;
#endif
#ifndef glTexGenf_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfloat param;
} glTexGenf_ARGS;
typedef struct {
    int index;
    glTexGenf_ARGS args;
} glTexGenf_PACKED;
#endif
#ifndef glTexGenfv_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} glTexGenfv_ARGS;
typedef struct {
    int index;
    glTexGenfv_ARGS args;
} glTexGenfv_PACKED;
#endif
#ifndef glTexGeni_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLint param;
} glTexGeni_ARGS;
typedef struct {
    int index;
    glTexGeni_ARGS args;
} glTexGeni_PACKED;
#endif
#ifndef glTexGeniv_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLint * params;
} glTexGeniv_ARGS;
typedef struct {
    int index;
    glTexGeniv_ARGS args;
} glTexGeniv_PACKED;
#endif
#ifndef glTexGenxOES_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfixed param;
} glTexGenxOES_ARGS;
typedef struct {
    int index;
    glTexGenxOES_ARGS args;
} glTexGenxOES_PACKED;
#endif
#ifndef glTexGenxvOES_RETURN
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfixed * params;
} glTexGenxvOES_ARGS;
typedef struct {
    int index;
    glTexGenxvOES_ARGS args;
} glTexGenxvOES_PACKED;
#endif
#ifndef glTexImage1D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint internalformat;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexImage1D_ARGS;
typedef struct {
    int index;
    glTexImage1D_ARGS args;
} glTexImage1D_PACKED;
#endif
#ifndef glTexImage2D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexImage2D_ARGS;
typedef struct {
    int index;
    glTexImage2D_ARGS args;
} glTexImage2D_PACKED;
#endif
#ifndef glTexImage2DMultisample_RETURN
typedef struct {
    GLenum target;
    GLsizei samples;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedsamplelocations;
} glTexImage2DMultisample_ARGS;
typedef struct {
    int index;
    glTexImage2DMultisample_ARGS args;
} glTexImage2DMultisample_PACKED;
#endif
#ifndef glTexImage2DMultisampleCoverageNV_RETURN
typedef struct {
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedSampleLocations;
} glTexImage2DMultisampleCoverageNV_ARGS;
typedef struct {
    int index;
    glTexImage2DMultisampleCoverageNV_ARGS args;
} glTexImage2DMultisampleCoverageNV_PACKED;
#endif
#ifndef glTexImage3D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexImage3D_ARGS;
typedef struct {
    int index;
    glTexImage3D_ARGS args;
} glTexImage3D_PACKED;
#endif
#ifndef glTexImage3DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexImage3DEXT_ARGS;
typedef struct {
    int index;
    glTexImage3DEXT_ARGS args;
} glTexImage3DEXT_PACKED;
#endif
#ifndef glTexImage3DMultisample_RETURN
typedef struct {
    GLenum target;
    GLsizei samples;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedsamplelocations;
} glTexImage3DMultisample_ARGS;
typedef struct {
    int index;
    glTexImage3DMultisample_ARGS args;
} glTexImage3DMultisample_PACKED;
#endif
#ifndef glTexImage3DMultisampleCoverageNV_RETURN
typedef struct {
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedSampleLocations;
} glTexImage3DMultisampleCoverageNV_ARGS;
typedef struct {
    int index;
    glTexImage3DMultisampleCoverageNV_ARGS args;
} glTexImage3DMultisampleCoverageNV_PACKED;
#endif
#ifndef glTexImage4DSGIS_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexImage4DSGIS_ARGS;
typedef struct {
    int index;
    glTexImage4DSGIS_ARGS args;
} glTexImage4DSGIS_PACKED;
#endif
#ifndef glTexParameterIiv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glTexParameterIiv_ARGS;
typedef struct {
    int index;
    glTexParameterIiv_ARGS args;
} glTexParameterIiv_PACKED;
#endif
#ifndef glTexParameterIivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glTexParameterIivEXT_ARGS;
typedef struct {
    int index;
    glTexParameterIivEXT_ARGS args;
} glTexParameterIivEXT_PACKED;
#endif
#ifndef glTexParameterIuiv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} glTexParameterIuiv_ARGS;
typedef struct {
    int index;
    glTexParameterIuiv_ARGS args;
} glTexParameterIuiv_PACKED;
#endif
#ifndef glTexParameterIuivEXT_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} glTexParameterIuivEXT_ARGS;
typedef struct {
    int index;
    glTexParameterIuivEXT_ARGS args;
} glTexParameterIuivEXT_PACKED;
#endif
#ifndef glTexParameterf_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} glTexParameterf_ARGS;
typedef struct {
    int index;
    glTexParameterf_ARGS args;
} glTexParameterf_PACKED;
#endif
#ifndef glTexParameterfv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glTexParameterfv_ARGS;
typedef struct {
    int index;
    glTexParameterfv_ARGS args;
} glTexParameterfv_PACKED;
#endif
#ifndef glTexParameteri_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} glTexParameteri_ARGS;
typedef struct {
    int index;
    glTexParameteri_ARGS args;
} glTexParameteri_PACKED;
#endif
#ifndef glTexParameteriv_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} glTexParameteriv_ARGS;
typedef struct {
    int index;
    glTexParameteriv_ARGS args;
} glTexParameteriv_PACKED;
#endif
#ifndef glTexParameterxOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} glTexParameterxOES_ARGS;
typedef struct {
    int index;
    glTexParameterxOES_ARGS args;
} glTexParameterxOES_PACKED;
#endif
#ifndef glTexParameterxvOES_RETURN
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} glTexParameterxvOES_ARGS;
typedef struct {
    int index;
    glTexParameterxvOES_ARGS args;
} glTexParameterxvOES_PACKED;
#endif
#ifndef glTexRenderbufferNV_RETURN
typedef struct {
    GLenum target;
    GLuint renderbuffer;
} glTexRenderbufferNV_ARGS;
typedef struct {
    int index;
    glTexRenderbufferNV_ARGS args;
} glTexRenderbufferNV_PACKED;
#endif
#ifndef glTexStorage1D_RETURN
typedef struct {
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
} glTexStorage1D_ARGS;
typedef struct {
    int index;
    glTexStorage1D_ARGS args;
} glTexStorage1D_PACKED;
#endif
#ifndef glTexStorage2D_RETURN
typedef struct {
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glTexStorage2D_ARGS;
typedef struct {
    int index;
    glTexStorage2D_ARGS args;
} glTexStorage2D_PACKED;
#endif
#ifndef glTexStorage2DMultisample_RETURN
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedsamplelocations;
} glTexStorage2DMultisample_ARGS;
typedef struct {
    int index;
    glTexStorage2DMultisample_ARGS args;
} glTexStorage2DMultisample_PACKED;
#endif
#ifndef glTexStorage3D_RETURN
typedef struct {
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} glTexStorage3D_ARGS;
typedef struct {
    int index;
    glTexStorage3D_ARGS args;
} glTexStorage3D_PACKED;
#endif
#ifndef glTexStorage3DMultisample_RETURN
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedsamplelocations;
} glTexStorage3DMultisample_ARGS;
typedef struct {
    int index;
    glTexStorage3DMultisample_ARGS args;
} glTexStorage3DMultisample_PACKED;
#endif
#ifndef glTexStorageSparseAMD_RETURN
typedef struct {
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei layers;
    GLbitfield flags;
} glTexStorageSparseAMD_ARGS;
typedef struct {
    int index;
    glTexStorageSparseAMD_ARGS args;
} glTexStorageSparseAMD_PACKED;
#endif
#ifndef glTexSubImage1D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexSubImage1D_ARGS;
typedef struct {
    int index;
    glTexSubImage1D_ARGS args;
} glTexSubImage1D_PACKED;
#endif
#ifndef glTexSubImage1DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glTexSubImage1DEXT_ARGS args;
} glTexSubImage1DEXT_PACKED;
#endif
#ifndef glTexSubImage2D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexSubImage2D_ARGS;
typedef struct {
    int index;
    glTexSubImage2D_ARGS args;
} glTexSubImage2D_PACKED;
#endif
#ifndef glTexSubImage2DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glTexSubImage2DEXT_ARGS args;
} glTexSubImage2DEXT_PACKED;
#endif
#ifndef glTexSubImage3D_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexSubImage3D_ARGS;
typedef struct {
    int index;
    glTexSubImage3D_ARGS args;
} glTexSubImage3D_PACKED;
#endif
#ifndef glTexSubImage3DEXT_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glTexSubImage3DEXT_ARGS args;
} glTexSubImage3DEXT_PACKED;
#endif
#ifndef glTexSubImage4DSGIS_RETURN
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint woffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTexSubImage4DSGIS_ARGS;
typedef struct {
    int index;
    glTexSubImage4DSGIS_ARGS args;
} glTexSubImage4DSGIS_PACKED;
#endif
#ifndef glTextureBarrierNV_RETURN
typedef struct {
    int index;
} glTextureBarrierNV_PACKED;
#endif
#ifndef glTextureBufferEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} glTextureBufferEXT_ARGS;
typedef struct {
    int index;
    glTextureBufferEXT_ARGS args;
} glTextureBufferEXT_PACKED;
#endif
#ifndef glTextureBufferRangeEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} glTextureBufferRangeEXT_ARGS;
typedef struct {
    int index;
    glTextureBufferRangeEXT_ARGS args;
} glTextureBufferRangeEXT_PACKED;
#endif
#ifndef glTextureColorMaskSGIS_RETURN
typedef struct {
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;
} glTextureColorMaskSGIS_ARGS;
typedef struct {
    int index;
    glTextureColorMaskSGIS_ARGS args;
} glTextureColorMaskSGIS_PACKED;
#endif
#ifndef glTextureImage1DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTextureImage1DEXT_ARGS;
typedef struct {
    int index;
    glTextureImage1DEXT_ARGS args;
} glTextureImage1DEXT_PACKED;
#endif
#ifndef glTextureImage2DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTextureImage2DEXT_ARGS;
typedef struct {
    int index;
    glTextureImage2DEXT_ARGS args;
} glTextureImage2DEXT_PACKED;
#endif
#ifndef glTextureImage2DMultisampleCoverageNV_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedSampleLocations;
} glTextureImage2DMultisampleCoverageNV_ARGS;
typedef struct {
    int index;
    glTextureImage2DMultisampleCoverageNV_ARGS args;
} glTextureImage2DMultisampleCoverageNV_PACKED;
#endif
#ifndef glTextureImage2DMultisampleNV_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedSampleLocations;
} glTextureImage2DMultisampleNV_ARGS;
typedef struct {
    int index;
    glTextureImage2DMultisampleNV_ARGS args;
} glTextureImage2DMultisampleNV_PACKED;
#endif
#ifndef glTextureImage3DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTextureImage3DEXT_ARGS;
typedef struct {
    int index;
    glTextureImage3DEXT_ARGS args;
} glTextureImage3DEXT_PACKED;
#endif
#ifndef glTextureImage3DMultisampleCoverageNV_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedSampleLocations;
} glTextureImage3DMultisampleCoverageNV_ARGS;
typedef struct {
    int index;
    glTextureImage3DMultisampleCoverageNV_ARGS args;
} glTextureImage3DMultisampleCoverageNV_PACKED;
#endif
#ifndef glTextureImage3DMultisampleNV_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedSampleLocations;
} glTextureImage3DMultisampleNV_ARGS;
typedef struct {
    int index;
    glTextureImage3DMultisampleNV_ARGS args;
} glTextureImage3DMultisampleNV_PACKED;
#endif
#ifndef glTextureLightEXT_RETURN
typedef struct {
    GLenum pname;
} glTextureLightEXT_ARGS;
typedef struct {
    int index;
    glTextureLightEXT_ARGS args;
} glTextureLightEXT_PACKED;
#endif
#ifndef glTextureMaterialEXT_RETURN
typedef struct {
    GLenum face;
    GLenum mode;
} glTextureMaterialEXT_ARGS;
typedef struct {
    int index;
    glTextureMaterialEXT_ARGS args;
} glTextureMaterialEXT_PACKED;
#endif
#ifndef glTextureNormalEXT_RETURN
typedef struct {
    GLenum mode;
} glTextureNormalEXT_ARGS;
typedef struct {
    int index;
    glTextureNormalEXT_ARGS args;
} glTextureNormalEXT_PACKED;
#endif
#ifndef glTextureParameterIivEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} glTextureParameterIivEXT_ARGS;
typedef struct {
    int index;
    glTextureParameterIivEXT_ARGS args;
} glTextureParameterIivEXT_PACKED;
#endif
#ifndef glTextureParameterIuivEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLuint * params;
} glTextureParameterIuivEXT_ARGS;
typedef struct {
    int index;
    glTextureParameterIuivEXT_ARGS args;
} glTextureParameterIuivEXT_PACKED;
#endif
#ifndef glTextureParameterfEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLfloat param;
} glTextureParameterfEXT_ARGS;
typedef struct {
    int index;
    glTextureParameterfEXT_ARGS args;
} glTextureParameterfEXT_PACKED;
#endif
#ifndef glTextureParameterfvEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} glTextureParameterfvEXT_ARGS;
typedef struct {
    int index;
    glTextureParameterfvEXT_ARGS args;
} glTextureParameterfvEXT_PACKED;
#endif
#ifndef glTextureParameteriEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint param;
} glTextureParameteriEXT_ARGS;
typedef struct {
    int index;
    glTextureParameteriEXT_ARGS args;
} glTextureParameteriEXT_PACKED;
#endif
#ifndef glTextureParameterivEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} glTextureParameterivEXT_ARGS;
typedef struct {
    int index;
    glTextureParameterivEXT_ARGS args;
} glTextureParameterivEXT_PACKED;
#endif
#ifndef glTextureRangeAPPLE_RETURN
typedef struct {
    GLenum target;
    GLsizei length;
    GLvoid * pointer;
} glTextureRangeAPPLE_ARGS;
typedef struct {
    int index;
    glTextureRangeAPPLE_ARGS args;
} glTextureRangeAPPLE_PACKED;
#endif
#ifndef glTextureRenderbufferEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLuint renderbuffer;
} glTextureRenderbufferEXT_ARGS;
typedef struct {
    int index;
    glTextureRenderbufferEXT_ARGS args;
} glTextureRenderbufferEXT_PACKED;
#endif
#ifndef glTextureStorage1DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
} glTextureStorage1DEXT_ARGS;
typedef struct {
    int index;
    glTextureStorage1DEXT_ARGS args;
} glTextureStorage1DEXT_PACKED;
#endif
#ifndef glTextureStorage2DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} glTextureStorage2DEXT_ARGS;
typedef struct {
    int index;
    glTextureStorage2DEXT_ARGS args;
} glTextureStorage2DEXT_PACKED;
#endif
#ifndef glTextureStorage2DMultisampleEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedsamplelocations;
} glTextureStorage2DMultisampleEXT_ARGS;
typedef struct {
    int index;
    glTextureStorage2DMultisampleEXT_ARGS args;
} glTextureStorage2DMultisampleEXT_PACKED;
#endif
#ifndef glTextureStorage3DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} glTextureStorage3DEXT_ARGS;
typedef struct {
    int index;
    glTextureStorage3DEXT_ARGS args;
} glTextureStorage3DEXT_PACKED;
#endif
#ifndef glTextureStorage3DMultisampleEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedsamplelocations;
} glTextureStorage3DMultisampleEXT_ARGS;
typedef struct {
    int index;
    glTextureStorage3DMultisampleEXT_ARGS args;
} glTextureStorage3DMultisampleEXT_PACKED;
#endif
#ifndef glTextureStorageSparseAMD_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei layers;
    GLbitfield flags;
} glTextureStorageSparseAMD_ARGS;
typedef struct {
    int index;
    glTextureStorageSparseAMD_ARGS args;
} glTextureStorageSparseAMD_PACKED;
#endif
#ifndef glTextureSubImage1DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTextureSubImage1DEXT_ARGS;
typedef struct {
    int index;
    glTextureSubImage1DEXT_ARGS args;
} glTextureSubImage1DEXT_PACKED;
#endif
#ifndef glTextureSubImage2DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTextureSubImage2DEXT_ARGS;
typedef struct {
    int index;
    glTextureSubImage2DEXT_ARGS args;
} glTextureSubImage2DEXT_PACKED;
#endif
#ifndef glTextureSubImage3DEXT_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} glTextureSubImage3DEXT_ARGS;
typedef struct {
    int index;
    glTextureSubImage3DEXT_ARGS args;
} glTextureSubImage3DEXT_PACKED;
#endif
#ifndef glTextureView_RETURN
typedef struct {
    GLuint texture;
    GLenum target;
    GLuint origtexture;
    GLenum internalformat;
    GLuint minlevel;
    GLuint numlevels;
    GLuint minlayer;
    GLuint numlayers;
} glTextureView_ARGS;
typedef struct {
    int index;
    glTextureView_ARGS args;
} glTextureView_PACKED;
#endif
#ifndef glTrackMatrixNV_RETURN
typedef struct {
    GLenum target;
    GLuint address;
    GLenum matrix;
    GLenum transform;
} glTrackMatrixNV_ARGS;
typedef struct {
    int index;
    glTrackMatrixNV_ARGS args;
} glTrackMatrixNV_PACKED;
#endif
#ifndef glTransformFeedbackAttribsNV_RETURN
typedef struct {
    GLsizei count;
    GLint * attribs;
    GLenum bufferMode;
} glTransformFeedbackAttribsNV_ARGS;
typedef struct {
    int index;
    glTransformFeedbackAttribsNV_ARGS args;
} glTransformFeedbackAttribsNV_PACKED;
#endif
#ifndef glTransformFeedbackStreamAttribsNV_RETURN
typedef struct {
    GLsizei count;
    GLint * attribs;
    GLsizei nbuffers;
    GLint * bufstreams;
    GLenum bufferMode;
} glTransformFeedbackStreamAttribsNV_ARGS;
typedef struct {
    int index;
    glTransformFeedbackStreamAttribsNV_ARGS args;
} glTransformFeedbackStreamAttribsNV_PACKED;
#endif
#ifndef glTransformFeedbackVaryings_RETURN
typedef struct {
    GLuint program;
    GLsizei count;
    GLchar*const * varyings;
    GLenum bufferMode;
} glTransformFeedbackVaryings_ARGS;
typedef struct {
    int index;
    glTransformFeedbackVaryings_ARGS args;
} glTransformFeedbackVaryings_PACKED;
#endif
#ifndef glTransformFeedbackVaryingsEXT_RETURN
typedef struct {
    GLuint program;
    GLsizei count;
    GLchar * varyings;
    GLenum bufferMode;
} glTransformFeedbackVaryingsEXT_ARGS;
typedef struct {
    int index;
    glTransformFeedbackVaryingsEXT_ARGS args;
} glTransformFeedbackVaryingsEXT_PACKED;
#endif
#ifndef glTransformFeedbackVaryingsNV_RETURN
typedef struct {
    GLuint program;
    GLsizei count;
    GLint * locations;
    GLenum bufferMode;
} glTransformFeedbackVaryingsNV_ARGS;
typedef struct {
    int index;
    glTransformFeedbackVaryingsNV_ARGS args;
} glTransformFeedbackVaryingsNV_PACKED;
#endif
#ifndef glTransformPathNV_RETURN
typedef struct {
    GLuint resultPath;
    GLuint srcPath;
    GLenum transformType;
    GLfloat * transformValues;
} glTransformPathNV_ARGS;
typedef struct {
    int index;
    glTransformPathNV_ARGS args;
} glTransformPathNV_PACKED;
#endif
#ifndef glTranslated_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glTranslated_ARGS;
typedef struct {
    int index;
    glTranslated_ARGS args;
} glTranslated_PACKED;
#endif
#ifndef glTranslatef_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glTranslatef_ARGS;
typedef struct {
    int index;
    glTranslatef_ARGS args;
} glTranslatef_PACKED;
#endif
#ifndef glTranslatexOES_RETURN
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} glTranslatexOES_ARGS;
typedef struct {
    int index;
    glTranslatexOES_ARGS args;
} glTranslatexOES_PACKED;
#endif
#ifndef glUniform1d_RETURN
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
} glUniform1d_ARGS;
typedef struct {
    int index;
    glUniform1d_ARGS args;
} glUniform1d_PACKED;
#endif
#ifndef glUniform1dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} glUniform1dv_ARGS;
typedef struct {
    int index;
    glUniform1dv_ARGS args;
} glUniform1dv_PACKED;
#endif
#ifndef glUniform1f_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
} glUniform1f_ARGS;
typedef struct {
    int index;
    glUniform1f_ARGS args;
} glUniform1f_PACKED;
#endif
#ifndef glUniform1fARB_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
} glUniform1fARB_ARGS;
typedef struct {
    int index;
    glUniform1fARB_ARGS args;
} glUniform1fARB_PACKED;
#endif
#ifndef glUniform1fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform1fv_ARGS;
typedef struct {
    int index;
    glUniform1fv_ARGS args;
} glUniform1fv_PACKED;
#endif
#ifndef glUniform1fvARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform1fvARB_ARGS;
typedef struct {
    int index;
    glUniform1fvARB_ARGS args;
} glUniform1fvARB_PACKED;
#endif
#ifndef glUniform1i_RETURN
typedef struct {
    GLint location;
    GLint v0;
} glUniform1i_ARGS;
typedef struct {
    int index;
    glUniform1i_ARGS args;
} glUniform1i_PACKED;
#endif
#ifndef glUniform1i64NV_RETURN
typedef struct {
    GLint location;
    GLint64EXT x;
} glUniform1i64NV_ARGS;
typedef struct {
    int index;
    glUniform1i64NV_ARGS args;
} glUniform1i64NV_PACKED;
#endif
#ifndef glUniform1i64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glUniform1i64vNV_ARGS;
typedef struct {
    int index;
    glUniform1i64vNV_ARGS args;
} glUniform1i64vNV_PACKED;
#endif
#ifndef glUniform1iARB_RETURN
typedef struct {
    GLint location;
    GLint v0;
} glUniform1iARB_ARGS;
typedef struct {
    int index;
    glUniform1iARB_ARGS args;
} glUniform1iARB_PACKED;
#endif
#ifndef glUniform1iv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform1iv_ARGS;
typedef struct {
    int index;
    glUniform1iv_ARGS args;
} glUniform1iv_PACKED;
#endif
#ifndef glUniform1ivARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform1ivARB_ARGS;
typedef struct {
    int index;
    glUniform1ivARB_ARGS args;
} glUniform1ivARB_PACKED;
#endif
#ifndef glUniform1ui_RETURN
typedef struct {
    GLint location;
    GLuint v0;
} glUniform1ui_ARGS;
typedef struct {
    int index;
    glUniform1ui_ARGS args;
} glUniform1ui_PACKED;
#endif
#ifndef glUniform1ui64NV_RETURN
typedef struct {
    GLint location;
    GLuint64EXT x;
} glUniform1ui64NV_ARGS;
typedef struct {
    int index;
    glUniform1ui64NV_ARGS args;
} glUniform1ui64NV_PACKED;
#endif
#ifndef glUniform1ui64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glUniform1ui64vNV_ARGS;
typedef struct {
    int index;
    glUniform1ui64vNV_ARGS args;
} glUniform1ui64vNV_PACKED;
#endif
#ifndef glUniform1uiEXT_RETURN
typedef struct {
    GLint location;
    GLuint v0;
} glUniform1uiEXT_ARGS;
typedef struct {
    int index;
    glUniform1uiEXT_ARGS args;
} glUniform1uiEXT_PACKED;
#endif
#ifndef glUniform1uiv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform1uiv_ARGS;
typedef struct {
    int index;
    glUniform1uiv_ARGS args;
} glUniform1uiv_PACKED;
#endif
#ifndef glUniform1uivEXT_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform1uivEXT_ARGS;
typedef struct {
    int index;
    glUniform1uivEXT_ARGS args;
} glUniform1uivEXT_PACKED;
#endif
#ifndef glUniform2d_RETURN
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glUniform2d_ARGS;
typedef struct {
    int index;
    glUniform2d_ARGS args;
} glUniform2d_PACKED;
#endif
#ifndef glUniform2dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} glUniform2dv_ARGS;
typedef struct {
    int index;
    glUniform2dv_ARGS args;
} glUniform2dv_PACKED;
#endif
#ifndef glUniform2f_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
} glUniform2f_ARGS;
typedef struct {
    int index;
    glUniform2f_ARGS args;
} glUniform2f_PACKED;
#endif
#ifndef glUniform2fARB_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
} glUniform2fARB_ARGS;
typedef struct {
    int index;
    glUniform2fARB_ARGS args;
} glUniform2fARB_PACKED;
#endif
#ifndef glUniform2fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform2fv_ARGS;
typedef struct {
    int index;
    glUniform2fv_ARGS args;
} glUniform2fv_PACKED;
#endif
#ifndef glUniform2fvARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform2fvARB_ARGS;
typedef struct {
    int index;
    glUniform2fvARB_ARGS args;
} glUniform2fvARB_PACKED;
#endif
#ifndef glUniform2i_RETURN
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
} glUniform2i_ARGS;
typedef struct {
    int index;
    glUniform2i_ARGS args;
} glUniform2i_PACKED;
#endif
#ifndef glUniform2i64NV_RETURN
typedef struct {
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
} glUniform2i64NV_ARGS;
typedef struct {
    int index;
    glUniform2i64NV_ARGS args;
} glUniform2i64NV_PACKED;
#endif
#ifndef glUniform2i64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glUniform2i64vNV_ARGS;
typedef struct {
    int index;
    glUniform2i64vNV_ARGS args;
} glUniform2i64vNV_PACKED;
#endif
#ifndef glUniform2iARB_RETURN
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
} glUniform2iARB_ARGS;
typedef struct {
    int index;
    glUniform2iARB_ARGS args;
} glUniform2iARB_PACKED;
#endif
#ifndef glUniform2iv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform2iv_ARGS;
typedef struct {
    int index;
    glUniform2iv_ARGS args;
} glUniform2iv_PACKED;
#endif
#ifndef glUniform2ivARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform2ivARB_ARGS;
typedef struct {
    int index;
    glUniform2ivARB_ARGS args;
} glUniform2ivARB_PACKED;
#endif
#ifndef glUniform2ui_RETURN
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
} glUniform2ui_ARGS;
typedef struct {
    int index;
    glUniform2ui_ARGS args;
} glUniform2ui_PACKED;
#endif
#ifndef glUniform2ui64NV_RETURN
typedef struct {
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
} glUniform2ui64NV_ARGS;
typedef struct {
    int index;
    glUniform2ui64NV_ARGS args;
} glUniform2ui64NV_PACKED;
#endif
#ifndef glUniform2ui64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glUniform2ui64vNV_ARGS;
typedef struct {
    int index;
    glUniform2ui64vNV_ARGS args;
} glUniform2ui64vNV_PACKED;
#endif
#ifndef glUniform2uiEXT_RETURN
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
} glUniform2uiEXT_ARGS;
typedef struct {
    int index;
    glUniform2uiEXT_ARGS args;
} glUniform2uiEXT_PACKED;
#endif
#ifndef glUniform2uiv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform2uiv_ARGS;
typedef struct {
    int index;
    glUniform2uiv_ARGS args;
} glUniform2uiv_PACKED;
#endif
#ifndef glUniform2uivEXT_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform2uivEXT_ARGS;
typedef struct {
    int index;
    glUniform2uivEXT_ARGS args;
} glUniform2uivEXT_PACKED;
#endif
#ifndef glUniform3d_RETURN
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glUniform3d_ARGS;
typedef struct {
    int index;
    glUniform3d_ARGS args;
} glUniform3d_PACKED;
#endif
#ifndef glUniform3dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} glUniform3dv_ARGS;
typedef struct {
    int index;
    glUniform3dv_ARGS args;
} glUniform3dv_PACKED;
#endif
#ifndef glUniform3f_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} glUniform3f_ARGS;
typedef struct {
    int index;
    glUniform3f_ARGS args;
} glUniform3f_PACKED;
#endif
#ifndef glUniform3fARB_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} glUniform3fARB_ARGS;
typedef struct {
    int index;
    glUniform3fARB_ARGS args;
} glUniform3fARB_PACKED;
#endif
#ifndef glUniform3fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform3fv_ARGS;
typedef struct {
    int index;
    glUniform3fv_ARGS args;
} glUniform3fv_PACKED;
#endif
#ifndef glUniform3fvARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform3fvARB_ARGS;
typedef struct {
    int index;
    glUniform3fvARB_ARGS args;
} glUniform3fvARB_PACKED;
#endif
#ifndef glUniform3i_RETURN
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} glUniform3i_ARGS;
typedef struct {
    int index;
    glUniform3i_ARGS args;
} glUniform3i_PACKED;
#endif
#ifndef glUniform3i64NV_RETURN
typedef struct {
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
} glUniform3i64NV_ARGS;
typedef struct {
    int index;
    glUniform3i64NV_ARGS args;
} glUniform3i64NV_PACKED;
#endif
#ifndef glUniform3i64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glUniform3i64vNV_ARGS;
typedef struct {
    int index;
    glUniform3i64vNV_ARGS args;
} glUniform3i64vNV_PACKED;
#endif
#ifndef glUniform3iARB_RETURN
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} glUniform3iARB_ARGS;
typedef struct {
    int index;
    glUniform3iARB_ARGS args;
} glUniform3iARB_PACKED;
#endif
#ifndef glUniform3iv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform3iv_ARGS;
typedef struct {
    int index;
    glUniform3iv_ARGS args;
} glUniform3iv_PACKED;
#endif
#ifndef glUniform3ivARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform3ivARB_ARGS;
typedef struct {
    int index;
    glUniform3ivARB_ARGS args;
} glUniform3ivARB_PACKED;
#endif
#ifndef glUniform3ui_RETURN
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} glUniform3ui_ARGS;
typedef struct {
    int index;
    glUniform3ui_ARGS args;
} glUniform3ui_PACKED;
#endif
#ifndef glUniform3ui64NV_RETURN
typedef struct {
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
} glUniform3ui64NV_ARGS;
typedef struct {
    int index;
    glUniform3ui64NV_ARGS args;
} glUniform3ui64NV_PACKED;
#endif
#ifndef glUniform3ui64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glUniform3ui64vNV_ARGS;
typedef struct {
    int index;
    glUniform3ui64vNV_ARGS args;
} glUniform3ui64vNV_PACKED;
#endif
#ifndef glUniform3uiEXT_RETURN
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} glUniform3uiEXT_ARGS;
typedef struct {
    int index;
    glUniform3uiEXT_ARGS args;
} glUniform3uiEXT_PACKED;
#endif
#ifndef glUniform3uiv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform3uiv_ARGS;
typedef struct {
    int index;
    glUniform3uiv_ARGS args;
} glUniform3uiv_PACKED;
#endif
#ifndef glUniform3uivEXT_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform3uivEXT_ARGS;
typedef struct {
    int index;
    glUniform3uivEXT_ARGS args;
} glUniform3uivEXT_PACKED;
#endif
#ifndef glUniform4d_RETURN
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glUniform4d_ARGS;
typedef struct {
    int index;
    glUniform4d_ARGS args;
} glUniform4d_PACKED;
#endif
#ifndef glUniform4dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} glUniform4dv_ARGS;
typedef struct {
    int index;
    glUniform4dv_ARGS args;
} glUniform4dv_PACKED;
#endif
#ifndef glUniform4f_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} glUniform4f_ARGS;
typedef struct {
    int index;
    glUniform4f_ARGS args;
} glUniform4f_PACKED;
#endif
#ifndef glUniform4fARB_RETURN
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} glUniform4fARB_ARGS;
typedef struct {
    int index;
    glUniform4fARB_ARGS args;
} glUniform4fARB_PACKED;
#endif
#ifndef glUniform4fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform4fv_ARGS;
typedef struct {
    int index;
    glUniform4fv_ARGS args;
} glUniform4fv_PACKED;
#endif
#ifndef glUniform4fvARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} glUniform4fvARB_ARGS;
typedef struct {
    int index;
    glUniform4fvARB_ARGS args;
} glUniform4fvARB_PACKED;
#endif
#ifndef glUniform4i_RETURN
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} glUniform4i_ARGS;
typedef struct {
    int index;
    glUniform4i_ARGS args;
} glUniform4i_PACKED;
#endif
#ifndef glUniform4i64NV_RETURN
typedef struct {
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
    GLint64EXT w;
} glUniform4i64NV_ARGS;
typedef struct {
    int index;
    glUniform4i64NV_ARGS args;
} glUniform4i64NV_PACKED;
#endif
#ifndef glUniform4i64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} glUniform4i64vNV_ARGS;
typedef struct {
    int index;
    glUniform4i64vNV_ARGS args;
} glUniform4i64vNV_PACKED;
#endif
#ifndef glUniform4iARB_RETURN
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} glUniform4iARB_ARGS;
typedef struct {
    int index;
    glUniform4iARB_ARGS args;
} glUniform4iARB_PACKED;
#endif
#ifndef glUniform4iv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform4iv_ARGS;
typedef struct {
    int index;
    glUniform4iv_ARGS args;
} glUniform4iv_PACKED;
#endif
#ifndef glUniform4ivARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} glUniform4ivARB_ARGS;
typedef struct {
    int index;
    glUniform4ivARB_ARGS args;
} glUniform4ivARB_PACKED;
#endif
#ifndef glUniform4ui_RETURN
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} glUniform4ui_ARGS;
typedef struct {
    int index;
    glUniform4ui_ARGS args;
} glUniform4ui_PACKED;
#endif
#ifndef glUniform4ui64NV_RETURN
typedef struct {
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
    GLuint64EXT w;
} glUniform4ui64NV_ARGS;
typedef struct {
    int index;
    glUniform4ui64NV_ARGS args;
} glUniform4ui64NV_PACKED;
#endif
#ifndef glUniform4ui64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glUniform4ui64vNV_ARGS;
typedef struct {
    int index;
    glUniform4ui64vNV_ARGS args;
} glUniform4ui64vNV_PACKED;
#endif
#ifndef glUniform4uiEXT_RETURN
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} glUniform4uiEXT_ARGS;
typedef struct {
    int index;
    glUniform4uiEXT_ARGS args;
} glUniform4uiEXT_PACKED;
#endif
#ifndef glUniform4uiv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform4uiv_ARGS;
typedef struct {
    int index;
    glUniform4uiv_ARGS args;
} glUniform4uiv_PACKED;
#endif
#ifndef glUniform4uivEXT_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} glUniform4uivEXT_ARGS;
typedef struct {
    int index;
    glUniform4uivEXT_ARGS args;
} glUniform4uivEXT_PACKED;
#endif
#ifndef glUniformBlockBinding_RETURN
typedef struct {
    GLuint program;
    GLuint uniformBlockIndex;
    GLuint uniformBlockBinding;
} glUniformBlockBinding_ARGS;
typedef struct {
    int index;
    glUniformBlockBinding_ARGS args;
} glUniformBlockBinding_PACKED;
#endif
#ifndef glUniformBufferEXT_RETURN
typedef struct {
    GLuint program;
    GLint location;
    GLuint buffer;
} glUniformBufferEXT_ARGS;
typedef struct {
    int index;
    glUniformBufferEXT_ARGS args;
} glUniformBufferEXT_PACKED;
#endif
#ifndef glUniformHandleui64NV_RETURN
typedef struct {
    GLint location;
    GLuint64 value;
} glUniformHandleui64NV_ARGS;
typedef struct {
    int index;
    glUniformHandleui64NV_ARGS args;
} glUniformHandleui64NV_PACKED;
#endif
#ifndef glUniformHandleui64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64 * value;
} glUniformHandleui64vNV_ARGS;
typedef struct {
    int index;
    glUniformHandleui64vNV_ARGS args;
} glUniformHandleui64vNV_PACKED;
#endif
#ifndef glUniformMatrix2dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix2dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix2dv_ARGS args;
} glUniformMatrix2dv_PACKED;
#endif
#ifndef glUniformMatrix2fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix2fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix2fv_ARGS args;
} glUniformMatrix2fv_PACKED;
#endif
#ifndef glUniformMatrix2fvARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix2fvARB_ARGS;
typedef struct {
    int index;
    glUniformMatrix2fvARB_ARGS args;
} glUniformMatrix2fvARB_PACKED;
#endif
#ifndef glUniformMatrix2x3dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix2x3dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix2x3dv_ARGS args;
} glUniformMatrix2x3dv_PACKED;
#endif
#ifndef glUniformMatrix2x3fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix2x3fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix2x3fv_ARGS args;
} glUniformMatrix2x3fv_PACKED;
#endif
#ifndef glUniformMatrix2x4dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix2x4dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix2x4dv_ARGS args;
} glUniformMatrix2x4dv_PACKED;
#endif
#ifndef glUniformMatrix2x4fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix2x4fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix2x4fv_ARGS args;
} glUniformMatrix2x4fv_PACKED;
#endif
#ifndef glUniformMatrix3dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix3dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix3dv_ARGS args;
} glUniformMatrix3dv_PACKED;
#endif
#ifndef glUniformMatrix3fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix3fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix3fv_ARGS args;
} glUniformMatrix3fv_PACKED;
#endif
#ifndef glUniformMatrix3fvARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix3fvARB_ARGS;
typedef struct {
    int index;
    glUniformMatrix3fvARB_ARGS args;
} glUniformMatrix3fvARB_PACKED;
#endif
#ifndef glUniformMatrix3x2dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix3x2dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix3x2dv_ARGS args;
} glUniformMatrix3x2dv_PACKED;
#endif
#ifndef glUniformMatrix3x2fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix3x2fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix3x2fv_ARGS args;
} glUniformMatrix3x2fv_PACKED;
#endif
#ifndef glUniformMatrix3x4dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix3x4dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix3x4dv_ARGS args;
} glUniformMatrix3x4dv_PACKED;
#endif
#ifndef glUniformMatrix3x4fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix3x4fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix3x4fv_ARGS args;
} glUniformMatrix3x4fv_PACKED;
#endif
#ifndef glUniformMatrix4dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix4dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix4dv_ARGS args;
} glUniformMatrix4dv_PACKED;
#endif
#ifndef glUniformMatrix4fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix4fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix4fv_ARGS args;
} glUniformMatrix4fv_PACKED;
#endif
#ifndef glUniformMatrix4fvARB_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix4fvARB_ARGS;
typedef struct {
    int index;
    glUniformMatrix4fvARB_ARGS args;
} glUniformMatrix4fvARB_PACKED;
#endif
#ifndef glUniformMatrix4x2dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix4x2dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix4x2dv_ARGS args;
} glUniformMatrix4x2dv_PACKED;
#endif
#ifndef glUniformMatrix4x2fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix4x2fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix4x2fv_ARGS args;
} glUniformMatrix4x2fv_PACKED;
#endif
#ifndef glUniformMatrix4x3dv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} glUniformMatrix4x3dv_ARGS;
typedef struct {
    int index;
    glUniformMatrix4x3dv_ARGS args;
} glUniformMatrix4x3dv_PACKED;
#endif
#ifndef glUniformMatrix4x3fv_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} glUniformMatrix4x3fv_ARGS;
typedef struct {
    int index;
    glUniformMatrix4x3fv_ARGS args;
} glUniformMatrix4x3fv_PACKED;
#endif
#ifndef glUniformSubroutinesuiv_RETURN
typedef struct {
    GLenum shadertype;
    GLsizei count;
    GLuint * indices;
} glUniformSubroutinesuiv_ARGS;
typedef struct {
    int index;
    glUniformSubroutinesuiv_ARGS args;
} glUniformSubroutinesuiv_PACKED;
#endif
#ifndef glUniformui64NV_RETURN
typedef struct {
    GLint location;
    GLuint64EXT value;
} glUniformui64NV_ARGS;
typedef struct {
    int index;
    glUniformui64NV_ARGS args;
} glUniformui64NV_PACKED;
#endif
#ifndef glUniformui64vNV_RETURN
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} glUniformui64vNV_ARGS;
typedef struct {
    int index;
    glUniformui64vNV_ARGS args;
} glUniformui64vNV_PACKED;
#endif
#ifndef glUnlockArraysEXT_RETURN
typedef struct {
    int index;
} glUnlockArraysEXT_PACKED;
#endif
#ifndef glUnmapBuffer_RETURN
typedef struct {
    GLenum target;
} glUnmapBuffer_ARGS;
typedef struct {
    int index;
    glUnmapBuffer_ARGS args;
} glUnmapBuffer_PACKED;
#endif
#ifndef glUnmapBufferARB_RETURN
typedef struct {
    GLenum target;
} glUnmapBufferARB_ARGS;
typedef struct {
    int index;
    glUnmapBufferARB_ARGS args;
} glUnmapBufferARB_PACKED;
#endif
#ifndef glUnmapNamedBufferEXT_RETURN
typedef struct {
    GLuint buffer;
} glUnmapNamedBufferEXT_ARGS;
typedef struct {
    int index;
    glUnmapNamedBufferEXT_ARGS args;
} glUnmapNamedBufferEXT_PACKED;
#endif
#ifndef glUnmapObjectBufferATI_RETURN
typedef struct {
    GLuint buffer;
} glUnmapObjectBufferATI_ARGS;
typedef struct {
    int index;
    glUnmapObjectBufferATI_ARGS args;
} glUnmapObjectBufferATI_PACKED;
#endif
#ifndef glUnmapTexture2DINTEL_RETURN
typedef struct {
    GLuint texture;
    GLint level;
} glUnmapTexture2DINTEL_ARGS;
typedef struct {
    int index;
    glUnmapTexture2DINTEL_ARGS args;
} glUnmapTexture2DINTEL_PACKED;
#endif
#ifndef glUpdateObjectBufferATI_RETURN
typedef struct {
    GLuint buffer;
    GLuint offset;
    GLsizei size;
    GLvoid * pointer;
    GLenum preserve;
} glUpdateObjectBufferATI_ARGS;
typedef struct {
    int index;
    glUpdateObjectBufferATI_ARGS args;
} glUpdateObjectBufferATI_PACKED;
#endif
#ifndef glUseProgram_RETURN
typedef struct {
    GLuint program;
} glUseProgram_ARGS;
typedef struct {
    int index;
    glUseProgram_ARGS args;
} glUseProgram_PACKED;
#endif
#ifndef glUseProgramObjectARB_RETURN
typedef struct {
    GLhandleARB programObj;
} glUseProgramObjectARB_ARGS;
typedef struct {
    int index;
    glUseProgramObjectARB_ARGS args;
} glUseProgramObjectARB_PACKED;
#endif
#ifndef glUseProgramStages_RETURN
typedef struct {
    GLuint pipeline;
    GLbitfield stages;
    GLuint program;
} glUseProgramStages_ARGS;
typedef struct {
    int index;
    glUseProgramStages_ARGS args;
} glUseProgramStages_PACKED;
#endif
#ifndef glUseShaderProgramEXT_RETURN
typedef struct {
    GLenum type;
    GLuint program;
} glUseShaderProgramEXT_ARGS;
typedef struct {
    int index;
    glUseShaderProgramEXT_ARGS args;
} glUseShaderProgramEXT_PACKED;
#endif
#ifndef glVDPAUFiniNV_RETURN
typedef struct {
    int index;
} glVDPAUFiniNV_PACKED;
#endif
#ifndef glVDPAUGetSurfaceivNV_RETURN
typedef struct {
    GLvdpauSurfaceNV surface;
    GLenum pname;
    GLsizei bufSize;
    GLsizei * length;
    GLint * values;
} glVDPAUGetSurfaceivNV_ARGS;
typedef struct {
    int index;
    glVDPAUGetSurfaceivNV_ARGS args;
} glVDPAUGetSurfaceivNV_PACKED;
#endif
#ifndef glVDPAUInitNV_RETURN
typedef struct {
    GLvoid * vdpDevice;
    GLvoid * getProcAddress;
} glVDPAUInitNV_ARGS;
typedef struct {
    int index;
    glVDPAUInitNV_ARGS args;
} glVDPAUInitNV_PACKED;
#endif
#ifndef glVDPAUIsSurfaceNV_RETURN
typedef struct {
    GLvdpauSurfaceNV surface;
} glVDPAUIsSurfaceNV_ARGS;
typedef struct {
    int index;
    glVDPAUIsSurfaceNV_ARGS args;
} glVDPAUIsSurfaceNV_PACKED;
#endif
#ifndef glVDPAUMapSurfacesNV_RETURN
typedef struct {
    GLsizei numSurfaces;
    GLvdpauSurfaceNV * surfaces;
} glVDPAUMapSurfacesNV_ARGS;
typedef struct {
    int index;
    glVDPAUMapSurfacesNV_ARGS args;
} glVDPAUMapSurfacesNV_PACKED;
#endif
#ifndef glVDPAURegisterOutputSurfaceNV_RETURN
typedef struct {
    GLvoid * vdpSurface;
    GLenum target;
    GLsizei numTextureNames;
    GLuint * textureNames;
} glVDPAURegisterOutputSurfaceNV_ARGS;
typedef struct {
    int index;
    glVDPAURegisterOutputSurfaceNV_ARGS args;
} glVDPAURegisterOutputSurfaceNV_PACKED;
#endif
#ifndef glVDPAURegisterVideoSurfaceNV_RETURN
typedef struct {
    GLvoid * vdpSurface;
    GLenum target;
    GLsizei numTextureNames;
    GLuint * textureNames;
} glVDPAURegisterVideoSurfaceNV_ARGS;
typedef struct {
    int index;
    glVDPAURegisterVideoSurfaceNV_ARGS args;
} glVDPAURegisterVideoSurfaceNV_PACKED;
#endif
#ifndef glVDPAUSurfaceAccessNV_RETURN
typedef struct {
    GLvdpauSurfaceNV surface;
    GLenum access;
} glVDPAUSurfaceAccessNV_ARGS;
typedef struct {
    int index;
    glVDPAUSurfaceAccessNV_ARGS args;
} glVDPAUSurfaceAccessNV_PACKED;
#endif
#ifndef glVDPAUUnmapSurfacesNV_RETURN
typedef struct {
    GLsizei numSurface;
    GLvdpauSurfaceNV * surfaces;
} glVDPAUUnmapSurfacesNV_ARGS;
typedef struct {
    int index;
    glVDPAUUnmapSurfacesNV_ARGS args;
} glVDPAUUnmapSurfacesNV_PACKED;
#endif
#ifndef glVDPAUUnregisterSurfaceNV_RETURN
typedef struct {
    GLvdpauSurfaceNV surface;
} glVDPAUUnregisterSurfaceNV_ARGS;
typedef struct {
    int index;
    glVDPAUUnregisterSurfaceNV_ARGS args;
} glVDPAUUnregisterSurfaceNV_PACKED;
#endif
#ifndef glValidateProgram_RETURN
typedef struct {
    GLuint program;
} glValidateProgram_ARGS;
typedef struct {
    int index;
    glValidateProgram_ARGS args;
} glValidateProgram_PACKED;
#endif
#ifndef glValidateProgramARB_RETURN
typedef struct {
    GLhandleARB programObj;
} glValidateProgramARB_ARGS;
typedef struct {
    int index;
    glValidateProgramARB_ARGS args;
} glValidateProgramARB_PACKED;
#endif
#ifndef glValidateProgramPipeline_RETURN
typedef struct {
    GLuint pipeline;
} glValidateProgramPipeline_ARGS;
typedef struct {
    int index;
    glValidateProgramPipeline_ARGS args;
} glValidateProgramPipeline_PACKED;
#endif
#ifndef glVariantArrayObjectATI_RETURN
typedef struct {
    GLuint id;
    GLenum type;
    GLsizei stride;
    GLuint buffer;
    GLuint offset;
} glVariantArrayObjectATI_ARGS;
typedef struct {
    int index;
    glVariantArrayObjectATI_ARGS args;
} glVariantArrayObjectATI_PACKED;
#endif
#ifndef glVariantPointerEXT_RETURN
typedef struct {
    GLuint id;
    GLenum type;
    GLuint stride;
    GLvoid * addr;
} glVariantPointerEXT_ARGS;
typedef struct {
    int index;
    glVariantPointerEXT_ARGS args;
} glVariantPointerEXT_PACKED;
#endif
#ifndef glVariantbvEXT_RETURN
typedef struct {
    GLuint id;
    GLbyte * addr;
} glVariantbvEXT_ARGS;
typedef struct {
    int index;
    glVariantbvEXT_ARGS args;
} glVariantbvEXT_PACKED;
#endif
#ifndef glVariantdvEXT_RETURN
typedef struct {
    GLuint id;
    GLdouble * addr;
} glVariantdvEXT_ARGS;
typedef struct {
    int index;
    glVariantdvEXT_ARGS args;
} glVariantdvEXT_PACKED;
#endif
#ifndef glVariantfvEXT_RETURN
typedef struct {
    GLuint id;
    GLfloat * addr;
} glVariantfvEXT_ARGS;
typedef struct {
    int index;
    glVariantfvEXT_ARGS args;
} glVariantfvEXT_PACKED;
#endif
#ifndef glVariantivEXT_RETURN
typedef struct {
    GLuint id;
    GLint * addr;
} glVariantivEXT_ARGS;
typedef struct {
    int index;
    glVariantivEXT_ARGS args;
} glVariantivEXT_PACKED;
#endif
#ifndef glVariantsvEXT_RETURN
typedef struct {
    GLuint id;
    GLshort * addr;
} glVariantsvEXT_ARGS;
typedef struct {
    int index;
    glVariantsvEXT_ARGS args;
} glVariantsvEXT_PACKED;
#endif
#ifndef glVariantubvEXT_RETURN
typedef struct {
    GLuint id;
    GLubyte * addr;
} glVariantubvEXT_ARGS;
typedef struct {
    int index;
    glVariantubvEXT_ARGS args;
} glVariantubvEXT_PACKED;
#endif
#ifndef glVariantuivEXT_RETURN
typedef struct {
    GLuint id;
    GLuint * addr;
} glVariantuivEXT_ARGS;
typedef struct {
    int index;
    glVariantuivEXT_ARGS args;
} glVariantuivEXT_PACKED;
#endif
#ifndef glVariantusvEXT_RETURN
typedef struct {
    GLuint id;
    GLushort * addr;
} glVariantusvEXT_ARGS;
typedef struct {
    int index;
    glVariantusvEXT_ARGS args;
} glVariantusvEXT_PACKED;
#endif
#ifndef glVertex2bOES_RETURN
typedef struct {
    GLbyte x;
} glVertex2bOES_ARGS;
typedef struct {
    int index;
    glVertex2bOES_ARGS args;
} glVertex2bOES_PACKED;
#endif
#ifndef glVertex2bvOES_RETURN
typedef struct {
    GLbyte * coords;
} glVertex2bvOES_ARGS;
typedef struct {
    int index;
    glVertex2bvOES_ARGS args;
} glVertex2bvOES_PACKED;
#endif
#ifndef glVertex2d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glVertex2d_ARGS;
typedef struct {
    int index;
    glVertex2d_ARGS args;
} glVertex2d_PACKED;
#endif
#ifndef glVertex2dv_RETURN
typedef struct {
    GLdouble * v;
} glVertex2dv_ARGS;
typedef struct {
    int index;
    glVertex2dv_ARGS args;
} glVertex2dv_PACKED;
#endif
#ifndef glVertex2f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
} glVertex2f_ARGS;
typedef struct {
    int index;
    glVertex2f_ARGS args;
} glVertex2f_PACKED;
#endif
#ifndef glVertex2fv_RETURN
typedef struct {
    GLfloat * v;
} glVertex2fv_ARGS;
typedef struct {
    int index;
    glVertex2fv_ARGS args;
} glVertex2fv_PACKED;
#endif
#ifndef glVertex2hNV_RETURN
typedef struct {
    GLhalfNV x;
    GLhalfNV y;
} glVertex2hNV_ARGS;
typedef struct {
    int index;
    glVertex2hNV_ARGS args;
} glVertex2hNV_PACKED;
#endif
#ifndef glVertex2hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glVertex2hvNV_ARGS;
typedef struct {
    int index;
    glVertex2hvNV_ARGS args;
} glVertex2hvNV_PACKED;
#endif
#ifndef glVertex2i_RETURN
typedef struct {
    GLint x;
    GLint y;
} glVertex2i_ARGS;
typedef struct {
    int index;
    glVertex2i_ARGS args;
} glVertex2i_PACKED;
#endif
#ifndef glVertex2iv_RETURN
typedef struct {
    GLint * v;
} glVertex2iv_ARGS;
typedef struct {
    int index;
    glVertex2iv_ARGS args;
} glVertex2iv_PACKED;
#endif
#ifndef glVertex2s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
} glVertex2s_ARGS;
typedef struct {
    int index;
    glVertex2s_ARGS args;
} glVertex2s_PACKED;
#endif
#ifndef glVertex2sv_RETURN
typedef struct {
    GLshort * v;
} glVertex2sv_ARGS;
typedef struct {
    int index;
    glVertex2sv_ARGS args;
} glVertex2sv_PACKED;
#endif
#ifndef glVertex2xOES_RETURN
typedef struct {
    GLfixed x;
} glVertex2xOES_ARGS;
typedef struct {
    int index;
    glVertex2xOES_ARGS args;
} glVertex2xOES_PACKED;
#endif
#ifndef glVertex2xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glVertex2xvOES_ARGS;
typedef struct {
    int index;
    glVertex2xvOES_ARGS args;
} glVertex2xvOES_PACKED;
#endif
#ifndef glVertex3bOES_RETURN
typedef struct {
    GLbyte x;
    GLbyte y;
} glVertex3bOES_ARGS;
typedef struct {
    int index;
    glVertex3bOES_ARGS args;
} glVertex3bOES_PACKED;
#endif
#ifndef glVertex3bvOES_RETURN
typedef struct {
    GLbyte * coords;
} glVertex3bvOES_ARGS;
typedef struct {
    int index;
    glVertex3bvOES_ARGS args;
} glVertex3bvOES_PACKED;
#endif
#ifndef glVertex3d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glVertex3d_ARGS;
typedef struct {
    int index;
    glVertex3d_ARGS args;
} glVertex3d_PACKED;
#endif
#ifndef glVertex3dv_RETURN
typedef struct {
    GLdouble * v;
} glVertex3dv_ARGS;
typedef struct {
    int index;
    glVertex3dv_ARGS args;
} glVertex3dv_PACKED;
#endif
#ifndef glVertex3f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glVertex3f_ARGS;
typedef struct {
    int index;
    glVertex3f_ARGS args;
} glVertex3f_PACKED;
#endif
#ifndef glVertex3fv_RETURN
typedef struct {
    GLfloat * v;
} glVertex3fv_ARGS;
typedef struct {
    int index;
    glVertex3fv_ARGS args;
} glVertex3fv_PACKED;
#endif
#ifndef glVertex3hNV_RETURN
typedef struct {
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
} glVertex3hNV_ARGS;
typedef struct {
    int index;
    glVertex3hNV_ARGS args;
} glVertex3hNV_PACKED;
#endif
#ifndef glVertex3hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glVertex3hvNV_ARGS;
typedef struct {
    int index;
    glVertex3hvNV_ARGS args;
} glVertex3hvNV_PACKED;
#endif
#ifndef glVertex3i_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} glVertex3i_ARGS;
typedef struct {
    int index;
    glVertex3i_ARGS args;
} glVertex3i_PACKED;
#endif
#ifndef glVertex3iv_RETURN
typedef struct {
    GLint * v;
} glVertex3iv_ARGS;
typedef struct {
    int index;
    glVertex3iv_ARGS args;
} glVertex3iv_PACKED;
#endif
#ifndef glVertex3s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} glVertex3s_ARGS;
typedef struct {
    int index;
    glVertex3s_ARGS args;
} glVertex3s_PACKED;
#endif
#ifndef glVertex3sv_RETURN
typedef struct {
    GLshort * v;
} glVertex3sv_ARGS;
typedef struct {
    int index;
    glVertex3sv_ARGS args;
} glVertex3sv_PACKED;
#endif
#ifndef glVertex3xOES_RETURN
typedef struct {
    GLfixed x;
    GLfixed y;
} glVertex3xOES_ARGS;
typedef struct {
    int index;
    glVertex3xOES_ARGS args;
} glVertex3xOES_PACKED;
#endif
#ifndef glVertex3xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glVertex3xvOES_ARGS;
typedef struct {
    int index;
    glVertex3xvOES_ARGS args;
} glVertex3xvOES_PACKED;
#endif
#ifndef glVertex4bOES_RETURN
typedef struct {
    GLbyte x;
    GLbyte y;
    GLbyte z;
} glVertex4bOES_ARGS;
typedef struct {
    int index;
    glVertex4bOES_ARGS args;
} glVertex4bOES_PACKED;
#endif
#ifndef glVertex4bvOES_RETURN
typedef struct {
    GLbyte * coords;
} glVertex4bvOES_ARGS;
typedef struct {
    int index;
    glVertex4bvOES_ARGS args;
} glVertex4bvOES_PACKED;
#endif
#ifndef glVertex4d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glVertex4d_ARGS;
typedef struct {
    int index;
    glVertex4d_ARGS args;
} glVertex4d_PACKED;
#endif
#ifndef glVertex4dv_RETURN
typedef struct {
    GLdouble * v;
} glVertex4dv_ARGS;
typedef struct {
    int index;
    glVertex4dv_ARGS args;
} glVertex4dv_PACKED;
#endif
#ifndef glVertex4f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glVertex4f_ARGS;
typedef struct {
    int index;
    glVertex4f_ARGS args;
} glVertex4f_PACKED;
#endif
#ifndef glVertex4fv_RETURN
typedef struct {
    GLfloat * v;
} glVertex4fv_ARGS;
typedef struct {
    int index;
    glVertex4fv_ARGS args;
} glVertex4fv_PACKED;
#endif
#ifndef glVertex4hNV_RETURN
typedef struct {
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
    GLhalfNV w;
} glVertex4hNV_ARGS;
typedef struct {
    int index;
    glVertex4hNV_ARGS args;
} glVertex4hNV_PACKED;
#endif
#ifndef glVertex4hvNV_RETURN
typedef struct {
    GLhalfNV * v;
} glVertex4hvNV_ARGS;
typedef struct {
    int index;
    glVertex4hvNV_ARGS args;
} glVertex4hvNV_PACKED;
#endif
#ifndef glVertex4i_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glVertex4i_ARGS;
typedef struct {
    int index;
    glVertex4i_ARGS args;
} glVertex4i_PACKED;
#endif
#ifndef glVertex4iv_RETURN
typedef struct {
    GLint * v;
} glVertex4iv_ARGS;
typedef struct {
    int index;
    glVertex4iv_ARGS args;
} glVertex4iv_PACKED;
#endif
#ifndef glVertex4s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} glVertex4s_ARGS;
typedef struct {
    int index;
    glVertex4s_ARGS args;
} glVertex4s_PACKED;
#endif
#ifndef glVertex4sv_RETURN
typedef struct {
    GLshort * v;
} glVertex4sv_ARGS;
typedef struct {
    int index;
    glVertex4sv_ARGS args;
} glVertex4sv_PACKED;
#endif
#ifndef glVertex4xOES_RETURN
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} glVertex4xOES_ARGS;
typedef struct {
    int index;
    glVertex4xOES_ARGS args;
} glVertex4xOES_PACKED;
#endif
#ifndef glVertex4xvOES_RETURN
typedef struct {
    GLfixed * coords;
} glVertex4xvOES_ARGS;
typedef struct {
    int index;
    glVertex4xvOES_ARGS args;
} glVertex4xvOES_PACKED;
#endif
#ifndef glVertexArrayBindVertexBufferEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint bindingindex;
    GLuint buffer;
    GLintptr offset;
    GLsizei stride;
} glVertexArrayBindVertexBufferEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayBindVertexBufferEXT_ARGS args;
} glVertexArrayBindVertexBufferEXT_PACKED;
#endif
#ifndef glVertexArrayColorOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayColorOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayColorOffsetEXT_ARGS args;
} glVertexArrayColorOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayEdgeFlagOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayEdgeFlagOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayEdgeFlagOffsetEXT_ARGS args;
} glVertexArrayEdgeFlagOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayFogCoordOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayFogCoordOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayFogCoordOffsetEXT_ARGS args;
} glVertexArrayFogCoordOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayIndexOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayIndexOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayIndexOffsetEXT_ARGS args;
} glVertexArrayIndexOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayMultiTexCoordOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum texunit;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayMultiTexCoordOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayMultiTexCoordOffsetEXT_ARGS args;
} glVertexArrayMultiTexCoordOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayNormalOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayNormalOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayNormalOffsetEXT_ARGS args;
} glVertexArrayNormalOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayParameteriAPPLE_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glVertexArrayParameteriAPPLE_ARGS;
typedef struct {
    int index;
    glVertexArrayParameteriAPPLE_ARGS args;
} glVertexArrayParameteriAPPLE_PACKED;
#endif
#ifndef glVertexArrayRangeAPPLE_RETURN
typedef struct {
    GLsizei length;
    GLvoid * pointer;
} glVertexArrayRangeAPPLE_ARGS;
typedef struct {
    int index;
    glVertexArrayRangeAPPLE_ARGS args;
} glVertexArrayRangeAPPLE_PACKED;
#endif
#ifndef glVertexArrayRangeNV_RETURN
typedef struct {
    GLsizei length;
    GLvoid * pointer;
} glVertexArrayRangeNV_ARGS;
typedef struct {
    int index;
    glVertexArrayRangeNV_ARGS args;
} glVertexArrayRangeNV_PACKED;
#endif
#ifndef glVertexArraySecondaryColorOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArraySecondaryColorOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArraySecondaryColorOffsetEXT_ARGS args;
} glVertexArraySecondaryColorOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayTexCoordOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayTexCoordOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayTexCoordOffsetEXT_ARGS args;
} glVertexArrayTexCoordOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayVertexAttribBindingEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLuint bindingindex;
} glVertexArrayVertexAttribBindingEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexAttribBindingEXT_ARGS args;
} glVertexArrayVertexAttribBindingEXT_PACKED;
#endif
#ifndef glVertexArrayVertexAttribFormatEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLuint relativeoffset;
} glVertexArrayVertexAttribFormatEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexAttribFormatEXT_ARGS args;
} glVertexArrayVertexAttribFormatEXT_PACKED;
#endif
#ifndef glVertexArrayVertexAttribIFormatEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} glVertexArrayVertexAttribIFormatEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexAttribIFormatEXT_ARGS args;
} glVertexArrayVertexAttribIFormatEXT_PACKED;
#endif
#ifndef glVertexArrayVertexAttribIOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayVertexAttribIOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexAttribIOffsetEXT_ARGS args;
} glVertexArrayVertexAttribIOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayVertexAttribLFormatEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} glVertexArrayVertexAttribLFormatEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexAttribLFormatEXT_ARGS args;
} glVertexArrayVertexAttribLFormatEXT_PACKED;
#endif
#ifndef glVertexArrayVertexAttribLOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayVertexAttribLOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexAttribLOffsetEXT_ARGS args;
} glVertexArrayVertexAttribLOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayVertexAttribOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayVertexAttribOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexAttribOffsetEXT_ARGS args;
} glVertexArrayVertexAttribOffsetEXT_PACKED;
#endif
#ifndef glVertexArrayVertexBindingDivisorEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint bindingindex;
    GLuint divisor;
} glVertexArrayVertexBindingDivisorEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexBindingDivisorEXT_ARGS args;
} glVertexArrayVertexBindingDivisorEXT_PACKED;
#endif
#ifndef glVertexArrayVertexOffsetEXT_RETURN
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} glVertexArrayVertexOffsetEXT_ARGS;
typedef struct {
    int index;
    glVertexArrayVertexOffsetEXT_ARGS args;
} glVertexArrayVertexOffsetEXT_PACKED;
#endif
#ifndef glVertexAttrib1d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} glVertexAttrib1d_ARGS;
typedef struct {
    int index;
    glVertexAttrib1d_ARGS args;
} glVertexAttrib1d_PACKED;
#endif
#ifndef glVertexAttrib1dARB_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} glVertexAttrib1dARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib1dARB_ARGS args;
} glVertexAttrib1dARB_PACKED;
#endif
#ifndef glVertexAttrib1dNV_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} glVertexAttrib1dNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1dNV_ARGS args;
} glVertexAttrib1dNV_PACKED;
#endif
#ifndef glVertexAttrib1dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib1dv_ARGS;
typedef struct {
    int index;
    glVertexAttrib1dv_ARGS args;
} glVertexAttrib1dv_PACKED;
#endif
#ifndef glVertexAttrib1dvARB_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib1dvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib1dvARB_ARGS args;
} glVertexAttrib1dvARB_PACKED;
#endif
#ifndef glVertexAttrib1dvNV_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib1dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1dvNV_ARGS args;
} glVertexAttrib1dvNV_PACKED;
#endif
#ifndef glVertexAttrib1f_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
} glVertexAttrib1f_ARGS;
typedef struct {
    int index;
    glVertexAttrib1f_ARGS args;
} glVertexAttrib1f_PACKED;
#endif
#ifndef glVertexAttrib1fARB_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
} glVertexAttrib1fARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib1fARB_ARGS args;
} glVertexAttrib1fARB_PACKED;
#endif
#ifndef glVertexAttrib1fNV_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
} glVertexAttrib1fNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1fNV_ARGS args;
} glVertexAttrib1fNV_PACKED;
#endif
#ifndef glVertexAttrib1fv_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib1fv_ARGS;
typedef struct {
    int index;
    glVertexAttrib1fv_ARGS args;
} glVertexAttrib1fv_PACKED;
#endif
#ifndef glVertexAttrib1fvARB_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib1fvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib1fvARB_ARGS args;
} glVertexAttrib1fvARB_PACKED;
#endif
#ifndef glVertexAttrib1fvNV_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib1fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1fvNV_ARGS args;
} glVertexAttrib1fvNV_PACKED;
#endif
#ifndef glVertexAttrib1hNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV x;
} glVertexAttrib1hNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1hNV_ARGS args;
} glVertexAttrib1hNV_PACKED;
#endif
#ifndef glVertexAttrib1hvNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV * v;
} glVertexAttrib1hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1hvNV_ARGS args;
} glVertexAttrib1hvNV_PACKED;
#endif
#ifndef glVertexAttrib1s_RETURN
typedef struct {
    GLuint index;
    GLshort x;
} glVertexAttrib1s_ARGS;
typedef struct {
    int index;
    glVertexAttrib1s_ARGS args;
} glVertexAttrib1s_PACKED;
#endif
#ifndef glVertexAttrib1sARB_RETURN
typedef struct {
    GLuint index;
    GLshort x;
} glVertexAttrib1sARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib1sARB_ARGS args;
} glVertexAttrib1sARB_PACKED;
#endif
#ifndef glVertexAttrib1sNV_RETURN
typedef struct {
    GLuint index;
    GLshort x;
} glVertexAttrib1sNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1sNV_ARGS args;
} glVertexAttrib1sNV_PACKED;
#endif
#ifndef glVertexAttrib1sv_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib1sv_ARGS;
typedef struct {
    int index;
    glVertexAttrib1sv_ARGS args;
} glVertexAttrib1sv_PACKED;
#endif
#ifndef glVertexAttrib1svARB_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib1svARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib1svARB_ARGS args;
} glVertexAttrib1svARB_PACKED;
#endif
#ifndef glVertexAttrib1svNV_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib1svNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib1svNV_ARGS args;
} glVertexAttrib1svNV_PACKED;
#endif
#ifndef glVertexAttrib2d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glVertexAttrib2d_ARGS;
typedef struct {
    int index;
    glVertexAttrib2d_ARGS args;
} glVertexAttrib2d_PACKED;
#endif
#ifndef glVertexAttrib2dARB_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glVertexAttrib2dARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib2dARB_ARGS args;
} glVertexAttrib2dARB_PACKED;
#endif
#ifndef glVertexAttrib2dNV_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glVertexAttrib2dNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2dNV_ARGS args;
} glVertexAttrib2dNV_PACKED;
#endif
#ifndef glVertexAttrib2dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib2dv_ARGS;
typedef struct {
    int index;
    glVertexAttrib2dv_ARGS args;
} glVertexAttrib2dv_PACKED;
#endif
#ifndef glVertexAttrib2dvARB_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib2dvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib2dvARB_ARGS args;
} glVertexAttrib2dvARB_PACKED;
#endif
#ifndef glVertexAttrib2dvNV_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib2dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2dvNV_ARGS args;
} glVertexAttrib2dvNV_PACKED;
#endif
#ifndef glVertexAttrib2f_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
} glVertexAttrib2f_ARGS;
typedef struct {
    int index;
    glVertexAttrib2f_ARGS args;
} glVertexAttrib2f_PACKED;
#endif
#ifndef glVertexAttrib2fARB_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
} glVertexAttrib2fARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib2fARB_ARGS args;
} glVertexAttrib2fARB_PACKED;
#endif
#ifndef glVertexAttrib2fNV_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
} glVertexAttrib2fNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2fNV_ARGS args;
} glVertexAttrib2fNV_PACKED;
#endif
#ifndef glVertexAttrib2fv_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib2fv_ARGS;
typedef struct {
    int index;
    glVertexAttrib2fv_ARGS args;
} glVertexAttrib2fv_PACKED;
#endif
#ifndef glVertexAttrib2fvARB_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib2fvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib2fvARB_ARGS args;
} glVertexAttrib2fvARB_PACKED;
#endif
#ifndef glVertexAttrib2fvNV_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib2fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2fvNV_ARGS args;
} glVertexAttrib2fvNV_PACKED;
#endif
#ifndef glVertexAttrib2hNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV x;
    GLhalfNV y;
} glVertexAttrib2hNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2hNV_ARGS args;
} glVertexAttrib2hNV_PACKED;
#endif
#ifndef glVertexAttrib2hvNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV * v;
} glVertexAttrib2hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2hvNV_ARGS args;
} glVertexAttrib2hvNV_PACKED;
#endif
#ifndef glVertexAttrib2s_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
} glVertexAttrib2s_ARGS;
typedef struct {
    int index;
    glVertexAttrib2s_ARGS args;
} glVertexAttrib2s_PACKED;
#endif
#ifndef glVertexAttrib2sARB_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
} glVertexAttrib2sARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib2sARB_ARGS args;
} glVertexAttrib2sARB_PACKED;
#endif
#ifndef glVertexAttrib2sNV_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
} glVertexAttrib2sNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2sNV_ARGS args;
} glVertexAttrib2sNV_PACKED;
#endif
#ifndef glVertexAttrib2sv_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib2sv_ARGS;
typedef struct {
    int index;
    glVertexAttrib2sv_ARGS args;
} glVertexAttrib2sv_PACKED;
#endif
#ifndef glVertexAttrib2svARB_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib2svARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib2svARB_ARGS args;
} glVertexAttrib2svARB_PACKED;
#endif
#ifndef glVertexAttrib2svNV_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib2svNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib2svNV_ARGS args;
} glVertexAttrib2svNV_PACKED;
#endif
#ifndef glVertexAttrib3d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glVertexAttrib3d_ARGS;
typedef struct {
    int index;
    glVertexAttrib3d_ARGS args;
} glVertexAttrib3d_PACKED;
#endif
#ifndef glVertexAttrib3dARB_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glVertexAttrib3dARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib3dARB_ARGS args;
} glVertexAttrib3dARB_PACKED;
#endif
#ifndef glVertexAttrib3dNV_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glVertexAttrib3dNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3dNV_ARGS args;
} glVertexAttrib3dNV_PACKED;
#endif
#ifndef glVertexAttrib3dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib3dv_ARGS;
typedef struct {
    int index;
    glVertexAttrib3dv_ARGS args;
} glVertexAttrib3dv_PACKED;
#endif
#ifndef glVertexAttrib3dvARB_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib3dvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib3dvARB_ARGS args;
} glVertexAttrib3dvARB_PACKED;
#endif
#ifndef glVertexAttrib3dvNV_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib3dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3dvNV_ARGS args;
} glVertexAttrib3dvNV_PACKED;
#endif
#ifndef glVertexAttrib3f_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glVertexAttrib3f_ARGS;
typedef struct {
    int index;
    glVertexAttrib3f_ARGS args;
} glVertexAttrib3f_PACKED;
#endif
#ifndef glVertexAttrib3fARB_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glVertexAttrib3fARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib3fARB_ARGS args;
} glVertexAttrib3fARB_PACKED;
#endif
#ifndef glVertexAttrib3fNV_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glVertexAttrib3fNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3fNV_ARGS args;
} glVertexAttrib3fNV_PACKED;
#endif
#ifndef glVertexAttrib3fv_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib3fv_ARGS;
typedef struct {
    int index;
    glVertexAttrib3fv_ARGS args;
} glVertexAttrib3fv_PACKED;
#endif
#ifndef glVertexAttrib3fvARB_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib3fvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib3fvARB_ARGS args;
} glVertexAttrib3fvARB_PACKED;
#endif
#ifndef glVertexAttrib3fvNV_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib3fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3fvNV_ARGS args;
} glVertexAttrib3fvNV_PACKED;
#endif
#ifndef glVertexAttrib3hNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
} glVertexAttrib3hNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3hNV_ARGS args;
} glVertexAttrib3hNV_PACKED;
#endif
#ifndef glVertexAttrib3hvNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV * v;
} glVertexAttrib3hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3hvNV_ARGS args;
} glVertexAttrib3hvNV_PACKED;
#endif
#ifndef glVertexAttrib3s_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
} glVertexAttrib3s_ARGS;
typedef struct {
    int index;
    glVertexAttrib3s_ARGS args;
} glVertexAttrib3s_PACKED;
#endif
#ifndef glVertexAttrib3sARB_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
} glVertexAttrib3sARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib3sARB_ARGS args;
} glVertexAttrib3sARB_PACKED;
#endif
#ifndef glVertexAttrib3sNV_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
} glVertexAttrib3sNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3sNV_ARGS args;
} glVertexAttrib3sNV_PACKED;
#endif
#ifndef glVertexAttrib3sv_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib3sv_ARGS;
typedef struct {
    int index;
    glVertexAttrib3sv_ARGS args;
} glVertexAttrib3sv_PACKED;
#endif
#ifndef glVertexAttrib3svARB_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib3svARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib3svARB_ARGS args;
} glVertexAttrib3svARB_PACKED;
#endif
#ifndef glVertexAttrib3svNV_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib3svNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib3svNV_ARGS args;
} glVertexAttrib3svNV_PACKED;
#endif
#ifndef glVertexAttrib4Nbv_RETURN
typedef struct {
    GLuint index;
    GLbyte * v;
} glVertexAttrib4Nbv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4Nbv_ARGS args;
} glVertexAttrib4Nbv_PACKED;
#endif
#ifndef glVertexAttrib4NbvARB_RETURN
typedef struct {
    GLuint index;
    GLbyte * v;
} glVertexAttrib4NbvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4NbvARB_ARGS args;
} glVertexAttrib4NbvARB_PACKED;
#endif
#ifndef glVertexAttrib4Niv_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttrib4Niv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4Niv_ARGS args;
} glVertexAttrib4Niv_PACKED;
#endif
#ifndef glVertexAttrib4NivARB_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttrib4NivARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4NivARB_ARGS args;
} glVertexAttrib4NivARB_PACKED;
#endif
#ifndef glVertexAttrib4Nsv_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib4Nsv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4Nsv_ARGS args;
} glVertexAttrib4Nsv_PACKED;
#endif
#ifndef glVertexAttrib4NsvARB_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib4NsvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4NsvARB_ARGS args;
} glVertexAttrib4NsvARB_PACKED;
#endif
#ifndef glVertexAttrib4Nub_RETURN
typedef struct {
    GLuint index;
    GLubyte x;
    GLubyte y;
    GLubyte z;
    GLubyte w;
} glVertexAttrib4Nub_ARGS;
typedef struct {
    int index;
    glVertexAttrib4Nub_ARGS args;
} glVertexAttrib4Nub_PACKED;
#endif
#ifndef glVertexAttrib4NubARB_RETURN
typedef struct {
    GLuint index;
    GLubyte x;
    GLubyte y;
    GLubyte z;
    GLubyte w;
} glVertexAttrib4NubARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4NubARB_ARGS args;
} glVertexAttrib4NubARB_PACKED;
#endif
#ifndef glVertexAttrib4Nubv_RETURN
typedef struct {
    GLuint index;
    GLubyte * v;
} glVertexAttrib4Nubv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4Nubv_ARGS args;
} glVertexAttrib4Nubv_PACKED;
#endif
#ifndef glVertexAttrib4NubvARB_RETURN
typedef struct {
    GLuint index;
    GLubyte * v;
} glVertexAttrib4NubvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4NubvARB_ARGS args;
} glVertexAttrib4NubvARB_PACKED;
#endif
#ifndef glVertexAttrib4Nuiv_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttrib4Nuiv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4Nuiv_ARGS args;
} glVertexAttrib4Nuiv_PACKED;
#endif
#ifndef glVertexAttrib4NuivARB_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttrib4NuivARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4NuivARB_ARGS args;
} glVertexAttrib4NuivARB_PACKED;
#endif
#ifndef glVertexAttrib4Nusv_RETURN
typedef struct {
    GLuint index;
    GLushort * v;
} glVertexAttrib4Nusv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4Nusv_ARGS args;
} glVertexAttrib4Nusv_PACKED;
#endif
#ifndef glVertexAttrib4NusvARB_RETURN
typedef struct {
    GLuint index;
    GLushort * v;
} glVertexAttrib4NusvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4NusvARB_ARGS args;
} glVertexAttrib4NusvARB_PACKED;
#endif
#ifndef glVertexAttrib4bv_RETURN
typedef struct {
    GLuint index;
    GLbyte * v;
} glVertexAttrib4bv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4bv_ARGS args;
} glVertexAttrib4bv_PACKED;
#endif
#ifndef glVertexAttrib4bvARB_RETURN
typedef struct {
    GLuint index;
    GLbyte * v;
} glVertexAttrib4bvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4bvARB_ARGS args;
} glVertexAttrib4bvARB_PACKED;
#endif
#ifndef glVertexAttrib4d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glVertexAttrib4d_ARGS;
typedef struct {
    int index;
    glVertexAttrib4d_ARGS args;
} glVertexAttrib4d_PACKED;
#endif
#ifndef glVertexAttrib4dARB_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glVertexAttrib4dARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4dARB_ARGS args;
} glVertexAttrib4dARB_PACKED;
#endif
#ifndef glVertexAttrib4dNV_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glVertexAttrib4dNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4dNV_ARGS args;
} glVertexAttrib4dNV_PACKED;
#endif
#ifndef glVertexAttrib4dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib4dv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4dv_ARGS args;
} glVertexAttrib4dv_PACKED;
#endif
#ifndef glVertexAttrib4dvARB_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib4dvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4dvARB_ARGS args;
} glVertexAttrib4dvARB_PACKED;
#endif
#ifndef glVertexAttrib4dvNV_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttrib4dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4dvNV_ARGS args;
} glVertexAttrib4dvNV_PACKED;
#endif
#ifndef glVertexAttrib4f_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glVertexAttrib4f_ARGS;
typedef struct {
    int index;
    glVertexAttrib4f_ARGS args;
} glVertexAttrib4f_PACKED;
#endif
#ifndef glVertexAttrib4fARB_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glVertexAttrib4fARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4fARB_ARGS args;
} glVertexAttrib4fARB_PACKED;
#endif
#ifndef glVertexAttrib4fNV_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glVertexAttrib4fNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4fNV_ARGS args;
} glVertexAttrib4fNV_PACKED;
#endif
#ifndef glVertexAttrib4fv_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib4fv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4fv_ARGS args;
} glVertexAttrib4fv_PACKED;
#endif
#ifndef glVertexAttrib4fvARB_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib4fvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4fvARB_ARGS args;
} glVertexAttrib4fvARB_PACKED;
#endif
#ifndef glVertexAttrib4fvNV_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glVertexAttrib4fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4fvNV_ARGS args;
} glVertexAttrib4fvNV_PACKED;
#endif
#ifndef glVertexAttrib4hNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
    GLhalfNV w;
} glVertexAttrib4hNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4hNV_ARGS args;
} glVertexAttrib4hNV_PACKED;
#endif
#ifndef glVertexAttrib4hvNV_RETURN
typedef struct {
    GLuint index;
    GLhalfNV * v;
} glVertexAttrib4hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4hvNV_ARGS args;
} glVertexAttrib4hvNV_PACKED;
#endif
#ifndef glVertexAttrib4iv_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttrib4iv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4iv_ARGS args;
} glVertexAttrib4iv_PACKED;
#endif
#ifndef glVertexAttrib4ivARB_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttrib4ivARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4ivARB_ARGS args;
} glVertexAttrib4ivARB_PACKED;
#endif
#ifndef glVertexAttrib4s_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} glVertexAttrib4s_ARGS;
typedef struct {
    int index;
    glVertexAttrib4s_ARGS args;
} glVertexAttrib4s_PACKED;
#endif
#ifndef glVertexAttrib4sARB_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} glVertexAttrib4sARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4sARB_ARGS args;
} glVertexAttrib4sARB_PACKED;
#endif
#ifndef glVertexAttrib4sNV_RETURN
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} glVertexAttrib4sNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4sNV_ARGS args;
} glVertexAttrib4sNV_PACKED;
#endif
#ifndef glVertexAttrib4sv_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib4sv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4sv_ARGS args;
} glVertexAttrib4sv_PACKED;
#endif
#ifndef glVertexAttrib4svARB_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib4svARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4svARB_ARGS args;
} glVertexAttrib4svARB_PACKED;
#endif
#ifndef glVertexAttrib4svNV_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttrib4svNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4svNV_ARGS args;
} glVertexAttrib4svNV_PACKED;
#endif
#ifndef glVertexAttrib4ubNV_RETURN
typedef struct {
    GLuint index;
    GLubyte x;
    GLubyte y;
    GLubyte z;
    GLubyte w;
} glVertexAttrib4ubNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4ubNV_ARGS args;
} glVertexAttrib4ubNV_PACKED;
#endif
#ifndef glVertexAttrib4ubv_RETURN
typedef struct {
    GLuint index;
    GLubyte * v;
} glVertexAttrib4ubv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4ubv_ARGS args;
} glVertexAttrib4ubv_PACKED;
#endif
#ifndef glVertexAttrib4ubvARB_RETURN
typedef struct {
    GLuint index;
    GLubyte * v;
} glVertexAttrib4ubvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4ubvARB_ARGS args;
} glVertexAttrib4ubvARB_PACKED;
#endif
#ifndef glVertexAttrib4ubvNV_RETURN
typedef struct {
    GLuint index;
    GLubyte * v;
} glVertexAttrib4ubvNV_ARGS;
typedef struct {
    int index;
    glVertexAttrib4ubvNV_ARGS args;
} glVertexAttrib4ubvNV_PACKED;
#endif
#ifndef glVertexAttrib4uiv_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttrib4uiv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4uiv_ARGS args;
} glVertexAttrib4uiv_PACKED;
#endif
#ifndef glVertexAttrib4uivARB_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttrib4uivARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4uivARB_ARGS args;
} glVertexAttrib4uivARB_PACKED;
#endif
#ifndef glVertexAttrib4usv_RETURN
typedef struct {
    GLuint index;
    GLushort * v;
} glVertexAttrib4usv_ARGS;
typedef struct {
    int index;
    glVertexAttrib4usv_ARGS args;
} glVertexAttrib4usv_PACKED;
#endif
#ifndef glVertexAttrib4usvARB_RETURN
typedef struct {
    GLuint index;
    GLushort * v;
} glVertexAttrib4usvARB_ARGS;
typedef struct {
    int index;
    glVertexAttrib4usvARB_ARGS args;
} glVertexAttrib4usvARB_PACKED;
#endif
#ifndef glVertexAttribArrayObjectATI_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLuint buffer;
    GLuint offset;
} glVertexAttribArrayObjectATI_ARGS;
typedef struct {
    int index;
    glVertexAttribArrayObjectATI_ARGS args;
} glVertexAttribArrayObjectATI_PACKED;
#endif
#ifndef glVertexAttribBinding_RETURN
typedef struct {
    GLuint attribindex;
    GLuint bindingindex;
} glVertexAttribBinding_ARGS;
typedef struct {
    int index;
    glVertexAttribBinding_ARGS args;
} glVertexAttribBinding_PACKED;
#endif
#ifndef glVertexAttribDivisor_RETURN
typedef struct {
    GLuint index;
    GLuint divisor;
} glVertexAttribDivisor_ARGS;
typedef struct {
    int index;
    glVertexAttribDivisor_ARGS args;
} glVertexAttribDivisor_PACKED;
#endif
#ifndef glVertexAttribDivisorARB_RETURN
typedef struct {
    GLuint index;
    GLuint divisor;
} glVertexAttribDivisorARB_ARGS;
typedef struct {
    int index;
    glVertexAttribDivisorARB_ARGS args;
} glVertexAttribDivisorARB_PACKED;
#endif
#ifndef glVertexAttribFormat_RETURN
typedef struct {
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLuint relativeoffset;
} glVertexAttribFormat_ARGS;
typedef struct {
    int index;
    glVertexAttribFormat_ARGS args;
} glVertexAttribFormat_PACKED;
#endif
#ifndef glVertexAttribFormatNV_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
} glVertexAttribFormatNV_ARGS;
typedef struct {
    int index;
    glVertexAttribFormatNV_ARGS args;
} glVertexAttribFormatNV_PACKED;
#endif
#ifndef glVertexAttribI1i_RETURN
typedef struct {
    GLuint index;
    GLint x;
} glVertexAttribI1i_ARGS;
typedef struct {
    int index;
    glVertexAttribI1i_ARGS args;
} glVertexAttribI1i_PACKED;
#endif
#ifndef glVertexAttribI1iEXT_RETURN
typedef struct {
    GLuint index;
    GLint x;
} glVertexAttribI1iEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI1iEXT_ARGS args;
} glVertexAttribI1iEXT_PACKED;
#endif
#ifndef glVertexAttribI1iv_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI1iv_ARGS;
typedef struct {
    int index;
    glVertexAttribI1iv_ARGS args;
} glVertexAttribI1iv_PACKED;
#endif
#ifndef glVertexAttribI1ivEXT_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI1ivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI1ivEXT_ARGS args;
} glVertexAttribI1ivEXT_PACKED;
#endif
#ifndef glVertexAttribI1ui_RETURN
typedef struct {
    GLuint index;
    GLuint x;
} glVertexAttribI1ui_ARGS;
typedef struct {
    int index;
    glVertexAttribI1ui_ARGS args;
} glVertexAttribI1ui_PACKED;
#endif
#ifndef glVertexAttribI1uiEXT_RETURN
typedef struct {
    GLuint index;
    GLuint x;
} glVertexAttribI1uiEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI1uiEXT_ARGS args;
} glVertexAttribI1uiEXT_PACKED;
#endif
#ifndef glVertexAttribI1uiv_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI1uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribI1uiv_ARGS args;
} glVertexAttribI1uiv_PACKED;
#endif
#ifndef glVertexAttribI1uivEXT_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI1uivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI1uivEXT_ARGS args;
} glVertexAttribI1uivEXT_PACKED;
#endif
#ifndef glVertexAttribI2i_RETURN
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
} glVertexAttribI2i_ARGS;
typedef struct {
    int index;
    glVertexAttribI2i_ARGS args;
} glVertexAttribI2i_PACKED;
#endif
#ifndef glVertexAttribI2iEXT_RETURN
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
} glVertexAttribI2iEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI2iEXT_ARGS args;
} glVertexAttribI2iEXT_PACKED;
#endif
#ifndef glVertexAttribI2iv_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI2iv_ARGS;
typedef struct {
    int index;
    glVertexAttribI2iv_ARGS args;
} glVertexAttribI2iv_PACKED;
#endif
#ifndef glVertexAttribI2ivEXT_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI2ivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI2ivEXT_ARGS args;
} glVertexAttribI2ivEXT_PACKED;
#endif
#ifndef glVertexAttribI2ui_RETURN
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
} glVertexAttribI2ui_ARGS;
typedef struct {
    int index;
    glVertexAttribI2ui_ARGS args;
} glVertexAttribI2ui_PACKED;
#endif
#ifndef glVertexAttribI2uiEXT_RETURN
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
} glVertexAttribI2uiEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI2uiEXT_ARGS args;
} glVertexAttribI2uiEXT_PACKED;
#endif
#ifndef glVertexAttribI2uiv_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI2uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribI2uiv_ARGS args;
} glVertexAttribI2uiv_PACKED;
#endif
#ifndef glVertexAttribI2uivEXT_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI2uivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI2uivEXT_ARGS args;
} glVertexAttribI2uivEXT_PACKED;
#endif
#ifndef glVertexAttribI3i_RETURN
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
} glVertexAttribI3i_ARGS;
typedef struct {
    int index;
    glVertexAttribI3i_ARGS args;
} glVertexAttribI3i_PACKED;
#endif
#ifndef glVertexAttribI3iEXT_RETURN
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
} glVertexAttribI3iEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI3iEXT_ARGS args;
} glVertexAttribI3iEXT_PACKED;
#endif
#ifndef glVertexAttribI3iv_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI3iv_ARGS;
typedef struct {
    int index;
    glVertexAttribI3iv_ARGS args;
} glVertexAttribI3iv_PACKED;
#endif
#ifndef glVertexAttribI3ivEXT_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI3ivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI3ivEXT_ARGS args;
} glVertexAttribI3ivEXT_PACKED;
#endif
#ifndef glVertexAttribI3ui_RETURN
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
} glVertexAttribI3ui_ARGS;
typedef struct {
    int index;
    glVertexAttribI3ui_ARGS args;
} glVertexAttribI3ui_PACKED;
#endif
#ifndef glVertexAttribI3uiEXT_RETURN
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
} glVertexAttribI3uiEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI3uiEXT_ARGS args;
} glVertexAttribI3uiEXT_PACKED;
#endif
#ifndef glVertexAttribI3uiv_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI3uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribI3uiv_ARGS args;
} glVertexAttribI3uiv_PACKED;
#endif
#ifndef glVertexAttribI3uivEXT_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI3uivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI3uivEXT_ARGS args;
} glVertexAttribI3uivEXT_PACKED;
#endif
#ifndef glVertexAttribI4bv_RETURN
typedef struct {
    GLuint index;
    GLbyte * v;
} glVertexAttribI4bv_ARGS;
typedef struct {
    int index;
    glVertexAttribI4bv_ARGS args;
} glVertexAttribI4bv_PACKED;
#endif
#ifndef glVertexAttribI4bvEXT_RETURN
typedef struct {
    GLuint index;
    GLbyte * v;
} glVertexAttribI4bvEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4bvEXT_ARGS args;
} glVertexAttribI4bvEXT_PACKED;
#endif
#ifndef glVertexAttribI4i_RETURN
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glVertexAttribI4i_ARGS;
typedef struct {
    int index;
    glVertexAttribI4i_ARGS args;
} glVertexAttribI4i_PACKED;
#endif
#ifndef glVertexAttribI4iEXT_RETURN
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glVertexAttribI4iEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4iEXT_ARGS args;
} glVertexAttribI4iEXT_PACKED;
#endif
#ifndef glVertexAttribI4iv_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI4iv_ARGS;
typedef struct {
    int index;
    glVertexAttribI4iv_ARGS args;
} glVertexAttribI4iv_PACKED;
#endif
#ifndef glVertexAttribI4ivEXT_RETURN
typedef struct {
    GLuint index;
    GLint * v;
} glVertexAttribI4ivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4ivEXT_ARGS args;
} glVertexAttribI4ivEXT_PACKED;
#endif
#ifndef glVertexAttribI4sv_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttribI4sv_ARGS;
typedef struct {
    int index;
    glVertexAttribI4sv_ARGS args;
} glVertexAttribI4sv_PACKED;
#endif
#ifndef glVertexAttribI4svEXT_RETURN
typedef struct {
    GLuint index;
    GLshort * v;
} glVertexAttribI4svEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4svEXT_ARGS args;
} glVertexAttribI4svEXT_PACKED;
#endif
#ifndef glVertexAttribI4ubv_RETURN
typedef struct {
    GLuint index;
    GLubyte * v;
} glVertexAttribI4ubv_ARGS;
typedef struct {
    int index;
    glVertexAttribI4ubv_ARGS args;
} glVertexAttribI4ubv_PACKED;
#endif
#ifndef glVertexAttribI4ubvEXT_RETURN
typedef struct {
    GLuint index;
    GLubyte * v;
} glVertexAttribI4ubvEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4ubvEXT_ARGS args;
} glVertexAttribI4ubvEXT_PACKED;
#endif
#ifndef glVertexAttribI4ui_RETURN
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} glVertexAttribI4ui_ARGS;
typedef struct {
    int index;
    glVertexAttribI4ui_ARGS args;
} glVertexAttribI4ui_PACKED;
#endif
#ifndef glVertexAttribI4uiEXT_RETURN
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} glVertexAttribI4uiEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4uiEXT_ARGS args;
} glVertexAttribI4uiEXT_PACKED;
#endif
#ifndef glVertexAttribI4uiv_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI4uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribI4uiv_ARGS args;
} glVertexAttribI4uiv_PACKED;
#endif
#ifndef glVertexAttribI4uivEXT_RETURN
typedef struct {
    GLuint index;
    GLuint * v;
} glVertexAttribI4uivEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4uivEXT_ARGS args;
} glVertexAttribI4uivEXT_PACKED;
#endif
#ifndef glVertexAttribI4usv_RETURN
typedef struct {
    GLuint index;
    GLushort * v;
} glVertexAttribI4usv_ARGS;
typedef struct {
    int index;
    glVertexAttribI4usv_ARGS args;
} glVertexAttribI4usv_PACKED;
#endif
#ifndef glVertexAttribI4usvEXT_RETURN
typedef struct {
    GLuint index;
    GLushort * v;
} glVertexAttribI4usvEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribI4usvEXT_ARGS args;
} glVertexAttribI4usvEXT_PACKED;
#endif
#ifndef glVertexAttribIFormat_RETURN
typedef struct {
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} glVertexAttribIFormat_ARGS;
typedef struct {
    int index;
    glVertexAttribIFormat_ARGS args;
} glVertexAttribIFormat_PACKED;
#endif
#ifndef glVertexAttribIFormatNV_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
} glVertexAttribIFormatNV_ARGS;
typedef struct {
    int index;
    glVertexAttribIFormatNV_ARGS args;
} glVertexAttribIFormatNV_PACKED;
#endif
#ifndef glVertexAttribIPointer_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glVertexAttribIPointer_ARGS;
typedef struct {
    int index;
    glVertexAttribIPointer_ARGS args;
} glVertexAttribIPointer_PACKED;
#endif
#ifndef glVertexAttribIPointerEXT_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glVertexAttribIPointerEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribIPointerEXT_ARGS args;
} glVertexAttribIPointerEXT_PACKED;
#endif
#ifndef glVertexAttribL1d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} glVertexAttribL1d_ARGS;
typedef struct {
    int index;
    glVertexAttribL1d_ARGS args;
} glVertexAttribL1d_PACKED;
#endif
#ifndef glVertexAttribL1dEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} glVertexAttribL1dEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL1dEXT_ARGS args;
} glVertexAttribL1dEXT_PACKED;
#endif
#ifndef glVertexAttribL1dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL1dv_ARGS;
typedef struct {
    int index;
    glVertexAttribL1dv_ARGS args;
} glVertexAttribL1dv_PACKED;
#endif
#ifndef glVertexAttribL1dvEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL1dvEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL1dvEXT_ARGS args;
} glVertexAttribL1dvEXT_PACKED;
#endif
#ifndef glVertexAttribL1i64NV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT x;
} glVertexAttribL1i64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL1i64NV_ARGS args;
} glVertexAttribL1i64NV_PACKED;
#endif
#ifndef glVertexAttribL1i64vNV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT * v;
} glVertexAttribL1i64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL1i64vNV_ARGS args;
} glVertexAttribL1i64vNV_PACKED;
#endif
#ifndef glVertexAttribL1ui64NV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT x;
} glVertexAttribL1ui64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL1ui64NV_ARGS args;
} glVertexAttribL1ui64NV_PACKED;
#endif
#ifndef glVertexAttribL1ui64vNV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} glVertexAttribL1ui64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL1ui64vNV_ARGS args;
} glVertexAttribL1ui64vNV_PACKED;
#endif
#ifndef glVertexAttribL2d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glVertexAttribL2d_ARGS;
typedef struct {
    int index;
    glVertexAttribL2d_ARGS args;
} glVertexAttribL2d_PACKED;
#endif
#ifndef glVertexAttribL2dEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glVertexAttribL2dEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL2dEXT_ARGS args;
} glVertexAttribL2dEXT_PACKED;
#endif
#ifndef glVertexAttribL2dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL2dv_ARGS;
typedef struct {
    int index;
    glVertexAttribL2dv_ARGS args;
} glVertexAttribL2dv_PACKED;
#endif
#ifndef glVertexAttribL2dvEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL2dvEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL2dvEXT_ARGS args;
} glVertexAttribL2dvEXT_PACKED;
#endif
#ifndef glVertexAttribL2i64NV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT x;
    GLint64EXT y;
} glVertexAttribL2i64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL2i64NV_ARGS args;
} glVertexAttribL2i64NV_PACKED;
#endif
#ifndef glVertexAttribL2i64vNV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT * v;
} glVertexAttribL2i64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL2i64vNV_ARGS args;
} glVertexAttribL2i64vNV_PACKED;
#endif
#ifndef glVertexAttribL2ui64NV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT x;
    GLuint64EXT y;
} glVertexAttribL2ui64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL2ui64NV_ARGS args;
} glVertexAttribL2ui64NV_PACKED;
#endif
#ifndef glVertexAttribL2ui64vNV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} glVertexAttribL2ui64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL2ui64vNV_ARGS args;
} glVertexAttribL2ui64vNV_PACKED;
#endif
#ifndef glVertexAttribL3d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glVertexAttribL3d_ARGS;
typedef struct {
    int index;
    glVertexAttribL3d_ARGS args;
} glVertexAttribL3d_PACKED;
#endif
#ifndef glVertexAttribL3dEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glVertexAttribL3dEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL3dEXT_ARGS args;
} glVertexAttribL3dEXT_PACKED;
#endif
#ifndef glVertexAttribL3dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL3dv_ARGS;
typedef struct {
    int index;
    glVertexAttribL3dv_ARGS args;
} glVertexAttribL3dv_PACKED;
#endif
#ifndef glVertexAttribL3dvEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL3dvEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL3dvEXT_ARGS args;
} glVertexAttribL3dvEXT_PACKED;
#endif
#ifndef glVertexAttribL3i64NV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
} glVertexAttribL3i64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL3i64NV_ARGS args;
} glVertexAttribL3i64NV_PACKED;
#endif
#ifndef glVertexAttribL3i64vNV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT * v;
} glVertexAttribL3i64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL3i64vNV_ARGS args;
} glVertexAttribL3i64vNV_PACKED;
#endif
#ifndef glVertexAttribL3ui64NV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
} glVertexAttribL3ui64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL3ui64NV_ARGS args;
} glVertexAttribL3ui64NV_PACKED;
#endif
#ifndef glVertexAttribL3ui64vNV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} glVertexAttribL3ui64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL3ui64vNV_ARGS args;
} glVertexAttribL3ui64vNV_PACKED;
#endif
#ifndef glVertexAttribL4d_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glVertexAttribL4d_ARGS;
typedef struct {
    int index;
    glVertexAttribL4d_ARGS args;
} glVertexAttribL4d_PACKED;
#endif
#ifndef glVertexAttribL4dEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glVertexAttribL4dEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL4dEXT_ARGS args;
} glVertexAttribL4dEXT_PACKED;
#endif
#ifndef glVertexAttribL4dv_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL4dv_ARGS;
typedef struct {
    int index;
    glVertexAttribL4dv_ARGS args;
} glVertexAttribL4dv_PACKED;
#endif
#ifndef glVertexAttribL4dvEXT_RETURN
typedef struct {
    GLuint index;
    GLdouble * v;
} glVertexAttribL4dvEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribL4dvEXT_ARGS args;
} glVertexAttribL4dvEXT_PACKED;
#endif
#ifndef glVertexAttribL4i64NV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
    GLint64EXT w;
} glVertexAttribL4i64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL4i64NV_ARGS args;
} glVertexAttribL4i64NV_PACKED;
#endif
#ifndef glVertexAttribL4i64vNV_RETURN
typedef struct {
    GLuint index;
    GLint64EXT * v;
} glVertexAttribL4i64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL4i64vNV_ARGS args;
} glVertexAttribL4i64vNV_PACKED;
#endif
#ifndef glVertexAttribL4ui64NV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
    GLuint64EXT w;
} glVertexAttribL4ui64NV_ARGS;
typedef struct {
    int index;
    glVertexAttribL4ui64NV_ARGS args;
} glVertexAttribL4ui64NV_PACKED;
#endif
#ifndef glVertexAttribL4ui64vNV_RETURN
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} glVertexAttribL4ui64vNV_ARGS;
typedef struct {
    int index;
    glVertexAttribL4ui64vNV_ARGS args;
} glVertexAttribL4ui64vNV_PACKED;
#endif
#ifndef glVertexAttribLFormat_RETURN
typedef struct {
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} glVertexAttribLFormat_ARGS;
typedef struct {
    int index;
    glVertexAttribLFormat_ARGS args;
} glVertexAttribLFormat_PACKED;
#endif
#ifndef glVertexAttribLFormatNV_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
} glVertexAttribLFormatNV_ARGS;
typedef struct {
    int index;
    glVertexAttribLFormatNV_ARGS args;
} glVertexAttribLFormatNV_PACKED;
#endif
#ifndef glVertexAttribLPointer_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glVertexAttribLPointer_ARGS;
typedef struct {
    int index;
    glVertexAttribLPointer_ARGS args;
} glVertexAttribLPointer_PACKED;
#endif
#ifndef glVertexAttribLPointerEXT_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glVertexAttribLPointerEXT_ARGS;
typedef struct {
    int index;
    glVertexAttribLPointerEXT_ARGS args;
} glVertexAttribLPointerEXT_PACKED;
#endif
#ifndef glVertexAttribP1ui_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} glVertexAttribP1ui_ARGS;
typedef struct {
    int index;
    glVertexAttribP1ui_ARGS args;
} glVertexAttribP1ui_PACKED;
#endif
#ifndef glVertexAttribP1uiv_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} glVertexAttribP1uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribP1uiv_ARGS args;
} glVertexAttribP1uiv_PACKED;
#endif
#ifndef glVertexAttribP2ui_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} glVertexAttribP2ui_ARGS;
typedef struct {
    int index;
    glVertexAttribP2ui_ARGS args;
} glVertexAttribP2ui_PACKED;
#endif
#ifndef glVertexAttribP2uiv_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} glVertexAttribP2uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribP2uiv_ARGS args;
} glVertexAttribP2uiv_PACKED;
#endif
#ifndef glVertexAttribP3ui_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} glVertexAttribP3ui_ARGS;
typedef struct {
    int index;
    glVertexAttribP3ui_ARGS args;
} glVertexAttribP3ui_PACKED;
#endif
#ifndef glVertexAttribP3uiv_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} glVertexAttribP3uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribP3uiv_ARGS args;
} glVertexAttribP3uiv_PACKED;
#endif
#ifndef glVertexAttribP4ui_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} glVertexAttribP4ui_ARGS;
typedef struct {
    int index;
    glVertexAttribP4ui_ARGS args;
} glVertexAttribP4ui_PACKED;
#endif
#ifndef glVertexAttribP4uiv_RETURN
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} glVertexAttribP4uiv_ARGS;
typedef struct {
    int index;
    glVertexAttribP4uiv_ARGS args;
} glVertexAttribP4uiv_PACKED;
#endif
#ifndef glVertexAttribPointer_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLvoid * pointer;
} glVertexAttribPointer_ARGS;
typedef struct {
    int index;
    glVertexAttribPointer_ARGS args;
} glVertexAttribPointer_PACKED;
#endif
#ifndef glVertexAttribPointerARB_RETURN
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLvoid * pointer;
} glVertexAttribPointerARB_ARGS;
typedef struct {
    int index;
    glVertexAttribPointerARB_ARGS args;
} glVertexAttribPointerARB_PACKED;
#endif
#ifndef glVertexAttribPointerNV_RETURN
typedef struct {
    GLuint index;
    GLint fsize;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glVertexAttribPointerNV_ARGS;
typedef struct {
    int index;
    glVertexAttribPointerNV_ARGS args;
} glVertexAttribPointerNV_PACKED;
#endif
#ifndef glVertexAttribs1dvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} glVertexAttribs1dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs1dvNV_ARGS args;
} glVertexAttribs1dvNV_PACKED;
#endif
#ifndef glVertexAttribs1fvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} glVertexAttribs1fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs1fvNV_ARGS args;
} glVertexAttribs1fvNV_PACKED;
#endif
#ifndef glVertexAttribs1hvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} glVertexAttribs1hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs1hvNV_ARGS args;
} glVertexAttribs1hvNV_PACKED;
#endif
#ifndef glVertexAttribs1svNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} glVertexAttribs1svNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs1svNV_ARGS args;
} glVertexAttribs1svNV_PACKED;
#endif
#ifndef glVertexAttribs2dvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} glVertexAttribs2dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs2dvNV_ARGS args;
} glVertexAttribs2dvNV_PACKED;
#endif
#ifndef glVertexAttribs2fvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} glVertexAttribs2fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs2fvNV_ARGS args;
} glVertexAttribs2fvNV_PACKED;
#endif
#ifndef glVertexAttribs2hvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} glVertexAttribs2hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs2hvNV_ARGS args;
} glVertexAttribs2hvNV_PACKED;
#endif
#ifndef glVertexAttribs2svNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} glVertexAttribs2svNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs2svNV_ARGS args;
} glVertexAttribs2svNV_PACKED;
#endif
#ifndef glVertexAttribs3dvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} glVertexAttribs3dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs3dvNV_ARGS args;
} glVertexAttribs3dvNV_PACKED;
#endif
#ifndef glVertexAttribs3fvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} glVertexAttribs3fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs3fvNV_ARGS args;
} glVertexAttribs3fvNV_PACKED;
#endif
#ifndef glVertexAttribs3hvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} glVertexAttribs3hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs3hvNV_ARGS args;
} glVertexAttribs3hvNV_PACKED;
#endif
#ifndef glVertexAttribs3svNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} glVertexAttribs3svNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs3svNV_ARGS args;
} glVertexAttribs3svNV_PACKED;
#endif
#ifndef glVertexAttribs4dvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} glVertexAttribs4dvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs4dvNV_ARGS args;
} glVertexAttribs4dvNV_PACKED;
#endif
#ifndef glVertexAttribs4fvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} glVertexAttribs4fvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs4fvNV_ARGS args;
} glVertexAttribs4fvNV_PACKED;
#endif
#ifndef glVertexAttribs4hvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} glVertexAttribs4hvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs4hvNV_ARGS args;
} glVertexAttribs4hvNV_PACKED;
#endif
#ifndef glVertexAttribs4svNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} glVertexAttribs4svNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs4svNV_ARGS args;
} glVertexAttribs4svNV_PACKED;
#endif
#ifndef glVertexAttribs4ubvNV_RETURN
typedef struct {
    GLuint index;
    GLsizei count;
    GLubyte * v;
} glVertexAttribs4ubvNV_ARGS;
typedef struct {
    int index;
    glVertexAttribs4ubvNV_ARGS args;
} glVertexAttribs4ubvNV_PACKED;
#endif
#ifndef glVertexBindingDivisor_RETURN
typedef struct {
    GLuint bindingindex;
    GLuint divisor;
} glVertexBindingDivisor_ARGS;
typedef struct {
    int index;
    glVertexBindingDivisor_ARGS args;
} glVertexBindingDivisor_PACKED;
#endif
#ifndef glVertexBlendARB_RETURN
typedef struct {
    GLint count;
} glVertexBlendARB_ARGS;
typedef struct {
    int index;
    glVertexBlendARB_ARGS args;
} glVertexBlendARB_PACKED;
#endif
#ifndef glVertexBlendEnvfATI_RETURN
typedef struct {
    GLenum pname;
    GLfloat param;
} glVertexBlendEnvfATI_ARGS;
typedef struct {
    int index;
    glVertexBlendEnvfATI_ARGS args;
} glVertexBlendEnvfATI_PACKED;
#endif
#ifndef glVertexBlendEnviATI_RETURN
typedef struct {
    GLenum pname;
    GLint param;
} glVertexBlendEnviATI_ARGS;
typedef struct {
    int index;
    glVertexBlendEnviATI_ARGS args;
} glVertexBlendEnviATI_PACKED;
#endif
#ifndef glVertexFormatNV_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} glVertexFormatNV_ARGS;
typedef struct {
    int index;
    glVertexFormatNV_ARGS args;
} glVertexFormatNV_PACKED;
#endif
#ifndef glVertexP2ui_RETURN
typedef struct {
    GLenum type;
    GLuint value;
} glVertexP2ui_ARGS;
typedef struct {
    int index;
    glVertexP2ui_ARGS args;
} glVertexP2ui_PACKED;
#endif
#ifndef glVertexP2uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * value;
} glVertexP2uiv_ARGS;
typedef struct {
    int index;
    glVertexP2uiv_ARGS args;
} glVertexP2uiv_PACKED;
#endif
#ifndef glVertexP3ui_RETURN
typedef struct {
    GLenum type;
    GLuint value;
} glVertexP3ui_ARGS;
typedef struct {
    int index;
    glVertexP3ui_ARGS args;
} glVertexP3ui_PACKED;
#endif
#ifndef glVertexP3uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * value;
} glVertexP3uiv_ARGS;
typedef struct {
    int index;
    glVertexP3uiv_ARGS args;
} glVertexP3uiv_PACKED;
#endif
#ifndef glVertexP4ui_RETURN
typedef struct {
    GLenum type;
    GLuint value;
} glVertexP4ui_ARGS;
typedef struct {
    int index;
    glVertexP4ui_ARGS args;
} glVertexP4ui_PACKED;
#endif
#ifndef glVertexP4uiv_RETURN
typedef struct {
    GLenum type;
    GLuint * value;
} glVertexP4uiv_ARGS;
typedef struct {
    int index;
    glVertexP4uiv_ARGS args;
} glVertexP4uiv_PACKED;
#endif
#ifndef glVertexPointer_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glVertexPointer_ARGS;
typedef struct {
    int index;
    glVertexPointer_ARGS args;
} glVertexPointer_PACKED;
#endif
#ifndef glVertexPointerEXT_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} glVertexPointerEXT_ARGS;
typedef struct {
    int index;
    glVertexPointerEXT_ARGS args;
} glVertexPointerEXT_PACKED;
#endif
#ifndef glVertexPointerListIBM_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} glVertexPointerListIBM_ARGS;
typedef struct {
    int index;
    glVertexPointerListIBM_ARGS args;
} glVertexPointerListIBM_PACKED;
#endif
#ifndef glVertexPointervINTEL_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLvoid * pointer;
} glVertexPointervINTEL_ARGS;
typedef struct {
    int index;
    glVertexPointervINTEL_ARGS args;
} glVertexPointervINTEL_PACKED;
#endif
#ifndef glVertexStream1dATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
} glVertexStream1dATI_ARGS;
typedef struct {
    int index;
    glVertexStream1dATI_ARGS args;
} glVertexStream1dATI_PACKED;
#endif
#ifndef glVertexStream1dvATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble * coords;
} glVertexStream1dvATI_ARGS;
typedef struct {
    int index;
    glVertexStream1dvATI_ARGS args;
} glVertexStream1dvATI_PACKED;
#endif
#ifndef glVertexStream1fATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat x;
} glVertexStream1fATI_ARGS;
typedef struct {
    int index;
    glVertexStream1fATI_ARGS args;
} glVertexStream1fATI_PACKED;
#endif
#ifndef glVertexStream1fvATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat * coords;
} glVertexStream1fvATI_ARGS;
typedef struct {
    int index;
    glVertexStream1fvATI_ARGS args;
} glVertexStream1fvATI_PACKED;
#endif
#ifndef glVertexStream1iATI_RETURN
typedef struct {
    GLenum stream;
    GLint x;
} glVertexStream1iATI_ARGS;
typedef struct {
    int index;
    glVertexStream1iATI_ARGS args;
} glVertexStream1iATI_PACKED;
#endif
#ifndef glVertexStream1ivATI_RETURN
typedef struct {
    GLenum stream;
    GLint * coords;
} glVertexStream1ivATI_ARGS;
typedef struct {
    int index;
    glVertexStream1ivATI_ARGS args;
} glVertexStream1ivATI_PACKED;
#endif
#ifndef glVertexStream1sATI_RETURN
typedef struct {
    GLenum stream;
    GLshort x;
} glVertexStream1sATI_ARGS;
typedef struct {
    int index;
    glVertexStream1sATI_ARGS args;
} glVertexStream1sATI_PACKED;
#endif
#ifndef glVertexStream1svATI_RETURN
typedef struct {
    GLenum stream;
    GLshort * coords;
} glVertexStream1svATI_ARGS;
typedef struct {
    int index;
    glVertexStream1svATI_ARGS args;
} glVertexStream1svATI_PACKED;
#endif
#ifndef glVertexStream2dATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glVertexStream2dATI_ARGS;
typedef struct {
    int index;
    glVertexStream2dATI_ARGS args;
} glVertexStream2dATI_PACKED;
#endif
#ifndef glVertexStream2dvATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble * coords;
} glVertexStream2dvATI_ARGS;
typedef struct {
    int index;
    glVertexStream2dvATI_ARGS args;
} glVertexStream2dvATI_PACKED;
#endif
#ifndef glVertexStream2fATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat x;
    GLfloat y;
} glVertexStream2fATI_ARGS;
typedef struct {
    int index;
    glVertexStream2fATI_ARGS args;
} glVertexStream2fATI_PACKED;
#endif
#ifndef glVertexStream2fvATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat * coords;
} glVertexStream2fvATI_ARGS;
typedef struct {
    int index;
    glVertexStream2fvATI_ARGS args;
} glVertexStream2fvATI_PACKED;
#endif
#ifndef glVertexStream2iATI_RETURN
typedef struct {
    GLenum stream;
    GLint x;
    GLint y;
} glVertexStream2iATI_ARGS;
typedef struct {
    int index;
    glVertexStream2iATI_ARGS args;
} glVertexStream2iATI_PACKED;
#endif
#ifndef glVertexStream2ivATI_RETURN
typedef struct {
    GLenum stream;
    GLint * coords;
} glVertexStream2ivATI_ARGS;
typedef struct {
    int index;
    glVertexStream2ivATI_ARGS args;
} glVertexStream2ivATI_PACKED;
#endif
#ifndef glVertexStream2sATI_RETURN
typedef struct {
    GLenum stream;
    GLshort x;
    GLshort y;
} glVertexStream2sATI_ARGS;
typedef struct {
    int index;
    glVertexStream2sATI_ARGS args;
} glVertexStream2sATI_PACKED;
#endif
#ifndef glVertexStream2svATI_RETURN
typedef struct {
    GLenum stream;
    GLshort * coords;
} glVertexStream2svATI_ARGS;
typedef struct {
    int index;
    glVertexStream2svATI_ARGS args;
} glVertexStream2svATI_PACKED;
#endif
#ifndef glVertexStream3dATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glVertexStream3dATI_ARGS;
typedef struct {
    int index;
    glVertexStream3dATI_ARGS args;
} glVertexStream3dATI_PACKED;
#endif
#ifndef glVertexStream3dvATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble * coords;
} glVertexStream3dvATI_ARGS;
typedef struct {
    int index;
    glVertexStream3dvATI_ARGS args;
} glVertexStream3dvATI_PACKED;
#endif
#ifndef glVertexStream3fATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glVertexStream3fATI_ARGS;
typedef struct {
    int index;
    glVertexStream3fATI_ARGS args;
} glVertexStream3fATI_PACKED;
#endif
#ifndef glVertexStream3fvATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat * coords;
} glVertexStream3fvATI_ARGS;
typedef struct {
    int index;
    glVertexStream3fvATI_ARGS args;
} glVertexStream3fvATI_PACKED;
#endif
#ifndef glVertexStream3iATI_RETURN
typedef struct {
    GLenum stream;
    GLint x;
    GLint y;
    GLint z;
} glVertexStream3iATI_ARGS;
typedef struct {
    int index;
    glVertexStream3iATI_ARGS args;
} glVertexStream3iATI_PACKED;
#endif
#ifndef glVertexStream3ivATI_RETURN
typedef struct {
    GLenum stream;
    GLint * coords;
} glVertexStream3ivATI_ARGS;
typedef struct {
    int index;
    glVertexStream3ivATI_ARGS args;
} glVertexStream3ivATI_PACKED;
#endif
#ifndef glVertexStream3sATI_RETURN
typedef struct {
    GLenum stream;
    GLshort x;
    GLshort y;
    GLshort z;
} glVertexStream3sATI_ARGS;
typedef struct {
    int index;
    glVertexStream3sATI_ARGS args;
} glVertexStream3sATI_PACKED;
#endif
#ifndef glVertexStream3svATI_RETURN
typedef struct {
    GLenum stream;
    GLshort * coords;
} glVertexStream3svATI_ARGS;
typedef struct {
    int index;
    glVertexStream3svATI_ARGS args;
} glVertexStream3svATI_PACKED;
#endif
#ifndef glVertexStream4dATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glVertexStream4dATI_ARGS;
typedef struct {
    int index;
    glVertexStream4dATI_ARGS args;
} glVertexStream4dATI_PACKED;
#endif
#ifndef glVertexStream4dvATI_RETURN
typedef struct {
    GLenum stream;
    GLdouble * coords;
} glVertexStream4dvATI_ARGS;
typedef struct {
    int index;
    glVertexStream4dvATI_ARGS args;
} glVertexStream4dvATI_PACKED;
#endif
#ifndef glVertexStream4fATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glVertexStream4fATI_ARGS;
typedef struct {
    int index;
    glVertexStream4fATI_ARGS args;
} glVertexStream4fATI_PACKED;
#endif
#ifndef glVertexStream4fvATI_RETURN
typedef struct {
    GLenum stream;
    GLfloat * coords;
} glVertexStream4fvATI_ARGS;
typedef struct {
    int index;
    glVertexStream4fvATI_ARGS args;
} glVertexStream4fvATI_PACKED;
#endif
#ifndef glVertexStream4iATI_RETURN
typedef struct {
    GLenum stream;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glVertexStream4iATI_ARGS;
typedef struct {
    int index;
    glVertexStream4iATI_ARGS args;
} glVertexStream4iATI_PACKED;
#endif
#ifndef glVertexStream4ivATI_RETURN
typedef struct {
    GLenum stream;
    GLint * coords;
} glVertexStream4ivATI_ARGS;
typedef struct {
    int index;
    glVertexStream4ivATI_ARGS args;
} glVertexStream4ivATI_PACKED;
#endif
#ifndef glVertexStream4sATI_RETURN
typedef struct {
    GLenum stream;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} glVertexStream4sATI_ARGS;
typedef struct {
    int index;
    glVertexStream4sATI_ARGS args;
} glVertexStream4sATI_PACKED;
#endif
#ifndef glVertexStream4svATI_RETURN
typedef struct {
    GLenum stream;
    GLshort * coords;
} glVertexStream4svATI_ARGS;
typedef struct {
    int index;
    glVertexStream4svATI_ARGS args;
} glVertexStream4svATI_PACKED;
#endif
#ifndef glVertexWeightPointerEXT_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glVertexWeightPointerEXT_ARGS;
typedef struct {
    int index;
    glVertexWeightPointerEXT_ARGS args;
} glVertexWeightPointerEXT_PACKED;
#endif
#ifndef glVertexWeightfEXT_RETURN
typedef struct {
    GLfloat weight;
} glVertexWeightfEXT_ARGS;
typedef struct {
    int index;
    glVertexWeightfEXT_ARGS args;
} glVertexWeightfEXT_PACKED;
#endif
#ifndef glVertexWeightfvEXT_RETURN
typedef struct {
    GLfloat * weight;
} glVertexWeightfvEXT_ARGS;
typedef struct {
    int index;
    glVertexWeightfvEXT_ARGS args;
} glVertexWeightfvEXT_PACKED;
#endif
#ifndef glVertexWeighthNV_RETURN
typedef struct {
    GLhalfNV weight;
} glVertexWeighthNV_ARGS;
typedef struct {
    int index;
    glVertexWeighthNV_ARGS args;
} glVertexWeighthNV_PACKED;
#endif
#ifndef glVertexWeighthvNV_RETURN
typedef struct {
    GLhalfNV * weight;
} glVertexWeighthvNV_ARGS;
typedef struct {
    int index;
    glVertexWeighthvNV_ARGS args;
} glVertexWeighthvNV_PACKED;
#endif
#ifndef glVideoCaptureNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint * sequence_num;
    GLuint64EXT * capture_time;
} glVideoCaptureNV_ARGS;
typedef struct {
    int index;
    glVideoCaptureNV_ARGS args;
} glVideoCaptureNV_PACKED;
#endif
#ifndef glVideoCaptureStreamParameterdvNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLdouble * params;
} glVideoCaptureStreamParameterdvNV_ARGS;
typedef struct {
    int index;
    glVideoCaptureStreamParameterdvNV_ARGS args;
} glVideoCaptureStreamParameterdvNV_PACKED;
#endif
#ifndef glVideoCaptureStreamParameterfvNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLfloat * params;
} glVideoCaptureStreamParameterfvNV_ARGS;
typedef struct {
    int index;
    glVideoCaptureStreamParameterfvNV_ARGS args;
} glVideoCaptureStreamParameterfvNV_PACKED;
#endif
#ifndef glVideoCaptureStreamParameterivNV_RETURN
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLint * params;
} glVideoCaptureStreamParameterivNV_ARGS;
typedef struct {
    int index;
    glVideoCaptureStreamParameterivNV_ARGS args;
} glVideoCaptureStreamParameterivNV_PACKED;
#endif
#ifndef glViewport_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} glViewport_ARGS;
typedef struct {
    int index;
    glViewport_ARGS args;
} glViewport_PACKED;
#endif
#ifndef glViewportArrayv_RETURN
typedef struct {
    GLuint first;
    GLsizei count;
    GLfloat * v;
} glViewportArrayv_ARGS;
typedef struct {
    int index;
    glViewportArrayv_ARGS args;
} glViewportArrayv_PACKED;
#endif
#ifndef glViewportIndexedf_RETURN
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat w;
    GLfloat h;
} glViewportIndexedf_ARGS;
typedef struct {
    int index;
    glViewportIndexedf_ARGS args;
} glViewportIndexedf_PACKED;
#endif
#ifndef glViewportIndexedfv_RETURN
typedef struct {
    GLuint index;
    GLfloat * v;
} glViewportIndexedfv_ARGS;
typedef struct {
    int index;
    glViewportIndexedfv_ARGS args;
} glViewportIndexedfv_PACKED;
#endif
#ifndef glWaitSync_RETURN
typedef struct {
    GLsync sync;
    GLbitfield flags;
    GLuint64 timeout;
} glWaitSync_ARGS;
typedef struct {
    int index;
    glWaitSync_ARGS args;
} glWaitSync_PACKED;
#endif
#ifndef glWeightPathsNV_RETURN
typedef struct {
    GLuint resultPath;
    GLsizei numPaths;
    GLuint * paths;
    GLfloat * weights;
} glWeightPathsNV_ARGS;
typedef struct {
    int index;
    glWeightPathsNV_ARGS args;
} glWeightPathsNV_PACKED;
#endif
#ifndef glWeightPointerARB_RETURN
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} glWeightPointerARB_ARGS;
typedef struct {
    int index;
    glWeightPointerARB_ARGS args;
} glWeightPointerARB_PACKED;
#endif
#ifndef glWeightbvARB_RETURN
typedef struct {
    GLint size;
    GLbyte * weights;
} glWeightbvARB_ARGS;
typedef struct {
    int index;
    glWeightbvARB_ARGS args;
} glWeightbvARB_PACKED;
#endif
#ifndef glWeightdvARB_RETURN
typedef struct {
    GLint size;
    GLdouble * weights;
} glWeightdvARB_ARGS;
typedef struct {
    int index;
    glWeightdvARB_ARGS args;
} glWeightdvARB_PACKED;
#endif
#ifndef glWeightfvARB_RETURN
typedef struct {
    GLint size;
    GLfloat * weights;
} glWeightfvARB_ARGS;
typedef struct {
    int index;
    glWeightfvARB_ARGS args;
} glWeightfvARB_PACKED;
#endif
#ifndef glWeightivARB_RETURN
typedef struct {
    GLint size;
    GLint * weights;
} glWeightivARB_ARGS;
typedef struct {
    int index;
    glWeightivARB_ARGS args;
} glWeightivARB_PACKED;
#endif
#ifndef glWeightsvARB_RETURN
typedef struct {
    GLint size;
    GLshort * weights;
} glWeightsvARB_ARGS;
typedef struct {
    int index;
    glWeightsvARB_ARGS args;
} glWeightsvARB_PACKED;
#endif
#ifndef glWeightubvARB_RETURN
typedef struct {
    GLint size;
    GLubyte * weights;
} glWeightubvARB_ARGS;
typedef struct {
    int index;
    glWeightubvARB_ARGS args;
} glWeightubvARB_PACKED;
#endif
#ifndef glWeightuivARB_RETURN
typedef struct {
    GLint size;
    GLuint * weights;
} glWeightuivARB_ARGS;
typedef struct {
    int index;
    glWeightuivARB_ARGS args;
} glWeightuivARB_PACKED;
#endif
#ifndef glWeightusvARB_RETURN
typedef struct {
    GLint size;
    GLushort * weights;
} glWeightusvARB_ARGS;
typedef struct {
    int index;
    glWeightusvARB_ARGS args;
} glWeightusvARB_PACKED;
#endif
#ifndef glWindowPos2d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glWindowPos2d_ARGS;
typedef struct {
    int index;
    glWindowPos2d_ARGS args;
} glWindowPos2d_PACKED;
#endif
#ifndef glWindowPos2dARB_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glWindowPos2dARB_ARGS;
typedef struct {
    int index;
    glWindowPos2dARB_ARGS args;
} glWindowPos2dARB_PACKED;
#endif
#ifndef glWindowPos2dMESA_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} glWindowPos2dMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2dMESA_ARGS args;
} glWindowPos2dMESA_PACKED;
#endif
#ifndef glWindowPos2dv_RETURN
typedef struct {
    GLdouble * v;
} glWindowPos2dv_ARGS;
typedef struct {
    int index;
    glWindowPos2dv_ARGS args;
} glWindowPos2dv_PACKED;
#endif
#ifndef glWindowPos2dvARB_RETURN
typedef struct {
    GLdouble * v;
} glWindowPos2dvARB_ARGS;
typedef struct {
    int index;
    glWindowPos2dvARB_ARGS args;
} glWindowPos2dvARB_PACKED;
#endif
#ifndef glWindowPos2dvMESA_RETURN
typedef struct {
    GLdouble * v;
} glWindowPos2dvMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2dvMESA_ARGS args;
} glWindowPos2dvMESA_PACKED;
#endif
#ifndef glWindowPos2f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
} glWindowPos2f_ARGS;
typedef struct {
    int index;
    glWindowPos2f_ARGS args;
} glWindowPos2f_PACKED;
#endif
#ifndef glWindowPos2fARB_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
} glWindowPos2fARB_ARGS;
typedef struct {
    int index;
    glWindowPos2fARB_ARGS args;
} glWindowPos2fARB_PACKED;
#endif
#ifndef glWindowPos2fMESA_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
} glWindowPos2fMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2fMESA_ARGS args;
} glWindowPos2fMESA_PACKED;
#endif
#ifndef glWindowPos2fv_RETURN
typedef struct {
    GLfloat * v;
} glWindowPos2fv_ARGS;
typedef struct {
    int index;
    glWindowPos2fv_ARGS args;
} glWindowPos2fv_PACKED;
#endif
#ifndef glWindowPos2fvARB_RETURN
typedef struct {
    GLfloat * v;
} glWindowPos2fvARB_ARGS;
typedef struct {
    int index;
    glWindowPos2fvARB_ARGS args;
} glWindowPos2fvARB_PACKED;
#endif
#ifndef glWindowPos2fvMESA_RETURN
typedef struct {
    GLfloat * v;
} glWindowPos2fvMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2fvMESA_ARGS args;
} glWindowPos2fvMESA_PACKED;
#endif
#ifndef glWindowPos2i_RETURN
typedef struct {
    GLint x;
    GLint y;
} glWindowPos2i_ARGS;
typedef struct {
    int index;
    glWindowPos2i_ARGS args;
} glWindowPos2i_PACKED;
#endif
#ifndef glWindowPos2iARB_RETURN
typedef struct {
    GLint x;
    GLint y;
} glWindowPos2iARB_ARGS;
typedef struct {
    int index;
    glWindowPos2iARB_ARGS args;
} glWindowPos2iARB_PACKED;
#endif
#ifndef glWindowPos2iMESA_RETURN
typedef struct {
    GLint x;
    GLint y;
} glWindowPos2iMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2iMESA_ARGS args;
} glWindowPos2iMESA_PACKED;
#endif
#ifndef glWindowPos2iv_RETURN
typedef struct {
    GLint * v;
} glWindowPos2iv_ARGS;
typedef struct {
    int index;
    glWindowPos2iv_ARGS args;
} glWindowPos2iv_PACKED;
#endif
#ifndef glWindowPos2ivARB_RETURN
typedef struct {
    GLint * v;
} glWindowPos2ivARB_ARGS;
typedef struct {
    int index;
    glWindowPos2ivARB_ARGS args;
} glWindowPos2ivARB_PACKED;
#endif
#ifndef glWindowPos2ivMESA_RETURN
typedef struct {
    GLint * v;
} glWindowPos2ivMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2ivMESA_ARGS args;
} glWindowPos2ivMESA_PACKED;
#endif
#ifndef glWindowPos2s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
} glWindowPos2s_ARGS;
typedef struct {
    int index;
    glWindowPos2s_ARGS args;
} glWindowPos2s_PACKED;
#endif
#ifndef glWindowPos2sARB_RETURN
typedef struct {
    GLshort x;
    GLshort y;
} glWindowPos2sARB_ARGS;
typedef struct {
    int index;
    glWindowPos2sARB_ARGS args;
} glWindowPos2sARB_PACKED;
#endif
#ifndef glWindowPos2sMESA_RETURN
typedef struct {
    GLshort x;
    GLshort y;
} glWindowPos2sMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2sMESA_ARGS args;
} glWindowPos2sMESA_PACKED;
#endif
#ifndef glWindowPos2sv_RETURN
typedef struct {
    GLshort * v;
} glWindowPos2sv_ARGS;
typedef struct {
    int index;
    glWindowPos2sv_ARGS args;
} glWindowPos2sv_PACKED;
#endif
#ifndef glWindowPos2svARB_RETURN
typedef struct {
    GLshort * v;
} glWindowPos2svARB_ARGS;
typedef struct {
    int index;
    glWindowPos2svARB_ARGS args;
} glWindowPos2svARB_PACKED;
#endif
#ifndef glWindowPos2svMESA_RETURN
typedef struct {
    GLshort * v;
} glWindowPos2svMESA_ARGS;
typedef struct {
    int index;
    glWindowPos2svMESA_ARGS args;
} glWindowPos2svMESA_PACKED;
#endif
#ifndef glWindowPos3d_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glWindowPos3d_ARGS;
typedef struct {
    int index;
    glWindowPos3d_ARGS args;
} glWindowPos3d_PACKED;
#endif
#ifndef glWindowPos3dARB_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glWindowPos3dARB_ARGS;
typedef struct {
    int index;
    glWindowPos3dARB_ARGS args;
} glWindowPos3dARB_PACKED;
#endif
#ifndef glWindowPos3dMESA_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} glWindowPos3dMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3dMESA_ARGS args;
} glWindowPos3dMESA_PACKED;
#endif
#ifndef glWindowPos3dv_RETURN
typedef struct {
    GLdouble * v;
} glWindowPos3dv_ARGS;
typedef struct {
    int index;
    glWindowPos3dv_ARGS args;
} glWindowPos3dv_PACKED;
#endif
#ifndef glWindowPos3dvARB_RETURN
typedef struct {
    GLdouble * v;
} glWindowPos3dvARB_ARGS;
typedef struct {
    int index;
    glWindowPos3dvARB_ARGS args;
} glWindowPos3dvARB_PACKED;
#endif
#ifndef glWindowPos3dvMESA_RETURN
typedef struct {
    GLdouble * v;
} glWindowPos3dvMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3dvMESA_ARGS args;
} glWindowPos3dvMESA_PACKED;
#endif
#ifndef glWindowPos3f_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glWindowPos3f_ARGS;
typedef struct {
    int index;
    glWindowPos3f_ARGS args;
} glWindowPos3f_PACKED;
#endif
#ifndef glWindowPos3fARB_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glWindowPos3fARB_ARGS;
typedef struct {
    int index;
    glWindowPos3fARB_ARGS args;
} glWindowPos3fARB_PACKED;
#endif
#ifndef glWindowPos3fMESA_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} glWindowPos3fMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3fMESA_ARGS args;
} glWindowPos3fMESA_PACKED;
#endif
#ifndef glWindowPos3fv_RETURN
typedef struct {
    GLfloat * v;
} glWindowPos3fv_ARGS;
typedef struct {
    int index;
    glWindowPos3fv_ARGS args;
} glWindowPos3fv_PACKED;
#endif
#ifndef glWindowPos3fvARB_RETURN
typedef struct {
    GLfloat * v;
} glWindowPos3fvARB_ARGS;
typedef struct {
    int index;
    glWindowPos3fvARB_ARGS args;
} glWindowPos3fvARB_PACKED;
#endif
#ifndef glWindowPos3fvMESA_RETURN
typedef struct {
    GLfloat * v;
} glWindowPos3fvMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3fvMESA_ARGS args;
} glWindowPos3fvMESA_PACKED;
#endif
#ifndef glWindowPos3i_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} glWindowPos3i_ARGS;
typedef struct {
    int index;
    glWindowPos3i_ARGS args;
} glWindowPos3i_PACKED;
#endif
#ifndef glWindowPos3iARB_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} glWindowPos3iARB_ARGS;
typedef struct {
    int index;
    glWindowPos3iARB_ARGS args;
} glWindowPos3iARB_PACKED;
#endif
#ifndef glWindowPos3iMESA_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} glWindowPos3iMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3iMESA_ARGS args;
} glWindowPos3iMESA_PACKED;
#endif
#ifndef glWindowPos3iv_RETURN
typedef struct {
    GLint * v;
} glWindowPos3iv_ARGS;
typedef struct {
    int index;
    glWindowPos3iv_ARGS args;
} glWindowPos3iv_PACKED;
#endif
#ifndef glWindowPos3ivARB_RETURN
typedef struct {
    GLint * v;
} glWindowPos3ivARB_ARGS;
typedef struct {
    int index;
    glWindowPos3ivARB_ARGS args;
} glWindowPos3ivARB_PACKED;
#endif
#ifndef glWindowPos3ivMESA_RETURN
typedef struct {
    GLint * v;
} glWindowPos3ivMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3ivMESA_ARGS args;
} glWindowPos3ivMESA_PACKED;
#endif
#ifndef glWindowPos3s_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} glWindowPos3s_ARGS;
typedef struct {
    int index;
    glWindowPos3s_ARGS args;
} glWindowPos3s_PACKED;
#endif
#ifndef glWindowPos3sARB_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} glWindowPos3sARB_ARGS;
typedef struct {
    int index;
    glWindowPos3sARB_ARGS args;
} glWindowPos3sARB_PACKED;
#endif
#ifndef glWindowPos3sMESA_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} glWindowPos3sMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3sMESA_ARGS args;
} glWindowPos3sMESA_PACKED;
#endif
#ifndef glWindowPos3sv_RETURN
typedef struct {
    GLshort * v;
} glWindowPos3sv_ARGS;
typedef struct {
    int index;
    glWindowPos3sv_ARGS args;
} glWindowPos3sv_PACKED;
#endif
#ifndef glWindowPos3svARB_RETURN
typedef struct {
    GLshort * v;
} glWindowPos3svARB_ARGS;
typedef struct {
    int index;
    glWindowPos3svARB_ARGS args;
} glWindowPos3svARB_PACKED;
#endif
#ifndef glWindowPos3svMESA_RETURN
typedef struct {
    GLshort * v;
} glWindowPos3svMESA_ARGS;
typedef struct {
    int index;
    glWindowPos3svMESA_ARGS args;
} glWindowPos3svMESA_PACKED;
#endif
#ifndef glWindowPos4dMESA_RETURN
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} glWindowPos4dMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4dMESA_ARGS args;
} glWindowPos4dMESA_PACKED;
#endif
#ifndef glWindowPos4dvMESA_RETURN
typedef struct {
    GLdouble * v;
} glWindowPos4dvMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4dvMESA_ARGS args;
} glWindowPos4dvMESA_PACKED;
#endif
#ifndef glWindowPos4fMESA_RETURN
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} glWindowPos4fMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4fMESA_ARGS args;
} glWindowPos4fMESA_PACKED;
#endif
#ifndef glWindowPos4fvMESA_RETURN
typedef struct {
    GLfloat * v;
} glWindowPos4fvMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4fvMESA_ARGS args;
} glWindowPos4fvMESA_PACKED;
#endif
#ifndef glWindowPos4iMESA_RETURN
typedef struct {
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} glWindowPos4iMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4iMESA_ARGS args;
} glWindowPos4iMESA_PACKED;
#endif
#ifndef glWindowPos4ivMESA_RETURN
typedef struct {
    GLint * v;
} glWindowPos4ivMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4ivMESA_ARGS args;
} glWindowPos4ivMESA_PACKED;
#endif
#ifndef glWindowPos4sMESA_RETURN
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} glWindowPos4sMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4sMESA_ARGS args;
} glWindowPos4sMESA_PACKED;
#endif
#ifndef glWindowPos4svMESA_RETURN
typedef struct {
    GLshort * v;
} glWindowPos4svMESA_ARGS;
typedef struct {
    int index;
    glWindowPos4svMESA_ARGS args;
} glWindowPos4svMESA_PACKED;
#endif
#ifndef glWriteMaskEXT_RETURN
typedef struct {
    GLuint res;
    GLuint in;
    GLenum outX;
    GLenum outY;
    GLenum outZ;
    GLenum outW;
} glWriteMaskEXT_ARGS;
typedef struct {
    int index;
    glWriteMaskEXT_ARGS args;
} glWriteMaskEXT_PACKED;
#endif

#ifndef glAccum_RETURN
#define glAccum_RETURN void
#define glAccum_ARG_NAMES op, value
#define glAccum_ARG_EXPAND GLenum op, GLfloat value
#define glAccum_ARG_NAMES_TAIL , op, value
#define glAccum_ARG_EXPAND_TAIL , GLenum op, GLfloat value
#define forward_glAccum(_op, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glAccum_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAccum(dst, _op, _value), NULL); \
    });
#define call_glAccum(packed, ret_v) do { \
    glAccum_PACKED *unpacked = (glAccum_PACKED *)packed; \
    glAccum_ARGS *args = (glAccum_ARGS *)&unpacked->args; \
    glAccum(args->op, args->value);; \
} while(0)
void glAccum(glAccum_ARG_EXPAND);
packed_call_t *pack_glAccum(glAccum_PACKED *_dst glAccum_ARG_EXPAND_TAIL);
typedef void (*glAccum_PTR)(glAccum_ARG_EXPAND);
#endif
#ifndef glAccumxOES_RETURN
#define glAccumxOES_RETURN void
#define glAccumxOES_ARG_NAMES op, value
#define glAccumxOES_ARG_EXPAND GLenum op, GLfixed value
#define glAccumxOES_ARG_NAMES_TAIL , op, value
#define glAccumxOES_ARG_EXPAND_TAIL , GLenum op, GLfixed value
#define forward_glAccumxOES(_op, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glAccumxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAccumxOES(dst, _op, _value), NULL); \
    });
#define call_glAccumxOES(packed, ret_v) do { \
    glAccumxOES_PACKED *unpacked = (glAccumxOES_PACKED *)packed; \
    glAccumxOES_ARGS *args = (glAccumxOES_ARGS *)&unpacked->args; \
    glAccumxOES(args->op, args->value);; \
} while(0)
void glAccumxOES(glAccumxOES_ARG_EXPAND);
packed_call_t *pack_glAccumxOES(glAccumxOES_PACKED *_dst glAccumxOES_ARG_EXPAND_TAIL);
typedef void (*glAccumxOES_PTR)(glAccumxOES_ARG_EXPAND);
#endif
#ifndef glActiveProgramEXT_RETURN
#define glActiveProgramEXT_RETURN void
#define glActiveProgramEXT_ARG_NAMES program
#define glActiveProgramEXT_ARG_EXPAND GLuint program
#define glActiveProgramEXT_ARG_NAMES_TAIL , program
#define glActiveProgramEXT_ARG_EXPAND_TAIL , GLuint program
#define forward_glActiveProgramEXT(_program) \
    ({ \
        void *dst = remote_dma(sizeof(glActiveProgramEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glActiveProgramEXT(dst, _program), NULL); \
    });
#define call_glActiveProgramEXT(packed, ret_v) do { \
    glActiveProgramEXT_PACKED *unpacked = (glActiveProgramEXT_PACKED *)packed; \
    glActiveProgramEXT_ARGS *args = (glActiveProgramEXT_ARGS *)&unpacked->args; \
    glActiveProgramEXT(args->program);; \
} while(0)
void glActiveProgramEXT(glActiveProgramEXT_ARG_EXPAND);
packed_call_t *pack_glActiveProgramEXT(glActiveProgramEXT_PACKED *_dst glActiveProgramEXT_ARG_EXPAND_TAIL);
typedef void (*glActiveProgramEXT_PTR)(glActiveProgramEXT_ARG_EXPAND);
#endif
#ifndef glActiveShaderProgram_RETURN
#define glActiveShaderProgram_RETURN void
#define glActiveShaderProgram_ARG_NAMES pipeline, program
#define glActiveShaderProgram_ARG_EXPAND GLuint pipeline, GLuint program
#define glActiveShaderProgram_ARG_NAMES_TAIL , pipeline, program
#define glActiveShaderProgram_ARG_EXPAND_TAIL , GLuint pipeline, GLuint program
#define forward_glActiveShaderProgram(_pipeline, _program) \
    ({ \
        void *dst = remote_dma(sizeof(glActiveShaderProgram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glActiveShaderProgram(dst, _pipeline, _program), NULL); \
    });
#define call_glActiveShaderProgram(packed, ret_v) do { \
    glActiveShaderProgram_PACKED *unpacked = (glActiveShaderProgram_PACKED *)packed; \
    glActiveShaderProgram_ARGS *args = (glActiveShaderProgram_ARGS *)&unpacked->args; \
    glActiveShaderProgram(args->pipeline, args->program);; \
} while(0)
void glActiveShaderProgram(glActiveShaderProgram_ARG_EXPAND);
packed_call_t *pack_glActiveShaderProgram(glActiveShaderProgram_PACKED *_dst glActiveShaderProgram_ARG_EXPAND_TAIL);
typedef void (*glActiveShaderProgram_PTR)(glActiveShaderProgram_ARG_EXPAND);
#endif
#ifndef glActiveStencilFaceEXT_RETURN
#define glActiveStencilFaceEXT_RETURN void
#define glActiveStencilFaceEXT_ARG_NAMES face
#define glActiveStencilFaceEXT_ARG_EXPAND GLenum face
#define glActiveStencilFaceEXT_ARG_NAMES_TAIL , face
#define glActiveStencilFaceEXT_ARG_EXPAND_TAIL , GLenum face
#define forward_glActiveStencilFaceEXT(_face) \
    ({ \
        void *dst = remote_dma(sizeof(glActiveStencilFaceEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glActiveStencilFaceEXT(dst, _face), NULL); \
    });
#define call_glActiveStencilFaceEXT(packed, ret_v) do { \
    glActiveStencilFaceEXT_PACKED *unpacked = (glActiveStencilFaceEXT_PACKED *)packed; \
    glActiveStencilFaceEXT_ARGS *args = (glActiveStencilFaceEXT_ARGS *)&unpacked->args; \
    glActiveStencilFaceEXT(args->face);; \
} while(0)
void glActiveStencilFaceEXT(glActiveStencilFaceEXT_ARG_EXPAND);
packed_call_t *pack_glActiveStencilFaceEXT(glActiveStencilFaceEXT_PACKED *_dst glActiveStencilFaceEXT_ARG_EXPAND_TAIL);
typedef void (*glActiveStencilFaceEXT_PTR)(glActiveStencilFaceEXT_ARG_EXPAND);
#endif
#ifndef glActiveTexture_RETURN
#define glActiveTexture_RETURN void
#define glActiveTexture_ARG_NAMES texture
#define glActiveTexture_ARG_EXPAND GLenum texture
#define glActiveTexture_ARG_NAMES_TAIL , texture
#define glActiveTexture_ARG_EXPAND_TAIL , GLenum texture
#define forward_glActiveTexture(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glActiveTexture_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glActiveTexture(dst, _texture), NULL); \
    });
#define call_glActiveTexture(packed, ret_v) do { \
    glActiveTexture_PACKED *unpacked = (glActiveTexture_PACKED *)packed; \
    glActiveTexture_ARGS *args = (glActiveTexture_ARGS *)&unpacked->args; \
    glActiveTexture(args->texture);; \
} while(0)
void glActiveTexture(glActiveTexture_ARG_EXPAND);
packed_call_t *pack_glActiveTexture(glActiveTexture_PACKED *_dst glActiveTexture_ARG_EXPAND_TAIL);
typedef void (*glActiveTexture_PTR)(glActiveTexture_ARG_EXPAND);
#endif
#ifndef glActiveTextureARB_RETURN
#define glActiveTextureARB_RETURN void
#define glActiveTextureARB_ARG_NAMES texture
#define glActiveTextureARB_ARG_EXPAND GLenum texture
#define glActiveTextureARB_ARG_NAMES_TAIL , texture
#define glActiveTextureARB_ARG_EXPAND_TAIL , GLenum texture
#define forward_glActiveTextureARB(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glActiveTextureARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glActiveTextureARB(dst, _texture), NULL); \
    });
#define call_glActiveTextureARB(packed, ret_v) do { \
    glActiveTextureARB_PACKED *unpacked = (glActiveTextureARB_PACKED *)packed; \
    glActiveTextureARB_ARGS *args = (glActiveTextureARB_ARGS *)&unpacked->args; \
    glActiveTextureARB(args->texture);; \
} while(0)
void glActiveTextureARB(glActiveTextureARB_ARG_EXPAND);
packed_call_t *pack_glActiveTextureARB(glActiveTextureARB_PACKED *_dst glActiveTextureARB_ARG_EXPAND_TAIL);
typedef void (*glActiveTextureARB_PTR)(glActiveTextureARB_ARG_EXPAND);
#endif
#ifndef glActiveVaryingNV_RETURN
#define glActiveVaryingNV_RETURN void
#define glActiveVaryingNV_ARG_NAMES program, name
#define glActiveVaryingNV_ARG_EXPAND GLuint program, const GLchar * name
#define glActiveVaryingNV_ARG_NAMES_TAIL , program, name
#define glActiveVaryingNV_ARG_EXPAND_TAIL , GLuint program, const GLchar * name
#define forward_glActiveVaryingNV(_program, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glActiveVaryingNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glActiveVaryingNV(dst, _program, _name), NULL); \
    });
#define call_glActiveVaryingNV(packed, ret_v) do { \
    glActiveVaryingNV_PACKED *unpacked = (glActiveVaryingNV_PACKED *)packed; \
    glActiveVaryingNV_ARGS *args = (glActiveVaryingNV_ARGS *)&unpacked->args; \
    glActiveVaryingNV(args->program, args->name);; \
} while(0)
void glActiveVaryingNV(glActiveVaryingNV_ARG_EXPAND);
packed_call_t *pack_glActiveVaryingNV(glActiveVaryingNV_PACKED *_dst glActiveVaryingNV_ARG_EXPAND_TAIL);
typedef void (*glActiveVaryingNV_PTR)(glActiveVaryingNV_ARG_EXPAND);
#endif
#ifndef glAlphaFragmentOp1ATI_RETURN
#define glAlphaFragmentOp1ATI_RETURN void
#define glAlphaFragmentOp1ATI_ARG_NAMES op, dst, dstMod, arg1, arg1Rep, arg1Mod
#define glAlphaFragmentOp1ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod
#define glAlphaFragmentOp1ATI_ARG_NAMES_TAIL , op, dst, dstMod, arg1, arg1Rep, arg1Mod
#define glAlphaFragmentOp1ATI_ARG_EXPAND_TAIL , GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod
#define forward_glAlphaFragmentOp1ATI(_op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod) \
    ({ \
        void *dst = remote_dma(sizeof(glAlphaFragmentOp1ATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAlphaFragmentOp1ATI(dst, _op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod), NULL); \
    });
#define call_glAlphaFragmentOp1ATI(packed, ret_v) do { \
    glAlphaFragmentOp1ATI_PACKED *unpacked = (glAlphaFragmentOp1ATI_PACKED *)packed; \
    glAlphaFragmentOp1ATI_ARGS *args = (glAlphaFragmentOp1ATI_ARGS *)&unpacked->args; \
    glAlphaFragmentOp1ATI(args->op, args->dst, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod);; \
} while(0)
void glAlphaFragmentOp1ATI(glAlphaFragmentOp1ATI_ARG_EXPAND);
packed_call_t *pack_glAlphaFragmentOp1ATI(glAlphaFragmentOp1ATI_PACKED *_dst glAlphaFragmentOp1ATI_ARG_EXPAND_TAIL);
typedef void (*glAlphaFragmentOp1ATI_PTR)(glAlphaFragmentOp1ATI_ARG_EXPAND);
#endif
#ifndef glAlphaFragmentOp2ATI_RETURN
#define glAlphaFragmentOp2ATI_RETURN void
#define glAlphaFragmentOp2ATI_ARG_NAMES op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod
#define glAlphaFragmentOp2ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod
#define glAlphaFragmentOp2ATI_ARG_NAMES_TAIL , op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod
#define glAlphaFragmentOp2ATI_ARG_EXPAND_TAIL , GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod
#define forward_glAlphaFragmentOp2ATI(_op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod) \
    ({ \
        void *dst = remote_dma(sizeof(glAlphaFragmentOp2ATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAlphaFragmentOp2ATI(dst, _op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod), NULL); \
    });
#define call_glAlphaFragmentOp2ATI(packed, ret_v) do { \
    glAlphaFragmentOp2ATI_PACKED *unpacked = (glAlphaFragmentOp2ATI_PACKED *)packed; \
    glAlphaFragmentOp2ATI_ARGS *args = (glAlphaFragmentOp2ATI_ARGS *)&unpacked->args; \
    glAlphaFragmentOp2ATI(args->op, args->dst, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod);; \
} while(0)
void glAlphaFragmentOp2ATI(glAlphaFragmentOp2ATI_ARG_EXPAND);
packed_call_t *pack_glAlphaFragmentOp2ATI(glAlphaFragmentOp2ATI_PACKED *_dst glAlphaFragmentOp2ATI_ARG_EXPAND_TAIL);
typedef void (*glAlphaFragmentOp2ATI_PTR)(glAlphaFragmentOp2ATI_ARG_EXPAND);
#endif
#ifndef glAlphaFragmentOp3ATI_RETURN
#define glAlphaFragmentOp3ATI_RETURN void
#define glAlphaFragmentOp3ATI_ARG_NAMES op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod
#define glAlphaFragmentOp3ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod
#define glAlphaFragmentOp3ATI_ARG_NAMES_TAIL , op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod
#define glAlphaFragmentOp3ATI_ARG_EXPAND_TAIL , GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod
#define forward_glAlphaFragmentOp3ATI(_op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod, _arg3, _arg3Rep, _arg3Mod) \
    ({ \
        void *dst = remote_dma(sizeof(glAlphaFragmentOp3ATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAlphaFragmentOp3ATI(dst, _op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod, _arg3, _arg3Rep, _arg3Mod), NULL); \
    });
#define call_glAlphaFragmentOp3ATI(packed, ret_v) do { \
    glAlphaFragmentOp3ATI_PACKED *unpacked = (glAlphaFragmentOp3ATI_PACKED *)packed; \
    glAlphaFragmentOp3ATI_ARGS *args = (glAlphaFragmentOp3ATI_ARGS *)&unpacked->args; \
    glAlphaFragmentOp3ATI(args->op, args->dst, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod, args->arg3, args->arg3Rep, args->arg3Mod);; \
} while(0)
void glAlphaFragmentOp3ATI(glAlphaFragmentOp3ATI_ARG_EXPAND);
packed_call_t *pack_glAlphaFragmentOp3ATI(glAlphaFragmentOp3ATI_PACKED *_dst glAlphaFragmentOp3ATI_ARG_EXPAND_TAIL);
typedef void (*glAlphaFragmentOp3ATI_PTR)(glAlphaFragmentOp3ATI_ARG_EXPAND);
#endif
#ifndef glAlphaFunc_RETURN
#define glAlphaFunc_RETURN void
#define glAlphaFunc_ARG_NAMES func, ref
#define glAlphaFunc_ARG_EXPAND GLenum func, GLfloat ref
#define glAlphaFunc_ARG_NAMES_TAIL , func, ref
#define glAlphaFunc_ARG_EXPAND_TAIL , GLenum func, GLfloat ref
#define forward_glAlphaFunc(_func, _ref) \
    ({ \
        void *dst = remote_dma(sizeof(glAlphaFunc_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAlphaFunc(dst, _func, _ref), NULL); \
    });
#define call_glAlphaFunc(packed, ret_v) do { \
    glAlphaFunc_PACKED *unpacked = (glAlphaFunc_PACKED *)packed; \
    glAlphaFunc_ARGS *args = (glAlphaFunc_ARGS *)&unpacked->args; \
    glAlphaFunc(args->func, args->ref);; \
} while(0)
void glAlphaFunc(glAlphaFunc_ARG_EXPAND);
packed_call_t *pack_glAlphaFunc(glAlphaFunc_PACKED *_dst glAlphaFunc_ARG_EXPAND_TAIL);
typedef void (*glAlphaFunc_PTR)(glAlphaFunc_ARG_EXPAND);
#endif
#ifndef glAlphaFuncxOES_RETURN
#define glAlphaFuncxOES_RETURN void
#define glAlphaFuncxOES_ARG_NAMES func, ref
#define glAlphaFuncxOES_ARG_EXPAND GLenum func, GLfixed ref
#define glAlphaFuncxOES_ARG_NAMES_TAIL , func, ref
#define glAlphaFuncxOES_ARG_EXPAND_TAIL , GLenum func, GLfixed ref
#define forward_glAlphaFuncxOES(_func, _ref) \
    ({ \
        void *dst = remote_dma(sizeof(glAlphaFuncxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAlphaFuncxOES(dst, _func, _ref), NULL); \
    });
#define call_glAlphaFuncxOES(packed, ret_v) do { \
    glAlphaFuncxOES_PACKED *unpacked = (glAlphaFuncxOES_PACKED *)packed; \
    glAlphaFuncxOES_ARGS *args = (glAlphaFuncxOES_ARGS *)&unpacked->args; \
    glAlphaFuncxOES(args->func, args->ref);; \
} while(0)
void glAlphaFuncxOES(glAlphaFuncxOES_ARG_EXPAND);
packed_call_t *pack_glAlphaFuncxOES(glAlphaFuncxOES_PACKED *_dst glAlphaFuncxOES_ARG_EXPAND_TAIL);
typedef void (*glAlphaFuncxOES_PTR)(glAlphaFuncxOES_ARG_EXPAND);
#endif
#ifndef glApplyTextureEXT_RETURN
#define glApplyTextureEXT_RETURN void
#define glApplyTextureEXT_ARG_NAMES mode
#define glApplyTextureEXT_ARG_EXPAND GLenum mode
#define glApplyTextureEXT_ARG_NAMES_TAIL , mode
#define glApplyTextureEXT_ARG_EXPAND_TAIL , GLenum mode
#define forward_glApplyTextureEXT(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glApplyTextureEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glApplyTextureEXT(dst, _mode), NULL); \
    });
#define call_glApplyTextureEXT(packed, ret_v) do { \
    glApplyTextureEXT_PACKED *unpacked = (glApplyTextureEXT_PACKED *)packed; \
    glApplyTextureEXT_ARGS *args = (glApplyTextureEXT_ARGS *)&unpacked->args; \
    glApplyTextureEXT(args->mode);; \
} while(0)
void glApplyTextureEXT(glApplyTextureEXT_ARG_EXPAND);
packed_call_t *pack_glApplyTextureEXT(glApplyTextureEXT_PACKED *_dst glApplyTextureEXT_ARG_EXPAND_TAIL);
typedef void (*glApplyTextureEXT_PTR)(glApplyTextureEXT_ARG_EXPAND);
#endif
#ifndef glAreProgramsResidentNV_RETURN
#define glAreProgramsResidentNV_RETURN GLboolean
#define glAreProgramsResidentNV_ARG_NAMES n, programs, residences
#define glAreProgramsResidentNV_ARG_EXPAND GLsizei n, const GLuint * programs, GLboolean * residences
#define glAreProgramsResidentNV_ARG_NAMES_TAIL , n, programs, residences
#define glAreProgramsResidentNV_ARG_EXPAND_TAIL , GLsizei n, const GLuint * programs, GLboolean * residences
#define forward_glAreProgramsResidentNV(_n, _programs, _residences) \
    ({ \
        void *dst = remote_dma(sizeof(glAreProgramsResidentNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glAreProgramsResidentNV(dst, _n, _programs, _residences), &ret); \
        ret; \
    });
#define call_glAreProgramsResidentNV(packed, ret_v) do { \
    glAreProgramsResidentNV_PACKED *unpacked = (glAreProgramsResidentNV_PACKED *)packed; \
    glAreProgramsResidentNV_ARGS *args = (glAreProgramsResidentNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glAreProgramsResidentNV(args->n, args->programs, args->residences);; \
    } else { \
        glAreProgramsResidentNV(args->n, args->programs, args->residences);; \
    } \
} while(0)
GLboolean glAreProgramsResidentNV(glAreProgramsResidentNV_ARG_EXPAND);
packed_call_t *pack_glAreProgramsResidentNV(glAreProgramsResidentNV_PACKED *_dst glAreProgramsResidentNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glAreProgramsResidentNV_PTR)(glAreProgramsResidentNV_ARG_EXPAND);
#endif
#ifndef glAreTexturesResident_RETURN
#define glAreTexturesResident_RETURN GLboolean
#define glAreTexturesResident_ARG_NAMES n, textures, residences
#define glAreTexturesResident_ARG_EXPAND GLsizei n, const GLuint * textures, GLboolean * residences
#define glAreTexturesResident_ARG_NAMES_TAIL , n, textures, residences
#define glAreTexturesResident_ARG_EXPAND_TAIL , GLsizei n, const GLuint * textures, GLboolean * residences
#define forward_glAreTexturesResident(_n, _textures, _residences) \
    ({ \
        void *dst = remote_dma(sizeof(glAreTexturesResident_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glAreTexturesResident(dst, _n, _textures, _residences), &ret); \
        ret; \
    });
#define call_glAreTexturesResident(packed, ret_v) do { \
    glAreTexturesResident_PACKED *unpacked = (glAreTexturesResident_PACKED *)packed; \
    glAreTexturesResident_ARGS *args = (glAreTexturesResident_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glAreTexturesResident(args->n, args->textures, args->residences);; \
    } else { \
        glAreTexturesResident(args->n, args->textures, args->residences);; \
    } \
} while(0)
GLboolean glAreTexturesResident(glAreTexturesResident_ARG_EXPAND);
packed_call_t *pack_glAreTexturesResident(glAreTexturesResident_PACKED *_dst glAreTexturesResident_ARG_EXPAND_TAIL);
typedef GLboolean (*glAreTexturesResident_PTR)(glAreTexturesResident_ARG_EXPAND);
#endif
#ifndef glAreTexturesResidentEXT_RETURN
#define glAreTexturesResidentEXT_RETURN GLboolean
#define glAreTexturesResidentEXT_ARG_NAMES n, textures, residences
#define glAreTexturesResidentEXT_ARG_EXPAND GLsizei n, const GLuint * textures, GLboolean * residences
#define glAreTexturesResidentEXT_ARG_NAMES_TAIL , n, textures, residences
#define glAreTexturesResidentEXT_ARG_EXPAND_TAIL , GLsizei n, const GLuint * textures, GLboolean * residences
#define forward_glAreTexturesResidentEXT(_n, _textures, _residences) \
    ({ \
        void *dst = remote_dma(sizeof(glAreTexturesResidentEXT_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glAreTexturesResidentEXT(dst, _n, _textures, _residences), &ret); \
        ret; \
    });
#define call_glAreTexturesResidentEXT(packed, ret_v) do { \
    glAreTexturesResidentEXT_PACKED *unpacked = (glAreTexturesResidentEXT_PACKED *)packed; \
    glAreTexturesResidentEXT_ARGS *args = (glAreTexturesResidentEXT_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glAreTexturesResidentEXT(args->n, args->textures, args->residences);; \
    } else { \
        glAreTexturesResidentEXT(args->n, args->textures, args->residences);; \
    } \
} while(0)
GLboolean glAreTexturesResidentEXT(glAreTexturesResidentEXT_ARG_EXPAND);
packed_call_t *pack_glAreTexturesResidentEXT(glAreTexturesResidentEXT_PACKED *_dst glAreTexturesResidentEXT_ARG_EXPAND_TAIL);
typedef GLboolean (*glAreTexturesResidentEXT_PTR)(glAreTexturesResidentEXT_ARG_EXPAND);
#endif
#ifndef glArrayElement_RETURN
#define glArrayElement_RETURN void
#define glArrayElement_ARG_NAMES i
#define glArrayElement_ARG_EXPAND GLint i
#define glArrayElement_ARG_NAMES_TAIL , i
#define glArrayElement_ARG_EXPAND_TAIL , GLint i
#define forward_glArrayElement(_i) \
    ({ \
        void *dst = remote_dma(sizeof(glArrayElement_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glArrayElement(dst, _i), NULL); \
    });
#define call_glArrayElement(packed, ret_v) do { \
    glArrayElement_PACKED *unpacked = (glArrayElement_PACKED *)packed; \
    glArrayElement_ARGS *args = (glArrayElement_ARGS *)&unpacked->args; \
    glArrayElement(args->i);; \
} while(0)
void glArrayElement(glArrayElement_ARG_EXPAND);
packed_call_t *pack_glArrayElement(glArrayElement_PACKED *_dst glArrayElement_ARG_EXPAND_TAIL);
typedef void (*glArrayElement_PTR)(glArrayElement_ARG_EXPAND);
#endif
#ifndef glArrayElementEXT_RETURN
#define glArrayElementEXT_RETURN void
#define glArrayElementEXT_ARG_NAMES i
#define glArrayElementEXT_ARG_EXPAND GLint i
#define glArrayElementEXT_ARG_NAMES_TAIL , i
#define glArrayElementEXT_ARG_EXPAND_TAIL , GLint i
#define forward_glArrayElementEXT(_i) \
    ({ \
        void *dst = remote_dma(sizeof(glArrayElementEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glArrayElementEXT(dst, _i), NULL); \
    });
#define call_glArrayElementEXT(packed, ret_v) do { \
    glArrayElementEXT_PACKED *unpacked = (glArrayElementEXT_PACKED *)packed; \
    glArrayElementEXT_ARGS *args = (glArrayElementEXT_ARGS *)&unpacked->args; \
    glArrayElementEXT(args->i);; \
} while(0)
void glArrayElementEXT(glArrayElementEXT_ARG_EXPAND);
packed_call_t *pack_glArrayElementEXT(glArrayElementEXT_PACKED *_dst glArrayElementEXT_ARG_EXPAND_TAIL);
typedef void (*glArrayElementEXT_PTR)(glArrayElementEXT_ARG_EXPAND);
#endif
#ifndef glArrayObjectATI_RETURN
#define glArrayObjectATI_RETURN void
#define glArrayObjectATI_ARG_NAMES array, size, type, stride, buffer, offset
#define glArrayObjectATI_ARG_EXPAND GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset
#define glArrayObjectATI_ARG_NAMES_TAIL , array, size, type, stride, buffer, offset
#define glArrayObjectATI_ARG_EXPAND_TAIL , GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset
#define forward_glArrayObjectATI(_array, _size, _type, _stride, _buffer, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glArrayObjectATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glArrayObjectATI(dst, _array, _size, _type, _stride, _buffer, _offset), NULL); \
    });
#define call_glArrayObjectATI(packed, ret_v) do { \
    glArrayObjectATI_PACKED *unpacked = (glArrayObjectATI_PACKED *)packed; \
    glArrayObjectATI_ARGS *args = (glArrayObjectATI_ARGS *)&unpacked->args; \
    glArrayObjectATI(args->array, args->size, args->type, args->stride, args->buffer, args->offset);; \
} while(0)
void glArrayObjectATI(glArrayObjectATI_ARG_EXPAND);
packed_call_t *pack_glArrayObjectATI(glArrayObjectATI_PACKED *_dst glArrayObjectATI_ARG_EXPAND_TAIL);
typedef void (*glArrayObjectATI_PTR)(glArrayObjectATI_ARG_EXPAND);
#endif
#ifndef glAsyncMarkerSGIX_RETURN
#define glAsyncMarkerSGIX_RETURN void
#define glAsyncMarkerSGIX_ARG_NAMES marker
#define glAsyncMarkerSGIX_ARG_EXPAND GLuint marker
#define glAsyncMarkerSGIX_ARG_NAMES_TAIL , marker
#define glAsyncMarkerSGIX_ARG_EXPAND_TAIL , GLuint marker
#define forward_glAsyncMarkerSGIX(_marker) \
    ({ \
        void *dst = remote_dma(sizeof(glAsyncMarkerSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAsyncMarkerSGIX(dst, _marker), NULL); \
    });
#define call_glAsyncMarkerSGIX(packed, ret_v) do { \
    glAsyncMarkerSGIX_PACKED *unpacked = (glAsyncMarkerSGIX_PACKED *)packed; \
    glAsyncMarkerSGIX_ARGS *args = (glAsyncMarkerSGIX_ARGS *)&unpacked->args; \
    glAsyncMarkerSGIX(args->marker);; \
} while(0)
void glAsyncMarkerSGIX(glAsyncMarkerSGIX_ARG_EXPAND);
packed_call_t *pack_glAsyncMarkerSGIX(glAsyncMarkerSGIX_PACKED *_dst glAsyncMarkerSGIX_ARG_EXPAND_TAIL);
typedef void (*glAsyncMarkerSGIX_PTR)(glAsyncMarkerSGIX_ARG_EXPAND);
#endif
#ifndef glAttachObjectARB_RETURN
#define glAttachObjectARB_RETURN void
#define glAttachObjectARB_ARG_NAMES containerObj, obj
#define glAttachObjectARB_ARG_EXPAND GLhandleARB containerObj, GLhandleARB obj
#define glAttachObjectARB_ARG_NAMES_TAIL , containerObj, obj
#define glAttachObjectARB_ARG_EXPAND_TAIL , GLhandleARB containerObj, GLhandleARB obj
#define forward_glAttachObjectARB(_containerObj, _obj) \
    ({ \
        void *dst = remote_dma(sizeof(glAttachObjectARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAttachObjectARB(dst, _containerObj, _obj), NULL); \
    });
#define call_glAttachObjectARB(packed, ret_v) do { \
    glAttachObjectARB_PACKED *unpacked = (glAttachObjectARB_PACKED *)packed; \
    glAttachObjectARB_ARGS *args = (glAttachObjectARB_ARGS *)&unpacked->args; \
    glAttachObjectARB(args->containerObj, args->obj);; \
} while(0)
void glAttachObjectARB(glAttachObjectARB_ARG_EXPAND);
packed_call_t *pack_glAttachObjectARB(glAttachObjectARB_PACKED *_dst glAttachObjectARB_ARG_EXPAND_TAIL);
typedef void (*glAttachObjectARB_PTR)(glAttachObjectARB_ARG_EXPAND);
#endif
#ifndef glAttachShader_RETURN
#define glAttachShader_RETURN void
#define glAttachShader_ARG_NAMES program, shader
#define glAttachShader_ARG_EXPAND GLuint program, GLuint shader
#define glAttachShader_ARG_NAMES_TAIL , program, shader
#define glAttachShader_ARG_EXPAND_TAIL , GLuint program, GLuint shader
#define forward_glAttachShader(_program, _shader) \
    ({ \
        void *dst = remote_dma(sizeof(glAttachShader_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glAttachShader(dst, _program, _shader), NULL); \
    });
#define call_glAttachShader(packed, ret_v) do { \
    glAttachShader_PACKED *unpacked = (glAttachShader_PACKED *)packed; \
    glAttachShader_ARGS *args = (glAttachShader_ARGS *)&unpacked->args; \
    glAttachShader(args->program, args->shader);; \
} while(0)
void glAttachShader(glAttachShader_ARG_EXPAND);
packed_call_t *pack_glAttachShader(glAttachShader_PACKED *_dst glAttachShader_ARG_EXPAND_TAIL);
typedef void (*glAttachShader_PTR)(glAttachShader_ARG_EXPAND);
#endif
#ifndef glBegin_RETURN
#define glBegin_RETURN void
#define glBegin_ARG_NAMES mode
#define glBegin_ARG_EXPAND GLenum mode
#define glBegin_ARG_NAMES_TAIL , mode
#define glBegin_ARG_EXPAND_TAIL , GLenum mode
#define forward_glBegin(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBegin_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBegin(dst, _mode), NULL); \
    });
#define call_glBegin(packed, ret_v) do { \
    glBegin_PACKED *unpacked = (glBegin_PACKED *)packed; \
    glBegin_ARGS *args = (glBegin_ARGS *)&unpacked->args; \
    glBegin(args->mode);; \
} while(0)
void glBegin(glBegin_ARG_EXPAND);
packed_call_t *pack_glBegin(glBegin_PACKED *_dst glBegin_ARG_EXPAND_TAIL);
typedef void (*glBegin_PTR)(glBegin_ARG_EXPAND);
#endif
#ifndef glBeginConditionalRender_RETURN
#define glBeginConditionalRender_RETURN void
#define glBeginConditionalRender_ARG_NAMES id, mode
#define glBeginConditionalRender_ARG_EXPAND GLuint id, GLenum mode
#define glBeginConditionalRender_ARG_NAMES_TAIL , id, mode
#define glBeginConditionalRender_ARG_EXPAND_TAIL , GLuint id, GLenum mode
#define forward_glBeginConditionalRender(_id, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginConditionalRender_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginConditionalRender(dst, _id, _mode), NULL); \
    });
#define call_glBeginConditionalRender(packed, ret_v) do { \
    glBeginConditionalRender_PACKED *unpacked = (glBeginConditionalRender_PACKED *)packed; \
    glBeginConditionalRender_ARGS *args = (glBeginConditionalRender_ARGS *)&unpacked->args; \
    glBeginConditionalRender(args->id, args->mode);; \
} while(0)
void glBeginConditionalRender(glBeginConditionalRender_ARG_EXPAND);
packed_call_t *pack_glBeginConditionalRender(glBeginConditionalRender_PACKED *_dst glBeginConditionalRender_ARG_EXPAND_TAIL);
typedef void (*glBeginConditionalRender_PTR)(glBeginConditionalRender_ARG_EXPAND);
#endif
#ifndef glBeginConditionalRenderNV_RETURN
#define glBeginConditionalRenderNV_RETURN void
#define glBeginConditionalRenderNV_ARG_NAMES id, mode
#define glBeginConditionalRenderNV_ARG_EXPAND GLuint id, GLenum mode
#define glBeginConditionalRenderNV_ARG_NAMES_TAIL , id, mode
#define glBeginConditionalRenderNV_ARG_EXPAND_TAIL , GLuint id, GLenum mode
#define forward_glBeginConditionalRenderNV(_id, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginConditionalRenderNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginConditionalRenderNV(dst, _id, _mode), NULL); \
    });
#define call_glBeginConditionalRenderNV(packed, ret_v) do { \
    glBeginConditionalRenderNV_PACKED *unpacked = (glBeginConditionalRenderNV_PACKED *)packed; \
    glBeginConditionalRenderNV_ARGS *args = (glBeginConditionalRenderNV_ARGS *)&unpacked->args; \
    glBeginConditionalRenderNV(args->id, args->mode);; \
} while(0)
void glBeginConditionalRenderNV(glBeginConditionalRenderNV_ARG_EXPAND);
packed_call_t *pack_glBeginConditionalRenderNV(glBeginConditionalRenderNV_PACKED *_dst glBeginConditionalRenderNV_ARG_EXPAND_TAIL);
typedef void (*glBeginConditionalRenderNV_PTR)(glBeginConditionalRenderNV_ARG_EXPAND);
#endif
#ifndef glBeginConditionalRenderNVX_RETURN
#define glBeginConditionalRenderNVX_RETURN void
#define glBeginConditionalRenderNVX_ARG_NAMES id
#define glBeginConditionalRenderNVX_ARG_EXPAND GLuint id
#define glBeginConditionalRenderNVX_ARG_NAMES_TAIL , id
#define glBeginConditionalRenderNVX_ARG_EXPAND_TAIL , GLuint id
#define forward_glBeginConditionalRenderNVX(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginConditionalRenderNVX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginConditionalRenderNVX(dst, _id), NULL); \
    });
#define call_glBeginConditionalRenderNVX(packed, ret_v) do { \
    glBeginConditionalRenderNVX_PACKED *unpacked = (glBeginConditionalRenderNVX_PACKED *)packed; \
    glBeginConditionalRenderNVX_ARGS *args = (glBeginConditionalRenderNVX_ARGS *)&unpacked->args; \
    glBeginConditionalRenderNVX(args->id);; \
} while(0)
void glBeginConditionalRenderNVX(glBeginConditionalRenderNVX_ARG_EXPAND);
packed_call_t *pack_glBeginConditionalRenderNVX(glBeginConditionalRenderNVX_PACKED *_dst glBeginConditionalRenderNVX_ARG_EXPAND_TAIL);
typedef void (*glBeginConditionalRenderNVX_PTR)(glBeginConditionalRenderNVX_ARG_EXPAND);
#endif
#ifndef glBeginFragmentShaderATI_RETURN
#define glBeginFragmentShaderATI_RETURN void
#define glBeginFragmentShaderATI_ARG_NAMES 
#define glBeginFragmentShaderATI_ARG_EXPAND 
#define glBeginFragmentShaderATI_ARG_NAMES_TAIL 
#define glBeginFragmentShaderATI_ARG_EXPAND_TAIL 
#define forward_glBeginFragmentShaderATI() \
    ({ \
        void *dst = remote_dma(sizeof(glBeginFragmentShaderATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginFragmentShaderATI(dst), NULL); \
    });
#define call_glBeginFragmentShaderATI(packed, ret_v) do { \
    glBeginFragmentShaderATI();; \
} while(0)
void glBeginFragmentShaderATI(glBeginFragmentShaderATI_ARG_EXPAND);
packed_call_t *pack_glBeginFragmentShaderATI(glBeginFragmentShaderATI_PACKED *_dst glBeginFragmentShaderATI_ARG_EXPAND_TAIL);
typedef void (*glBeginFragmentShaderATI_PTR)(glBeginFragmentShaderATI_ARG_EXPAND);
#endif
#ifndef glBeginOcclusionQueryNV_RETURN
#define glBeginOcclusionQueryNV_RETURN void
#define glBeginOcclusionQueryNV_ARG_NAMES id
#define glBeginOcclusionQueryNV_ARG_EXPAND GLuint id
#define glBeginOcclusionQueryNV_ARG_NAMES_TAIL , id
#define glBeginOcclusionQueryNV_ARG_EXPAND_TAIL , GLuint id
#define forward_glBeginOcclusionQueryNV(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginOcclusionQueryNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginOcclusionQueryNV(dst, _id), NULL); \
    });
#define call_glBeginOcclusionQueryNV(packed, ret_v) do { \
    glBeginOcclusionQueryNV_PACKED *unpacked = (glBeginOcclusionQueryNV_PACKED *)packed; \
    glBeginOcclusionQueryNV_ARGS *args = (glBeginOcclusionQueryNV_ARGS *)&unpacked->args; \
    glBeginOcclusionQueryNV(args->id);; \
} while(0)
void glBeginOcclusionQueryNV(glBeginOcclusionQueryNV_ARG_EXPAND);
packed_call_t *pack_glBeginOcclusionQueryNV(glBeginOcclusionQueryNV_PACKED *_dst glBeginOcclusionQueryNV_ARG_EXPAND_TAIL);
typedef void (*glBeginOcclusionQueryNV_PTR)(glBeginOcclusionQueryNV_ARG_EXPAND);
#endif
#ifndef glBeginPerfMonitorAMD_RETURN
#define glBeginPerfMonitorAMD_RETURN void
#define glBeginPerfMonitorAMD_ARG_NAMES monitor
#define glBeginPerfMonitorAMD_ARG_EXPAND GLuint monitor
#define glBeginPerfMonitorAMD_ARG_NAMES_TAIL , monitor
#define glBeginPerfMonitorAMD_ARG_EXPAND_TAIL , GLuint monitor
#define forward_glBeginPerfMonitorAMD(_monitor) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginPerfMonitorAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginPerfMonitorAMD(dst, _monitor), NULL); \
    });
#define call_glBeginPerfMonitorAMD(packed, ret_v) do { \
    glBeginPerfMonitorAMD_PACKED *unpacked = (glBeginPerfMonitorAMD_PACKED *)packed; \
    glBeginPerfMonitorAMD_ARGS *args = (glBeginPerfMonitorAMD_ARGS *)&unpacked->args; \
    glBeginPerfMonitorAMD(args->monitor);; \
} while(0)
void glBeginPerfMonitorAMD(glBeginPerfMonitorAMD_ARG_EXPAND);
packed_call_t *pack_glBeginPerfMonitorAMD(glBeginPerfMonitorAMD_PACKED *_dst glBeginPerfMonitorAMD_ARG_EXPAND_TAIL);
typedef void (*glBeginPerfMonitorAMD_PTR)(glBeginPerfMonitorAMD_ARG_EXPAND);
#endif
#ifndef glBeginQuery_RETURN
#define glBeginQuery_RETURN void
#define glBeginQuery_ARG_NAMES target, id
#define glBeginQuery_ARG_EXPAND GLenum target, GLuint id
#define glBeginQuery_ARG_NAMES_TAIL , target, id
#define glBeginQuery_ARG_EXPAND_TAIL , GLenum target, GLuint id
#define forward_glBeginQuery(_target, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginQuery_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginQuery(dst, _target, _id), NULL); \
    });
#define call_glBeginQuery(packed, ret_v) do { \
    glBeginQuery_PACKED *unpacked = (glBeginQuery_PACKED *)packed; \
    glBeginQuery_ARGS *args = (glBeginQuery_ARGS *)&unpacked->args; \
    glBeginQuery(args->target, args->id);; \
} while(0)
void glBeginQuery(glBeginQuery_ARG_EXPAND);
packed_call_t *pack_glBeginQuery(glBeginQuery_PACKED *_dst glBeginQuery_ARG_EXPAND_TAIL);
typedef void (*glBeginQuery_PTR)(glBeginQuery_ARG_EXPAND);
#endif
#ifndef glBeginQueryARB_RETURN
#define glBeginQueryARB_RETURN void
#define glBeginQueryARB_ARG_NAMES target, id
#define glBeginQueryARB_ARG_EXPAND GLenum target, GLuint id
#define glBeginQueryARB_ARG_NAMES_TAIL , target, id
#define glBeginQueryARB_ARG_EXPAND_TAIL , GLenum target, GLuint id
#define forward_glBeginQueryARB(_target, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginQueryARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginQueryARB(dst, _target, _id), NULL); \
    });
#define call_glBeginQueryARB(packed, ret_v) do { \
    glBeginQueryARB_PACKED *unpacked = (glBeginQueryARB_PACKED *)packed; \
    glBeginQueryARB_ARGS *args = (glBeginQueryARB_ARGS *)&unpacked->args; \
    glBeginQueryARB(args->target, args->id);; \
} while(0)
void glBeginQueryARB(glBeginQueryARB_ARG_EXPAND);
packed_call_t *pack_glBeginQueryARB(glBeginQueryARB_PACKED *_dst glBeginQueryARB_ARG_EXPAND_TAIL);
typedef void (*glBeginQueryARB_PTR)(glBeginQueryARB_ARG_EXPAND);
#endif
#ifndef glBeginQueryIndexed_RETURN
#define glBeginQueryIndexed_RETURN void
#define glBeginQueryIndexed_ARG_NAMES target, index, id
#define glBeginQueryIndexed_ARG_EXPAND GLenum target, GLuint index, GLuint id
#define glBeginQueryIndexed_ARG_NAMES_TAIL , target, index, id
#define glBeginQueryIndexed_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint id
#define forward_glBeginQueryIndexed(_target, _index, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginQueryIndexed_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginQueryIndexed(dst, _target, _index, _id), NULL); \
    });
#define call_glBeginQueryIndexed(packed, ret_v) do { \
    glBeginQueryIndexed_PACKED *unpacked = (glBeginQueryIndexed_PACKED *)packed; \
    glBeginQueryIndexed_ARGS *args = (glBeginQueryIndexed_ARGS *)&unpacked->args; \
    glBeginQueryIndexed(args->target, args->index, args->id);; \
} while(0)
void glBeginQueryIndexed(glBeginQueryIndexed_ARG_EXPAND);
packed_call_t *pack_glBeginQueryIndexed(glBeginQueryIndexed_PACKED *_dst glBeginQueryIndexed_ARG_EXPAND_TAIL);
typedef void (*glBeginQueryIndexed_PTR)(glBeginQueryIndexed_ARG_EXPAND);
#endif
#ifndef glBeginTransformFeedback_RETURN
#define glBeginTransformFeedback_RETURN void
#define glBeginTransformFeedback_ARG_NAMES primitiveMode
#define glBeginTransformFeedback_ARG_EXPAND GLenum primitiveMode
#define glBeginTransformFeedback_ARG_NAMES_TAIL , primitiveMode
#define glBeginTransformFeedback_ARG_EXPAND_TAIL , GLenum primitiveMode
#define forward_glBeginTransformFeedback(_primitiveMode) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginTransformFeedback_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginTransformFeedback(dst, _primitiveMode), NULL); \
    });
#define call_glBeginTransformFeedback(packed, ret_v) do { \
    glBeginTransformFeedback_PACKED *unpacked = (glBeginTransformFeedback_PACKED *)packed; \
    glBeginTransformFeedback_ARGS *args = (glBeginTransformFeedback_ARGS *)&unpacked->args; \
    glBeginTransformFeedback(args->primitiveMode);; \
} while(0)
void glBeginTransformFeedback(glBeginTransformFeedback_ARG_EXPAND);
packed_call_t *pack_glBeginTransformFeedback(glBeginTransformFeedback_PACKED *_dst glBeginTransformFeedback_ARG_EXPAND_TAIL);
typedef void (*glBeginTransformFeedback_PTR)(glBeginTransformFeedback_ARG_EXPAND);
#endif
#ifndef glBeginTransformFeedbackEXT_RETURN
#define glBeginTransformFeedbackEXT_RETURN void
#define glBeginTransformFeedbackEXT_ARG_NAMES primitiveMode
#define glBeginTransformFeedbackEXT_ARG_EXPAND GLenum primitiveMode
#define glBeginTransformFeedbackEXT_ARG_NAMES_TAIL , primitiveMode
#define glBeginTransformFeedbackEXT_ARG_EXPAND_TAIL , GLenum primitiveMode
#define forward_glBeginTransformFeedbackEXT(_primitiveMode) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginTransformFeedbackEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginTransformFeedbackEXT(dst, _primitiveMode), NULL); \
    });
#define call_glBeginTransformFeedbackEXT(packed, ret_v) do { \
    glBeginTransformFeedbackEXT_PACKED *unpacked = (glBeginTransformFeedbackEXT_PACKED *)packed; \
    glBeginTransformFeedbackEXT_ARGS *args = (glBeginTransformFeedbackEXT_ARGS *)&unpacked->args; \
    glBeginTransformFeedbackEXT(args->primitiveMode);; \
} while(0)
void glBeginTransformFeedbackEXT(glBeginTransformFeedbackEXT_ARG_EXPAND);
packed_call_t *pack_glBeginTransformFeedbackEXT(glBeginTransformFeedbackEXT_PACKED *_dst glBeginTransformFeedbackEXT_ARG_EXPAND_TAIL);
typedef void (*glBeginTransformFeedbackEXT_PTR)(glBeginTransformFeedbackEXT_ARG_EXPAND);
#endif
#ifndef glBeginTransformFeedbackNV_RETURN
#define glBeginTransformFeedbackNV_RETURN void
#define glBeginTransformFeedbackNV_ARG_NAMES primitiveMode
#define glBeginTransformFeedbackNV_ARG_EXPAND GLenum primitiveMode
#define glBeginTransformFeedbackNV_ARG_NAMES_TAIL , primitiveMode
#define glBeginTransformFeedbackNV_ARG_EXPAND_TAIL , GLenum primitiveMode
#define forward_glBeginTransformFeedbackNV(_primitiveMode) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginTransformFeedbackNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginTransformFeedbackNV(dst, _primitiveMode), NULL); \
    });
#define call_glBeginTransformFeedbackNV(packed, ret_v) do { \
    glBeginTransformFeedbackNV_PACKED *unpacked = (glBeginTransformFeedbackNV_PACKED *)packed; \
    glBeginTransformFeedbackNV_ARGS *args = (glBeginTransformFeedbackNV_ARGS *)&unpacked->args; \
    glBeginTransformFeedbackNV(args->primitiveMode);; \
} while(0)
void glBeginTransformFeedbackNV(glBeginTransformFeedbackNV_ARG_EXPAND);
packed_call_t *pack_glBeginTransformFeedbackNV(glBeginTransformFeedbackNV_PACKED *_dst glBeginTransformFeedbackNV_ARG_EXPAND_TAIL);
typedef void (*glBeginTransformFeedbackNV_PTR)(glBeginTransformFeedbackNV_ARG_EXPAND);
#endif
#ifndef glBeginVertexShaderEXT_RETURN
#define glBeginVertexShaderEXT_RETURN void
#define glBeginVertexShaderEXT_ARG_NAMES 
#define glBeginVertexShaderEXT_ARG_EXPAND 
#define glBeginVertexShaderEXT_ARG_NAMES_TAIL 
#define glBeginVertexShaderEXT_ARG_EXPAND_TAIL 
#define forward_glBeginVertexShaderEXT() \
    ({ \
        void *dst = remote_dma(sizeof(glBeginVertexShaderEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginVertexShaderEXT(dst), NULL); \
    });
#define call_glBeginVertexShaderEXT(packed, ret_v) do { \
    glBeginVertexShaderEXT();; \
} while(0)
void glBeginVertexShaderEXT(glBeginVertexShaderEXT_ARG_EXPAND);
packed_call_t *pack_glBeginVertexShaderEXT(glBeginVertexShaderEXT_PACKED *_dst glBeginVertexShaderEXT_ARG_EXPAND_TAIL);
typedef void (*glBeginVertexShaderEXT_PTR)(glBeginVertexShaderEXT_ARG_EXPAND);
#endif
#ifndef glBeginVideoCaptureNV_RETURN
#define glBeginVideoCaptureNV_RETURN void
#define glBeginVideoCaptureNV_ARG_NAMES video_capture_slot
#define glBeginVideoCaptureNV_ARG_EXPAND GLuint video_capture_slot
#define glBeginVideoCaptureNV_ARG_NAMES_TAIL , video_capture_slot
#define glBeginVideoCaptureNV_ARG_EXPAND_TAIL , GLuint video_capture_slot
#define forward_glBeginVideoCaptureNV(_video_capture_slot) \
    ({ \
        void *dst = remote_dma(sizeof(glBeginVideoCaptureNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBeginVideoCaptureNV(dst, _video_capture_slot), NULL); \
    });
#define call_glBeginVideoCaptureNV(packed, ret_v) do { \
    glBeginVideoCaptureNV_PACKED *unpacked = (glBeginVideoCaptureNV_PACKED *)packed; \
    glBeginVideoCaptureNV_ARGS *args = (glBeginVideoCaptureNV_ARGS *)&unpacked->args; \
    glBeginVideoCaptureNV(args->video_capture_slot);; \
} while(0)
void glBeginVideoCaptureNV(glBeginVideoCaptureNV_ARG_EXPAND);
packed_call_t *pack_glBeginVideoCaptureNV(glBeginVideoCaptureNV_PACKED *_dst glBeginVideoCaptureNV_ARG_EXPAND_TAIL);
typedef void (*glBeginVideoCaptureNV_PTR)(glBeginVideoCaptureNV_ARG_EXPAND);
#endif
#ifndef glBindAttribLocation_RETURN
#define glBindAttribLocation_RETURN void
#define glBindAttribLocation_ARG_NAMES program, index, name
#define glBindAttribLocation_ARG_EXPAND GLuint program, GLuint index, const GLchar * name
#define glBindAttribLocation_ARG_NAMES_TAIL , program, index, name
#define glBindAttribLocation_ARG_EXPAND_TAIL , GLuint program, GLuint index, const GLchar * name
#define forward_glBindAttribLocation(_program, _index, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glBindAttribLocation_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindAttribLocation(dst, _program, _index, _name), NULL); \
    });
#define call_glBindAttribLocation(packed, ret_v) do { \
    glBindAttribLocation_PACKED *unpacked = (glBindAttribLocation_PACKED *)packed; \
    glBindAttribLocation_ARGS *args = (glBindAttribLocation_ARGS *)&unpacked->args; \
    glBindAttribLocation(args->program, args->index, args->name);; \
} while(0)
void glBindAttribLocation(glBindAttribLocation_ARG_EXPAND);
packed_call_t *pack_glBindAttribLocation(glBindAttribLocation_PACKED *_dst glBindAttribLocation_ARG_EXPAND_TAIL);
typedef void (*glBindAttribLocation_PTR)(glBindAttribLocation_ARG_EXPAND);
#endif
#ifndef glBindAttribLocationARB_RETURN
#define glBindAttribLocationARB_RETURN void
#define glBindAttribLocationARB_ARG_NAMES programObj, index, name
#define glBindAttribLocationARB_ARG_EXPAND GLhandleARB programObj, GLuint index, const GLcharARB * name
#define glBindAttribLocationARB_ARG_NAMES_TAIL , programObj, index, name
#define glBindAttribLocationARB_ARG_EXPAND_TAIL , GLhandleARB programObj, GLuint index, const GLcharARB * name
#define forward_glBindAttribLocationARB(_programObj, _index, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glBindAttribLocationARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindAttribLocationARB(dst, _programObj, _index, _name), NULL); \
    });
#define call_glBindAttribLocationARB(packed, ret_v) do { \
    glBindAttribLocationARB_PACKED *unpacked = (glBindAttribLocationARB_PACKED *)packed; \
    glBindAttribLocationARB_ARGS *args = (glBindAttribLocationARB_ARGS *)&unpacked->args; \
    glBindAttribLocationARB(args->programObj, args->index, args->name);; \
} while(0)
void glBindAttribLocationARB(glBindAttribLocationARB_ARG_EXPAND);
packed_call_t *pack_glBindAttribLocationARB(glBindAttribLocationARB_PACKED *_dst glBindAttribLocationARB_ARG_EXPAND_TAIL);
typedef void (*glBindAttribLocationARB_PTR)(glBindAttribLocationARB_ARG_EXPAND);
#endif
#ifndef glBindBuffer_RETURN
#define glBindBuffer_RETURN void
#define glBindBuffer_ARG_NAMES target, buffer
#define glBindBuffer_ARG_EXPAND GLenum target, GLuint buffer
#define glBindBuffer_ARG_NAMES_TAIL , target, buffer
#define glBindBuffer_ARG_EXPAND_TAIL , GLenum target, GLuint buffer
#define forward_glBindBuffer(_target, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBuffer(dst, _target, _buffer), NULL); \
    });
#define call_glBindBuffer(packed, ret_v) do { \
    glBindBuffer_PACKED *unpacked = (glBindBuffer_PACKED *)packed; \
    glBindBuffer_ARGS *args = (glBindBuffer_ARGS *)&unpacked->args; \
    glBindBuffer(args->target, args->buffer);; \
} while(0)
void glBindBuffer(glBindBuffer_ARG_EXPAND);
packed_call_t *pack_glBindBuffer(glBindBuffer_PACKED *_dst glBindBuffer_ARG_EXPAND_TAIL);
typedef void (*glBindBuffer_PTR)(glBindBuffer_ARG_EXPAND);
#endif
#ifndef glBindBufferARB_RETURN
#define glBindBufferARB_RETURN void
#define glBindBufferARB_ARG_NAMES target, buffer
#define glBindBufferARB_ARG_EXPAND GLenum target, GLuint buffer
#define glBindBufferARB_ARG_NAMES_TAIL , target, buffer
#define glBindBufferARB_ARG_EXPAND_TAIL , GLenum target, GLuint buffer
#define forward_glBindBufferARB(_target, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferARB(dst, _target, _buffer), NULL); \
    });
#define call_glBindBufferARB(packed, ret_v) do { \
    glBindBufferARB_PACKED *unpacked = (glBindBufferARB_PACKED *)packed; \
    glBindBufferARB_ARGS *args = (glBindBufferARB_ARGS *)&unpacked->args; \
    glBindBufferARB(args->target, args->buffer);; \
} while(0)
void glBindBufferARB(glBindBufferARB_ARG_EXPAND);
packed_call_t *pack_glBindBufferARB(glBindBufferARB_PACKED *_dst glBindBufferARB_ARG_EXPAND_TAIL);
typedef void (*glBindBufferARB_PTR)(glBindBufferARB_ARG_EXPAND);
#endif
#ifndef glBindBufferBase_RETURN
#define glBindBufferBase_RETURN void
#define glBindBufferBase_ARG_NAMES target, index, buffer
#define glBindBufferBase_ARG_EXPAND GLenum target, GLuint index, GLuint buffer
#define glBindBufferBase_ARG_NAMES_TAIL , target, index, buffer
#define glBindBufferBase_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer
#define forward_glBindBufferBase(_target, _index, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferBase_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferBase(dst, _target, _index, _buffer), NULL); \
    });
#define call_glBindBufferBase(packed, ret_v) do { \
    glBindBufferBase_PACKED *unpacked = (glBindBufferBase_PACKED *)packed; \
    glBindBufferBase_ARGS *args = (glBindBufferBase_ARGS *)&unpacked->args; \
    glBindBufferBase(args->target, args->index, args->buffer);; \
} while(0)
void glBindBufferBase(glBindBufferBase_ARG_EXPAND);
packed_call_t *pack_glBindBufferBase(glBindBufferBase_PACKED *_dst glBindBufferBase_ARG_EXPAND_TAIL);
typedef void (*glBindBufferBase_PTR)(glBindBufferBase_ARG_EXPAND);
#endif
#ifndef glBindBufferBaseEXT_RETURN
#define glBindBufferBaseEXT_RETURN void
#define glBindBufferBaseEXT_ARG_NAMES target, index, buffer
#define glBindBufferBaseEXT_ARG_EXPAND GLenum target, GLuint index, GLuint buffer
#define glBindBufferBaseEXT_ARG_NAMES_TAIL , target, index, buffer
#define glBindBufferBaseEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer
#define forward_glBindBufferBaseEXT(_target, _index, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferBaseEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferBaseEXT(dst, _target, _index, _buffer), NULL); \
    });
#define call_glBindBufferBaseEXT(packed, ret_v) do { \
    glBindBufferBaseEXT_PACKED *unpacked = (glBindBufferBaseEXT_PACKED *)packed; \
    glBindBufferBaseEXT_ARGS *args = (glBindBufferBaseEXT_ARGS *)&unpacked->args; \
    glBindBufferBaseEXT(args->target, args->index, args->buffer);; \
} while(0)
void glBindBufferBaseEXT(glBindBufferBaseEXT_ARG_EXPAND);
packed_call_t *pack_glBindBufferBaseEXT(glBindBufferBaseEXT_PACKED *_dst glBindBufferBaseEXT_ARG_EXPAND_TAIL);
typedef void (*glBindBufferBaseEXT_PTR)(glBindBufferBaseEXT_ARG_EXPAND);
#endif
#ifndef glBindBufferBaseNV_RETURN
#define glBindBufferBaseNV_RETURN void
#define glBindBufferBaseNV_ARG_NAMES target, index, buffer
#define glBindBufferBaseNV_ARG_EXPAND GLenum target, GLuint index, GLuint buffer
#define glBindBufferBaseNV_ARG_NAMES_TAIL , target, index, buffer
#define glBindBufferBaseNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer
#define forward_glBindBufferBaseNV(_target, _index, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferBaseNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferBaseNV(dst, _target, _index, _buffer), NULL); \
    });
#define call_glBindBufferBaseNV(packed, ret_v) do { \
    glBindBufferBaseNV_PACKED *unpacked = (glBindBufferBaseNV_PACKED *)packed; \
    glBindBufferBaseNV_ARGS *args = (glBindBufferBaseNV_ARGS *)&unpacked->args; \
    glBindBufferBaseNV(args->target, args->index, args->buffer);; \
} while(0)
void glBindBufferBaseNV(glBindBufferBaseNV_ARG_EXPAND);
packed_call_t *pack_glBindBufferBaseNV(glBindBufferBaseNV_PACKED *_dst glBindBufferBaseNV_ARG_EXPAND_TAIL);
typedef void (*glBindBufferBaseNV_PTR)(glBindBufferBaseNV_ARG_EXPAND);
#endif
#ifndef glBindBufferOffsetEXT_RETURN
#define glBindBufferOffsetEXT_RETURN void
#define glBindBufferOffsetEXT_ARG_NAMES target, index, buffer, offset
#define glBindBufferOffsetEXT_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset
#define glBindBufferOffsetEXT_ARG_NAMES_TAIL , target, index, buffer, offset
#define glBindBufferOffsetEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer, GLintptr offset
#define forward_glBindBufferOffsetEXT(_target, _index, _buffer, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferOffsetEXT(dst, _target, _index, _buffer, _offset), NULL); \
    });
#define call_glBindBufferOffsetEXT(packed, ret_v) do { \
    glBindBufferOffsetEXT_PACKED *unpacked = (glBindBufferOffsetEXT_PACKED *)packed; \
    glBindBufferOffsetEXT_ARGS *args = (glBindBufferOffsetEXT_ARGS *)&unpacked->args; \
    glBindBufferOffsetEXT(args->target, args->index, args->buffer, args->offset);; \
} while(0)
void glBindBufferOffsetEXT(glBindBufferOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glBindBufferOffsetEXT(glBindBufferOffsetEXT_PACKED *_dst glBindBufferOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glBindBufferOffsetEXT_PTR)(glBindBufferOffsetEXT_ARG_EXPAND);
#endif
#ifndef glBindBufferOffsetNV_RETURN
#define glBindBufferOffsetNV_RETURN void
#define glBindBufferOffsetNV_ARG_NAMES target, index, buffer, offset
#define glBindBufferOffsetNV_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset
#define glBindBufferOffsetNV_ARG_NAMES_TAIL , target, index, buffer, offset
#define glBindBufferOffsetNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer, GLintptr offset
#define forward_glBindBufferOffsetNV(_target, _index, _buffer, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferOffsetNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferOffsetNV(dst, _target, _index, _buffer, _offset), NULL); \
    });
#define call_glBindBufferOffsetNV(packed, ret_v) do { \
    glBindBufferOffsetNV_PACKED *unpacked = (glBindBufferOffsetNV_PACKED *)packed; \
    glBindBufferOffsetNV_ARGS *args = (glBindBufferOffsetNV_ARGS *)&unpacked->args; \
    glBindBufferOffsetNV(args->target, args->index, args->buffer, args->offset);; \
} while(0)
void glBindBufferOffsetNV(glBindBufferOffsetNV_ARG_EXPAND);
packed_call_t *pack_glBindBufferOffsetNV(glBindBufferOffsetNV_PACKED *_dst glBindBufferOffsetNV_ARG_EXPAND_TAIL);
typedef void (*glBindBufferOffsetNV_PTR)(glBindBufferOffsetNV_ARG_EXPAND);
#endif
#ifndef glBindBufferRange_RETURN
#define glBindBufferRange_RETURN void
#define glBindBufferRange_ARG_NAMES target, index, buffer, offset, size
#define glBindBufferRange_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glBindBufferRange_ARG_NAMES_TAIL , target, index, buffer, offset, size
#define glBindBufferRange_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define forward_glBindBufferRange(_target, _index, _buffer, _offset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferRange_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferRange(dst, _target, _index, _buffer, _offset, _size), NULL); \
    });
#define call_glBindBufferRange(packed, ret_v) do { \
    glBindBufferRange_PACKED *unpacked = (glBindBufferRange_PACKED *)packed; \
    glBindBufferRange_ARGS *args = (glBindBufferRange_ARGS *)&unpacked->args; \
    glBindBufferRange(args->target, args->index, args->buffer, args->offset, args->size);; \
} while(0)
void glBindBufferRange(glBindBufferRange_ARG_EXPAND);
packed_call_t *pack_glBindBufferRange(glBindBufferRange_PACKED *_dst glBindBufferRange_ARG_EXPAND_TAIL);
typedef void (*glBindBufferRange_PTR)(glBindBufferRange_ARG_EXPAND);
#endif
#ifndef glBindBufferRangeEXT_RETURN
#define glBindBufferRangeEXT_RETURN void
#define glBindBufferRangeEXT_ARG_NAMES target, index, buffer, offset, size
#define glBindBufferRangeEXT_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glBindBufferRangeEXT_ARG_NAMES_TAIL , target, index, buffer, offset, size
#define glBindBufferRangeEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define forward_glBindBufferRangeEXT(_target, _index, _buffer, _offset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferRangeEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferRangeEXT(dst, _target, _index, _buffer, _offset, _size), NULL); \
    });
#define call_glBindBufferRangeEXT(packed, ret_v) do { \
    glBindBufferRangeEXT_PACKED *unpacked = (glBindBufferRangeEXT_PACKED *)packed; \
    glBindBufferRangeEXT_ARGS *args = (glBindBufferRangeEXT_ARGS *)&unpacked->args; \
    glBindBufferRangeEXT(args->target, args->index, args->buffer, args->offset, args->size);; \
} while(0)
void glBindBufferRangeEXT(glBindBufferRangeEXT_ARG_EXPAND);
packed_call_t *pack_glBindBufferRangeEXT(glBindBufferRangeEXT_PACKED *_dst glBindBufferRangeEXT_ARG_EXPAND_TAIL);
typedef void (*glBindBufferRangeEXT_PTR)(glBindBufferRangeEXT_ARG_EXPAND);
#endif
#ifndef glBindBufferRangeNV_RETURN
#define glBindBufferRangeNV_RETURN void
#define glBindBufferRangeNV_ARG_NAMES target, index, buffer, offset, size
#define glBindBufferRangeNV_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glBindBufferRangeNV_ARG_NAMES_TAIL , target, index, buffer, offset, size
#define glBindBufferRangeNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define forward_glBindBufferRangeNV(_target, _index, _buffer, _offset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glBindBufferRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindBufferRangeNV(dst, _target, _index, _buffer, _offset, _size), NULL); \
    });
#define call_glBindBufferRangeNV(packed, ret_v) do { \
    glBindBufferRangeNV_PACKED *unpacked = (glBindBufferRangeNV_PACKED *)packed; \
    glBindBufferRangeNV_ARGS *args = (glBindBufferRangeNV_ARGS *)&unpacked->args; \
    glBindBufferRangeNV(args->target, args->index, args->buffer, args->offset, args->size);; \
} while(0)
void glBindBufferRangeNV(glBindBufferRangeNV_ARG_EXPAND);
packed_call_t *pack_glBindBufferRangeNV(glBindBufferRangeNV_PACKED *_dst glBindBufferRangeNV_ARG_EXPAND_TAIL);
typedef void (*glBindBufferRangeNV_PTR)(glBindBufferRangeNV_ARG_EXPAND);
#endif
#ifndef glBindFragDataLocation_RETURN
#define glBindFragDataLocation_RETURN void
#define glBindFragDataLocation_ARG_NAMES program, color, name
#define glBindFragDataLocation_ARG_EXPAND GLuint program, GLuint color, const GLchar * name
#define glBindFragDataLocation_ARG_NAMES_TAIL , program, color, name
#define glBindFragDataLocation_ARG_EXPAND_TAIL , GLuint program, GLuint color, const GLchar * name
#define forward_glBindFragDataLocation(_program, _color, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glBindFragDataLocation_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindFragDataLocation(dst, _program, _color, _name), NULL); \
    });
#define call_glBindFragDataLocation(packed, ret_v) do { \
    glBindFragDataLocation_PACKED *unpacked = (glBindFragDataLocation_PACKED *)packed; \
    glBindFragDataLocation_ARGS *args = (glBindFragDataLocation_ARGS *)&unpacked->args; \
    glBindFragDataLocation(args->program, args->color, args->name);; \
} while(0)
void glBindFragDataLocation(glBindFragDataLocation_ARG_EXPAND);
packed_call_t *pack_glBindFragDataLocation(glBindFragDataLocation_PACKED *_dst glBindFragDataLocation_ARG_EXPAND_TAIL);
typedef void (*glBindFragDataLocation_PTR)(glBindFragDataLocation_ARG_EXPAND);
#endif
#ifndef glBindFragDataLocationEXT_RETURN
#define glBindFragDataLocationEXT_RETURN void
#define glBindFragDataLocationEXT_ARG_NAMES program, color, name
#define glBindFragDataLocationEXT_ARG_EXPAND GLuint program, GLuint color, const GLchar * name
#define glBindFragDataLocationEXT_ARG_NAMES_TAIL , program, color, name
#define glBindFragDataLocationEXT_ARG_EXPAND_TAIL , GLuint program, GLuint color, const GLchar * name
#define forward_glBindFragDataLocationEXT(_program, _color, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glBindFragDataLocationEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindFragDataLocationEXT(dst, _program, _color, _name), NULL); \
    });
#define call_glBindFragDataLocationEXT(packed, ret_v) do { \
    glBindFragDataLocationEXT_PACKED *unpacked = (glBindFragDataLocationEXT_PACKED *)packed; \
    glBindFragDataLocationEXT_ARGS *args = (glBindFragDataLocationEXT_ARGS *)&unpacked->args; \
    glBindFragDataLocationEXT(args->program, args->color, args->name);; \
} while(0)
void glBindFragDataLocationEXT(glBindFragDataLocationEXT_ARG_EXPAND);
packed_call_t *pack_glBindFragDataLocationEXT(glBindFragDataLocationEXT_PACKED *_dst glBindFragDataLocationEXT_ARG_EXPAND_TAIL);
typedef void (*glBindFragDataLocationEXT_PTR)(glBindFragDataLocationEXT_ARG_EXPAND);
#endif
#ifndef glBindFragDataLocationIndexed_RETURN
#define glBindFragDataLocationIndexed_RETURN void
#define glBindFragDataLocationIndexed_ARG_NAMES program, colorNumber, index, name
#define glBindFragDataLocationIndexed_ARG_EXPAND GLuint program, GLuint colorNumber, GLuint index, const GLchar * name
#define glBindFragDataLocationIndexed_ARG_NAMES_TAIL , program, colorNumber, index, name
#define glBindFragDataLocationIndexed_ARG_EXPAND_TAIL , GLuint program, GLuint colorNumber, GLuint index, const GLchar * name
#define forward_glBindFragDataLocationIndexed(_program, _colorNumber, _index, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glBindFragDataLocationIndexed_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindFragDataLocationIndexed(dst, _program, _colorNumber, _index, _name), NULL); \
    });
#define call_glBindFragDataLocationIndexed(packed, ret_v) do { \
    glBindFragDataLocationIndexed_PACKED *unpacked = (glBindFragDataLocationIndexed_PACKED *)packed; \
    glBindFragDataLocationIndexed_ARGS *args = (glBindFragDataLocationIndexed_ARGS *)&unpacked->args; \
    glBindFragDataLocationIndexed(args->program, args->colorNumber, args->index, args->name);; \
} while(0)
void glBindFragDataLocationIndexed(glBindFragDataLocationIndexed_ARG_EXPAND);
packed_call_t *pack_glBindFragDataLocationIndexed(glBindFragDataLocationIndexed_PACKED *_dst glBindFragDataLocationIndexed_ARG_EXPAND_TAIL);
typedef void (*glBindFragDataLocationIndexed_PTR)(glBindFragDataLocationIndexed_ARG_EXPAND);
#endif
#ifndef glBindFragmentShaderATI_RETURN
#define glBindFragmentShaderATI_RETURN void
#define glBindFragmentShaderATI_ARG_NAMES id
#define glBindFragmentShaderATI_ARG_EXPAND GLuint id
#define glBindFragmentShaderATI_ARG_NAMES_TAIL , id
#define glBindFragmentShaderATI_ARG_EXPAND_TAIL , GLuint id
#define forward_glBindFragmentShaderATI(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glBindFragmentShaderATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindFragmentShaderATI(dst, _id), NULL); \
    });
#define call_glBindFragmentShaderATI(packed, ret_v) do { \
    glBindFragmentShaderATI_PACKED *unpacked = (glBindFragmentShaderATI_PACKED *)packed; \
    glBindFragmentShaderATI_ARGS *args = (glBindFragmentShaderATI_ARGS *)&unpacked->args; \
    glBindFragmentShaderATI(args->id);; \
} while(0)
void glBindFragmentShaderATI(glBindFragmentShaderATI_ARG_EXPAND);
packed_call_t *pack_glBindFragmentShaderATI(glBindFragmentShaderATI_PACKED *_dst glBindFragmentShaderATI_ARG_EXPAND_TAIL);
typedef void (*glBindFragmentShaderATI_PTR)(glBindFragmentShaderATI_ARG_EXPAND);
#endif
#ifndef glBindFramebuffer_RETURN
#define glBindFramebuffer_RETURN void
#define glBindFramebuffer_ARG_NAMES target, framebuffer
#define glBindFramebuffer_ARG_EXPAND GLenum target, GLuint framebuffer
#define glBindFramebuffer_ARG_NAMES_TAIL , target, framebuffer
#define glBindFramebuffer_ARG_EXPAND_TAIL , GLenum target, GLuint framebuffer
#define forward_glBindFramebuffer(_target, _framebuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindFramebuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindFramebuffer(dst, _target, _framebuffer), NULL); \
    });
#define call_glBindFramebuffer(packed, ret_v) do { \
    glBindFramebuffer_PACKED *unpacked = (glBindFramebuffer_PACKED *)packed; \
    glBindFramebuffer_ARGS *args = (glBindFramebuffer_ARGS *)&unpacked->args; \
    glBindFramebuffer(args->target, args->framebuffer);; \
} while(0)
void glBindFramebuffer(glBindFramebuffer_ARG_EXPAND);
packed_call_t *pack_glBindFramebuffer(glBindFramebuffer_PACKED *_dst glBindFramebuffer_ARG_EXPAND_TAIL);
typedef void (*glBindFramebuffer_PTR)(glBindFramebuffer_ARG_EXPAND);
#endif
#ifndef glBindFramebufferEXT_RETURN
#define glBindFramebufferEXT_RETURN void
#define glBindFramebufferEXT_ARG_NAMES target, framebuffer
#define glBindFramebufferEXT_ARG_EXPAND GLenum target, GLuint framebuffer
#define glBindFramebufferEXT_ARG_NAMES_TAIL , target, framebuffer
#define glBindFramebufferEXT_ARG_EXPAND_TAIL , GLenum target, GLuint framebuffer
#define forward_glBindFramebufferEXT(_target, _framebuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindFramebufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindFramebufferEXT(dst, _target, _framebuffer), NULL); \
    });
#define call_glBindFramebufferEXT(packed, ret_v) do { \
    glBindFramebufferEXT_PACKED *unpacked = (glBindFramebufferEXT_PACKED *)packed; \
    glBindFramebufferEXT_ARGS *args = (glBindFramebufferEXT_ARGS *)&unpacked->args; \
    glBindFramebufferEXT(args->target, args->framebuffer);; \
} while(0)
void glBindFramebufferEXT(glBindFramebufferEXT_ARG_EXPAND);
packed_call_t *pack_glBindFramebufferEXT(glBindFramebufferEXT_PACKED *_dst glBindFramebufferEXT_ARG_EXPAND_TAIL);
typedef void (*glBindFramebufferEXT_PTR)(glBindFramebufferEXT_ARG_EXPAND);
#endif
#ifndef glBindImageTexture_RETURN
#define glBindImageTexture_RETURN void
#define glBindImageTexture_ARG_NAMES unit, texture, level, layered, layer, access, format
#define glBindImageTexture_ARG_EXPAND GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format
#define glBindImageTexture_ARG_NAMES_TAIL , unit, texture, level, layered, layer, access, format
#define glBindImageTexture_ARG_EXPAND_TAIL , GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format
#define forward_glBindImageTexture(_unit, _texture, _level, _layered, _layer, _access, _format) \
    ({ \
        void *dst = remote_dma(sizeof(glBindImageTexture_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindImageTexture(dst, _unit, _texture, _level, _layered, _layer, _access, _format), NULL); \
    });
#define call_glBindImageTexture(packed, ret_v) do { \
    glBindImageTexture_PACKED *unpacked = (glBindImageTexture_PACKED *)packed; \
    glBindImageTexture_ARGS *args = (glBindImageTexture_ARGS *)&unpacked->args; \
    glBindImageTexture(args->unit, args->texture, args->level, args->layered, args->layer, args->access, args->format);; \
} while(0)
void glBindImageTexture(glBindImageTexture_ARG_EXPAND);
packed_call_t *pack_glBindImageTexture(glBindImageTexture_PACKED *_dst glBindImageTexture_ARG_EXPAND_TAIL);
typedef void (*glBindImageTexture_PTR)(glBindImageTexture_ARG_EXPAND);
#endif
#ifndef glBindImageTextureEXT_RETURN
#define glBindImageTextureEXT_RETURN void
#define glBindImageTextureEXT_ARG_NAMES index, texture, level, layered, layer, access, format
#define glBindImageTextureEXT_ARG_EXPAND GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format
#define glBindImageTextureEXT_ARG_NAMES_TAIL , index, texture, level, layered, layer, access, format
#define glBindImageTextureEXT_ARG_EXPAND_TAIL , GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format
#define forward_glBindImageTextureEXT(_index, _texture, _level, _layered, _layer, _access, _format) \
    ({ \
        void *dst = remote_dma(sizeof(glBindImageTextureEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindImageTextureEXT(dst, _index, _texture, _level, _layered, _layer, _access, _format), NULL); \
    });
#define call_glBindImageTextureEXT(packed, ret_v) do { \
    glBindImageTextureEXT_PACKED *unpacked = (glBindImageTextureEXT_PACKED *)packed; \
    glBindImageTextureEXT_ARGS *args = (glBindImageTextureEXT_ARGS *)&unpacked->args; \
    glBindImageTextureEXT(args->index, args->texture, args->level, args->layered, args->layer, args->access, args->format);; \
} while(0)
void glBindImageTextureEXT(glBindImageTextureEXT_ARG_EXPAND);
packed_call_t *pack_glBindImageTextureEXT(glBindImageTextureEXT_PACKED *_dst glBindImageTextureEXT_ARG_EXPAND_TAIL);
typedef void (*glBindImageTextureEXT_PTR)(glBindImageTextureEXT_ARG_EXPAND);
#endif
#ifndef glBindLightParameterEXT_RETURN
#define glBindLightParameterEXT_RETURN GLuint
#define glBindLightParameterEXT_ARG_NAMES light, value
#define glBindLightParameterEXT_ARG_EXPAND GLenum light, GLenum value
#define glBindLightParameterEXT_ARG_NAMES_TAIL , light, value
#define glBindLightParameterEXT_ARG_EXPAND_TAIL , GLenum light, GLenum value
#define forward_glBindLightParameterEXT(_light, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glBindLightParameterEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glBindLightParameterEXT(dst, _light, _value), &ret); \
        ret; \
    });
#define call_glBindLightParameterEXT(packed, ret_v) do { \
    glBindLightParameterEXT_PACKED *unpacked = (glBindLightParameterEXT_PACKED *)packed; \
    glBindLightParameterEXT_ARGS *args = (glBindLightParameterEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindLightParameterEXT(args->light, args->value);; \
    } else { \
        glBindLightParameterEXT(args->light, args->value);; \
    } \
} while(0)
GLuint glBindLightParameterEXT(glBindLightParameterEXT_ARG_EXPAND);
packed_call_t *pack_glBindLightParameterEXT(glBindLightParameterEXT_PACKED *_dst glBindLightParameterEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glBindLightParameterEXT_PTR)(glBindLightParameterEXT_ARG_EXPAND);
#endif
#ifndef glBindMaterialParameterEXT_RETURN
#define glBindMaterialParameterEXT_RETURN GLuint
#define glBindMaterialParameterEXT_ARG_NAMES face, value
#define glBindMaterialParameterEXT_ARG_EXPAND GLenum face, GLenum value
#define glBindMaterialParameterEXT_ARG_NAMES_TAIL , face, value
#define glBindMaterialParameterEXT_ARG_EXPAND_TAIL , GLenum face, GLenum value
#define forward_glBindMaterialParameterEXT(_face, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glBindMaterialParameterEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glBindMaterialParameterEXT(dst, _face, _value), &ret); \
        ret; \
    });
#define call_glBindMaterialParameterEXT(packed, ret_v) do { \
    glBindMaterialParameterEXT_PACKED *unpacked = (glBindMaterialParameterEXT_PACKED *)packed; \
    glBindMaterialParameterEXT_ARGS *args = (glBindMaterialParameterEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindMaterialParameterEXT(args->face, args->value);; \
    } else { \
        glBindMaterialParameterEXT(args->face, args->value);; \
    } \
} while(0)
GLuint glBindMaterialParameterEXT(glBindMaterialParameterEXT_ARG_EXPAND);
packed_call_t *pack_glBindMaterialParameterEXT(glBindMaterialParameterEXT_PACKED *_dst glBindMaterialParameterEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glBindMaterialParameterEXT_PTR)(glBindMaterialParameterEXT_ARG_EXPAND);
#endif
#ifndef glBindMultiTextureEXT_RETURN
#define glBindMultiTextureEXT_RETURN void
#define glBindMultiTextureEXT_ARG_NAMES texunit, target, texture
#define glBindMultiTextureEXT_ARG_EXPAND GLenum texunit, GLenum target, GLuint texture
#define glBindMultiTextureEXT_ARG_NAMES_TAIL , texunit, target, texture
#define glBindMultiTextureEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLuint texture
#define forward_glBindMultiTextureEXT(_texunit, _target, _texture) \
    ({ \
        void *dst = remote_dma(sizeof(glBindMultiTextureEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindMultiTextureEXT(dst, _texunit, _target, _texture), NULL); \
    });
#define call_glBindMultiTextureEXT(packed, ret_v) do { \
    glBindMultiTextureEXT_PACKED *unpacked = (glBindMultiTextureEXT_PACKED *)packed; \
    glBindMultiTextureEXT_ARGS *args = (glBindMultiTextureEXT_ARGS *)&unpacked->args; \
    glBindMultiTextureEXT(args->texunit, args->target, args->texture);; \
} while(0)
void glBindMultiTextureEXT(glBindMultiTextureEXT_ARG_EXPAND);
packed_call_t *pack_glBindMultiTextureEXT(glBindMultiTextureEXT_PACKED *_dst glBindMultiTextureEXT_ARG_EXPAND_TAIL);
typedef void (*glBindMultiTextureEXT_PTR)(glBindMultiTextureEXT_ARG_EXPAND);
#endif
#ifndef glBindParameterEXT_RETURN
#define glBindParameterEXT_RETURN GLuint
#define glBindParameterEXT_ARG_NAMES value
#define glBindParameterEXT_ARG_EXPAND GLenum value
#define glBindParameterEXT_ARG_NAMES_TAIL , value
#define glBindParameterEXT_ARG_EXPAND_TAIL , GLenum value
#define forward_glBindParameterEXT(_value) \
    ({ \
        void *dst = remote_dma(sizeof(glBindParameterEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glBindParameterEXT(dst, _value), &ret); \
        ret; \
    });
#define call_glBindParameterEXT(packed, ret_v) do { \
    glBindParameterEXT_PACKED *unpacked = (glBindParameterEXT_PACKED *)packed; \
    glBindParameterEXT_ARGS *args = (glBindParameterEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindParameterEXT(args->value);; \
    } else { \
        glBindParameterEXT(args->value);; \
    } \
} while(0)
GLuint glBindParameterEXT(glBindParameterEXT_ARG_EXPAND);
packed_call_t *pack_glBindParameterEXT(glBindParameterEXT_PACKED *_dst glBindParameterEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glBindParameterEXT_PTR)(glBindParameterEXT_ARG_EXPAND);
#endif
#ifndef glBindProgramARB_RETURN
#define glBindProgramARB_RETURN void
#define glBindProgramARB_ARG_NAMES target, program
#define glBindProgramARB_ARG_EXPAND GLenum target, GLuint program
#define glBindProgramARB_ARG_NAMES_TAIL , target, program
#define glBindProgramARB_ARG_EXPAND_TAIL , GLenum target, GLuint program
#define forward_glBindProgramARB(_target, _program) \
    ({ \
        void *dst = remote_dma(sizeof(glBindProgramARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindProgramARB(dst, _target, _program), NULL); \
    });
#define call_glBindProgramARB(packed, ret_v) do { \
    glBindProgramARB_PACKED *unpacked = (glBindProgramARB_PACKED *)packed; \
    glBindProgramARB_ARGS *args = (glBindProgramARB_ARGS *)&unpacked->args; \
    glBindProgramARB(args->target, args->program);; \
} while(0)
void glBindProgramARB(glBindProgramARB_ARG_EXPAND);
packed_call_t *pack_glBindProgramARB(glBindProgramARB_PACKED *_dst glBindProgramARB_ARG_EXPAND_TAIL);
typedef void (*glBindProgramARB_PTR)(glBindProgramARB_ARG_EXPAND);
#endif
#ifndef glBindProgramNV_RETURN
#define glBindProgramNV_RETURN void
#define glBindProgramNV_ARG_NAMES target, id
#define glBindProgramNV_ARG_EXPAND GLenum target, GLuint id
#define glBindProgramNV_ARG_NAMES_TAIL , target, id
#define glBindProgramNV_ARG_EXPAND_TAIL , GLenum target, GLuint id
#define forward_glBindProgramNV(_target, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glBindProgramNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindProgramNV(dst, _target, _id), NULL); \
    });
#define call_glBindProgramNV(packed, ret_v) do { \
    glBindProgramNV_PACKED *unpacked = (glBindProgramNV_PACKED *)packed; \
    glBindProgramNV_ARGS *args = (glBindProgramNV_ARGS *)&unpacked->args; \
    glBindProgramNV(args->target, args->id);; \
} while(0)
void glBindProgramNV(glBindProgramNV_ARG_EXPAND);
packed_call_t *pack_glBindProgramNV(glBindProgramNV_PACKED *_dst glBindProgramNV_ARG_EXPAND_TAIL);
typedef void (*glBindProgramNV_PTR)(glBindProgramNV_ARG_EXPAND);
#endif
#ifndef glBindProgramPipeline_RETURN
#define glBindProgramPipeline_RETURN void
#define glBindProgramPipeline_ARG_NAMES pipeline
#define glBindProgramPipeline_ARG_EXPAND GLuint pipeline
#define glBindProgramPipeline_ARG_NAMES_TAIL , pipeline
#define glBindProgramPipeline_ARG_EXPAND_TAIL , GLuint pipeline
#define forward_glBindProgramPipeline(_pipeline) \
    ({ \
        void *dst = remote_dma(sizeof(glBindProgramPipeline_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindProgramPipeline(dst, _pipeline), NULL); \
    });
#define call_glBindProgramPipeline(packed, ret_v) do { \
    glBindProgramPipeline_PACKED *unpacked = (glBindProgramPipeline_PACKED *)packed; \
    glBindProgramPipeline_ARGS *args = (glBindProgramPipeline_ARGS *)&unpacked->args; \
    glBindProgramPipeline(args->pipeline);; \
} while(0)
void glBindProgramPipeline(glBindProgramPipeline_ARG_EXPAND);
packed_call_t *pack_glBindProgramPipeline(glBindProgramPipeline_PACKED *_dst glBindProgramPipeline_ARG_EXPAND_TAIL);
typedef void (*glBindProgramPipeline_PTR)(glBindProgramPipeline_ARG_EXPAND);
#endif
#ifndef glBindRenderbuffer_RETURN
#define glBindRenderbuffer_RETURN void
#define glBindRenderbuffer_ARG_NAMES target, renderbuffer
#define glBindRenderbuffer_ARG_EXPAND GLenum target, GLuint renderbuffer
#define glBindRenderbuffer_ARG_NAMES_TAIL , target, renderbuffer
#define glBindRenderbuffer_ARG_EXPAND_TAIL , GLenum target, GLuint renderbuffer
#define forward_glBindRenderbuffer(_target, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindRenderbuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindRenderbuffer(dst, _target, _renderbuffer), NULL); \
    });
#define call_glBindRenderbuffer(packed, ret_v) do { \
    glBindRenderbuffer_PACKED *unpacked = (glBindRenderbuffer_PACKED *)packed; \
    glBindRenderbuffer_ARGS *args = (glBindRenderbuffer_ARGS *)&unpacked->args; \
    glBindRenderbuffer(args->target, args->renderbuffer);; \
} while(0)
void glBindRenderbuffer(glBindRenderbuffer_ARG_EXPAND);
packed_call_t *pack_glBindRenderbuffer(glBindRenderbuffer_PACKED *_dst glBindRenderbuffer_ARG_EXPAND_TAIL);
typedef void (*glBindRenderbuffer_PTR)(glBindRenderbuffer_ARG_EXPAND);
#endif
#ifndef glBindRenderbufferEXT_RETURN
#define glBindRenderbufferEXT_RETURN void
#define glBindRenderbufferEXT_ARG_NAMES target, renderbuffer
#define glBindRenderbufferEXT_ARG_EXPAND GLenum target, GLuint renderbuffer
#define glBindRenderbufferEXT_ARG_NAMES_TAIL , target, renderbuffer
#define glBindRenderbufferEXT_ARG_EXPAND_TAIL , GLenum target, GLuint renderbuffer
#define forward_glBindRenderbufferEXT(_target, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glBindRenderbufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindRenderbufferEXT(dst, _target, _renderbuffer), NULL); \
    });
#define call_glBindRenderbufferEXT(packed, ret_v) do { \
    glBindRenderbufferEXT_PACKED *unpacked = (glBindRenderbufferEXT_PACKED *)packed; \
    glBindRenderbufferEXT_ARGS *args = (glBindRenderbufferEXT_ARGS *)&unpacked->args; \
    glBindRenderbufferEXT(args->target, args->renderbuffer);; \
} while(0)
void glBindRenderbufferEXT(glBindRenderbufferEXT_ARG_EXPAND);
packed_call_t *pack_glBindRenderbufferEXT(glBindRenderbufferEXT_PACKED *_dst glBindRenderbufferEXT_ARG_EXPAND_TAIL);
typedef void (*glBindRenderbufferEXT_PTR)(glBindRenderbufferEXT_ARG_EXPAND);
#endif
#ifndef glBindSampler_RETURN
#define glBindSampler_RETURN void
#define glBindSampler_ARG_NAMES unit, sampler
#define glBindSampler_ARG_EXPAND GLuint unit, GLuint sampler
#define glBindSampler_ARG_NAMES_TAIL , unit, sampler
#define glBindSampler_ARG_EXPAND_TAIL , GLuint unit, GLuint sampler
#define forward_glBindSampler(_unit, _sampler) \
    ({ \
        void *dst = remote_dma(sizeof(glBindSampler_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindSampler(dst, _unit, _sampler), NULL); \
    });
#define call_glBindSampler(packed, ret_v) do { \
    glBindSampler_PACKED *unpacked = (glBindSampler_PACKED *)packed; \
    glBindSampler_ARGS *args = (glBindSampler_ARGS *)&unpacked->args; \
    glBindSampler(args->unit, args->sampler);; \
} while(0)
void glBindSampler(glBindSampler_ARG_EXPAND);
packed_call_t *pack_glBindSampler(glBindSampler_PACKED *_dst glBindSampler_ARG_EXPAND_TAIL);
typedef void (*glBindSampler_PTR)(glBindSampler_ARG_EXPAND);
#endif
#ifndef glBindTexGenParameterEXT_RETURN
#define glBindTexGenParameterEXT_RETURN GLuint
#define glBindTexGenParameterEXT_ARG_NAMES unit, coord, value
#define glBindTexGenParameterEXT_ARG_EXPAND GLenum unit, GLenum coord, GLenum value
#define glBindTexGenParameterEXT_ARG_NAMES_TAIL , unit, coord, value
#define glBindTexGenParameterEXT_ARG_EXPAND_TAIL , GLenum unit, GLenum coord, GLenum value
#define forward_glBindTexGenParameterEXT(_unit, _coord, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glBindTexGenParameterEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glBindTexGenParameterEXT(dst, _unit, _coord, _value), &ret); \
        ret; \
    });
#define call_glBindTexGenParameterEXT(packed, ret_v) do { \
    glBindTexGenParameterEXT_PACKED *unpacked = (glBindTexGenParameterEXT_PACKED *)packed; \
    glBindTexGenParameterEXT_ARGS *args = (glBindTexGenParameterEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindTexGenParameterEXT(args->unit, args->coord, args->value);; \
    } else { \
        glBindTexGenParameterEXT(args->unit, args->coord, args->value);; \
    } \
} while(0)
GLuint glBindTexGenParameterEXT(glBindTexGenParameterEXT_ARG_EXPAND);
packed_call_t *pack_glBindTexGenParameterEXT(glBindTexGenParameterEXT_PACKED *_dst glBindTexGenParameterEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glBindTexGenParameterEXT_PTR)(glBindTexGenParameterEXT_ARG_EXPAND);
#endif
#ifndef glBindTexture_RETURN
#define glBindTexture_RETURN void
#define glBindTexture_ARG_NAMES target, texture
#define glBindTexture_ARG_EXPAND GLenum target, GLuint texture
#define glBindTexture_ARG_NAMES_TAIL , target, texture
#define glBindTexture_ARG_EXPAND_TAIL , GLenum target, GLuint texture
#define forward_glBindTexture(_target, _texture) \
    ({ \
        void *dst = remote_dma(sizeof(glBindTexture_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindTexture(dst, _target, _texture), NULL); \
    });
#define call_glBindTexture(packed, ret_v) do { \
    glBindTexture_PACKED *unpacked = (glBindTexture_PACKED *)packed; \
    glBindTexture_ARGS *args = (glBindTexture_ARGS *)&unpacked->args; \
    glBindTexture(args->target, args->texture);; \
} while(0)
void glBindTexture(glBindTexture_ARG_EXPAND);
packed_call_t *pack_glBindTexture(glBindTexture_PACKED *_dst glBindTexture_ARG_EXPAND_TAIL);
typedef void (*glBindTexture_PTR)(glBindTexture_ARG_EXPAND);
#endif
#ifndef glBindTextureEXT_RETURN
#define glBindTextureEXT_RETURN void
#define glBindTextureEXT_ARG_NAMES target, texture
#define glBindTextureEXT_ARG_EXPAND GLenum target, GLuint texture
#define glBindTextureEXT_ARG_NAMES_TAIL , target, texture
#define glBindTextureEXT_ARG_EXPAND_TAIL , GLenum target, GLuint texture
#define forward_glBindTextureEXT(_target, _texture) \
    ({ \
        void *dst = remote_dma(sizeof(glBindTextureEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindTextureEXT(dst, _target, _texture), NULL); \
    });
#define call_glBindTextureEXT(packed, ret_v) do { \
    glBindTextureEXT_PACKED *unpacked = (glBindTextureEXT_PACKED *)packed; \
    glBindTextureEXT_ARGS *args = (glBindTextureEXT_ARGS *)&unpacked->args; \
    glBindTextureEXT(args->target, args->texture);; \
} while(0)
void glBindTextureEXT(glBindTextureEXT_ARG_EXPAND);
packed_call_t *pack_glBindTextureEXT(glBindTextureEXT_PACKED *_dst glBindTextureEXT_ARG_EXPAND_TAIL);
typedef void (*glBindTextureEXT_PTR)(glBindTextureEXT_ARG_EXPAND);
#endif
#ifndef glBindTextureUnitParameterEXT_RETURN
#define glBindTextureUnitParameterEXT_RETURN GLuint
#define glBindTextureUnitParameterEXT_ARG_NAMES unit, value
#define glBindTextureUnitParameterEXT_ARG_EXPAND GLenum unit, GLenum value
#define glBindTextureUnitParameterEXT_ARG_NAMES_TAIL , unit, value
#define glBindTextureUnitParameterEXT_ARG_EXPAND_TAIL , GLenum unit, GLenum value
#define forward_glBindTextureUnitParameterEXT(_unit, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glBindTextureUnitParameterEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glBindTextureUnitParameterEXT(dst, _unit, _value), &ret); \
        ret; \
    });
#define call_glBindTextureUnitParameterEXT(packed, ret_v) do { \
    glBindTextureUnitParameterEXT_PACKED *unpacked = (glBindTextureUnitParameterEXT_PACKED *)packed; \
    glBindTextureUnitParameterEXT_ARGS *args = (glBindTextureUnitParameterEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindTextureUnitParameterEXT(args->unit, args->value);; \
    } else { \
        glBindTextureUnitParameterEXT(args->unit, args->value);; \
    } \
} while(0)
GLuint glBindTextureUnitParameterEXT(glBindTextureUnitParameterEXT_ARG_EXPAND);
packed_call_t *pack_glBindTextureUnitParameterEXT(glBindTextureUnitParameterEXT_PACKED *_dst glBindTextureUnitParameterEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glBindTextureUnitParameterEXT_PTR)(glBindTextureUnitParameterEXT_ARG_EXPAND);
#endif
#ifndef glBindTransformFeedback_RETURN
#define glBindTransformFeedback_RETURN void
#define glBindTransformFeedback_ARG_NAMES target, id
#define glBindTransformFeedback_ARG_EXPAND GLenum target, GLuint id
#define glBindTransformFeedback_ARG_NAMES_TAIL , target, id
#define glBindTransformFeedback_ARG_EXPAND_TAIL , GLenum target, GLuint id
#define forward_glBindTransformFeedback(_target, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glBindTransformFeedback_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindTransformFeedback(dst, _target, _id), NULL); \
    });
#define call_glBindTransformFeedback(packed, ret_v) do { \
    glBindTransformFeedback_PACKED *unpacked = (glBindTransformFeedback_PACKED *)packed; \
    glBindTransformFeedback_ARGS *args = (glBindTransformFeedback_ARGS *)&unpacked->args; \
    glBindTransformFeedback(args->target, args->id);; \
} while(0)
void glBindTransformFeedback(glBindTransformFeedback_ARG_EXPAND);
packed_call_t *pack_glBindTransformFeedback(glBindTransformFeedback_PACKED *_dst glBindTransformFeedback_ARG_EXPAND_TAIL);
typedef void (*glBindTransformFeedback_PTR)(glBindTransformFeedback_ARG_EXPAND);
#endif
#ifndef glBindTransformFeedbackNV_RETURN
#define glBindTransformFeedbackNV_RETURN void
#define glBindTransformFeedbackNV_ARG_NAMES target, id
#define glBindTransformFeedbackNV_ARG_EXPAND GLenum target, GLuint id
#define glBindTransformFeedbackNV_ARG_NAMES_TAIL , target, id
#define glBindTransformFeedbackNV_ARG_EXPAND_TAIL , GLenum target, GLuint id
#define forward_glBindTransformFeedbackNV(_target, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glBindTransformFeedbackNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindTransformFeedbackNV(dst, _target, _id), NULL); \
    });
#define call_glBindTransformFeedbackNV(packed, ret_v) do { \
    glBindTransformFeedbackNV_PACKED *unpacked = (glBindTransformFeedbackNV_PACKED *)packed; \
    glBindTransformFeedbackNV_ARGS *args = (glBindTransformFeedbackNV_ARGS *)&unpacked->args; \
    glBindTransformFeedbackNV(args->target, args->id);; \
} while(0)
void glBindTransformFeedbackNV(glBindTransformFeedbackNV_ARG_EXPAND);
packed_call_t *pack_glBindTransformFeedbackNV(glBindTransformFeedbackNV_PACKED *_dst glBindTransformFeedbackNV_ARG_EXPAND_TAIL);
typedef void (*glBindTransformFeedbackNV_PTR)(glBindTransformFeedbackNV_ARG_EXPAND);
#endif
#ifndef glBindVertexArray_RETURN
#define glBindVertexArray_RETURN void
#define glBindVertexArray_ARG_NAMES array
#define glBindVertexArray_ARG_EXPAND GLuint array
#define glBindVertexArray_ARG_NAMES_TAIL , array
#define glBindVertexArray_ARG_EXPAND_TAIL , GLuint array
#define forward_glBindVertexArray(_array) \
    ({ \
        void *dst = remote_dma(sizeof(glBindVertexArray_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindVertexArray(dst, _array), NULL); \
    });
#define call_glBindVertexArray(packed, ret_v) do { \
    glBindVertexArray_PACKED *unpacked = (glBindVertexArray_PACKED *)packed; \
    glBindVertexArray_ARGS *args = (glBindVertexArray_ARGS *)&unpacked->args; \
    glBindVertexArray(args->array);; \
} while(0)
void glBindVertexArray(glBindVertexArray_ARG_EXPAND);
packed_call_t *pack_glBindVertexArray(glBindVertexArray_PACKED *_dst glBindVertexArray_ARG_EXPAND_TAIL);
typedef void (*glBindVertexArray_PTR)(glBindVertexArray_ARG_EXPAND);
#endif
#ifndef glBindVertexArrayAPPLE_RETURN
#define glBindVertexArrayAPPLE_RETURN void
#define glBindVertexArrayAPPLE_ARG_NAMES array
#define glBindVertexArrayAPPLE_ARG_EXPAND GLuint array
#define glBindVertexArrayAPPLE_ARG_NAMES_TAIL , array
#define glBindVertexArrayAPPLE_ARG_EXPAND_TAIL , GLuint array
#define forward_glBindVertexArrayAPPLE(_array) \
    ({ \
        void *dst = remote_dma(sizeof(glBindVertexArrayAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindVertexArrayAPPLE(dst, _array), NULL); \
    });
#define call_glBindVertexArrayAPPLE(packed, ret_v) do { \
    glBindVertexArrayAPPLE_PACKED *unpacked = (glBindVertexArrayAPPLE_PACKED *)packed; \
    glBindVertexArrayAPPLE_ARGS *args = (glBindVertexArrayAPPLE_ARGS *)&unpacked->args; \
    glBindVertexArrayAPPLE(args->array);; \
} while(0)
void glBindVertexArrayAPPLE(glBindVertexArrayAPPLE_ARG_EXPAND);
packed_call_t *pack_glBindVertexArrayAPPLE(glBindVertexArrayAPPLE_PACKED *_dst glBindVertexArrayAPPLE_ARG_EXPAND_TAIL);
typedef void (*glBindVertexArrayAPPLE_PTR)(glBindVertexArrayAPPLE_ARG_EXPAND);
#endif
#ifndef glBindVertexBuffer_RETURN
#define glBindVertexBuffer_RETURN void
#define glBindVertexBuffer_ARG_NAMES bindingindex, buffer, offset, stride
#define glBindVertexBuffer_ARG_EXPAND GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride
#define glBindVertexBuffer_ARG_NAMES_TAIL , bindingindex, buffer, offset, stride
#define glBindVertexBuffer_ARG_EXPAND_TAIL , GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride
#define forward_glBindVertexBuffer(_bindingindex, _buffer, _offset, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glBindVertexBuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindVertexBuffer(dst, _bindingindex, _buffer, _offset, _stride), NULL); \
    });
#define call_glBindVertexBuffer(packed, ret_v) do { \
    glBindVertexBuffer_PACKED *unpacked = (glBindVertexBuffer_PACKED *)packed; \
    glBindVertexBuffer_ARGS *args = (glBindVertexBuffer_ARGS *)&unpacked->args; \
    glBindVertexBuffer(args->bindingindex, args->buffer, args->offset, args->stride);; \
} while(0)
void glBindVertexBuffer(glBindVertexBuffer_ARG_EXPAND);
packed_call_t *pack_glBindVertexBuffer(glBindVertexBuffer_PACKED *_dst glBindVertexBuffer_ARG_EXPAND_TAIL);
typedef void (*glBindVertexBuffer_PTR)(glBindVertexBuffer_ARG_EXPAND);
#endif
#ifndef glBindVertexShaderEXT_RETURN
#define glBindVertexShaderEXT_RETURN void
#define glBindVertexShaderEXT_ARG_NAMES id
#define glBindVertexShaderEXT_ARG_EXPAND GLuint id
#define glBindVertexShaderEXT_ARG_NAMES_TAIL , id
#define glBindVertexShaderEXT_ARG_EXPAND_TAIL , GLuint id
#define forward_glBindVertexShaderEXT(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glBindVertexShaderEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindVertexShaderEXT(dst, _id), NULL); \
    });
#define call_glBindVertexShaderEXT(packed, ret_v) do { \
    glBindVertexShaderEXT_PACKED *unpacked = (glBindVertexShaderEXT_PACKED *)packed; \
    glBindVertexShaderEXT_ARGS *args = (glBindVertexShaderEXT_ARGS *)&unpacked->args; \
    glBindVertexShaderEXT(args->id);; \
} while(0)
void glBindVertexShaderEXT(glBindVertexShaderEXT_ARG_EXPAND);
packed_call_t *pack_glBindVertexShaderEXT(glBindVertexShaderEXT_PACKED *_dst glBindVertexShaderEXT_ARG_EXPAND_TAIL);
typedef void (*glBindVertexShaderEXT_PTR)(glBindVertexShaderEXT_ARG_EXPAND);
#endif
#ifndef glBindVideoCaptureStreamBufferNV_RETURN
#define glBindVideoCaptureStreamBufferNV_RETURN void
#define glBindVideoCaptureStreamBufferNV_ARG_NAMES video_capture_slot, stream, frame_region, offset
#define glBindVideoCaptureStreamBufferNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset
#define glBindVideoCaptureStreamBufferNV_ARG_NAMES_TAIL , video_capture_slot, stream, frame_region, offset
#define glBindVideoCaptureStreamBufferNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset
#define forward_glBindVideoCaptureStreamBufferNV(_video_capture_slot, _stream, _frame_region, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glBindVideoCaptureStreamBufferNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindVideoCaptureStreamBufferNV(dst, _video_capture_slot, _stream, _frame_region, _offset), NULL); \
    });
#define call_glBindVideoCaptureStreamBufferNV(packed, ret_v) do { \
    glBindVideoCaptureStreamBufferNV_PACKED *unpacked = (glBindVideoCaptureStreamBufferNV_PACKED *)packed; \
    glBindVideoCaptureStreamBufferNV_ARGS *args = (glBindVideoCaptureStreamBufferNV_ARGS *)&unpacked->args; \
    glBindVideoCaptureStreamBufferNV(args->video_capture_slot, args->stream, args->frame_region, args->offset);; \
} while(0)
void glBindVideoCaptureStreamBufferNV(glBindVideoCaptureStreamBufferNV_ARG_EXPAND);
packed_call_t *pack_glBindVideoCaptureStreamBufferNV(glBindVideoCaptureStreamBufferNV_PACKED *_dst glBindVideoCaptureStreamBufferNV_ARG_EXPAND_TAIL);
typedef void (*glBindVideoCaptureStreamBufferNV_PTR)(glBindVideoCaptureStreamBufferNV_ARG_EXPAND);
#endif
#ifndef glBindVideoCaptureStreamTextureNV_RETURN
#define glBindVideoCaptureStreamTextureNV_RETURN void
#define glBindVideoCaptureStreamTextureNV_ARG_NAMES video_capture_slot, stream, frame_region, target, texture
#define glBindVideoCaptureStreamTextureNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture
#define glBindVideoCaptureStreamTextureNV_ARG_NAMES_TAIL , video_capture_slot, stream, frame_region, target, texture
#define glBindVideoCaptureStreamTextureNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture
#define forward_glBindVideoCaptureStreamTextureNV(_video_capture_slot, _stream, _frame_region, _target, _texture) \
    ({ \
        void *dst = remote_dma(sizeof(glBindVideoCaptureStreamTextureNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBindVideoCaptureStreamTextureNV(dst, _video_capture_slot, _stream, _frame_region, _target, _texture), NULL); \
    });
#define call_glBindVideoCaptureStreamTextureNV(packed, ret_v) do { \
    glBindVideoCaptureStreamTextureNV_PACKED *unpacked = (glBindVideoCaptureStreamTextureNV_PACKED *)packed; \
    glBindVideoCaptureStreamTextureNV_ARGS *args = (glBindVideoCaptureStreamTextureNV_ARGS *)&unpacked->args; \
    glBindVideoCaptureStreamTextureNV(args->video_capture_slot, args->stream, args->frame_region, args->target, args->texture);; \
} while(0)
void glBindVideoCaptureStreamTextureNV(glBindVideoCaptureStreamTextureNV_ARG_EXPAND);
packed_call_t *pack_glBindVideoCaptureStreamTextureNV(glBindVideoCaptureStreamTextureNV_PACKED *_dst glBindVideoCaptureStreamTextureNV_ARG_EXPAND_TAIL);
typedef void (*glBindVideoCaptureStreamTextureNV_PTR)(glBindVideoCaptureStreamTextureNV_ARG_EXPAND);
#endif
#ifndef glBinormal3bEXT_RETURN
#define glBinormal3bEXT_RETURN void
#define glBinormal3bEXT_ARG_NAMES bx, by, bz
#define glBinormal3bEXT_ARG_EXPAND GLbyte bx, GLbyte by, GLbyte bz
#define glBinormal3bEXT_ARG_NAMES_TAIL , bx, by, bz
#define glBinormal3bEXT_ARG_EXPAND_TAIL , GLbyte bx, GLbyte by, GLbyte bz
#define forward_glBinormal3bEXT(_bx, _by, _bz) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3bEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3bEXT(dst, _bx, _by, _bz), NULL); \
    });
#define call_glBinormal3bEXT(packed, ret_v) do { \
    glBinormal3bEXT_PACKED *unpacked = (glBinormal3bEXT_PACKED *)packed; \
    glBinormal3bEXT_ARGS *args = (glBinormal3bEXT_ARGS *)&unpacked->args; \
    glBinormal3bEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3bEXT(glBinormal3bEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3bEXT(glBinormal3bEXT_PACKED *_dst glBinormal3bEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3bEXT_PTR)(glBinormal3bEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3bvEXT_RETURN
#define glBinormal3bvEXT_RETURN void
#define glBinormal3bvEXT_ARG_NAMES v
#define glBinormal3bvEXT_ARG_EXPAND const GLbyte * v
#define glBinormal3bvEXT_ARG_NAMES_TAIL , v
#define glBinormal3bvEXT_ARG_EXPAND_TAIL , const GLbyte * v
#define forward_glBinormal3bvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3bvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3bvEXT(dst, _v), NULL); \
    });
#define call_glBinormal3bvEXT(packed, ret_v) do { \
    glBinormal3bvEXT_PACKED *unpacked = (glBinormal3bvEXT_PACKED *)packed; \
    glBinormal3bvEXT_ARGS *args = (glBinormal3bvEXT_ARGS *)&unpacked->args; \
    glBinormal3bvEXT(args->v);; \
} while(0)
void glBinormal3bvEXT(glBinormal3bvEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3bvEXT(glBinormal3bvEXT_PACKED *_dst glBinormal3bvEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3bvEXT_PTR)(glBinormal3bvEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3dEXT_RETURN
#define glBinormal3dEXT_RETURN void
#define glBinormal3dEXT_ARG_NAMES bx, by, bz
#define glBinormal3dEXT_ARG_EXPAND GLdouble bx, GLdouble by, GLdouble bz
#define glBinormal3dEXT_ARG_NAMES_TAIL , bx, by, bz
#define glBinormal3dEXT_ARG_EXPAND_TAIL , GLdouble bx, GLdouble by, GLdouble bz
#define forward_glBinormal3dEXT(_bx, _by, _bz) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3dEXT(dst, _bx, _by, _bz), NULL); \
    });
#define call_glBinormal3dEXT(packed, ret_v) do { \
    glBinormal3dEXT_PACKED *unpacked = (glBinormal3dEXT_PACKED *)packed; \
    glBinormal3dEXT_ARGS *args = (glBinormal3dEXT_ARGS *)&unpacked->args; \
    glBinormal3dEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3dEXT(glBinormal3dEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3dEXT(glBinormal3dEXT_PACKED *_dst glBinormal3dEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3dEXT_PTR)(glBinormal3dEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3dvEXT_RETURN
#define glBinormal3dvEXT_RETURN void
#define glBinormal3dvEXT_ARG_NAMES v
#define glBinormal3dvEXT_ARG_EXPAND const GLdouble * v
#define glBinormal3dvEXT_ARG_NAMES_TAIL , v
#define glBinormal3dvEXT_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glBinormal3dvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3dvEXT(dst, _v), NULL); \
    });
#define call_glBinormal3dvEXT(packed, ret_v) do { \
    glBinormal3dvEXT_PACKED *unpacked = (glBinormal3dvEXT_PACKED *)packed; \
    glBinormal3dvEXT_ARGS *args = (glBinormal3dvEXT_ARGS *)&unpacked->args; \
    glBinormal3dvEXT(args->v);; \
} while(0)
void glBinormal3dvEXT(glBinormal3dvEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3dvEXT(glBinormal3dvEXT_PACKED *_dst glBinormal3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3dvEXT_PTR)(glBinormal3dvEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3fEXT_RETURN
#define glBinormal3fEXT_RETURN void
#define glBinormal3fEXT_ARG_NAMES bx, by, bz
#define glBinormal3fEXT_ARG_EXPAND GLfloat bx, GLfloat by, GLfloat bz
#define glBinormal3fEXT_ARG_NAMES_TAIL , bx, by, bz
#define glBinormal3fEXT_ARG_EXPAND_TAIL , GLfloat bx, GLfloat by, GLfloat bz
#define forward_glBinormal3fEXT(_bx, _by, _bz) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3fEXT(dst, _bx, _by, _bz), NULL); \
    });
#define call_glBinormal3fEXT(packed, ret_v) do { \
    glBinormal3fEXT_PACKED *unpacked = (glBinormal3fEXT_PACKED *)packed; \
    glBinormal3fEXT_ARGS *args = (glBinormal3fEXT_ARGS *)&unpacked->args; \
    glBinormal3fEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3fEXT(glBinormal3fEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3fEXT(glBinormal3fEXT_PACKED *_dst glBinormal3fEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3fEXT_PTR)(glBinormal3fEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3fvEXT_RETURN
#define glBinormal3fvEXT_RETURN void
#define glBinormal3fvEXT_ARG_NAMES v
#define glBinormal3fvEXT_ARG_EXPAND const GLfloat * v
#define glBinormal3fvEXT_ARG_NAMES_TAIL , v
#define glBinormal3fvEXT_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glBinormal3fvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3fvEXT(dst, _v), NULL); \
    });
#define call_glBinormal3fvEXT(packed, ret_v) do { \
    glBinormal3fvEXT_PACKED *unpacked = (glBinormal3fvEXT_PACKED *)packed; \
    glBinormal3fvEXT_ARGS *args = (glBinormal3fvEXT_ARGS *)&unpacked->args; \
    glBinormal3fvEXT(args->v);; \
} while(0)
void glBinormal3fvEXT(glBinormal3fvEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3fvEXT(glBinormal3fvEXT_PACKED *_dst glBinormal3fvEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3fvEXT_PTR)(glBinormal3fvEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3iEXT_RETURN
#define glBinormal3iEXT_RETURN void
#define glBinormal3iEXT_ARG_NAMES bx, by, bz
#define glBinormal3iEXT_ARG_EXPAND GLint bx, GLint by, GLint bz
#define glBinormal3iEXT_ARG_NAMES_TAIL , bx, by, bz
#define glBinormal3iEXT_ARG_EXPAND_TAIL , GLint bx, GLint by, GLint bz
#define forward_glBinormal3iEXT(_bx, _by, _bz) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3iEXT(dst, _bx, _by, _bz), NULL); \
    });
#define call_glBinormal3iEXT(packed, ret_v) do { \
    glBinormal3iEXT_PACKED *unpacked = (glBinormal3iEXT_PACKED *)packed; \
    glBinormal3iEXT_ARGS *args = (glBinormal3iEXT_ARGS *)&unpacked->args; \
    glBinormal3iEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3iEXT(glBinormal3iEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3iEXT(glBinormal3iEXT_PACKED *_dst glBinormal3iEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3iEXT_PTR)(glBinormal3iEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3ivEXT_RETURN
#define glBinormal3ivEXT_RETURN void
#define glBinormal3ivEXT_ARG_NAMES v
#define glBinormal3ivEXT_ARG_EXPAND const GLint * v
#define glBinormal3ivEXT_ARG_NAMES_TAIL , v
#define glBinormal3ivEXT_ARG_EXPAND_TAIL , const GLint * v
#define forward_glBinormal3ivEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3ivEXT(dst, _v), NULL); \
    });
#define call_glBinormal3ivEXT(packed, ret_v) do { \
    glBinormal3ivEXT_PACKED *unpacked = (glBinormal3ivEXT_PACKED *)packed; \
    glBinormal3ivEXT_ARGS *args = (glBinormal3ivEXT_ARGS *)&unpacked->args; \
    glBinormal3ivEXT(args->v);; \
} while(0)
void glBinormal3ivEXT(glBinormal3ivEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3ivEXT(glBinormal3ivEXT_PACKED *_dst glBinormal3ivEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3ivEXT_PTR)(glBinormal3ivEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3sEXT_RETURN
#define glBinormal3sEXT_RETURN void
#define glBinormal3sEXT_ARG_NAMES bx, by, bz
#define glBinormal3sEXT_ARG_EXPAND GLshort bx, GLshort by, GLshort bz
#define glBinormal3sEXT_ARG_NAMES_TAIL , bx, by, bz
#define glBinormal3sEXT_ARG_EXPAND_TAIL , GLshort bx, GLshort by, GLshort bz
#define forward_glBinormal3sEXT(_bx, _by, _bz) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3sEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3sEXT(dst, _bx, _by, _bz), NULL); \
    });
#define call_glBinormal3sEXT(packed, ret_v) do { \
    glBinormal3sEXT_PACKED *unpacked = (glBinormal3sEXT_PACKED *)packed; \
    glBinormal3sEXT_ARGS *args = (glBinormal3sEXT_ARGS *)&unpacked->args; \
    glBinormal3sEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3sEXT(glBinormal3sEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3sEXT(glBinormal3sEXT_PACKED *_dst glBinormal3sEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3sEXT_PTR)(glBinormal3sEXT_ARG_EXPAND);
#endif
#ifndef glBinormal3svEXT_RETURN
#define glBinormal3svEXT_RETURN void
#define glBinormal3svEXT_ARG_NAMES v
#define glBinormal3svEXT_ARG_EXPAND const GLshort * v
#define glBinormal3svEXT_ARG_NAMES_TAIL , v
#define glBinormal3svEXT_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glBinormal3svEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormal3svEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormal3svEXT(dst, _v), NULL); \
    });
#define call_glBinormal3svEXT(packed, ret_v) do { \
    glBinormal3svEXT_PACKED *unpacked = (glBinormal3svEXT_PACKED *)packed; \
    glBinormal3svEXT_ARGS *args = (glBinormal3svEXT_ARGS *)&unpacked->args; \
    glBinormal3svEXT(args->v);; \
} while(0)
void glBinormal3svEXT(glBinormal3svEXT_ARG_EXPAND);
packed_call_t *pack_glBinormal3svEXT(glBinormal3svEXT_PACKED *_dst glBinormal3svEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormal3svEXT_PTR)(glBinormal3svEXT_ARG_EXPAND);
#endif
#ifndef glBinormalPointerEXT_RETURN
#define glBinormalPointerEXT_RETURN void
#define glBinormalPointerEXT_ARG_NAMES type, stride, pointer
#define glBinormalPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glBinormalPointerEXT_ARG_NAMES_TAIL , type, stride, pointer
#define glBinormalPointerEXT_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glBinormalPointerEXT(_type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glBinormalPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBinormalPointerEXT(dst, _type, _stride, _pointer), NULL); \
    });
#define call_glBinormalPointerEXT(packed, ret_v) do { \
    glBinormalPointerEXT_PACKED *unpacked = (glBinormalPointerEXT_PACKED *)packed; \
    glBinormalPointerEXT_ARGS *args = (glBinormalPointerEXT_ARGS *)&unpacked->args; \
    glBinormalPointerEXT(args->type, args->stride, args->pointer);; \
} while(0)
void glBinormalPointerEXT(glBinormalPointerEXT_ARG_EXPAND);
packed_call_t *pack_glBinormalPointerEXT(glBinormalPointerEXT_PACKED *_dst glBinormalPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glBinormalPointerEXT_PTR)(glBinormalPointerEXT_ARG_EXPAND);
#endif
#ifndef glBitmap_RETURN
#define glBitmap_RETURN void
#define glBitmap_ARG_NAMES width, height, xorig, yorig, xmove, ymove, bitmap
#define glBitmap_ARG_EXPAND GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap
#define glBitmap_ARG_NAMES_TAIL , width, height, xorig, yorig, xmove, ymove, bitmap
#define glBitmap_ARG_EXPAND_TAIL , GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap
#define forward_glBitmap(_width, _height, _xorig, _yorig, _xmove, _ymove, _bitmap) \
    ({ \
        void *dst = remote_dma(sizeof(glBitmap_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBitmap(dst, _width, _height, _xorig, _yorig, _xmove, _ymove, _bitmap), NULL); \
    });
#define call_glBitmap(packed, ret_v) do { \
    glBitmap_PACKED *unpacked = (glBitmap_PACKED *)packed; \
    glBitmap_ARGS *args = (glBitmap_ARGS *)&unpacked->args; \
    glBitmap(args->width, args->height, args->xorig, args->yorig, args->xmove, args->ymove, args->bitmap);; \
} while(0)
void glBitmap(glBitmap_ARG_EXPAND);
packed_call_t *pack_glBitmap(glBitmap_PACKED *_dst glBitmap_ARG_EXPAND_TAIL);
typedef void (*glBitmap_PTR)(glBitmap_ARG_EXPAND);
#endif
#ifndef glBitmapxOES_RETURN
#define glBitmapxOES_RETURN void
#define glBitmapxOES_ARG_NAMES width, height, xorig, yorig, xmove, ymove, bitmap
#define glBitmapxOES_ARG_EXPAND GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte * bitmap
#define glBitmapxOES_ARG_NAMES_TAIL , width, height, xorig, yorig, xmove, ymove, bitmap
#define glBitmapxOES_ARG_EXPAND_TAIL , GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte * bitmap
#define forward_glBitmapxOES(_width, _height, _xorig, _yorig, _xmove, _ymove, _bitmap) \
    ({ \
        void *dst = remote_dma(sizeof(glBitmapxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBitmapxOES(dst, _width, _height, _xorig, _yorig, _xmove, _ymove, _bitmap), NULL); \
    });
#define call_glBitmapxOES(packed, ret_v) do { \
    glBitmapxOES_PACKED *unpacked = (glBitmapxOES_PACKED *)packed; \
    glBitmapxOES_ARGS *args = (glBitmapxOES_ARGS *)&unpacked->args; \
    glBitmapxOES(args->width, args->height, args->xorig, args->yorig, args->xmove, args->ymove, args->bitmap);; \
} while(0)
void glBitmapxOES(glBitmapxOES_ARG_EXPAND);
packed_call_t *pack_glBitmapxOES(glBitmapxOES_PACKED *_dst glBitmapxOES_ARG_EXPAND_TAIL);
typedef void (*glBitmapxOES_PTR)(glBitmapxOES_ARG_EXPAND);
#endif
#ifndef glBlendColor_RETURN
#define glBlendColor_RETURN void
#define glBlendColor_ARG_NAMES red, green, blue, alpha
#define glBlendColor_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glBlendColor_ARG_NAMES_TAIL , red, green, blue, alpha
#define glBlendColor_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define forward_glBlendColor(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendColor_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendColor(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glBlendColor(packed, ret_v) do { \
    glBlendColor_PACKED *unpacked = (glBlendColor_PACKED *)packed; \
    glBlendColor_ARGS *args = (glBlendColor_ARGS *)&unpacked->args; \
    glBlendColor(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glBlendColor(glBlendColor_ARG_EXPAND);
packed_call_t *pack_glBlendColor(glBlendColor_PACKED *_dst glBlendColor_ARG_EXPAND_TAIL);
typedef void (*glBlendColor_PTR)(glBlendColor_ARG_EXPAND);
#endif
#ifndef glBlendColorEXT_RETURN
#define glBlendColorEXT_RETURN void
#define glBlendColorEXT_ARG_NAMES red, green, blue, alpha
#define glBlendColorEXT_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glBlendColorEXT_ARG_NAMES_TAIL , red, green, blue, alpha
#define glBlendColorEXT_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define forward_glBlendColorEXT(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendColorEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendColorEXT(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glBlendColorEXT(packed, ret_v) do { \
    glBlendColorEXT_PACKED *unpacked = (glBlendColorEXT_PACKED *)packed; \
    glBlendColorEXT_ARGS *args = (glBlendColorEXT_ARGS *)&unpacked->args; \
    glBlendColorEXT(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glBlendColorEXT(glBlendColorEXT_ARG_EXPAND);
packed_call_t *pack_glBlendColorEXT(glBlendColorEXT_PACKED *_dst glBlendColorEXT_ARG_EXPAND_TAIL);
typedef void (*glBlendColorEXT_PTR)(glBlendColorEXT_ARG_EXPAND);
#endif
#ifndef glBlendColorxOES_RETURN
#define glBlendColorxOES_RETURN void
#define glBlendColorxOES_ARG_NAMES red, green, blue, alpha
#define glBlendColorxOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glBlendColorxOES_ARG_NAMES_TAIL , red, green, blue, alpha
#define glBlendColorxOES_ARG_EXPAND_TAIL , GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define forward_glBlendColorxOES(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendColorxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendColorxOES(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glBlendColorxOES(packed, ret_v) do { \
    glBlendColorxOES_PACKED *unpacked = (glBlendColorxOES_PACKED *)packed; \
    glBlendColorxOES_ARGS *args = (glBlendColorxOES_ARGS *)&unpacked->args; \
    glBlendColorxOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glBlendColorxOES(glBlendColorxOES_ARG_EXPAND);
packed_call_t *pack_glBlendColorxOES(glBlendColorxOES_PACKED *_dst glBlendColorxOES_ARG_EXPAND_TAIL);
typedef void (*glBlendColorxOES_PTR)(glBlendColorxOES_ARG_EXPAND);
#endif
#ifndef glBlendEquation_RETURN
#define glBlendEquation_RETURN void
#define glBlendEquation_ARG_NAMES mode
#define glBlendEquation_ARG_EXPAND GLenum mode
#define glBlendEquation_ARG_NAMES_TAIL , mode
#define glBlendEquation_ARG_EXPAND_TAIL , GLenum mode
#define forward_glBlendEquation(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquation_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquation(dst, _mode), NULL); \
    });
#define call_glBlendEquation(packed, ret_v) do { \
    glBlendEquation_PACKED *unpacked = (glBlendEquation_PACKED *)packed; \
    glBlendEquation_ARGS *args = (glBlendEquation_ARGS *)&unpacked->args; \
    glBlendEquation(args->mode);; \
} while(0)
void glBlendEquation(glBlendEquation_ARG_EXPAND);
packed_call_t *pack_glBlendEquation(glBlendEquation_PACKED *_dst glBlendEquation_ARG_EXPAND_TAIL);
typedef void (*glBlendEquation_PTR)(glBlendEquation_ARG_EXPAND);
#endif
#ifndef glBlendEquationEXT_RETURN
#define glBlendEquationEXT_RETURN void
#define glBlendEquationEXT_ARG_NAMES mode
#define glBlendEquationEXT_ARG_EXPAND GLenum mode
#define glBlendEquationEXT_ARG_NAMES_TAIL , mode
#define glBlendEquationEXT_ARG_EXPAND_TAIL , GLenum mode
#define forward_glBlendEquationEXT(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationEXT(dst, _mode), NULL); \
    });
#define call_glBlendEquationEXT(packed, ret_v) do { \
    glBlendEquationEXT_PACKED *unpacked = (glBlendEquationEXT_PACKED *)packed; \
    glBlendEquationEXT_ARGS *args = (glBlendEquationEXT_ARGS *)&unpacked->args; \
    glBlendEquationEXT(args->mode);; \
} while(0)
void glBlendEquationEXT(glBlendEquationEXT_ARG_EXPAND);
packed_call_t *pack_glBlendEquationEXT(glBlendEquationEXT_PACKED *_dst glBlendEquationEXT_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationEXT_PTR)(glBlendEquationEXT_ARG_EXPAND);
#endif
#ifndef glBlendEquationIndexedAMD_RETURN
#define glBlendEquationIndexedAMD_RETURN void
#define glBlendEquationIndexedAMD_ARG_NAMES buf, mode
#define glBlendEquationIndexedAMD_ARG_EXPAND GLuint buf, GLenum mode
#define glBlendEquationIndexedAMD_ARG_NAMES_TAIL , buf, mode
#define glBlendEquationIndexedAMD_ARG_EXPAND_TAIL , GLuint buf, GLenum mode
#define forward_glBlendEquationIndexedAMD(_buf, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationIndexedAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationIndexedAMD(dst, _buf, _mode), NULL); \
    });
#define call_glBlendEquationIndexedAMD(packed, ret_v) do { \
    glBlendEquationIndexedAMD_PACKED *unpacked = (glBlendEquationIndexedAMD_PACKED *)packed; \
    glBlendEquationIndexedAMD_ARGS *args = (glBlendEquationIndexedAMD_ARGS *)&unpacked->args; \
    glBlendEquationIndexedAMD(args->buf, args->mode);; \
} while(0)
void glBlendEquationIndexedAMD(glBlendEquationIndexedAMD_ARG_EXPAND);
packed_call_t *pack_glBlendEquationIndexedAMD(glBlendEquationIndexedAMD_PACKED *_dst glBlendEquationIndexedAMD_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationIndexedAMD_PTR)(glBlendEquationIndexedAMD_ARG_EXPAND);
#endif
#ifndef glBlendEquationSeparate_RETURN
#define glBlendEquationSeparate_RETURN void
#define glBlendEquationSeparate_ARG_NAMES modeRGB, modeAlpha
#define glBlendEquationSeparate_ARG_EXPAND GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparate_ARG_NAMES_TAIL , modeRGB, modeAlpha
#define glBlendEquationSeparate_ARG_EXPAND_TAIL , GLenum modeRGB, GLenum modeAlpha
#define forward_glBlendEquationSeparate(_modeRGB, _modeAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationSeparate_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationSeparate(dst, _modeRGB, _modeAlpha), NULL); \
    });
#define call_glBlendEquationSeparate(packed, ret_v) do { \
    glBlendEquationSeparate_PACKED *unpacked = (glBlendEquationSeparate_PACKED *)packed; \
    glBlendEquationSeparate_ARGS *args = (glBlendEquationSeparate_ARGS *)&unpacked->args; \
    glBlendEquationSeparate(args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparate(glBlendEquationSeparate_ARG_EXPAND);
packed_call_t *pack_glBlendEquationSeparate(glBlendEquationSeparate_PACKED *_dst glBlendEquationSeparate_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationSeparate_PTR)(glBlendEquationSeparate_ARG_EXPAND);
#endif
#ifndef glBlendEquationSeparateEXT_RETURN
#define glBlendEquationSeparateEXT_RETURN void
#define glBlendEquationSeparateEXT_ARG_NAMES modeRGB, modeAlpha
#define glBlendEquationSeparateEXT_ARG_EXPAND GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparateEXT_ARG_NAMES_TAIL , modeRGB, modeAlpha
#define glBlendEquationSeparateEXT_ARG_EXPAND_TAIL , GLenum modeRGB, GLenum modeAlpha
#define forward_glBlendEquationSeparateEXT(_modeRGB, _modeAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationSeparateEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationSeparateEXT(dst, _modeRGB, _modeAlpha), NULL); \
    });
#define call_glBlendEquationSeparateEXT(packed, ret_v) do { \
    glBlendEquationSeparateEXT_PACKED *unpacked = (glBlendEquationSeparateEXT_PACKED *)packed; \
    glBlendEquationSeparateEXT_ARGS *args = (glBlendEquationSeparateEXT_ARGS *)&unpacked->args; \
    glBlendEquationSeparateEXT(args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparateEXT(glBlendEquationSeparateEXT_ARG_EXPAND);
packed_call_t *pack_glBlendEquationSeparateEXT(glBlendEquationSeparateEXT_PACKED *_dst glBlendEquationSeparateEXT_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationSeparateEXT_PTR)(glBlendEquationSeparateEXT_ARG_EXPAND);
#endif
#ifndef glBlendEquationSeparateIndexedAMD_RETURN
#define glBlendEquationSeparateIndexedAMD_RETURN void
#define glBlendEquationSeparateIndexedAMD_ARG_NAMES buf, modeRGB, modeAlpha
#define glBlendEquationSeparateIndexedAMD_ARG_EXPAND GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparateIndexedAMD_ARG_NAMES_TAIL , buf, modeRGB, modeAlpha
#define glBlendEquationSeparateIndexedAMD_ARG_EXPAND_TAIL , GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define forward_glBlendEquationSeparateIndexedAMD(_buf, _modeRGB, _modeAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationSeparateIndexedAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationSeparateIndexedAMD(dst, _buf, _modeRGB, _modeAlpha), NULL); \
    });
#define call_glBlendEquationSeparateIndexedAMD(packed, ret_v) do { \
    glBlendEquationSeparateIndexedAMD_PACKED *unpacked = (glBlendEquationSeparateIndexedAMD_PACKED *)packed; \
    glBlendEquationSeparateIndexedAMD_ARGS *args = (glBlendEquationSeparateIndexedAMD_ARGS *)&unpacked->args; \
    glBlendEquationSeparateIndexedAMD(args->buf, args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparateIndexedAMD(glBlendEquationSeparateIndexedAMD_ARG_EXPAND);
packed_call_t *pack_glBlendEquationSeparateIndexedAMD(glBlendEquationSeparateIndexedAMD_PACKED *_dst glBlendEquationSeparateIndexedAMD_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationSeparateIndexedAMD_PTR)(glBlendEquationSeparateIndexedAMD_ARG_EXPAND);
#endif
#ifndef glBlendEquationSeparatei_RETURN
#define glBlendEquationSeparatei_RETURN void
#define glBlendEquationSeparatei_ARG_NAMES buf, modeRGB, modeAlpha
#define glBlendEquationSeparatei_ARG_EXPAND GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparatei_ARG_NAMES_TAIL , buf, modeRGB, modeAlpha
#define glBlendEquationSeparatei_ARG_EXPAND_TAIL , GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define forward_glBlendEquationSeparatei(_buf, _modeRGB, _modeAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationSeparatei_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationSeparatei(dst, _buf, _modeRGB, _modeAlpha), NULL); \
    });
#define call_glBlendEquationSeparatei(packed, ret_v) do { \
    glBlendEquationSeparatei_PACKED *unpacked = (glBlendEquationSeparatei_PACKED *)packed; \
    glBlendEquationSeparatei_ARGS *args = (glBlendEquationSeparatei_ARGS *)&unpacked->args; \
    glBlendEquationSeparatei(args->buf, args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparatei(glBlendEquationSeparatei_ARG_EXPAND);
packed_call_t *pack_glBlendEquationSeparatei(glBlendEquationSeparatei_PACKED *_dst glBlendEquationSeparatei_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationSeparatei_PTR)(glBlendEquationSeparatei_ARG_EXPAND);
#endif
#ifndef glBlendEquationSeparateiARB_RETURN
#define glBlendEquationSeparateiARB_RETURN void
#define glBlendEquationSeparateiARB_ARG_NAMES buf, modeRGB, modeAlpha
#define glBlendEquationSeparateiARB_ARG_EXPAND GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparateiARB_ARG_NAMES_TAIL , buf, modeRGB, modeAlpha
#define glBlendEquationSeparateiARB_ARG_EXPAND_TAIL , GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define forward_glBlendEquationSeparateiARB(_buf, _modeRGB, _modeAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationSeparateiARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationSeparateiARB(dst, _buf, _modeRGB, _modeAlpha), NULL); \
    });
#define call_glBlendEquationSeparateiARB(packed, ret_v) do { \
    glBlendEquationSeparateiARB_PACKED *unpacked = (glBlendEquationSeparateiARB_PACKED *)packed; \
    glBlendEquationSeparateiARB_ARGS *args = (glBlendEquationSeparateiARB_ARGS *)&unpacked->args; \
    glBlendEquationSeparateiARB(args->buf, args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparateiARB(glBlendEquationSeparateiARB_ARG_EXPAND);
packed_call_t *pack_glBlendEquationSeparateiARB(glBlendEquationSeparateiARB_PACKED *_dst glBlendEquationSeparateiARB_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationSeparateiARB_PTR)(glBlendEquationSeparateiARB_ARG_EXPAND);
#endif
#ifndef glBlendEquationi_RETURN
#define glBlendEquationi_RETURN void
#define glBlendEquationi_ARG_NAMES buf, mode
#define glBlendEquationi_ARG_EXPAND GLuint buf, GLenum mode
#define glBlendEquationi_ARG_NAMES_TAIL , buf, mode
#define glBlendEquationi_ARG_EXPAND_TAIL , GLuint buf, GLenum mode
#define forward_glBlendEquationi(_buf, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationi_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationi(dst, _buf, _mode), NULL); \
    });
#define call_glBlendEquationi(packed, ret_v) do { \
    glBlendEquationi_PACKED *unpacked = (glBlendEquationi_PACKED *)packed; \
    glBlendEquationi_ARGS *args = (glBlendEquationi_ARGS *)&unpacked->args; \
    glBlendEquationi(args->buf, args->mode);; \
} while(0)
void glBlendEquationi(glBlendEquationi_ARG_EXPAND);
packed_call_t *pack_glBlendEquationi(glBlendEquationi_PACKED *_dst glBlendEquationi_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationi_PTR)(glBlendEquationi_ARG_EXPAND);
#endif
#ifndef glBlendEquationiARB_RETURN
#define glBlendEquationiARB_RETURN void
#define glBlendEquationiARB_ARG_NAMES buf, mode
#define glBlendEquationiARB_ARG_EXPAND GLuint buf, GLenum mode
#define glBlendEquationiARB_ARG_NAMES_TAIL , buf, mode
#define glBlendEquationiARB_ARG_EXPAND_TAIL , GLuint buf, GLenum mode
#define forward_glBlendEquationiARB(_buf, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendEquationiARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendEquationiARB(dst, _buf, _mode), NULL); \
    });
#define call_glBlendEquationiARB(packed, ret_v) do { \
    glBlendEquationiARB_PACKED *unpacked = (glBlendEquationiARB_PACKED *)packed; \
    glBlendEquationiARB_ARGS *args = (glBlendEquationiARB_ARGS *)&unpacked->args; \
    glBlendEquationiARB(args->buf, args->mode);; \
} while(0)
void glBlendEquationiARB(glBlendEquationiARB_ARG_EXPAND);
packed_call_t *pack_glBlendEquationiARB(glBlendEquationiARB_PACKED *_dst glBlendEquationiARB_ARG_EXPAND_TAIL);
typedef void (*glBlendEquationiARB_PTR)(glBlendEquationiARB_ARG_EXPAND);
#endif
#ifndef glBlendFunc_RETURN
#define glBlendFunc_RETURN void
#define glBlendFunc_ARG_NAMES sfactor, dfactor
#define glBlendFunc_ARG_EXPAND GLenum sfactor, GLenum dfactor
#define glBlendFunc_ARG_NAMES_TAIL , sfactor, dfactor
#define glBlendFunc_ARG_EXPAND_TAIL , GLenum sfactor, GLenum dfactor
#define forward_glBlendFunc(_sfactor, _dfactor) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFunc_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFunc(dst, _sfactor, _dfactor), NULL); \
    });
#define call_glBlendFunc(packed, ret_v) do { \
    glBlendFunc_PACKED *unpacked = (glBlendFunc_PACKED *)packed; \
    glBlendFunc_ARGS *args = (glBlendFunc_ARGS *)&unpacked->args; \
    glBlendFunc(args->sfactor, args->dfactor);; \
} while(0)
void glBlendFunc(glBlendFunc_ARG_EXPAND);
packed_call_t *pack_glBlendFunc(glBlendFunc_PACKED *_dst glBlendFunc_ARG_EXPAND_TAIL);
typedef void (*glBlendFunc_PTR)(glBlendFunc_ARG_EXPAND);
#endif
#ifndef glBlendFuncIndexedAMD_RETURN
#define glBlendFuncIndexedAMD_RETURN void
#define glBlendFuncIndexedAMD_ARG_NAMES buf, src, dst
#define glBlendFuncIndexedAMD_ARG_EXPAND GLuint buf, GLenum src, GLenum dst
#define glBlendFuncIndexedAMD_ARG_NAMES_TAIL , buf, src, dst
#define glBlendFuncIndexedAMD_ARG_EXPAND_TAIL , GLuint buf, GLenum src, GLenum dst
#define forward_glBlendFuncIndexedAMD(_buf, _src, _dst) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFuncIndexedAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFuncIndexedAMD(dst, _buf, _src, _dst), NULL); \
    });
#define call_glBlendFuncIndexedAMD(packed, ret_v) do { \
    glBlendFuncIndexedAMD_PACKED *unpacked = (glBlendFuncIndexedAMD_PACKED *)packed; \
    glBlendFuncIndexedAMD_ARGS *args = (glBlendFuncIndexedAMD_ARGS *)&unpacked->args; \
    glBlendFuncIndexedAMD(args->buf, args->src, args->dst);; \
} while(0)
void glBlendFuncIndexedAMD(glBlendFuncIndexedAMD_ARG_EXPAND);
packed_call_t *pack_glBlendFuncIndexedAMD(glBlendFuncIndexedAMD_PACKED *_dst glBlendFuncIndexedAMD_ARG_EXPAND_TAIL);
typedef void (*glBlendFuncIndexedAMD_PTR)(glBlendFuncIndexedAMD_ARG_EXPAND);
#endif
#ifndef glBlendFuncSeparate_RETURN
#define glBlendFuncSeparate_RETURN void
#define glBlendFuncSeparate_ARG_NAMES sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparate_ARG_EXPAND GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define glBlendFuncSeparate_ARG_NAMES_TAIL , sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparate_ARG_EXPAND_TAIL , GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define forward_glBlendFuncSeparate(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFuncSeparate_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFuncSeparate(dst, _sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha), NULL); \
    });
#define call_glBlendFuncSeparate(packed, ret_v) do { \
    glBlendFuncSeparate_PACKED *unpacked = (glBlendFuncSeparate_PACKED *)packed; \
    glBlendFuncSeparate_ARGS *args = (glBlendFuncSeparate_ARGS *)&unpacked->args; \
    glBlendFuncSeparate(args->sfactorRGB, args->dfactorRGB, args->sfactorAlpha, args->dfactorAlpha);; \
} while(0)
void glBlendFuncSeparate(glBlendFuncSeparate_ARG_EXPAND);
packed_call_t *pack_glBlendFuncSeparate(glBlendFuncSeparate_PACKED *_dst glBlendFuncSeparate_ARG_EXPAND_TAIL);
typedef void (*glBlendFuncSeparate_PTR)(glBlendFuncSeparate_ARG_EXPAND);
#endif
#ifndef glBlendFuncSeparateEXT_RETURN
#define glBlendFuncSeparateEXT_RETURN void
#define glBlendFuncSeparateEXT_ARG_NAMES sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparateEXT_ARG_EXPAND GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define glBlendFuncSeparateEXT_ARG_NAMES_TAIL , sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparateEXT_ARG_EXPAND_TAIL , GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define forward_glBlendFuncSeparateEXT(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFuncSeparateEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFuncSeparateEXT(dst, _sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha), NULL); \
    });
#define call_glBlendFuncSeparateEXT(packed, ret_v) do { \
    glBlendFuncSeparateEXT_PACKED *unpacked = (glBlendFuncSeparateEXT_PACKED *)packed; \
    glBlendFuncSeparateEXT_ARGS *args = (glBlendFuncSeparateEXT_ARGS *)&unpacked->args; \
    glBlendFuncSeparateEXT(args->sfactorRGB, args->dfactorRGB, args->sfactorAlpha, args->dfactorAlpha);; \
} while(0)
void glBlendFuncSeparateEXT(glBlendFuncSeparateEXT_ARG_EXPAND);
packed_call_t *pack_glBlendFuncSeparateEXT(glBlendFuncSeparateEXT_PACKED *_dst glBlendFuncSeparateEXT_ARG_EXPAND_TAIL);
typedef void (*glBlendFuncSeparateEXT_PTR)(glBlendFuncSeparateEXT_ARG_EXPAND);
#endif
#ifndef glBlendFuncSeparateINGR_RETURN
#define glBlendFuncSeparateINGR_RETURN void
#define glBlendFuncSeparateINGR_ARG_NAMES sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparateINGR_ARG_EXPAND GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define glBlendFuncSeparateINGR_ARG_NAMES_TAIL , sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparateINGR_ARG_EXPAND_TAIL , GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define forward_glBlendFuncSeparateINGR(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFuncSeparateINGR_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFuncSeparateINGR(dst, _sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha), NULL); \
    });
#define call_glBlendFuncSeparateINGR(packed, ret_v) do { \
    glBlendFuncSeparateINGR_PACKED *unpacked = (glBlendFuncSeparateINGR_PACKED *)packed; \
    glBlendFuncSeparateINGR_ARGS *args = (glBlendFuncSeparateINGR_ARGS *)&unpacked->args; \
    glBlendFuncSeparateINGR(args->sfactorRGB, args->dfactorRGB, args->sfactorAlpha, args->dfactorAlpha);; \
} while(0)
void glBlendFuncSeparateINGR(glBlendFuncSeparateINGR_ARG_EXPAND);
packed_call_t *pack_glBlendFuncSeparateINGR(glBlendFuncSeparateINGR_PACKED *_dst glBlendFuncSeparateINGR_ARG_EXPAND_TAIL);
typedef void (*glBlendFuncSeparateINGR_PTR)(glBlendFuncSeparateINGR_ARG_EXPAND);
#endif
#ifndef glBlendFuncSeparateIndexedAMD_RETURN
#define glBlendFuncSeparateIndexedAMD_RETURN void
#define glBlendFuncSeparateIndexedAMD_ARG_NAMES buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparateIndexedAMD_ARG_EXPAND GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define glBlendFuncSeparateIndexedAMD_ARG_NAMES_TAIL , buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparateIndexedAMD_ARG_EXPAND_TAIL , GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define forward_glBlendFuncSeparateIndexedAMD(_buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFuncSeparateIndexedAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFuncSeparateIndexedAMD(dst, _buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha), NULL); \
    });
#define call_glBlendFuncSeparateIndexedAMD(packed, ret_v) do { \
    glBlendFuncSeparateIndexedAMD_PACKED *unpacked = (glBlendFuncSeparateIndexedAMD_PACKED *)packed; \
    glBlendFuncSeparateIndexedAMD_ARGS *args = (glBlendFuncSeparateIndexedAMD_ARGS *)&unpacked->args; \
    glBlendFuncSeparateIndexedAMD(args->buf, args->srcRGB, args->dstRGB, args->srcAlpha, args->dstAlpha);; \
} while(0)
void glBlendFuncSeparateIndexedAMD(glBlendFuncSeparateIndexedAMD_ARG_EXPAND);
packed_call_t *pack_glBlendFuncSeparateIndexedAMD(glBlendFuncSeparateIndexedAMD_PACKED *_dst glBlendFuncSeparateIndexedAMD_ARG_EXPAND_TAIL);
typedef void (*glBlendFuncSeparateIndexedAMD_PTR)(glBlendFuncSeparateIndexedAMD_ARG_EXPAND);
#endif
#ifndef glBlendFuncSeparatei_RETURN
#define glBlendFuncSeparatei_RETURN void
#define glBlendFuncSeparatei_ARG_NAMES buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparatei_ARG_EXPAND GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define glBlendFuncSeparatei_ARG_NAMES_TAIL , buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparatei_ARG_EXPAND_TAIL , GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define forward_glBlendFuncSeparatei(_buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFuncSeparatei_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFuncSeparatei(dst, _buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha), NULL); \
    });
#define call_glBlendFuncSeparatei(packed, ret_v) do { \
    glBlendFuncSeparatei_PACKED *unpacked = (glBlendFuncSeparatei_PACKED *)packed; \
    glBlendFuncSeparatei_ARGS *args = (glBlendFuncSeparatei_ARGS *)&unpacked->args; \
    glBlendFuncSeparatei(args->buf, args->srcRGB, args->dstRGB, args->srcAlpha, args->dstAlpha);; \
} while(0)
void glBlendFuncSeparatei(glBlendFuncSeparatei_ARG_EXPAND);
packed_call_t *pack_glBlendFuncSeparatei(glBlendFuncSeparatei_PACKED *_dst glBlendFuncSeparatei_ARG_EXPAND_TAIL);
typedef void (*glBlendFuncSeparatei_PTR)(glBlendFuncSeparatei_ARG_EXPAND);
#endif
#ifndef glBlendFuncSeparateiARB_RETURN
#define glBlendFuncSeparateiARB_RETURN void
#define glBlendFuncSeparateiARB_ARG_NAMES buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparateiARB_ARG_EXPAND GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define glBlendFuncSeparateiARB_ARG_NAMES_TAIL , buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparateiARB_ARG_EXPAND_TAIL , GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define forward_glBlendFuncSeparateiARB(_buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFuncSeparateiARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFuncSeparateiARB(dst, _buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha), NULL); \
    });
#define call_glBlendFuncSeparateiARB(packed, ret_v) do { \
    glBlendFuncSeparateiARB_PACKED *unpacked = (glBlendFuncSeparateiARB_PACKED *)packed; \
    glBlendFuncSeparateiARB_ARGS *args = (glBlendFuncSeparateiARB_ARGS *)&unpacked->args; \
    glBlendFuncSeparateiARB(args->buf, args->srcRGB, args->dstRGB, args->srcAlpha, args->dstAlpha);; \
} while(0)
void glBlendFuncSeparateiARB(glBlendFuncSeparateiARB_ARG_EXPAND);
packed_call_t *pack_glBlendFuncSeparateiARB(glBlendFuncSeparateiARB_PACKED *_dst glBlendFuncSeparateiARB_ARG_EXPAND_TAIL);
typedef void (*glBlendFuncSeparateiARB_PTR)(glBlendFuncSeparateiARB_ARG_EXPAND);
#endif
#ifndef glBlendFunci_RETURN
#define glBlendFunci_RETURN void
#define glBlendFunci_ARG_NAMES buf, src, dst
#define glBlendFunci_ARG_EXPAND GLuint buf, GLenum src, GLenum dst
#define glBlendFunci_ARG_NAMES_TAIL , buf, src, dst
#define glBlendFunci_ARG_EXPAND_TAIL , GLuint buf, GLenum src, GLenum dst
#define forward_glBlendFunci(_buf, _src, _dst) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFunci_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFunci(dst, _buf, _src, _dst), NULL); \
    });
#define call_glBlendFunci(packed, ret_v) do { \
    glBlendFunci_PACKED *unpacked = (glBlendFunci_PACKED *)packed; \
    glBlendFunci_ARGS *args = (glBlendFunci_ARGS *)&unpacked->args; \
    glBlendFunci(args->buf, args->src, args->dst);; \
} while(0)
void glBlendFunci(glBlendFunci_ARG_EXPAND);
packed_call_t *pack_glBlendFunci(glBlendFunci_PACKED *_dst glBlendFunci_ARG_EXPAND_TAIL);
typedef void (*glBlendFunci_PTR)(glBlendFunci_ARG_EXPAND);
#endif
#ifndef glBlendFunciARB_RETURN
#define glBlendFunciARB_RETURN void
#define glBlendFunciARB_ARG_NAMES buf, src, dst
#define glBlendFunciARB_ARG_EXPAND GLuint buf, GLenum src, GLenum dst
#define glBlendFunciARB_ARG_NAMES_TAIL , buf, src, dst
#define glBlendFunciARB_ARG_EXPAND_TAIL , GLuint buf, GLenum src, GLenum dst
#define forward_glBlendFunciARB(_buf, _src, _dst) \
    ({ \
        void *dst = remote_dma(sizeof(glBlendFunciARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlendFunciARB(dst, _buf, _src, _dst), NULL); \
    });
#define call_glBlendFunciARB(packed, ret_v) do { \
    glBlendFunciARB_PACKED *unpacked = (glBlendFunciARB_PACKED *)packed; \
    glBlendFunciARB_ARGS *args = (glBlendFunciARB_ARGS *)&unpacked->args; \
    glBlendFunciARB(args->buf, args->src, args->dst);; \
} while(0)
void glBlendFunciARB(glBlendFunciARB_ARG_EXPAND);
packed_call_t *pack_glBlendFunciARB(glBlendFunciARB_PACKED *_dst glBlendFunciARB_ARG_EXPAND_TAIL);
typedef void (*glBlendFunciARB_PTR)(glBlendFunciARB_ARG_EXPAND);
#endif
#ifndef glBlitFramebuffer_RETURN
#define glBlitFramebuffer_RETURN void
#define glBlitFramebuffer_ARG_NAMES srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter
#define glBlitFramebuffer_ARG_EXPAND GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter
#define glBlitFramebuffer_ARG_NAMES_TAIL , srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter
#define glBlitFramebuffer_ARG_EXPAND_TAIL , GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter
#define forward_glBlitFramebuffer(_srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter) \
    ({ \
        void *dst = remote_dma(sizeof(glBlitFramebuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlitFramebuffer(dst, _srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter), NULL); \
    });
#define call_glBlitFramebuffer(packed, ret_v) do { \
    glBlitFramebuffer_PACKED *unpacked = (glBlitFramebuffer_PACKED *)packed; \
    glBlitFramebuffer_ARGS *args = (glBlitFramebuffer_ARGS *)&unpacked->args; \
    glBlitFramebuffer(args->srcX0, args->srcY0, args->srcX1, args->srcY1, args->dstX0, args->dstY0, args->dstX1, args->dstY1, args->mask, args->filter);; \
} while(0)
void glBlitFramebuffer(glBlitFramebuffer_ARG_EXPAND);
packed_call_t *pack_glBlitFramebuffer(glBlitFramebuffer_PACKED *_dst glBlitFramebuffer_ARG_EXPAND_TAIL);
typedef void (*glBlitFramebuffer_PTR)(glBlitFramebuffer_ARG_EXPAND);
#endif
#ifndef glBlitFramebufferEXT_RETURN
#define glBlitFramebufferEXT_RETURN void
#define glBlitFramebufferEXT_ARG_NAMES srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter
#define glBlitFramebufferEXT_ARG_EXPAND GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter
#define glBlitFramebufferEXT_ARG_NAMES_TAIL , srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter
#define glBlitFramebufferEXT_ARG_EXPAND_TAIL , GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter
#define forward_glBlitFramebufferEXT(_srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter) \
    ({ \
        void *dst = remote_dma(sizeof(glBlitFramebufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBlitFramebufferEXT(dst, _srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter), NULL); \
    });
#define call_glBlitFramebufferEXT(packed, ret_v) do { \
    glBlitFramebufferEXT_PACKED *unpacked = (glBlitFramebufferEXT_PACKED *)packed; \
    glBlitFramebufferEXT_ARGS *args = (glBlitFramebufferEXT_ARGS *)&unpacked->args; \
    glBlitFramebufferEXT(args->srcX0, args->srcY0, args->srcX1, args->srcY1, args->dstX0, args->dstY0, args->dstX1, args->dstY1, args->mask, args->filter);; \
} while(0)
void glBlitFramebufferEXT(glBlitFramebufferEXT_ARG_EXPAND);
packed_call_t *pack_glBlitFramebufferEXT(glBlitFramebufferEXT_PACKED *_dst glBlitFramebufferEXT_ARG_EXPAND_TAIL);
typedef void (*glBlitFramebufferEXT_PTR)(glBlitFramebufferEXT_ARG_EXPAND);
#endif
#ifndef glBufferAddressRangeNV_RETURN
#define glBufferAddressRangeNV_RETURN void
#define glBufferAddressRangeNV_ARG_NAMES pname, index, address, length
#define glBufferAddressRangeNV_ARG_EXPAND GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length
#define glBufferAddressRangeNV_ARG_NAMES_TAIL , pname, index, address, length
#define glBufferAddressRangeNV_ARG_EXPAND_TAIL , GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length
#define forward_glBufferAddressRangeNV(_pname, _index, _address, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glBufferAddressRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBufferAddressRangeNV(dst, _pname, _index, _address, _length), NULL); \
    });
#define call_glBufferAddressRangeNV(packed, ret_v) do { \
    glBufferAddressRangeNV_PACKED *unpacked = (glBufferAddressRangeNV_PACKED *)packed; \
    glBufferAddressRangeNV_ARGS *args = (glBufferAddressRangeNV_ARGS *)&unpacked->args; \
    glBufferAddressRangeNV(args->pname, args->index, args->address, args->length);; \
} while(0)
void glBufferAddressRangeNV(glBufferAddressRangeNV_ARG_EXPAND);
packed_call_t *pack_glBufferAddressRangeNV(glBufferAddressRangeNV_PACKED *_dst glBufferAddressRangeNV_ARG_EXPAND_TAIL);
typedef void (*glBufferAddressRangeNV_PTR)(glBufferAddressRangeNV_ARG_EXPAND);
#endif
#ifndef glBufferData_RETURN
#define glBufferData_RETURN void
#define glBufferData_ARG_NAMES target, size, data, usage
#define glBufferData_ARG_EXPAND GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage
#define glBufferData_ARG_NAMES_TAIL , target, size, data, usage
#define glBufferData_ARG_EXPAND_TAIL , GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage
#define forward_glBufferData(_target, _size, _data, _usage) \
    ({ \
        void *dst = remote_dma(sizeof(glBufferData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBufferData(dst, _target, _size, _data, _usage), NULL); \
    });
#define call_glBufferData(packed, ret_v) do { \
    glBufferData_PACKED *unpacked = (glBufferData_PACKED *)packed; \
    glBufferData_ARGS *args = (glBufferData_ARGS *)&unpacked->args; \
    glBufferData(args->target, args->size, args->data, args->usage);; \
} while(0)
void glBufferData(glBufferData_ARG_EXPAND);
packed_call_t *pack_glBufferData(glBufferData_PACKED *_dst glBufferData_ARG_EXPAND_TAIL);
typedef void (*glBufferData_PTR)(glBufferData_ARG_EXPAND);
#endif
#ifndef glBufferDataARB_RETURN
#define glBufferDataARB_RETURN void
#define glBufferDataARB_ARG_NAMES target, size, data, usage
#define glBufferDataARB_ARG_EXPAND GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage
#define glBufferDataARB_ARG_NAMES_TAIL , target, size, data, usage
#define glBufferDataARB_ARG_EXPAND_TAIL , GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage
#define forward_glBufferDataARB(_target, _size, _data, _usage) \
    ({ \
        void *dst = remote_dma(sizeof(glBufferDataARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBufferDataARB(dst, _target, _size, _data, _usage), NULL); \
    });
#define call_glBufferDataARB(packed, ret_v) do { \
    glBufferDataARB_PACKED *unpacked = (glBufferDataARB_PACKED *)packed; \
    glBufferDataARB_ARGS *args = (glBufferDataARB_ARGS *)&unpacked->args; \
    glBufferDataARB(args->target, args->size, args->data, args->usage);; \
} while(0)
void glBufferDataARB(glBufferDataARB_ARG_EXPAND);
packed_call_t *pack_glBufferDataARB(glBufferDataARB_PACKED *_dst glBufferDataARB_ARG_EXPAND_TAIL);
typedef void (*glBufferDataARB_PTR)(glBufferDataARB_ARG_EXPAND);
#endif
#ifndef glBufferParameteriAPPLE_RETURN
#define glBufferParameteriAPPLE_RETURN void
#define glBufferParameteriAPPLE_ARG_NAMES target, pname, param
#define glBufferParameteriAPPLE_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glBufferParameteriAPPLE_ARG_NAMES_TAIL , target, pname, param
#define glBufferParameteriAPPLE_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint param
#define forward_glBufferParameteriAPPLE(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glBufferParameteriAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBufferParameteriAPPLE(dst, _target, _pname, _param), NULL); \
    });
#define call_glBufferParameteriAPPLE(packed, ret_v) do { \
    glBufferParameteriAPPLE_PACKED *unpacked = (glBufferParameteriAPPLE_PACKED *)packed; \
    glBufferParameteriAPPLE_ARGS *args = (glBufferParameteriAPPLE_ARGS *)&unpacked->args; \
    glBufferParameteriAPPLE(args->target, args->pname, args->param);; \
} while(0)
void glBufferParameteriAPPLE(glBufferParameteriAPPLE_ARG_EXPAND);
packed_call_t *pack_glBufferParameteriAPPLE(glBufferParameteriAPPLE_PACKED *_dst glBufferParameteriAPPLE_ARG_EXPAND_TAIL);
typedef void (*glBufferParameteriAPPLE_PTR)(glBufferParameteriAPPLE_ARG_EXPAND);
#endif
#ifndef glBufferSubData_RETURN
#define glBufferSubData_RETURN void
#define glBufferSubData_ARG_NAMES target, offset, size, data
#define glBufferSubData_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data
#define glBufferSubData_ARG_NAMES_TAIL , target, offset, size, data
#define glBufferSubData_ARG_EXPAND_TAIL , GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data
#define forward_glBufferSubData(_target, _offset, _size, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glBufferSubData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBufferSubData(dst, _target, _offset, _size, _data), NULL); \
    });
#define call_glBufferSubData(packed, ret_v) do { \
    glBufferSubData_PACKED *unpacked = (glBufferSubData_PACKED *)packed; \
    glBufferSubData_ARGS *args = (glBufferSubData_ARGS *)&unpacked->args; \
    glBufferSubData(args->target, args->offset, args->size, args->data);; \
} while(0)
void glBufferSubData(glBufferSubData_ARG_EXPAND);
packed_call_t *pack_glBufferSubData(glBufferSubData_PACKED *_dst glBufferSubData_ARG_EXPAND_TAIL);
typedef void (*glBufferSubData_PTR)(glBufferSubData_ARG_EXPAND);
#endif
#ifndef glBufferSubDataARB_RETURN
#define glBufferSubDataARB_RETURN void
#define glBufferSubDataARB_ARG_NAMES target, offset, size, data
#define glBufferSubDataARB_ARG_EXPAND GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data
#define glBufferSubDataARB_ARG_NAMES_TAIL , target, offset, size, data
#define glBufferSubDataARB_ARG_EXPAND_TAIL , GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data
#define forward_glBufferSubDataARB(_target, _offset, _size, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glBufferSubDataARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glBufferSubDataARB(dst, _target, _offset, _size, _data), NULL); \
    });
#define call_glBufferSubDataARB(packed, ret_v) do { \
    glBufferSubDataARB_PACKED *unpacked = (glBufferSubDataARB_PACKED *)packed; \
    glBufferSubDataARB_ARGS *args = (glBufferSubDataARB_ARGS *)&unpacked->args; \
    glBufferSubDataARB(args->target, args->offset, args->size, args->data);; \
} while(0)
void glBufferSubDataARB(glBufferSubDataARB_ARG_EXPAND);
packed_call_t *pack_glBufferSubDataARB(glBufferSubDataARB_PACKED *_dst glBufferSubDataARB_ARG_EXPAND_TAIL);
typedef void (*glBufferSubDataARB_PTR)(glBufferSubDataARB_ARG_EXPAND);
#endif
#ifndef glCallList_RETURN
#define glCallList_RETURN void
#define glCallList_ARG_NAMES list
#define glCallList_ARG_EXPAND GLuint list
#define glCallList_ARG_NAMES_TAIL , list
#define glCallList_ARG_EXPAND_TAIL , GLuint list
#define forward_glCallList(_list) \
    ({ \
        void *dst = remote_dma(sizeof(glCallList_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCallList(dst, _list), NULL); \
    });
#define call_glCallList(packed, ret_v) do { \
    glCallList_PACKED *unpacked = (glCallList_PACKED *)packed; \
    glCallList_ARGS *args = (glCallList_ARGS *)&unpacked->args; \
    glCallList(args->list);; \
} while(0)
void glCallList(glCallList_ARG_EXPAND);
packed_call_t *pack_glCallList(glCallList_PACKED *_dst glCallList_ARG_EXPAND_TAIL);
typedef void (*glCallList_PTR)(glCallList_ARG_EXPAND);
#endif
#ifndef glCallLists_RETURN
#define glCallLists_RETURN void
#define glCallLists_ARG_NAMES n, type, lists
#define glCallLists_ARG_EXPAND GLsizei n, GLenum type, const GLvoid * lists
#define glCallLists_ARG_NAMES_TAIL , n, type, lists
#define glCallLists_ARG_EXPAND_TAIL , GLsizei n, GLenum type, const GLvoid * lists
#define forward_glCallLists(_n, _type, _lists) \
    ({ \
        void *dst = remote_dma(sizeof(glCallLists_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCallLists(dst, _n, _type, _lists), NULL); \
    });
#define call_glCallLists(packed, ret_v) do { \
    glCallLists_PACKED *unpacked = (glCallLists_PACKED *)packed; \
    glCallLists_ARGS *args = (glCallLists_ARGS *)&unpacked->args; \
    glCallLists(args->n, args->type, args->lists);; \
} while(0)
void glCallLists(glCallLists_ARG_EXPAND);
packed_call_t *pack_glCallLists(glCallLists_PACKED *_dst glCallLists_ARG_EXPAND_TAIL);
typedef void (*glCallLists_PTR)(glCallLists_ARG_EXPAND);
#endif
#ifndef glCheckFramebufferStatus_RETURN
#define glCheckFramebufferStatus_RETURN GLenum
#define glCheckFramebufferStatus_ARG_NAMES target
#define glCheckFramebufferStatus_ARG_EXPAND GLenum target
#define glCheckFramebufferStatus_ARG_NAMES_TAIL , target
#define glCheckFramebufferStatus_ARG_EXPAND_TAIL , GLenum target
#define forward_glCheckFramebufferStatus(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glCheckFramebufferStatus_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glCheckFramebufferStatus(dst, _target), &ret); \
        ret; \
    });
#define call_glCheckFramebufferStatus(packed, ret_v) do { \
    glCheckFramebufferStatus_PACKED *unpacked = (glCheckFramebufferStatus_PACKED *)packed; \
    glCheckFramebufferStatus_ARGS *args = (glCheckFramebufferStatus_ARGS *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glCheckFramebufferStatus(args->target);; \
    } else { \
        glCheckFramebufferStatus(args->target);; \
    } \
} while(0)
GLenum glCheckFramebufferStatus(glCheckFramebufferStatus_ARG_EXPAND);
packed_call_t *pack_glCheckFramebufferStatus(glCheckFramebufferStatus_PACKED *_dst glCheckFramebufferStatus_ARG_EXPAND_TAIL);
typedef GLenum (*glCheckFramebufferStatus_PTR)(glCheckFramebufferStatus_ARG_EXPAND);
#endif
#ifndef glCheckFramebufferStatusEXT_RETURN
#define glCheckFramebufferStatusEXT_RETURN GLenum
#define glCheckFramebufferStatusEXT_ARG_NAMES target
#define glCheckFramebufferStatusEXT_ARG_EXPAND GLenum target
#define glCheckFramebufferStatusEXT_ARG_NAMES_TAIL , target
#define glCheckFramebufferStatusEXT_ARG_EXPAND_TAIL , GLenum target
#define forward_glCheckFramebufferStatusEXT(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glCheckFramebufferStatusEXT_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glCheckFramebufferStatusEXT(dst, _target), &ret); \
        ret; \
    });
#define call_glCheckFramebufferStatusEXT(packed, ret_v) do { \
    glCheckFramebufferStatusEXT_PACKED *unpacked = (glCheckFramebufferStatusEXT_PACKED *)packed; \
    glCheckFramebufferStatusEXT_ARGS *args = (glCheckFramebufferStatusEXT_ARGS *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glCheckFramebufferStatusEXT(args->target);; \
    } else { \
        glCheckFramebufferStatusEXT(args->target);; \
    } \
} while(0)
GLenum glCheckFramebufferStatusEXT(glCheckFramebufferStatusEXT_ARG_EXPAND);
packed_call_t *pack_glCheckFramebufferStatusEXT(glCheckFramebufferStatusEXT_PACKED *_dst glCheckFramebufferStatusEXT_ARG_EXPAND_TAIL);
typedef GLenum (*glCheckFramebufferStatusEXT_PTR)(glCheckFramebufferStatusEXT_ARG_EXPAND);
#endif
#ifndef glCheckNamedFramebufferStatusEXT_RETURN
#define glCheckNamedFramebufferStatusEXT_RETURN GLenum
#define glCheckNamedFramebufferStatusEXT_ARG_NAMES framebuffer, target
#define glCheckNamedFramebufferStatusEXT_ARG_EXPAND GLuint framebuffer, GLenum target
#define glCheckNamedFramebufferStatusEXT_ARG_NAMES_TAIL , framebuffer, target
#define glCheckNamedFramebufferStatusEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum target
#define forward_glCheckNamedFramebufferStatusEXT(_framebuffer, _target) \
    ({ \
        void *dst = remote_dma(sizeof(glCheckNamedFramebufferStatusEXT_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glCheckNamedFramebufferStatusEXT(dst, _framebuffer, _target), &ret); \
        ret; \
    });
#define call_glCheckNamedFramebufferStatusEXT(packed, ret_v) do { \
    glCheckNamedFramebufferStatusEXT_PACKED *unpacked = (glCheckNamedFramebufferStatusEXT_PACKED *)packed; \
    glCheckNamedFramebufferStatusEXT_ARGS *args = (glCheckNamedFramebufferStatusEXT_ARGS *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glCheckNamedFramebufferStatusEXT(args->framebuffer, args->target);; \
    } else { \
        glCheckNamedFramebufferStatusEXT(args->framebuffer, args->target);; \
    } \
} while(0)
GLenum glCheckNamedFramebufferStatusEXT(glCheckNamedFramebufferStatusEXT_ARG_EXPAND);
packed_call_t *pack_glCheckNamedFramebufferStatusEXT(glCheckNamedFramebufferStatusEXT_PACKED *_dst glCheckNamedFramebufferStatusEXT_ARG_EXPAND_TAIL);
typedef GLenum (*glCheckNamedFramebufferStatusEXT_PTR)(glCheckNamedFramebufferStatusEXT_ARG_EXPAND);
#endif
#ifndef glClampColor_RETURN
#define glClampColor_RETURN void
#define glClampColor_ARG_NAMES target, clamp
#define glClampColor_ARG_EXPAND GLenum target, GLenum clamp
#define glClampColor_ARG_NAMES_TAIL , target, clamp
#define glClampColor_ARG_EXPAND_TAIL , GLenum target, GLenum clamp
#define forward_glClampColor(_target, _clamp) \
    ({ \
        void *dst = remote_dma(sizeof(glClampColor_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClampColor(dst, _target, _clamp), NULL); \
    });
#define call_glClampColor(packed, ret_v) do { \
    glClampColor_PACKED *unpacked = (glClampColor_PACKED *)packed; \
    glClampColor_ARGS *args = (glClampColor_ARGS *)&unpacked->args; \
    glClampColor(args->target, args->clamp);; \
} while(0)
void glClampColor(glClampColor_ARG_EXPAND);
packed_call_t *pack_glClampColor(glClampColor_PACKED *_dst glClampColor_ARG_EXPAND_TAIL);
typedef void (*glClampColor_PTR)(glClampColor_ARG_EXPAND);
#endif
#ifndef glClampColorARB_RETURN
#define glClampColorARB_RETURN void
#define glClampColorARB_ARG_NAMES target, clamp
#define glClampColorARB_ARG_EXPAND GLenum target, GLenum clamp
#define glClampColorARB_ARG_NAMES_TAIL , target, clamp
#define glClampColorARB_ARG_EXPAND_TAIL , GLenum target, GLenum clamp
#define forward_glClampColorARB(_target, _clamp) \
    ({ \
        void *dst = remote_dma(sizeof(glClampColorARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClampColorARB(dst, _target, _clamp), NULL); \
    });
#define call_glClampColorARB(packed, ret_v) do { \
    glClampColorARB_PACKED *unpacked = (glClampColorARB_PACKED *)packed; \
    glClampColorARB_ARGS *args = (glClampColorARB_ARGS *)&unpacked->args; \
    glClampColorARB(args->target, args->clamp);; \
} while(0)
void glClampColorARB(glClampColorARB_ARG_EXPAND);
packed_call_t *pack_glClampColorARB(glClampColorARB_PACKED *_dst glClampColorARB_ARG_EXPAND_TAIL);
typedef void (*glClampColorARB_PTR)(glClampColorARB_ARG_EXPAND);
#endif
#ifndef glClear_RETURN
#define glClear_RETURN void
#define glClear_ARG_NAMES mask
#define glClear_ARG_EXPAND GLbitfield mask
#define glClear_ARG_NAMES_TAIL , mask
#define glClear_ARG_EXPAND_TAIL , GLbitfield mask
#define forward_glClear(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glClear_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClear(dst, _mask), NULL); \
    });
#define call_glClear(packed, ret_v) do { \
    glClear_PACKED *unpacked = (glClear_PACKED *)packed; \
    glClear_ARGS *args = (glClear_ARGS *)&unpacked->args; \
    glClear(args->mask);; \
} while(0)
void glClear(glClear_ARG_EXPAND);
packed_call_t *pack_glClear(glClear_PACKED *_dst glClear_ARG_EXPAND_TAIL);
typedef void (*glClear_PTR)(glClear_ARG_EXPAND);
#endif
#ifndef glClearAccum_RETURN
#define glClearAccum_RETURN void
#define glClearAccum_ARG_NAMES red, green, blue, alpha
#define glClearAccum_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glClearAccum_ARG_NAMES_TAIL , red, green, blue, alpha
#define glClearAccum_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define forward_glClearAccum(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glClearAccum_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearAccum(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glClearAccum(packed, ret_v) do { \
    glClearAccum_PACKED *unpacked = (glClearAccum_PACKED *)packed; \
    glClearAccum_ARGS *args = (glClearAccum_ARGS *)&unpacked->args; \
    glClearAccum(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearAccum(glClearAccum_ARG_EXPAND);
packed_call_t *pack_glClearAccum(glClearAccum_PACKED *_dst glClearAccum_ARG_EXPAND_TAIL);
typedef void (*glClearAccum_PTR)(glClearAccum_ARG_EXPAND);
#endif
#ifndef glClearAccumxOES_RETURN
#define glClearAccumxOES_RETURN void
#define glClearAccumxOES_ARG_NAMES red, green, blue, alpha
#define glClearAccumxOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glClearAccumxOES_ARG_NAMES_TAIL , red, green, blue, alpha
#define glClearAccumxOES_ARG_EXPAND_TAIL , GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define forward_glClearAccumxOES(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glClearAccumxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearAccumxOES(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glClearAccumxOES(packed, ret_v) do { \
    glClearAccumxOES_PACKED *unpacked = (glClearAccumxOES_PACKED *)packed; \
    glClearAccumxOES_ARGS *args = (glClearAccumxOES_ARGS *)&unpacked->args; \
    glClearAccumxOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearAccumxOES(glClearAccumxOES_ARG_EXPAND);
packed_call_t *pack_glClearAccumxOES(glClearAccumxOES_PACKED *_dst glClearAccumxOES_ARG_EXPAND_TAIL);
typedef void (*glClearAccumxOES_PTR)(glClearAccumxOES_ARG_EXPAND);
#endif
#ifndef glClearBufferData_RETURN
#define glClearBufferData_RETURN void
#define glClearBufferData_ARG_NAMES target, internalformat, format, type, data
#define glClearBufferData_ARG_EXPAND GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data
#define glClearBufferData_ARG_NAMES_TAIL , target, internalformat, format, type, data
#define glClearBufferData_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data
#define forward_glClearBufferData(_target, _internalformat, _format, _type, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glClearBufferData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearBufferData(dst, _target, _internalformat, _format, _type, _data), NULL); \
    });
#define call_glClearBufferData(packed, ret_v) do { \
    glClearBufferData_PACKED *unpacked = (glClearBufferData_PACKED *)packed; \
    glClearBufferData_ARGS *args = (glClearBufferData_ARGS *)&unpacked->args; \
    glClearBufferData(args->target, args->internalformat, args->format, args->type, args->data);; \
} while(0)
void glClearBufferData(glClearBufferData_ARG_EXPAND);
packed_call_t *pack_glClearBufferData(glClearBufferData_PACKED *_dst glClearBufferData_ARG_EXPAND_TAIL);
typedef void (*glClearBufferData_PTR)(glClearBufferData_ARG_EXPAND);
#endif
#ifndef glClearBufferSubData_RETURN
#define glClearBufferSubData_RETURN void
#define glClearBufferSubData_ARG_NAMES target, internalformat, offset, size, format, type, data
#define glClearBufferSubData_ARG_EXPAND GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data
#define glClearBufferSubData_ARG_NAMES_TAIL , target, internalformat, offset, size, format, type, data
#define glClearBufferSubData_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data
#define forward_glClearBufferSubData(_target, _internalformat, _offset, _size, _format, _type, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glClearBufferSubData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearBufferSubData(dst, _target, _internalformat, _offset, _size, _format, _type, _data), NULL); \
    });
#define call_glClearBufferSubData(packed, ret_v) do { \
    glClearBufferSubData_PACKED *unpacked = (glClearBufferSubData_PACKED *)packed; \
    glClearBufferSubData_ARGS *args = (glClearBufferSubData_ARGS *)&unpacked->args; \
    glClearBufferSubData(args->target, args->internalformat, args->offset, args->size, args->format, args->type, args->data);; \
} while(0)
void glClearBufferSubData(glClearBufferSubData_ARG_EXPAND);
packed_call_t *pack_glClearBufferSubData(glClearBufferSubData_PACKED *_dst glClearBufferSubData_ARG_EXPAND_TAIL);
typedef void (*glClearBufferSubData_PTR)(glClearBufferSubData_ARG_EXPAND);
#endif
#ifndef glClearBufferfi_RETURN
#define glClearBufferfi_RETURN void
#define glClearBufferfi_ARG_NAMES buffer, drawbuffer, depth, stencil
#define glClearBufferfi_ARG_EXPAND GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil
#define glClearBufferfi_ARG_NAMES_TAIL , buffer, drawbuffer, depth, stencil
#define glClearBufferfi_ARG_EXPAND_TAIL , GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil
#define forward_glClearBufferfi(_buffer, _drawbuffer, _depth, _stencil) \
    ({ \
        void *dst = remote_dma(sizeof(glClearBufferfi_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearBufferfi(dst, _buffer, _drawbuffer, _depth, _stencil), NULL); \
    });
#define call_glClearBufferfi(packed, ret_v) do { \
    glClearBufferfi_PACKED *unpacked = (glClearBufferfi_PACKED *)packed; \
    glClearBufferfi_ARGS *args = (glClearBufferfi_ARGS *)&unpacked->args; \
    glClearBufferfi(args->buffer, args->drawbuffer, args->depth, args->stencil);; \
} while(0)
void glClearBufferfi(glClearBufferfi_ARG_EXPAND);
packed_call_t *pack_glClearBufferfi(glClearBufferfi_PACKED *_dst glClearBufferfi_ARG_EXPAND_TAIL);
typedef void (*glClearBufferfi_PTR)(glClearBufferfi_ARG_EXPAND);
#endif
#ifndef glClearBufferfv_RETURN
#define glClearBufferfv_RETURN void
#define glClearBufferfv_ARG_NAMES buffer, drawbuffer, value
#define glClearBufferfv_ARG_EXPAND GLenum buffer, GLint drawbuffer, const GLfloat * value
#define glClearBufferfv_ARG_NAMES_TAIL , buffer, drawbuffer, value
#define glClearBufferfv_ARG_EXPAND_TAIL , GLenum buffer, GLint drawbuffer, const GLfloat * value
#define forward_glClearBufferfv(_buffer, _drawbuffer, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glClearBufferfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearBufferfv(dst, _buffer, _drawbuffer, _value), NULL); \
    });
#define call_glClearBufferfv(packed, ret_v) do { \
    glClearBufferfv_PACKED *unpacked = (glClearBufferfv_PACKED *)packed; \
    glClearBufferfv_ARGS *args = (glClearBufferfv_ARGS *)&unpacked->args; \
    glClearBufferfv(args->buffer, args->drawbuffer, args->value);; \
} while(0)
void glClearBufferfv(glClearBufferfv_ARG_EXPAND);
packed_call_t *pack_glClearBufferfv(glClearBufferfv_PACKED *_dst glClearBufferfv_ARG_EXPAND_TAIL);
typedef void (*glClearBufferfv_PTR)(glClearBufferfv_ARG_EXPAND);
#endif
#ifndef glClearBufferiv_RETURN
#define glClearBufferiv_RETURN void
#define glClearBufferiv_ARG_NAMES buffer, drawbuffer, value
#define glClearBufferiv_ARG_EXPAND GLenum buffer, GLint drawbuffer, const GLint * value
#define glClearBufferiv_ARG_NAMES_TAIL , buffer, drawbuffer, value
#define glClearBufferiv_ARG_EXPAND_TAIL , GLenum buffer, GLint drawbuffer, const GLint * value
#define forward_glClearBufferiv(_buffer, _drawbuffer, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glClearBufferiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearBufferiv(dst, _buffer, _drawbuffer, _value), NULL); \
    });
#define call_glClearBufferiv(packed, ret_v) do { \
    glClearBufferiv_PACKED *unpacked = (glClearBufferiv_PACKED *)packed; \
    glClearBufferiv_ARGS *args = (glClearBufferiv_ARGS *)&unpacked->args; \
    glClearBufferiv(args->buffer, args->drawbuffer, args->value);; \
} while(0)
void glClearBufferiv(glClearBufferiv_ARG_EXPAND);
packed_call_t *pack_glClearBufferiv(glClearBufferiv_PACKED *_dst glClearBufferiv_ARG_EXPAND_TAIL);
typedef void (*glClearBufferiv_PTR)(glClearBufferiv_ARG_EXPAND);
#endif
#ifndef glClearBufferuiv_RETURN
#define glClearBufferuiv_RETURN void
#define glClearBufferuiv_ARG_NAMES buffer, drawbuffer, value
#define glClearBufferuiv_ARG_EXPAND GLenum buffer, GLint drawbuffer, const GLuint * value
#define glClearBufferuiv_ARG_NAMES_TAIL , buffer, drawbuffer, value
#define glClearBufferuiv_ARG_EXPAND_TAIL , GLenum buffer, GLint drawbuffer, const GLuint * value
#define forward_glClearBufferuiv(_buffer, _drawbuffer, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glClearBufferuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearBufferuiv(dst, _buffer, _drawbuffer, _value), NULL); \
    });
#define call_glClearBufferuiv(packed, ret_v) do { \
    glClearBufferuiv_PACKED *unpacked = (glClearBufferuiv_PACKED *)packed; \
    glClearBufferuiv_ARGS *args = (glClearBufferuiv_ARGS *)&unpacked->args; \
    glClearBufferuiv(args->buffer, args->drawbuffer, args->value);; \
} while(0)
void glClearBufferuiv(glClearBufferuiv_ARG_EXPAND);
packed_call_t *pack_glClearBufferuiv(glClearBufferuiv_PACKED *_dst glClearBufferuiv_ARG_EXPAND_TAIL);
typedef void (*glClearBufferuiv_PTR)(glClearBufferuiv_ARG_EXPAND);
#endif
#ifndef glClearColor_RETURN
#define glClearColor_RETURN void
#define glClearColor_ARG_NAMES red, green, blue, alpha
#define glClearColor_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glClearColor_ARG_NAMES_TAIL , red, green, blue, alpha
#define glClearColor_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define forward_glClearColor(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glClearColor_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearColor(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glClearColor(packed, ret_v) do { \
    glClearColor_PACKED *unpacked = (glClearColor_PACKED *)packed; \
    glClearColor_ARGS *args = (glClearColor_ARGS *)&unpacked->args; \
    glClearColor(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColor(glClearColor_ARG_EXPAND);
packed_call_t *pack_glClearColor(glClearColor_PACKED *_dst glClearColor_ARG_EXPAND_TAIL);
typedef void (*glClearColor_PTR)(glClearColor_ARG_EXPAND);
#endif
#ifndef glClearColorIiEXT_RETURN
#define glClearColorIiEXT_RETURN void
#define glClearColorIiEXT_ARG_NAMES red, green, blue, alpha
#define glClearColorIiEXT_ARG_EXPAND GLint red, GLint green, GLint blue, GLint alpha
#define glClearColorIiEXT_ARG_NAMES_TAIL , red, green, blue, alpha
#define glClearColorIiEXT_ARG_EXPAND_TAIL , GLint red, GLint green, GLint blue, GLint alpha
#define forward_glClearColorIiEXT(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glClearColorIiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearColorIiEXT(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glClearColorIiEXT(packed, ret_v) do { \
    glClearColorIiEXT_PACKED *unpacked = (glClearColorIiEXT_PACKED *)packed; \
    glClearColorIiEXT_ARGS *args = (glClearColorIiEXT_ARGS *)&unpacked->args; \
    glClearColorIiEXT(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColorIiEXT(glClearColorIiEXT_ARG_EXPAND);
packed_call_t *pack_glClearColorIiEXT(glClearColorIiEXT_PACKED *_dst glClearColorIiEXT_ARG_EXPAND_TAIL);
typedef void (*glClearColorIiEXT_PTR)(glClearColorIiEXT_ARG_EXPAND);
#endif
#ifndef glClearColorIuiEXT_RETURN
#define glClearColorIuiEXT_RETURN void
#define glClearColorIuiEXT_ARG_NAMES red, green, blue, alpha
#define glClearColorIuiEXT_ARG_EXPAND GLuint red, GLuint green, GLuint blue, GLuint alpha
#define glClearColorIuiEXT_ARG_NAMES_TAIL , red, green, blue, alpha
#define glClearColorIuiEXT_ARG_EXPAND_TAIL , GLuint red, GLuint green, GLuint blue, GLuint alpha
#define forward_glClearColorIuiEXT(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glClearColorIuiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearColorIuiEXT(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glClearColorIuiEXT(packed, ret_v) do { \
    glClearColorIuiEXT_PACKED *unpacked = (glClearColorIuiEXT_PACKED *)packed; \
    glClearColorIuiEXT_ARGS *args = (glClearColorIuiEXT_ARGS *)&unpacked->args; \
    glClearColorIuiEXT(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColorIuiEXT(glClearColorIuiEXT_ARG_EXPAND);
packed_call_t *pack_glClearColorIuiEXT(glClearColorIuiEXT_PACKED *_dst glClearColorIuiEXT_ARG_EXPAND_TAIL);
typedef void (*glClearColorIuiEXT_PTR)(glClearColorIuiEXT_ARG_EXPAND);
#endif
#ifndef glClearColorxOES_RETURN
#define glClearColorxOES_RETURN void
#define glClearColorxOES_ARG_NAMES red, green, blue, alpha
#define glClearColorxOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glClearColorxOES_ARG_NAMES_TAIL , red, green, blue, alpha
#define glClearColorxOES_ARG_EXPAND_TAIL , GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define forward_glClearColorxOES(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glClearColorxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearColorxOES(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glClearColorxOES(packed, ret_v) do { \
    glClearColorxOES_PACKED *unpacked = (glClearColorxOES_PACKED *)packed; \
    glClearColorxOES_ARGS *args = (glClearColorxOES_ARGS *)&unpacked->args; \
    glClearColorxOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColorxOES(glClearColorxOES_ARG_EXPAND);
packed_call_t *pack_glClearColorxOES(glClearColorxOES_PACKED *_dst glClearColorxOES_ARG_EXPAND_TAIL);
typedef void (*glClearColorxOES_PTR)(glClearColorxOES_ARG_EXPAND);
#endif
#ifndef glClearDepth_RETURN
#define glClearDepth_RETURN void
#define glClearDepth_ARG_NAMES depth
#define glClearDepth_ARG_EXPAND GLdouble depth
#define glClearDepth_ARG_NAMES_TAIL , depth
#define glClearDepth_ARG_EXPAND_TAIL , GLdouble depth
#define forward_glClearDepth(_depth) \
    ({ \
        void *dst = remote_dma(sizeof(glClearDepth_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearDepth(dst, _depth), NULL); \
    });
#define call_glClearDepth(packed, ret_v) do { \
    glClearDepth_PACKED *unpacked = (glClearDepth_PACKED *)packed; \
    glClearDepth_ARGS *args = (glClearDepth_ARGS *)&unpacked->args; \
    glClearDepth(args->depth);; \
} while(0)
void glClearDepth(glClearDepth_ARG_EXPAND);
packed_call_t *pack_glClearDepth(glClearDepth_PACKED *_dst glClearDepth_ARG_EXPAND_TAIL);
typedef void (*glClearDepth_PTR)(glClearDepth_ARG_EXPAND);
#endif
#ifndef glClearDepthdNV_RETURN
#define glClearDepthdNV_RETURN void
#define glClearDepthdNV_ARG_NAMES depth
#define glClearDepthdNV_ARG_EXPAND GLdouble depth
#define glClearDepthdNV_ARG_NAMES_TAIL , depth
#define glClearDepthdNV_ARG_EXPAND_TAIL , GLdouble depth
#define forward_glClearDepthdNV(_depth) \
    ({ \
        void *dst = remote_dma(sizeof(glClearDepthdNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearDepthdNV(dst, _depth), NULL); \
    });
#define call_glClearDepthdNV(packed, ret_v) do { \
    glClearDepthdNV_PACKED *unpacked = (glClearDepthdNV_PACKED *)packed; \
    glClearDepthdNV_ARGS *args = (glClearDepthdNV_ARGS *)&unpacked->args; \
    glClearDepthdNV(args->depth);; \
} while(0)
void glClearDepthdNV(glClearDepthdNV_ARG_EXPAND);
packed_call_t *pack_glClearDepthdNV(glClearDepthdNV_PACKED *_dst glClearDepthdNV_ARG_EXPAND_TAIL);
typedef void (*glClearDepthdNV_PTR)(glClearDepthdNV_ARG_EXPAND);
#endif
#ifndef glClearDepthf_RETURN
#define glClearDepthf_RETURN void
#define glClearDepthf_ARG_NAMES depth
#define glClearDepthf_ARG_EXPAND GLfloat depth
#define glClearDepthf_ARG_NAMES_TAIL , depth
#define glClearDepthf_ARG_EXPAND_TAIL , GLfloat depth
#define forward_glClearDepthf(_depth) \
    ({ \
        void *dst = remote_dma(sizeof(glClearDepthf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearDepthf(dst, _depth), NULL); \
    });
#define call_glClearDepthf(packed, ret_v) do { \
    glClearDepthf_PACKED *unpacked = (glClearDepthf_PACKED *)packed; \
    glClearDepthf_ARGS *args = (glClearDepthf_ARGS *)&unpacked->args; \
    glClearDepthf(args->depth);; \
} while(0)
void glClearDepthf(glClearDepthf_ARG_EXPAND);
packed_call_t *pack_glClearDepthf(glClearDepthf_PACKED *_dst glClearDepthf_ARG_EXPAND_TAIL);
typedef void (*glClearDepthf_PTR)(glClearDepthf_ARG_EXPAND);
#endif
#ifndef glClearDepthfOES_RETURN
#define glClearDepthfOES_RETURN void
#define glClearDepthfOES_ARG_NAMES depth
#define glClearDepthfOES_ARG_EXPAND GLclampf depth
#define glClearDepthfOES_ARG_NAMES_TAIL , depth
#define glClearDepthfOES_ARG_EXPAND_TAIL , GLclampf depth
#define forward_glClearDepthfOES(_depth) \
    ({ \
        void *dst = remote_dma(sizeof(glClearDepthfOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearDepthfOES(dst, _depth), NULL); \
    });
#define call_glClearDepthfOES(packed, ret_v) do { \
    glClearDepthfOES_PACKED *unpacked = (glClearDepthfOES_PACKED *)packed; \
    glClearDepthfOES_ARGS *args = (glClearDepthfOES_ARGS *)&unpacked->args; \
    glClearDepthfOES(args->depth);; \
} while(0)
void glClearDepthfOES(glClearDepthfOES_ARG_EXPAND);
packed_call_t *pack_glClearDepthfOES(glClearDepthfOES_PACKED *_dst glClearDepthfOES_ARG_EXPAND_TAIL);
typedef void (*glClearDepthfOES_PTR)(glClearDepthfOES_ARG_EXPAND);
#endif
#ifndef glClearDepthxOES_RETURN
#define glClearDepthxOES_RETURN void
#define glClearDepthxOES_ARG_NAMES depth
#define glClearDepthxOES_ARG_EXPAND GLfixed depth
#define glClearDepthxOES_ARG_NAMES_TAIL , depth
#define glClearDepthxOES_ARG_EXPAND_TAIL , GLfixed depth
#define forward_glClearDepthxOES(_depth) \
    ({ \
        void *dst = remote_dma(sizeof(glClearDepthxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearDepthxOES(dst, _depth), NULL); \
    });
#define call_glClearDepthxOES(packed, ret_v) do { \
    glClearDepthxOES_PACKED *unpacked = (glClearDepthxOES_PACKED *)packed; \
    glClearDepthxOES_ARGS *args = (glClearDepthxOES_ARGS *)&unpacked->args; \
    glClearDepthxOES(args->depth);; \
} while(0)
void glClearDepthxOES(glClearDepthxOES_ARG_EXPAND);
packed_call_t *pack_glClearDepthxOES(glClearDepthxOES_PACKED *_dst glClearDepthxOES_ARG_EXPAND_TAIL);
typedef void (*glClearDepthxOES_PTR)(glClearDepthxOES_ARG_EXPAND);
#endif
#ifndef glClearIndex_RETURN
#define glClearIndex_RETURN void
#define glClearIndex_ARG_NAMES c
#define glClearIndex_ARG_EXPAND GLfloat c
#define glClearIndex_ARG_NAMES_TAIL , c
#define glClearIndex_ARG_EXPAND_TAIL , GLfloat c
#define forward_glClearIndex(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glClearIndex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearIndex(dst, _c), NULL); \
    });
#define call_glClearIndex(packed, ret_v) do { \
    glClearIndex_PACKED *unpacked = (glClearIndex_PACKED *)packed; \
    glClearIndex_ARGS *args = (glClearIndex_ARGS *)&unpacked->args; \
    glClearIndex(args->c);; \
} while(0)
void glClearIndex(glClearIndex_ARG_EXPAND);
packed_call_t *pack_glClearIndex(glClearIndex_PACKED *_dst glClearIndex_ARG_EXPAND_TAIL);
typedef void (*glClearIndex_PTR)(glClearIndex_ARG_EXPAND);
#endif
#ifndef glClearNamedBufferDataEXT_RETURN
#define glClearNamedBufferDataEXT_RETURN void
#define glClearNamedBufferDataEXT_ARG_NAMES buffer, internalformat, format, type, data
#define glClearNamedBufferDataEXT_ARG_EXPAND GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data
#define glClearNamedBufferDataEXT_ARG_NAMES_TAIL , buffer, internalformat, format, type, data
#define glClearNamedBufferDataEXT_ARG_EXPAND_TAIL , GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data
#define forward_glClearNamedBufferDataEXT(_buffer, _internalformat, _format, _type, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glClearNamedBufferDataEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearNamedBufferDataEXT(dst, _buffer, _internalformat, _format, _type, _data), NULL); \
    });
#define call_glClearNamedBufferDataEXT(packed, ret_v) do { \
    glClearNamedBufferDataEXT_PACKED *unpacked = (glClearNamedBufferDataEXT_PACKED *)packed; \
    glClearNamedBufferDataEXT_ARGS *args = (glClearNamedBufferDataEXT_ARGS *)&unpacked->args; \
    glClearNamedBufferDataEXT(args->buffer, args->internalformat, args->format, args->type, args->data);; \
} while(0)
void glClearNamedBufferDataEXT(glClearNamedBufferDataEXT_ARG_EXPAND);
packed_call_t *pack_glClearNamedBufferDataEXT(glClearNamedBufferDataEXT_PACKED *_dst glClearNamedBufferDataEXT_ARG_EXPAND_TAIL);
typedef void (*glClearNamedBufferDataEXT_PTR)(glClearNamedBufferDataEXT_ARG_EXPAND);
#endif
#ifndef glClearNamedBufferSubDataEXT_RETURN
#define glClearNamedBufferSubDataEXT_RETURN void
#define glClearNamedBufferSubDataEXT_ARG_NAMES buffer, internalformat, format, type, offset, size, data
#define glClearNamedBufferSubDataEXT_ARG_EXPAND GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void * data
#define glClearNamedBufferSubDataEXT_ARG_NAMES_TAIL , buffer, internalformat, format, type, offset, size, data
#define glClearNamedBufferSubDataEXT_ARG_EXPAND_TAIL , GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void * data
#define forward_glClearNamedBufferSubDataEXT(_buffer, _internalformat, _format, _type, _offset, _size, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glClearNamedBufferSubDataEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearNamedBufferSubDataEXT(dst, _buffer, _internalformat, _format, _type, _offset, _size, _data), NULL); \
    });
#define call_glClearNamedBufferSubDataEXT(packed, ret_v) do { \
    glClearNamedBufferSubDataEXT_PACKED *unpacked = (glClearNamedBufferSubDataEXT_PACKED *)packed; \
    glClearNamedBufferSubDataEXT_ARGS *args = (glClearNamedBufferSubDataEXT_ARGS *)&unpacked->args; \
    glClearNamedBufferSubDataEXT(args->buffer, args->internalformat, args->format, args->type, args->offset, args->size, args->data);; \
} while(0)
void glClearNamedBufferSubDataEXT(glClearNamedBufferSubDataEXT_ARG_EXPAND);
packed_call_t *pack_glClearNamedBufferSubDataEXT(glClearNamedBufferSubDataEXT_PACKED *_dst glClearNamedBufferSubDataEXT_ARG_EXPAND_TAIL);
typedef void (*glClearNamedBufferSubDataEXT_PTR)(glClearNamedBufferSubDataEXT_ARG_EXPAND);
#endif
#ifndef glClearStencil_RETURN
#define glClearStencil_RETURN void
#define glClearStencil_ARG_NAMES s
#define glClearStencil_ARG_EXPAND GLint s
#define glClearStencil_ARG_NAMES_TAIL , s
#define glClearStencil_ARG_EXPAND_TAIL , GLint s
#define forward_glClearStencil(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glClearStencil_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClearStencil(dst, _s), NULL); \
    });
#define call_glClearStencil(packed, ret_v) do { \
    glClearStencil_PACKED *unpacked = (glClearStencil_PACKED *)packed; \
    glClearStencil_ARGS *args = (glClearStencil_ARGS *)&unpacked->args; \
    glClearStencil(args->s);; \
} while(0)
void glClearStencil(glClearStencil_ARG_EXPAND);
packed_call_t *pack_glClearStencil(glClearStencil_PACKED *_dst glClearStencil_ARG_EXPAND_TAIL);
typedef void (*glClearStencil_PTR)(glClearStencil_ARG_EXPAND);
#endif
#ifndef glClientActiveTexture_RETURN
#define glClientActiveTexture_RETURN void
#define glClientActiveTexture_ARG_NAMES texture
#define glClientActiveTexture_ARG_EXPAND GLenum texture
#define glClientActiveTexture_ARG_NAMES_TAIL , texture
#define glClientActiveTexture_ARG_EXPAND_TAIL , GLenum texture
#define forward_glClientActiveTexture(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glClientActiveTexture_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClientActiveTexture(dst, _texture), NULL); \
    });
#define call_glClientActiveTexture(packed, ret_v) do { \
    glClientActiveTexture_PACKED *unpacked = (glClientActiveTexture_PACKED *)packed; \
    glClientActiveTexture_ARGS *args = (glClientActiveTexture_ARGS *)&unpacked->args; \
    glClientActiveTexture(args->texture);; \
} while(0)
void glClientActiveTexture(glClientActiveTexture_ARG_EXPAND);
packed_call_t *pack_glClientActiveTexture(glClientActiveTexture_PACKED *_dst glClientActiveTexture_ARG_EXPAND_TAIL);
typedef void (*glClientActiveTexture_PTR)(glClientActiveTexture_ARG_EXPAND);
#endif
#ifndef glClientActiveTextureARB_RETURN
#define glClientActiveTextureARB_RETURN void
#define glClientActiveTextureARB_ARG_NAMES texture
#define glClientActiveTextureARB_ARG_EXPAND GLenum texture
#define glClientActiveTextureARB_ARG_NAMES_TAIL , texture
#define glClientActiveTextureARB_ARG_EXPAND_TAIL , GLenum texture
#define forward_glClientActiveTextureARB(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glClientActiveTextureARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClientActiveTextureARB(dst, _texture), NULL); \
    });
#define call_glClientActiveTextureARB(packed, ret_v) do { \
    glClientActiveTextureARB_PACKED *unpacked = (glClientActiveTextureARB_PACKED *)packed; \
    glClientActiveTextureARB_ARGS *args = (glClientActiveTextureARB_ARGS *)&unpacked->args; \
    glClientActiveTextureARB(args->texture);; \
} while(0)
void glClientActiveTextureARB(glClientActiveTextureARB_ARG_EXPAND);
packed_call_t *pack_glClientActiveTextureARB(glClientActiveTextureARB_PACKED *_dst glClientActiveTextureARB_ARG_EXPAND_TAIL);
typedef void (*glClientActiveTextureARB_PTR)(glClientActiveTextureARB_ARG_EXPAND);
#endif
#ifndef glClientActiveVertexStreamATI_RETURN
#define glClientActiveVertexStreamATI_RETURN void
#define glClientActiveVertexStreamATI_ARG_NAMES stream
#define glClientActiveVertexStreamATI_ARG_EXPAND GLenum stream
#define glClientActiveVertexStreamATI_ARG_NAMES_TAIL , stream
#define glClientActiveVertexStreamATI_ARG_EXPAND_TAIL , GLenum stream
#define forward_glClientActiveVertexStreamATI(_stream) \
    ({ \
        void *dst = remote_dma(sizeof(glClientActiveVertexStreamATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClientActiveVertexStreamATI(dst, _stream), NULL); \
    });
#define call_glClientActiveVertexStreamATI(packed, ret_v) do { \
    glClientActiveVertexStreamATI_PACKED *unpacked = (glClientActiveVertexStreamATI_PACKED *)packed; \
    glClientActiveVertexStreamATI_ARGS *args = (glClientActiveVertexStreamATI_ARGS *)&unpacked->args; \
    glClientActiveVertexStreamATI(args->stream);; \
} while(0)
void glClientActiveVertexStreamATI(glClientActiveVertexStreamATI_ARG_EXPAND);
packed_call_t *pack_glClientActiveVertexStreamATI(glClientActiveVertexStreamATI_PACKED *_dst glClientActiveVertexStreamATI_ARG_EXPAND_TAIL);
typedef void (*glClientActiveVertexStreamATI_PTR)(glClientActiveVertexStreamATI_ARG_EXPAND);
#endif
#ifndef glClientAttribDefaultEXT_RETURN
#define glClientAttribDefaultEXT_RETURN void
#define glClientAttribDefaultEXT_ARG_NAMES mask
#define glClientAttribDefaultEXT_ARG_EXPAND GLbitfield mask
#define glClientAttribDefaultEXT_ARG_NAMES_TAIL , mask
#define glClientAttribDefaultEXT_ARG_EXPAND_TAIL , GLbitfield mask
#define forward_glClientAttribDefaultEXT(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glClientAttribDefaultEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClientAttribDefaultEXT(dst, _mask), NULL); \
    });
#define call_glClientAttribDefaultEXT(packed, ret_v) do { \
    glClientAttribDefaultEXT_PACKED *unpacked = (glClientAttribDefaultEXT_PACKED *)packed; \
    glClientAttribDefaultEXT_ARGS *args = (glClientAttribDefaultEXT_ARGS *)&unpacked->args; \
    glClientAttribDefaultEXT(args->mask);; \
} while(0)
void glClientAttribDefaultEXT(glClientAttribDefaultEXT_ARG_EXPAND);
packed_call_t *pack_glClientAttribDefaultEXT(glClientAttribDefaultEXT_PACKED *_dst glClientAttribDefaultEXT_ARG_EXPAND_TAIL);
typedef void (*glClientAttribDefaultEXT_PTR)(glClientAttribDefaultEXT_ARG_EXPAND);
#endif
#ifndef glClientWaitSync_RETURN
#define glClientWaitSync_RETURN GLenum
#define glClientWaitSync_ARG_NAMES sync, flags, timeout
#define glClientWaitSync_ARG_EXPAND GLsync sync, GLbitfield flags, GLuint64 timeout
#define glClientWaitSync_ARG_NAMES_TAIL , sync, flags, timeout
#define glClientWaitSync_ARG_EXPAND_TAIL , GLsync sync, GLbitfield flags, GLuint64 timeout
#define forward_glClientWaitSync(_sync, _flags, _timeout) \
    ({ \
        void *dst = remote_dma(sizeof(glClientWaitSync_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glClientWaitSync(dst, _sync, _flags, _timeout), &ret); \
        ret; \
    });
#define call_glClientWaitSync(packed, ret_v) do { \
    glClientWaitSync_PACKED *unpacked = (glClientWaitSync_PACKED *)packed; \
    glClientWaitSync_ARGS *args = (glClientWaitSync_ARGS *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glClientWaitSync(args->sync, args->flags, args->timeout);; \
    } else { \
        glClientWaitSync(args->sync, args->flags, args->timeout);; \
    } \
} while(0)
GLenum glClientWaitSync(glClientWaitSync_ARG_EXPAND);
packed_call_t *pack_glClientWaitSync(glClientWaitSync_PACKED *_dst glClientWaitSync_ARG_EXPAND_TAIL);
typedef GLenum (*glClientWaitSync_PTR)(glClientWaitSync_ARG_EXPAND);
#endif
#ifndef glClipPlane_RETURN
#define glClipPlane_RETURN void
#define glClipPlane_ARG_NAMES plane, equation
#define glClipPlane_ARG_EXPAND GLenum plane, const GLdouble * equation
#define glClipPlane_ARG_NAMES_TAIL , plane, equation
#define glClipPlane_ARG_EXPAND_TAIL , GLenum plane, const GLdouble * equation
#define forward_glClipPlane(_plane, _equation) \
    ({ \
        void *dst = remote_dma(sizeof(glClipPlane_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClipPlane(dst, _plane, _equation), NULL); \
    });
#define call_glClipPlane(packed, ret_v) do { \
    glClipPlane_PACKED *unpacked = (glClipPlane_PACKED *)packed; \
    glClipPlane_ARGS *args = (glClipPlane_ARGS *)&unpacked->args; \
    glClipPlane(args->plane, args->equation);; \
} while(0)
void glClipPlane(glClipPlane_ARG_EXPAND);
packed_call_t *pack_glClipPlane(glClipPlane_PACKED *_dst glClipPlane_ARG_EXPAND_TAIL);
typedef void (*glClipPlane_PTR)(glClipPlane_ARG_EXPAND);
#endif
#ifndef glClipPlanefOES_RETURN
#define glClipPlanefOES_RETURN void
#define glClipPlanefOES_ARG_NAMES plane, equation
#define glClipPlanefOES_ARG_EXPAND GLenum plane, const GLfloat * equation
#define glClipPlanefOES_ARG_NAMES_TAIL , plane, equation
#define glClipPlanefOES_ARG_EXPAND_TAIL , GLenum plane, const GLfloat * equation
#define forward_glClipPlanefOES(_plane, _equation) \
    ({ \
        void *dst = remote_dma(sizeof(glClipPlanefOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClipPlanefOES(dst, _plane, _equation), NULL); \
    });
#define call_glClipPlanefOES(packed, ret_v) do { \
    glClipPlanefOES_PACKED *unpacked = (glClipPlanefOES_PACKED *)packed; \
    glClipPlanefOES_ARGS *args = (glClipPlanefOES_ARGS *)&unpacked->args; \
    glClipPlanefOES(args->plane, args->equation);; \
} while(0)
void glClipPlanefOES(glClipPlanefOES_ARG_EXPAND);
packed_call_t *pack_glClipPlanefOES(glClipPlanefOES_PACKED *_dst glClipPlanefOES_ARG_EXPAND_TAIL);
typedef void (*glClipPlanefOES_PTR)(glClipPlanefOES_ARG_EXPAND);
#endif
#ifndef glClipPlanexOES_RETURN
#define glClipPlanexOES_RETURN void
#define glClipPlanexOES_ARG_NAMES plane, equation
#define glClipPlanexOES_ARG_EXPAND GLenum plane, const GLfixed * equation
#define glClipPlanexOES_ARG_NAMES_TAIL , plane, equation
#define glClipPlanexOES_ARG_EXPAND_TAIL , GLenum plane, const GLfixed * equation
#define forward_glClipPlanexOES(_plane, _equation) \
    ({ \
        void *dst = remote_dma(sizeof(glClipPlanexOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glClipPlanexOES(dst, _plane, _equation), NULL); \
    });
#define call_glClipPlanexOES(packed, ret_v) do { \
    glClipPlanexOES_PACKED *unpacked = (glClipPlanexOES_PACKED *)packed; \
    glClipPlanexOES_ARGS *args = (glClipPlanexOES_ARGS *)&unpacked->args; \
    glClipPlanexOES(args->plane, args->equation);; \
} while(0)
void glClipPlanexOES(glClipPlanexOES_ARG_EXPAND);
packed_call_t *pack_glClipPlanexOES(glClipPlanexOES_PACKED *_dst glClipPlanexOES_ARG_EXPAND_TAIL);
typedef void (*glClipPlanexOES_PTR)(glClipPlanexOES_ARG_EXPAND);
#endif
#ifndef glColor3b_RETURN
#define glColor3b_RETURN void
#define glColor3b_ARG_NAMES red, green, blue
#define glColor3b_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue
#define glColor3b_ARG_NAMES_TAIL , red, green, blue
#define glColor3b_ARG_EXPAND_TAIL , GLbyte red, GLbyte green, GLbyte blue
#define forward_glColor3b(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3b_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3b(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3b(packed, ret_v) do { \
    glColor3b_PACKED *unpacked = (glColor3b_PACKED *)packed; \
    glColor3b_ARGS *args = (glColor3b_ARGS *)&unpacked->args; \
    glColor3b(args->red, args->green, args->blue);; \
} while(0)
void glColor3b(glColor3b_ARG_EXPAND);
packed_call_t *pack_glColor3b(glColor3b_PACKED *_dst glColor3b_ARG_EXPAND_TAIL);
typedef void (*glColor3b_PTR)(glColor3b_ARG_EXPAND);
#endif
#ifndef glColor3bv_RETURN
#define glColor3bv_RETURN void
#define glColor3bv_ARG_NAMES v
#define glColor3bv_ARG_EXPAND const GLbyte * v
#define glColor3bv_ARG_NAMES_TAIL , v
#define glColor3bv_ARG_EXPAND_TAIL , const GLbyte * v
#define forward_glColor3bv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3bv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3bv(dst, _v), NULL); \
    });
#define call_glColor3bv(packed, ret_v) do { \
    glColor3bv_PACKED *unpacked = (glColor3bv_PACKED *)packed; \
    glColor3bv_ARGS *args = (glColor3bv_ARGS *)&unpacked->args; \
    glColor3bv(args->v);; \
} while(0)
void glColor3bv(glColor3bv_ARG_EXPAND);
packed_call_t *pack_glColor3bv(glColor3bv_PACKED *_dst glColor3bv_ARG_EXPAND_TAIL);
typedef void (*glColor3bv_PTR)(glColor3bv_ARG_EXPAND);
#endif
#ifndef glColor3d_RETURN
#define glColor3d_RETURN void
#define glColor3d_ARG_NAMES red, green, blue
#define glColor3d_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue
#define glColor3d_ARG_NAMES_TAIL , red, green, blue
#define glColor3d_ARG_EXPAND_TAIL , GLdouble red, GLdouble green, GLdouble blue
#define forward_glColor3d(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3d(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3d(packed, ret_v) do { \
    glColor3d_PACKED *unpacked = (glColor3d_PACKED *)packed; \
    glColor3d_ARGS *args = (glColor3d_ARGS *)&unpacked->args; \
    glColor3d(args->red, args->green, args->blue);; \
} while(0)
void glColor3d(glColor3d_ARG_EXPAND);
packed_call_t *pack_glColor3d(glColor3d_PACKED *_dst glColor3d_ARG_EXPAND_TAIL);
typedef void (*glColor3d_PTR)(glColor3d_ARG_EXPAND);
#endif
#ifndef glColor3dv_RETURN
#define glColor3dv_RETURN void
#define glColor3dv_ARG_NAMES v
#define glColor3dv_ARG_EXPAND const GLdouble * v
#define glColor3dv_ARG_NAMES_TAIL , v
#define glColor3dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glColor3dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3dv(dst, _v), NULL); \
    });
#define call_glColor3dv(packed, ret_v) do { \
    glColor3dv_PACKED *unpacked = (glColor3dv_PACKED *)packed; \
    glColor3dv_ARGS *args = (glColor3dv_ARGS *)&unpacked->args; \
    glColor3dv(args->v);; \
} while(0)
void glColor3dv(glColor3dv_ARG_EXPAND);
packed_call_t *pack_glColor3dv(glColor3dv_PACKED *_dst glColor3dv_ARG_EXPAND_TAIL);
typedef void (*glColor3dv_PTR)(glColor3dv_ARG_EXPAND);
#endif
#ifndef glColor3f_RETURN
#define glColor3f_RETURN void
#define glColor3f_ARG_NAMES red, green, blue
#define glColor3f_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue
#define glColor3f_ARG_NAMES_TAIL , red, green, blue
#define glColor3f_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue
#define forward_glColor3f(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3f(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3f(packed, ret_v) do { \
    glColor3f_PACKED *unpacked = (glColor3f_PACKED *)packed; \
    glColor3f_ARGS *args = (glColor3f_ARGS *)&unpacked->args; \
    glColor3f(args->red, args->green, args->blue);; \
} while(0)
void glColor3f(glColor3f_ARG_EXPAND);
packed_call_t *pack_glColor3f(glColor3f_PACKED *_dst glColor3f_ARG_EXPAND_TAIL);
typedef void (*glColor3f_PTR)(glColor3f_ARG_EXPAND);
#endif
#ifndef glColor3fVertex3fSUN_RETURN
#define glColor3fVertex3fSUN_RETURN void
#define glColor3fVertex3fSUN_ARG_NAMES r, g, b, x, y, z
#define glColor3fVertex3fSUN_ARG_EXPAND GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define glColor3fVertex3fSUN_ARG_NAMES_TAIL , r, g, b, x, y, z
#define glColor3fVertex3fSUN_ARG_EXPAND_TAIL , GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define forward_glColor3fVertex3fSUN(_r, _g, _b, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3fVertex3fSUN(dst, _r, _g, _b, _x, _y, _z), NULL); \
    });
#define call_glColor3fVertex3fSUN(packed, ret_v) do { \
    glColor3fVertex3fSUN_PACKED *unpacked = (glColor3fVertex3fSUN_PACKED *)packed; \
    glColor3fVertex3fSUN_ARGS *args = (glColor3fVertex3fSUN_ARGS *)&unpacked->args; \
    glColor3fVertex3fSUN(args->r, args->g, args->b, args->x, args->y, args->z);; \
} while(0)
void glColor3fVertex3fSUN(glColor3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glColor3fVertex3fSUN(glColor3fVertex3fSUN_PACKED *_dst glColor3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glColor3fVertex3fSUN_PTR)(glColor3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glColor3fVertex3fvSUN_RETURN
#define glColor3fVertex3fvSUN_RETURN void
#define glColor3fVertex3fvSUN_ARG_NAMES c, v
#define glColor3fVertex3fvSUN_ARG_EXPAND const GLfloat * c, const GLfloat * v
#define glColor3fVertex3fvSUN_ARG_NAMES_TAIL , c, v
#define glColor3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * c, const GLfloat * v
#define forward_glColor3fVertex3fvSUN(_c, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3fVertex3fvSUN(dst, _c, _v), NULL); \
    });
#define call_glColor3fVertex3fvSUN(packed, ret_v) do { \
    glColor3fVertex3fvSUN_PACKED *unpacked = (glColor3fVertex3fvSUN_PACKED *)packed; \
    glColor3fVertex3fvSUN_ARGS *args = (glColor3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glColor3fVertex3fvSUN(args->c, args->v);; \
} while(0)
void glColor3fVertex3fvSUN(glColor3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glColor3fVertex3fvSUN(glColor3fVertex3fvSUN_PACKED *_dst glColor3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glColor3fVertex3fvSUN_PTR)(glColor3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glColor3fv_RETURN
#define glColor3fv_RETURN void
#define glColor3fv_ARG_NAMES v
#define glColor3fv_ARG_EXPAND const GLfloat * v
#define glColor3fv_ARG_NAMES_TAIL , v
#define glColor3fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glColor3fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3fv(dst, _v), NULL); \
    });
#define call_glColor3fv(packed, ret_v) do { \
    glColor3fv_PACKED *unpacked = (glColor3fv_PACKED *)packed; \
    glColor3fv_ARGS *args = (glColor3fv_ARGS *)&unpacked->args; \
    glColor3fv(args->v);; \
} while(0)
void glColor3fv(glColor3fv_ARG_EXPAND);
packed_call_t *pack_glColor3fv(glColor3fv_PACKED *_dst glColor3fv_ARG_EXPAND_TAIL);
typedef void (*glColor3fv_PTR)(glColor3fv_ARG_EXPAND);
#endif
#ifndef glColor3hNV_RETURN
#define glColor3hNV_RETURN void
#define glColor3hNV_ARG_NAMES red, green, blue
#define glColor3hNV_ARG_EXPAND GLhalfNV red, GLhalfNV green, GLhalfNV blue
#define glColor3hNV_ARG_NAMES_TAIL , red, green, blue
#define glColor3hNV_ARG_EXPAND_TAIL , GLhalfNV red, GLhalfNV green, GLhalfNV blue
#define forward_glColor3hNV(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3hNV(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3hNV(packed, ret_v) do { \
    glColor3hNV_PACKED *unpacked = (glColor3hNV_PACKED *)packed; \
    glColor3hNV_ARGS *args = (glColor3hNV_ARGS *)&unpacked->args; \
    glColor3hNV(args->red, args->green, args->blue);; \
} while(0)
void glColor3hNV(glColor3hNV_ARG_EXPAND);
packed_call_t *pack_glColor3hNV(glColor3hNV_PACKED *_dst glColor3hNV_ARG_EXPAND_TAIL);
typedef void (*glColor3hNV_PTR)(glColor3hNV_ARG_EXPAND);
#endif
#ifndef glColor3hvNV_RETURN
#define glColor3hvNV_RETURN void
#define glColor3hvNV_ARG_NAMES v
#define glColor3hvNV_ARG_EXPAND const GLhalfNV * v
#define glColor3hvNV_ARG_NAMES_TAIL , v
#define glColor3hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glColor3hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3hvNV(dst, _v), NULL); \
    });
#define call_glColor3hvNV(packed, ret_v) do { \
    glColor3hvNV_PACKED *unpacked = (glColor3hvNV_PACKED *)packed; \
    glColor3hvNV_ARGS *args = (glColor3hvNV_ARGS *)&unpacked->args; \
    glColor3hvNV(args->v);; \
} while(0)
void glColor3hvNV(glColor3hvNV_ARG_EXPAND);
packed_call_t *pack_glColor3hvNV(glColor3hvNV_PACKED *_dst glColor3hvNV_ARG_EXPAND_TAIL);
typedef void (*glColor3hvNV_PTR)(glColor3hvNV_ARG_EXPAND);
#endif
#ifndef glColor3i_RETURN
#define glColor3i_RETURN void
#define glColor3i_ARG_NAMES red, green, blue
#define glColor3i_ARG_EXPAND GLint red, GLint green, GLint blue
#define glColor3i_ARG_NAMES_TAIL , red, green, blue
#define glColor3i_ARG_EXPAND_TAIL , GLint red, GLint green, GLint blue
#define forward_glColor3i(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3i(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3i(packed, ret_v) do { \
    glColor3i_PACKED *unpacked = (glColor3i_PACKED *)packed; \
    glColor3i_ARGS *args = (glColor3i_ARGS *)&unpacked->args; \
    glColor3i(args->red, args->green, args->blue);; \
} while(0)
void glColor3i(glColor3i_ARG_EXPAND);
packed_call_t *pack_glColor3i(glColor3i_PACKED *_dst glColor3i_ARG_EXPAND_TAIL);
typedef void (*glColor3i_PTR)(glColor3i_ARG_EXPAND);
#endif
#ifndef glColor3iv_RETURN
#define glColor3iv_RETURN void
#define glColor3iv_ARG_NAMES v
#define glColor3iv_ARG_EXPAND const GLint * v
#define glColor3iv_ARG_NAMES_TAIL , v
#define glColor3iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glColor3iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3iv(dst, _v), NULL); \
    });
#define call_glColor3iv(packed, ret_v) do { \
    glColor3iv_PACKED *unpacked = (glColor3iv_PACKED *)packed; \
    glColor3iv_ARGS *args = (glColor3iv_ARGS *)&unpacked->args; \
    glColor3iv(args->v);; \
} while(0)
void glColor3iv(glColor3iv_ARG_EXPAND);
packed_call_t *pack_glColor3iv(glColor3iv_PACKED *_dst glColor3iv_ARG_EXPAND_TAIL);
typedef void (*glColor3iv_PTR)(glColor3iv_ARG_EXPAND);
#endif
#ifndef glColor3s_RETURN
#define glColor3s_RETURN void
#define glColor3s_ARG_NAMES red, green, blue
#define glColor3s_ARG_EXPAND GLshort red, GLshort green, GLshort blue
#define glColor3s_ARG_NAMES_TAIL , red, green, blue
#define glColor3s_ARG_EXPAND_TAIL , GLshort red, GLshort green, GLshort blue
#define forward_glColor3s(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3s(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3s(packed, ret_v) do { \
    glColor3s_PACKED *unpacked = (glColor3s_PACKED *)packed; \
    glColor3s_ARGS *args = (glColor3s_ARGS *)&unpacked->args; \
    glColor3s(args->red, args->green, args->blue);; \
} while(0)
void glColor3s(glColor3s_ARG_EXPAND);
packed_call_t *pack_glColor3s(glColor3s_PACKED *_dst glColor3s_ARG_EXPAND_TAIL);
typedef void (*glColor3s_PTR)(glColor3s_ARG_EXPAND);
#endif
#ifndef glColor3sv_RETURN
#define glColor3sv_RETURN void
#define glColor3sv_ARG_NAMES v
#define glColor3sv_ARG_EXPAND const GLshort * v
#define glColor3sv_ARG_NAMES_TAIL , v
#define glColor3sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glColor3sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3sv(dst, _v), NULL); \
    });
#define call_glColor3sv(packed, ret_v) do { \
    glColor3sv_PACKED *unpacked = (glColor3sv_PACKED *)packed; \
    glColor3sv_ARGS *args = (glColor3sv_ARGS *)&unpacked->args; \
    glColor3sv(args->v);; \
} while(0)
void glColor3sv(glColor3sv_ARG_EXPAND);
packed_call_t *pack_glColor3sv(glColor3sv_PACKED *_dst glColor3sv_ARG_EXPAND_TAIL);
typedef void (*glColor3sv_PTR)(glColor3sv_ARG_EXPAND);
#endif
#ifndef glColor3ub_RETURN
#define glColor3ub_RETURN void
#define glColor3ub_ARG_NAMES red, green, blue
#define glColor3ub_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue
#define glColor3ub_ARG_NAMES_TAIL , red, green, blue
#define glColor3ub_ARG_EXPAND_TAIL , GLubyte red, GLubyte green, GLubyte blue
#define forward_glColor3ub(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3ub_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3ub(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3ub(packed, ret_v) do { \
    glColor3ub_PACKED *unpacked = (glColor3ub_PACKED *)packed; \
    glColor3ub_ARGS *args = (glColor3ub_ARGS *)&unpacked->args; \
    glColor3ub(args->red, args->green, args->blue);; \
} while(0)
void glColor3ub(glColor3ub_ARG_EXPAND);
packed_call_t *pack_glColor3ub(glColor3ub_PACKED *_dst glColor3ub_ARG_EXPAND_TAIL);
typedef void (*glColor3ub_PTR)(glColor3ub_ARG_EXPAND);
#endif
#ifndef glColor3ubv_RETURN
#define glColor3ubv_RETURN void
#define glColor3ubv_ARG_NAMES v
#define glColor3ubv_ARG_EXPAND const GLubyte * v
#define glColor3ubv_ARG_NAMES_TAIL , v
#define glColor3ubv_ARG_EXPAND_TAIL , const GLubyte * v
#define forward_glColor3ubv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3ubv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3ubv(dst, _v), NULL); \
    });
#define call_glColor3ubv(packed, ret_v) do { \
    glColor3ubv_PACKED *unpacked = (glColor3ubv_PACKED *)packed; \
    glColor3ubv_ARGS *args = (glColor3ubv_ARGS *)&unpacked->args; \
    glColor3ubv(args->v);; \
} while(0)
void glColor3ubv(glColor3ubv_ARG_EXPAND);
packed_call_t *pack_glColor3ubv(glColor3ubv_PACKED *_dst glColor3ubv_ARG_EXPAND_TAIL);
typedef void (*glColor3ubv_PTR)(glColor3ubv_ARG_EXPAND);
#endif
#ifndef glColor3ui_RETURN
#define glColor3ui_RETURN void
#define glColor3ui_ARG_NAMES red, green, blue
#define glColor3ui_ARG_EXPAND GLuint red, GLuint green, GLuint blue
#define glColor3ui_ARG_NAMES_TAIL , red, green, blue
#define glColor3ui_ARG_EXPAND_TAIL , GLuint red, GLuint green, GLuint blue
#define forward_glColor3ui(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3ui(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3ui(packed, ret_v) do { \
    glColor3ui_PACKED *unpacked = (glColor3ui_PACKED *)packed; \
    glColor3ui_ARGS *args = (glColor3ui_ARGS *)&unpacked->args; \
    glColor3ui(args->red, args->green, args->blue);; \
} while(0)
void glColor3ui(glColor3ui_ARG_EXPAND);
packed_call_t *pack_glColor3ui(glColor3ui_PACKED *_dst glColor3ui_ARG_EXPAND_TAIL);
typedef void (*glColor3ui_PTR)(glColor3ui_ARG_EXPAND);
#endif
#ifndef glColor3uiv_RETURN
#define glColor3uiv_RETURN void
#define glColor3uiv_ARG_NAMES v
#define glColor3uiv_ARG_EXPAND const GLuint * v
#define glColor3uiv_ARG_NAMES_TAIL , v
#define glColor3uiv_ARG_EXPAND_TAIL , const GLuint * v
#define forward_glColor3uiv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3uiv(dst, _v), NULL); \
    });
#define call_glColor3uiv(packed, ret_v) do { \
    glColor3uiv_PACKED *unpacked = (glColor3uiv_PACKED *)packed; \
    glColor3uiv_ARGS *args = (glColor3uiv_ARGS *)&unpacked->args; \
    glColor3uiv(args->v);; \
} while(0)
void glColor3uiv(glColor3uiv_ARG_EXPAND);
packed_call_t *pack_glColor3uiv(glColor3uiv_PACKED *_dst glColor3uiv_ARG_EXPAND_TAIL);
typedef void (*glColor3uiv_PTR)(glColor3uiv_ARG_EXPAND);
#endif
#ifndef glColor3us_RETURN
#define glColor3us_RETURN void
#define glColor3us_ARG_NAMES red, green, blue
#define glColor3us_ARG_EXPAND GLushort red, GLushort green, GLushort blue
#define glColor3us_ARG_NAMES_TAIL , red, green, blue
#define glColor3us_ARG_EXPAND_TAIL , GLushort red, GLushort green, GLushort blue
#define forward_glColor3us(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3us_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3us(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3us(packed, ret_v) do { \
    glColor3us_PACKED *unpacked = (glColor3us_PACKED *)packed; \
    glColor3us_ARGS *args = (glColor3us_ARGS *)&unpacked->args; \
    glColor3us(args->red, args->green, args->blue);; \
} while(0)
void glColor3us(glColor3us_ARG_EXPAND);
packed_call_t *pack_glColor3us(glColor3us_PACKED *_dst glColor3us_ARG_EXPAND_TAIL);
typedef void (*glColor3us_PTR)(glColor3us_ARG_EXPAND);
#endif
#ifndef glColor3usv_RETURN
#define glColor3usv_RETURN void
#define glColor3usv_ARG_NAMES v
#define glColor3usv_ARG_EXPAND const GLushort * v
#define glColor3usv_ARG_NAMES_TAIL , v
#define glColor3usv_ARG_EXPAND_TAIL , const GLushort * v
#define forward_glColor3usv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3usv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3usv(dst, _v), NULL); \
    });
#define call_glColor3usv(packed, ret_v) do { \
    glColor3usv_PACKED *unpacked = (glColor3usv_PACKED *)packed; \
    glColor3usv_ARGS *args = (glColor3usv_ARGS *)&unpacked->args; \
    glColor3usv(args->v);; \
} while(0)
void glColor3usv(glColor3usv_ARG_EXPAND);
packed_call_t *pack_glColor3usv(glColor3usv_PACKED *_dst glColor3usv_ARG_EXPAND_TAIL);
typedef void (*glColor3usv_PTR)(glColor3usv_ARG_EXPAND);
#endif
#ifndef glColor3xOES_RETURN
#define glColor3xOES_RETURN void
#define glColor3xOES_ARG_NAMES red, green, blue
#define glColor3xOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue
#define glColor3xOES_ARG_NAMES_TAIL , red, green, blue
#define glColor3xOES_ARG_EXPAND_TAIL , GLfixed red, GLfixed green, GLfixed blue
#define forward_glColor3xOES(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3xOES(dst, _red, _green, _blue), NULL); \
    });
#define call_glColor3xOES(packed, ret_v) do { \
    glColor3xOES_PACKED *unpacked = (glColor3xOES_PACKED *)packed; \
    glColor3xOES_ARGS *args = (glColor3xOES_ARGS *)&unpacked->args; \
    glColor3xOES(args->red, args->green, args->blue);; \
} while(0)
void glColor3xOES(glColor3xOES_ARG_EXPAND);
packed_call_t *pack_glColor3xOES(glColor3xOES_PACKED *_dst glColor3xOES_ARG_EXPAND_TAIL);
typedef void (*glColor3xOES_PTR)(glColor3xOES_ARG_EXPAND);
#endif
#ifndef glColor3xvOES_RETURN
#define glColor3xvOES_RETURN void
#define glColor3xvOES_ARG_NAMES components
#define glColor3xvOES_ARG_EXPAND const GLfixed * components
#define glColor3xvOES_ARG_NAMES_TAIL , components
#define glColor3xvOES_ARG_EXPAND_TAIL , const GLfixed * components
#define forward_glColor3xvOES(_components) \
    ({ \
        void *dst = remote_dma(sizeof(glColor3xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor3xvOES(dst, _components), NULL); \
    });
#define call_glColor3xvOES(packed, ret_v) do { \
    glColor3xvOES_PACKED *unpacked = (glColor3xvOES_PACKED *)packed; \
    glColor3xvOES_ARGS *args = (glColor3xvOES_ARGS *)&unpacked->args; \
    glColor3xvOES(args->components);; \
} while(0)
void glColor3xvOES(glColor3xvOES_ARG_EXPAND);
packed_call_t *pack_glColor3xvOES(glColor3xvOES_PACKED *_dst glColor3xvOES_ARG_EXPAND_TAIL);
typedef void (*glColor3xvOES_PTR)(glColor3xvOES_ARG_EXPAND);
#endif
#ifndef glColor4b_RETURN
#define glColor4b_RETURN void
#define glColor4b_ARG_NAMES red, green, blue, alpha
#define glColor4b_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha
#define glColor4b_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4b_ARG_EXPAND_TAIL , GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha
#define forward_glColor4b(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4b_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4b(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4b(packed, ret_v) do { \
    glColor4b_PACKED *unpacked = (glColor4b_PACKED *)packed; \
    glColor4b_ARGS *args = (glColor4b_ARGS *)&unpacked->args; \
    glColor4b(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4b(glColor4b_ARG_EXPAND);
packed_call_t *pack_glColor4b(glColor4b_PACKED *_dst glColor4b_ARG_EXPAND_TAIL);
typedef void (*glColor4b_PTR)(glColor4b_ARG_EXPAND);
#endif
#ifndef glColor4bv_RETURN
#define glColor4bv_RETURN void
#define glColor4bv_ARG_NAMES v
#define glColor4bv_ARG_EXPAND const GLbyte * v
#define glColor4bv_ARG_NAMES_TAIL , v
#define glColor4bv_ARG_EXPAND_TAIL , const GLbyte * v
#define forward_glColor4bv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4bv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4bv(dst, _v), NULL); \
    });
#define call_glColor4bv(packed, ret_v) do { \
    glColor4bv_PACKED *unpacked = (glColor4bv_PACKED *)packed; \
    glColor4bv_ARGS *args = (glColor4bv_ARGS *)&unpacked->args; \
    glColor4bv(args->v);; \
} while(0)
void glColor4bv(glColor4bv_ARG_EXPAND);
packed_call_t *pack_glColor4bv(glColor4bv_PACKED *_dst glColor4bv_ARG_EXPAND_TAIL);
typedef void (*glColor4bv_PTR)(glColor4bv_ARG_EXPAND);
#endif
#ifndef glColor4d_RETURN
#define glColor4d_RETURN void
#define glColor4d_ARG_NAMES red, green, blue, alpha
#define glColor4d_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha
#define glColor4d_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4d_ARG_EXPAND_TAIL , GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha
#define forward_glColor4d(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4d(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4d(packed, ret_v) do { \
    glColor4d_PACKED *unpacked = (glColor4d_PACKED *)packed; \
    glColor4d_ARGS *args = (glColor4d_ARGS *)&unpacked->args; \
    glColor4d(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4d(glColor4d_ARG_EXPAND);
packed_call_t *pack_glColor4d(glColor4d_PACKED *_dst glColor4d_ARG_EXPAND_TAIL);
typedef void (*glColor4d_PTR)(glColor4d_ARG_EXPAND);
#endif
#ifndef glColor4dv_RETURN
#define glColor4dv_RETURN void
#define glColor4dv_ARG_NAMES v
#define glColor4dv_ARG_EXPAND const GLdouble * v
#define glColor4dv_ARG_NAMES_TAIL , v
#define glColor4dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glColor4dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4dv(dst, _v), NULL); \
    });
#define call_glColor4dv(packed, ret_v) do { \
    glColor4dv_PACKED *unpacked = (glColor4dv_PACKED *)packed; \
    glColor4dv_ARGS *args = (glColor4dv_ARGS *)&unpacked->args; \
    glColor4dv(args->v);; \
} while(0)
void glColor4dv(glColor4dv_ARG_EXPAND);
packed_call_t *pack_glColor4dv(glColor4dv_PACKED *_dst glColor4dv_ARG_EXPAND_TAIL);
typedef void (*glColor4dv_PTR)(glColor4dv_ARG_EXPAND);
#endif
#ifndef glColor4f_RETURN
#define glColor4f_RETURN void
#define glColor4f_ARG_NAMES red, green, blue, alpha
#define glColor4f_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glColor4f_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4f_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define forward_glColor4f(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4f(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4f(packed, ret_v) do { \
    glColor4f_PACKED *unpacked = (glColor4f_PACKED *)packed; \
    glColor4f_ARGS *args = (glColor4f_ARGS *)&unpacked->args; \
    glColor4f(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4f(glColor4f_ARG_EXPAND);
packed_call_t *pack_glColor4f(glColor4f_PACKED *_dst glColor4f_ARG_EXPAND_TAIL);
typedef void (*glColor4f_PTR)(glColor4f_ARG_EXPAND);
#endif
#ifndef glColor4fNormal3fVertex3fSUN_RETURN
#define glColor4fNormal3fVertex3fSUN_RETURN void
#define glColor4fNormal3fVertex3fSUN_ARG_NAMES r, g, b, a, nx, ny, nz, x, y, z
#define glColor4fNormal3fVertex3fSUN_ARG_EXPAND GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glColor4fNormal3fVertex3fSUN_ARG_NAMES_TAIL , r, g, b, a, nx, ny, nz, x, y, z
#define glColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glColor4fNormal3fVertex3fSUN(_r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4fNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4fNormal3fVertex3fSUN(dst, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    glColor4fNormal3fVertex3fSUN_PACKED *unpacked = (glColor4fNormal3fVertex3fSUN_PACKED *)packed; \
    glColor4fNormal3fVertex3fSUN_ARGS *args = (glColor4fNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glColor4fNormal3fVertex3fSUN(args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glColor4fNormal3fVertex3fSUN(glColor4fNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glColor4fNormal3fVertex3fSUN(glColor4fNormal3fVertex3fSUN_PACKED *_dst glColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glColor4fNormal3fVertex3fSUN_PTR)(glColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glColor4fNormal3fVertex3fvSUN_RETURN
#define glColor4fNormal3fVertex3fvSUN_RETURN void
#define glColor4fNormal3fVertex3fvSUN_ARG_NAMES c, n, v
#define glColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glColor4fNormal3fVertex3fvSUN_ARG_NAMES_TAIL , c, n, v
#define glColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * c, const GLfloat * n, const GLfloat * v
#define forward_glColor4fNormal3fVertex3fvSUN(_c, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4fNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4fNormal3fVertex3fvSUN(dst, _c, _n, _v), NULL); \
    });
#define call_glColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    glColor4fNormal3fVertex3fvSUN_PACKED *unpacked = (glColor4fNormal3fVertex3fvSUN_PACKED *)packed; \
    glColor4fNormal3fVertex3fvSUN_ARGS *args = (glColor4fNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glColor4fNormal3fVertex3fvSUN(args->c, args->n, args->v);; \
} while(0)
void glColor4fNormal3fVertex3fvSUN(glColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glColor4fNormal3fVertex3fvSUN(glColor4fNormal3fVertex3fvSUN_PACKED *_dst glColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glColor4fNormal3fVertex3fvSUN_PTR)(glColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glColor4fv_RETURN
#define glColor4fv_RETURN void
#define glColor4fv_ARG_NAMES v
#define glColor4fv_ARG_EXPAND const GLfloat * v
#define glColor4fv_ARG_NAMES_TAIL , v
#define glColor4fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glColor4fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4fv(dst, _v), NULL); \
    });
#define call_glColor4fv(packed, ret_v) do { \
    glColor4fv_PACKED *unpacked = (glColor4fv_PACKED *)packed; \
    glColor4fv_ARGS *args = (glColor4fv_ARGS *)&unpacked->args; \
    glColor4fv(args->v);; \
} while(0)
void glColor4fv(glColor4fv_ARG_EXPAND);
packed_call_t *pack_glColor4fv(glColor4fv_PACKED *_dst glColor4fv_ARG_EXPAND_TAIL);
typedef void (*glColor4fv_PTR)(glColor4fv_ARG_EXPAND);
#endif
#ifndef glColor4hNV_RETURN
#define glColor4hNV_RETURN void
#define glColor4hNV_ARG_NAMES red, green, blue, alpha
#define glColor4hNV_ARG_EXPAND GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha
#define glColor4hNV_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4hNV_ARG_EXPAND_TAIL , GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha
#define forward_glColor4hNV(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4hNV(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4hNV(packed, ret_v) do { \
    glColor4hNV_PACKED *unpacked = (glColor4hNV_PACKED *)packed; \
    glColor4hNV_ARGS *args = (glColor4hNV_ARGS *)&unpacked->args; \
    glColor4hNV(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4hNV(glColor4hNV_ARG_EXPAND);
packed_call_t *pack_glColor4hNV(glColor4hNV_PACKED *_dst glColor4hNV_ARG_EXPAND_TAIL);
typedef void (*glColor4hNV_PTR)(glColor4hNV_ARG_EXPAND);
#endif
#ifndef glColor4hvNV_RETURN
#define glColor4hvNV_RETURN void
#define glColor4hvNV_ARG_NAMES v
#define glColor4hvNV_ARG_EXPAND const GLhalfNV * v
#define glColor4hvNV_ARG_NAMES_TAIL , v
#define glColor4hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glColor4hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4hvNV(dst, _v), NULL); \
    });
#define call_glColor4hvNV(packed, ret_v) do { \
    glColor4hvNV_PACKED *unpacked = (glColor4hvNV_PACKED *)packed; \
    glColor4hvNV_ARGS *args = (glColor4hvNV_ARGS *)&unpacked->args; \
    glColor4hvNV(args->v);; \
} while(0)
void glColor4hvNV(glColor4hvNV_ARG_EXPAND);
packed_call_t *pack_glColor4hvNV(glColor4hvNV_PACKED *_dst glColor4hvNV_ARG_EXPAND_TAIL);
typedef void (*glColor4hvNV_PTR)(glColor4hvNV_ARG_EXPAND);
#endif
#ifndef glColor4i_RETURN
#define glColor4i_RETURN void
#define glColor4i_ARG_NAMES red, green, blue, alpha
#define glColor4i_ARG_EXPAND GLint red, GLint green, GLint blue, GLint alpha
#define glColor4i_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4i_ARG_EXPAND_TAIL , GLint red, GLint green, GLint blue, GLint alpha
#define forward_glColor4i(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4i(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4i(packed, ret_v) do { \
    glColor4i_PACKED *unpacked = (glColor4i_PACKED *)packed; \
    glColor4i_ARGS *args = (glColor4i_ARGS *)&unpacked->args; \
    glColor4i(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4i(glColor4i_ARG_EXPAND);
packed_call_t *pack_glColor4i(glColor4i_PACKED *_dst glColor4i_ARG_EXPAND_TAIL);
typedef void (*glColor4i_PTR)(glColor4i_ARG_EXPAND);
#endif
#ifndef glColor4iv_RETURN
#define glColor4iv_RETURN void
#define glColor4iv_ARG_NAMES v
#define glColor4iv_ARG_EXPAND const GLint * v
#define glColor4iv_ARG_NAMES_TAIL , v
#define glColor4iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glColor4iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4iv(dst, _v), NULL); \
    });
#define call_glColor4iv(packed, ret_v) do { \
    glColor4iv_PACKED *unpacked = (glColor4iv_PACKED *)packed; \
    glColor4iv_ARGS *args = (glColor4iv_ARGS *)&unpacked->args; \
    glColor4iv(args->v);; \
} while(0)
void glColor4iv(glColor4iv_ARG_EXPAND);
packed_call_t *pack_glColor4iv(glColor4iv_PACKED *_dst glColor4iv_ARG_EXPAND_TAIL);
typedef void (*glColor4iv_PTR)(glColor4iv_ARG_EXPAND);
#endif
#ifndef glColor4s_RETURN
#define glColor4s_RETURN void
#define glColor4s_ARG_NAMES red, green, blue, alpha
#define glColor4s_ARG_EXPAND GLshort red, GLshort green, GLshort blue, GLshort alpha
#define glColor4s_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4s_ARG_EXPAND_TAIL , GLshort red, GLshort green, GLshort blue, GLshort alpha
#define forward_glColor4s(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4s(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4s(packed, ret_v) do { \
    glColor4s_PACKED *unpacked = (glColor4s_PACKED *)packed; \
    glColor4s_ARGS *args = (glColor4s_ARGS *)&unpacked->args; \
    glColor4s(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4s(glColor4s_ARG_EXPAND);
packed_call_t *pack_glColor4s(glColor4s_PACKED *_dst glColor4s_ARG_EXPAND_TAIL);
typedef void (*glColor4s_PTR)(glColor4s_ARG_EXPAND);
#endif
#ifndef glColor4sv_RETURN
#define glColor4sv_RETURN void
#define glColor4sv_ARG_NAMES v
#define glColor4sv_ARG_EXPAND const GLshort * v
#define glColor4sv_ARG_NAMES_TAIL , v
#define glColor4sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glColor4sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4sv(dst, _v), NULL); \
    });
#define call_glColor4sv(packed, ret_v) do { \
    glColor4sv_PACKED *unpacked = (glColor4sv_PACKED *)packed; \
    glColor4sv_ARGS *args = (glColor4sv_ARGS *)&unpacked->args; \
    glColor4sv(args->v);; \
} while(0)
void glColor4sv(glColor4sv_ARG_EXPAND);
packed_call_t *pack_glColor4sv(glColor4sv_PACKED *_dst glColor4sv_ARG_EXPAND_TAIL);
typedef void (*glColor4sv_PTR)(glColor4sv_ARG_EXPAND);
#endif
#ifndef glColor4ub_RETURN
#define glColor4ub_RETURN void
#define glColor4ub_ARG_NAMES red, green, blue, alpha
#define glColor4ub_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha
#define glColor4ub_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4ub_ARG_EXPAND_TAIL , GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha
#define forward_glColor4ub(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4ub_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4ub(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4ub(packed, ret_v) do { \
    glColor4ub_PACKED *unpacked = (glColor4ub_PACKED *)packed; \
    glColor4ub_ARGS *args = (glColor4ub_ARGS *)&unpacked->args; \
    glColor4ub(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4ub(glColor4ub_ARG_EXPAND);
packed_call_t *pack_glColor4ub(glColor4ub_PACKED *_dst glColor4ub_ARG_EXPAND_TAIL);
typedef void (*glColor4ub_PTR)(glColor4ub_ARG_EXPAND);
#endif
#ifndef glColor4ubVertex2fSUN_RETURN
#define glColor4ubVertex2fSUN_RETURN void
#define glColor4ubVertex2fSUN_ARG_NAMES r, g, b, a, x, y
#define glColor4ubVertex2fSUN_ARG_EXPAND GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y
#define glColor4ubVertex2fSUN_ARG_NAMES_TAIL , r, g, b, a, x, y
#define glColor4ubVertex2fSUN_ARG_EXPAND_TAIL , GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y
#define forward_glColor4ubVertex2fSUN(_r, _g, _b, _a, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4ubVertex2fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4ubVertex2fSUN(dst, _r, _g, _b, _a, _x, _y), NULL); \
    });
#define call_glColor4ubVertex2fSUN(packed, ret_v) do { \
    glColor4ubVertex2fSUN_PACKED *unpacked = (glColor4ubVertex2fSUN_PACKED *)packed; \
    glColor4ubVertex2fSUN_ARGS *args = (glColor4ubVertex2fSUN_ARGS *)&unpacked->args; \
    glColor4ubVertex2fSUN(args->r, args->g, args->b, args->a, args->x, args->y);; \
} while(0)
void glColor4ubVertex2fSUN(glColor4ubVertex2fSUN_ARG_EXPAND);
packed_call_t *pack_glColor4ubVertex2fSUN(glColor4ubVertex2fSUN_PACKED *_dst glColor4ubVertex2fSUN_ARG_EXPAND_TAIL);
typedef void (*glColor4ubVertex2fSUN_PTR)(glColor4ubVertex2fSUN_ARG_EXPAND);
#endif
#ifndef glColor4ubVertex2fvSUN_RETURN
#define glColor4ubVertex2fvSUN_RETURN void
#define glColor4ubVertex2fvSUN_ARG_NAMES c, v
#define glColor4ubVertex2fvSUN_ARG_EXPAND const GLubyte * c, const GLfloat * v
#define glColor4ubVertex2fvSUN_ARG_NAMES_TAIL , c, v
#define glColor4ubVertex2fvSUN_ARG_EXPAND_TAIL , const GLubyte * c, const GLfloat * v
#define forward_glColor4ubVertex2fvSUN(_c, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4ubVertex2fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4ubVertex2fvSUN(dst, _c, _v), NULL); \
    });
#define call_glColor4ubVertex2fvSUN(packed, ret_v) do { \
    glColor4ubVertex2fvSUN_PACKED *unpacked = (glColor4ubVertex2fvSUN_PACKED *)packed; \
    glColor4ubVertex2fvSUN_ARGS *args = (glColor4ubVertex2fvSUN_ARGS *)&unpacked->args; \
    glColor4ubVertex2fvSUN(args->c, args->v);; \
} while(0)
void glColor4ubVertex2fvSUN(glColor4ubVertex2fvSUN_ARG_EXPAND);
packed_call_t *pack_glColor4ubVertex2fvSUN(glColor4ubVertex2fvSUN_PACKED *_dst glColor4ubVertex2fvSUN_ARG_EXPAND_TAIL);
typedef void (*glColor4ubVertex2fvSUN_PTR)(glColor4ubVertex2fvSUN_ARG_EXPAND);
#endif
#ifndef glColor4ubVertex3fSUN_RETURN
#define glColor4ubVertex3fSUN_RETURN void
#define glColor4ubVertex3fSUN_ARG_NAMES r, g, b, a, x, y, z
#define glColor4ubVertex3fSUN_ARG_EXPAND GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define glColor4ubVertex3fSUN_ARG_NAMES_TAIL , r, g, b, a, x, y, z
#define glColor4ubVertex3fSUN_ARG_EXPAND_TAIL , GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define forward_glColor4ubVertex3fSUN(_r, _g, _b, _a, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4ubVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4ubVertex3fSUN(dst, _r, _g, _b, _a, _x, _y, _z), NULL); \
    });
#define call_glColor4ubVertex3fSUN(packed, ret_v) do { \
    glColor4ubVertex3fSUN_PACKED *unpacked = (glColor4ubVertex3fSUN_PACKED *)packed; \
    glColor4ubVertex3fSUN_ARGS *args = (glColor4ubVertex3fSUN_ARGS *)&unpacked->args; \
    glColor4ubVertex3fSUN(args->r, args->g, args->b, args->a, args->x, args->y, args->z);; \
} while(0)
void glColor4ubVertex3fSUN(glColor4ubVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glColor4ubVertex3fSUN(glColor4ubVertex3fSUN_PACKED *_dst glColor4ubVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glColor4ubVertex3fSUN_PTR)(glColor4ubVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glColor4ubVertex3fvSUN_RETURN
#define glColor4ubVertex3fvSUN_RETURN void
#define glColor4ubVertex3fvSUN_ARG_NAMES c, v
#define glColor4ubVertex3fvSUN_ARG_EXPAND const GLubyte * c, const GLfloat * v
#define glColor4ubVertex3fvSUN_ARG_NAMES_TAIL , c, v
#define glColor4ubVertex3fvSUN_ARG_EXPAND_TAIL , const GLubyte * c, const GLfloat * v
#define forward_glColor4ubVertex3fvSUN(_c, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4ubVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4ubVertex3fvSUN(dst, _c, _v), NULL); \
    });
#define call_glColor4ubVertex3fvSUN(packed, ret_v) do { \
    glColor4ubVertex3fvSUN_PACKED *unpacked = (glColor4ubVertex3fvSUN_PACKED *)packed; \
    glColor4ubVertex3fvSUN_ARGS *args = (glColor4ubVertex3fvSUN_ARGS *)&unpacked->args; \
    glColor4ubVertex3fvSUN(args->c, args->v);; \
} while(0)
void glColor4ubVertex3fvSUN(glColor4ubVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glColor4ubVertex3fvSUN(glColor4ubVertex3fvSUN_PACKED *_dst glColor4ubVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glColor4ubVertex3fvSUN_PTR)(glColor4ubVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glColor4ubv_RETURN
#define glColor4ubv_RETURN void
#define glColor4ubv_ARG_NAMES v
#define glColor4ubv_ARG_EXPAND const GLubyte * v
#define glColor4ubv_ARG_NAMES_TAIL , v
#define glColor4ubv_ARG_EXPAND_TAIL , const GLubyte * v
#define forward_glColor4ubv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4ubv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4ubv(dst, _v), NULL); \
    });
#define call_glColor4ubv(packed, ret_v) do { \
    glColor4ubv_PACKED *unpacked = (glColor4ubv_PACKED *)packed; \
    glColor4ubv_ARGS *args = (glColor4ubv_ARGS *)&unpacked->args; \
    glColor4ubv(args->v);; \
} while(0)
void glColor4ubv(glColor4ubv_ARG_EXPAND);
packed_call_t *pack_glColor4ubv(glColor4ubv_PACKED *_dst glColor4ubv_ARG_EXPAND_TAIL);
typedef void (*glColor4ubv_PTR)(glColor4ubv_ARG_EXPAND);
#endif
#ifndef glColor4ui_RETURN
#define glColor4ui_RETURN void
#define glColor4ui_ARG_NAMES red, green, blue, alpha
#define glColor4ui_ARG_EXPAND GLuint red, GLuint green, GLuint blue, GLuint alpha
#define glColor4ui_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4ui_ARG_EXPAND_TAIL , GLuint red, GLuint green, GLuint blue, GLuint alpha
#define forward_glColor4ui(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4ui(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4ui(packed, ret_v) do { \
    glColor4ui_PACKED *unpacked = (glColor4ui_PACKED *)packed; \
    glColor4ui_ARGS *args = (glColor4ui_ARGS *)&unpacked->args; \
    glColor4ui(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4ui(glColor4ui_ARG_EXPAND);
packed_call_t *pack_glColor4ui(glColor4ui_PACKED *_dst glColor4ui_ARG_EXPAND_TAIL);
typedef void (*glColor4ui_PTR)(glColor4ui_ARG_EXPAND);
#endif
#ifndef glColor4uiv_RETURN
#define glColor4uiv_RETURN void
#define glColor4uiv_ARG_NAMES v
#define glColor4uiv_ARG_EXPAND const GLuint * v
#define glColor4uiv_ARG_NAMES_TAIL , v
#define glColor4uiv_ARG_EXPAND_TAIL , const GLuint * v
#define forward_glColor4uiv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4uiv(dst, _v), NULL); \
    });
#define call_glColor4uiv(packed, ret_v) do { \
    glColor4uiv_PACKED *unpacked = (glColor4uiv_PACKED *)packed; \
    glColor4uiv_ARGS *args = (glColor4uiv_ARGS *)&unpacked->args; \
    glColor4uiv(args->v);; \
} while(0)
void glColor4uiv(glColor4uiv_ARG_EXPAND);
packed_call_t *pack_glColor4uiv(glColor4uiv_PACKED *_dst glColor4uiv_ARG_EXPAND_TAIL);
typedef void (*glColor4uiv_PTR)(glColor4uiv_ARG_EXPAND);
#endif
#ifndef glColor4us_RETURN
#define glColor4us_RETURN void
#define glColor4us_ARG_NAMES red, green, blue, alpha
#define glColor4us_ARG_EXPAND GLushort red, GLushort green, GLushort blue, GLushort alpha
#define glColor4us_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4us_ARG_EXPAND_TAIL , GLushort red, GLushort green, GLushort blue, GLushort alpha
#define forward_glColor4us(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4us_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4us(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4us(packed, ret_v) do { \
    glColor4us_PACKED *unpacked = (glColor4us_PACKED *)packed; \
    glColor4us_ARGS *args = (glColor4us_ARGS *)&unpacked->args; \
    glColor4us(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4us(glColor4us_ARG_EXPAND);
packed_call_t *pack_glColor4us(glColor4us_PACKED *_dst glColor4us_ARG_EXPAND_TAIL);
typedef void (*glColor4us_PTR)(glColor4us_ARG_EXPAND);
#endif
#ifndef glColor4usv_RETURN
#define glColor4usv_RETURN void
#define glColor4usv_ARG_NAMES v
#define glColor4usv_ARG_EXPAND const GLushort * v
#define glColor4usv_ARG_NAMES_TAIL , v
#define glColor4usv_ARG_EXPAND_TAIL , const GLushort * v
#define forward_glColor4usv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4usv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4usv(dst, _v), NULL); \
    });
#define call_glColor4usv(packed, ret_v) do { \
    glColor4usv_PACKED *unpacked = (glColor4usv_PACKED *)packed; \
    glColor4usv_ARGS *args = (glColor4usv_ARGS *)&unpacked->args; \
    glColor4usv(args->v);; \
} while(0)
void glColor4usv(glColor4usv_ARG_EXPAND);
packed_call_t *pack_glColor4usv(glColor4usv_PACKED *_dst glColor4usv_ARG_EXPAND_TAIL);
typedef void (*glColor4usv_PTR)(glColor4usv_ARG_EXPAND);
#endif
#ifndef glColor4xOES_RETURN
#define glColor4xOES_RETURN void
#define glColor4xOES_ARG_NAMES red, green, blue, alpha
#define glColor4xOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glColor4xOES_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColor4xOES_ARG_EXPAND_TAIL , GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define forward_glColor4xOES(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4xOES(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColor4xOES(packed, ret_v) do { \
    glColor4xOES_PACKED *unpacked = (glColor4xOES_PACKED *)packed; \
    glColor4xOES_ARGS *args = (glColor4xOES_ARGS *)&unpacked->args; \
    glColor4xOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4xOES(glColor4xOES_ARG_EXPAND);
packed_call_t *pack_glColor4xOES(glColor4xOES_PACKED *_dst glColor4xOES_ARG_EXPAND_TAIL);
typedef void (*glColor4xOES_PTR)(glColor4xOES_ARG_EXPAND);
#endif
#ifndef glColor4xvOES_RETURN
#define glColor4xvOES_RETURN void
#define glColor4xvOES_ARG_NAMES components
#define glColor4xvOES_ARG_EXPAND const GLfixed * components
#define glColor4xvOES_ARG_NAMES_TAIL , components
#define glColor4xvOES_ARG_EXPAND_TAIL , const GLfixed * components
#define forward_glColor4xvOES(_components) \
    ({ \
        void *dst = remote_dma(sizeof(glColor4xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColor4xvOES(dst, _components), NULL); \
    });
#define call_glColor4xvOES(packed, ret_v) do { \
    glColor4xvOES_PACKED *unpacked = (glColor4xvOES_PACKED *)packed; \
    glColor4xvOES_ARGS *args = (glColor4xvOES_ARGS *)&unpacked->args; \
    glColor4xvOES(args->components);; \
} while(0)
void glColor4xvOES(glColor4xvOES_ARG_EXPAND);
packed_call_t *pack_glColor4xvOES(glColor4xvOES_PACKED *_dst glColor4xvOES_ARG_EXPAND_TAIL);
typedef void (*glColor4xvOES_PTR)(glColor4xvOES_ARG_EXPAND);
#endif
#ifndef glColorFormatNV_RETURN
#define glColorFormatNV_RETURN void
#define glColorFormatNV_ARG_NAMES size, type, stride
#define glColorFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glColorFormatNV_ARG_NAMES_TAIL , size, type, stride
#define glColorFormatNV_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride
#define forward_glColorFormatNV(_size, _type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glColorFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorFormatNV(dst, _size, _type, _stride), NULL); \
    });
#define call_glColorFormatNV(packed, ret_v) do { \
    glColorFormatNV_PACKED *unpacked = (glColorFormatNV_PACKED *)packed; \
    glColorFormatNV_ARGS *args = (glColorFormatNV_ARGS *)&unpacked->args; \
    glColorFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glColorFormatNV(glColorFormatNV_ARG_EXPAND);
packed_call_t *pack_glColorFormatNV(glColorFormatNV_PACKED *_dst glColorFormatNV_ARG_EXPAND_TAIL);
typedef void (*glColorFormatNV_PTR)(glColorFormatNV_ARG_EXPAND);
#endif
#ifndef glColorFragmentOp1ATI_RETURN
#define glColorFragmentOp1ATI_RETURN void
#define glColorFragmentOp1ATI_ARG_NAMES op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod
#define glColorFragmentOp1ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod
#define glColorFragmentOp1ATI_ARG_NAMES_TAIL , op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod
#define glColorFragmentOp1ATI_ARG_EXPAND_TAIL , GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod
#define forward_glColorFragmentOp1ATI(_op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod) \
    ({ \
        void *dst = remote_dma(sizeof(glColorFragmentOp1ATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorFragmentOp1ATI(dst, _op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod), NULL); \
    });
#define call_glColorFragmentOp1ATI(packed, ret_v) do { \
    glColorFragmentOp1ATI_PACKED *unpacked = (glColorFragmentOp1ATI_PACKED *)packed; \
    glColorFragmentOp1ATI_ARGS *args = (glColorFragmentOp1ATI_ARGS *)&unpacked->args; \
    glColorFragmentOp1ATI(args->op, args->dst, args->dstMask, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod);; \
} while(0)
void glColorFragmentOp1ATI(glColorFragmentOp1ATI_ARG_EXPAND);
packed_call_t *pack_glColorFragmentOp1ATI(glColorFragmentOp1ATI_PACKED *_dst glColorFragmentOp1ATI_ARG_EXPAND_TAIL);
typedef void (*glColorFragmentOp1ATI_PTR)(glColorFragmentOp1ATI_ARG_EXPAND);
#endif
#ifndef glColorFragmentOp2ATI_RETURN
#define glColorFragmentOp2ATI_RETURN void
#define glColorFragmentOp2ATI_ARG_NAMES op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod
#define glColorFragmentOp2ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod
#define glColorFragmentOp2ATI_ARG_NAMES_TAIL , op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod
#define glColorFragmentOp2ATI_ARG_EXPAND_TAIL , GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod
#define forward_glColorFragmentOp2ATI(_op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod) \
    ({ \
        void *dst = remote_dma(sizeof(glColorFragmentOp2ATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorFragmentOp2ATI(dst, _op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod), NULL); \
    });
#define call_glColorFragmentOp2ATI(packed, ret_v) do { \
    glColorFragmentOp2ATI_PACKED *unpacked = (glColorFragmentOp2ATI_PACKED *)packed; \
    glColorFragmentOp2ATI_ARGS *args = (glColorFragmentOp2ATI_ARGS *)&unpacked->args; \
    glColorFragmentOp2ATI(args->op, args->dst, args->dstMask, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod);; \
} while(0)
void glColorFragmentOp2ATI(glColorFragmentOp2ATI_ARG_EXPAND);
packed_call_t *pack_glColorFragmentOp2ATI(glColorFragmentOp2ATI_PACKED *_dst glColorFragmentOp2ATI_ARG_EXPAND_TAIL);
typedef void (*glColorFragmentOp2ATI_PTR)(glColorFragmentOp2ATI_ARG_EXPAND);
#endif
#ifndef glColorFragmentOp3ATI_RETURN
#define glColorFragmentOp3ATI_RETURN void
#define glColorFragmentOp3ATI_ARG_NAMES op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod
#define glColorFragmentOp3ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod
#define glColorFragmentOp3ATI_ARG_NAMES_TAIL , op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod
#define glColorFragmentOp3ATI_ARG_EXPAND_TAIL , GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod
#define forward_glColorFragmentOp3ATI(_op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod, _arg3, _arg3Rep, _arg3Mod) \
    ({ \
        void *dst = remote_dma(sizeof(glColorFragmentOp3ATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorFragmentOp3ATI(dst, _op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod, _arg3, _arg3Rep, _arg3Mod), NULL); \
    });
#define call_glColorFragmentOp3ATI(packed, ret_v) do { \
    glColorFragmentOp3ATI_PACKED *unpacked = (glColorFragmentOp3ATI_PACKED *)packed; \
    glColorFragmentOp3ATI_ARGS *args = (glColorFragmentOp3ATI_ARGS *)&unpacked->args; \
    glColorFragmentOp3ATI(args->op, args->dst, args->dstMask, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod, args->arg3, args->arg3Rep, args->arg3Mod);; \
} while(0)
void glColorFragmentOp3ATI(glColorFragmentOp3ATI_ARG_EXPAND);
packed_call_t *pack_glColorFragmentOp3ATI(glColorFragmentOp3ATI_PACKED *_dst glColorFragmentOp3ATI_ARG_EXPAND_TAIL);
typedef void (*glColorFragmentOp3ATI_PTR)(glColorFragmentOp3ATI_ARG_EXPAND);
#endif
#ifndef glColorMask_RETURN
#define glColorMask_RETURN void
#define glColorMask_ARG_NAMES red, green, blue, alpha
#define glColorMask_ARG_EXPAND GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha
#define glColorMask_ARG_NAMES_TAIL , red, green, blue, alpha
#define glColorMask_ARG_EXPAND_TAIL , GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha
#define forward_glColorMask(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glColorMask_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorMask(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glColorMask(packed, ret_v) do { \
    glColorMask_PACKED *unpacked = (glColorMask_PACKED *)packed; \
    glColorMask_ARGS *args = (glColorMask_ARGS *)&unpacked->args; \
    glColorMask(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColorMask(glColorMask_ARG_EXPAND);
packed_call_t *pack_glColorMask(glColorMask_PACKED *_dst glColorMask_ARG_EXPAND_TAIL);
typedef void (*glColorMask_PTR)(glColorMask_ARG_EXPAND);
#endif
#ifndef glColorMaskIndexedEXT_RETURN
#define glColorMaskIndexedEXT_RETURN void
#define glColorMaskIndexedEXT_ARG_NAMES index, r, g, b, a
#define glColorMaskIndexedEXT_ARG_EXPAND GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a
#define glColorMaskIndexedEXT_ARG_NAMES_TAIL , index, r, g, b, a
#define glColorMaskIndexedEXT_ARG_EXPAND_TAIL , GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a
#define forward_glColorMaskIndexedEXT(_index, _r, _g, _b, _a) \
    ({ \
        void *dst = remote_dma(sizeof(glColorMaskIndexedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorMaskIndexedEXT(dst, _index, _r, _g, _b, _a), NULL); \
    });
#define call_glColorMaskIndexedEXT(packed, ret_v) do { \
    glColorMaskIndexedEXT_PACKED *unpacked = (glColorMaskIndexedEXT_PACKED *)packed; \
    glColorMaskIndexedEXT_ARGS *args = (glColorMaskIndexedEXT_ARGS *)&unpacked->args; \
    glColorMaskIndexedEXT(args->index, args->r, args->g, args->b, args->a);; \
} while(0)
void glColorMaskIndexedEXT(glColorMaskIndexedEXT_ARG_EXPAND);
packed_call_t *pack_glColorMaskIndexedEXT(glColorMaskIndexedEXT_PACKED *_dst glColorMaskIndexedEXT_ARG_EXPAND_TAIL);
typedef void (*glColorMaskIndexedEXT_PTR)(glColorMaskIndexedEXT_ARG_EXPAND);
#endif
#ifndef glColorMaski_RETURN
#define glColorMaski_RETURN void
#define glColorMaski_ARG_NAMES index, r, g, b, a
#define glColorMaski_ARG_EXPAND GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a
#define glColorMaski_ARG_NAMES_TAIL , index, r, g, b, a
#define glColorMaski_ARG_EXPAND_TAIL , GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a
#define forward_glColorMaski(_index, _r, _g, _b, _a) \
    ({ \
        void *dst = remote_dma(sizeof(glColorMaski_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorMaski(dst, _index, _r, _g, _b, _a), NULL); \
    });
#define call_glColorMaski(packed, ret_v) do { \
    glColorMaski_PACKED *unpacked = (glColorMaski_PACKED *)packed; \
    glColorMaski_ARGS *args = (glColorMaski_ARGS *)&unpacked->args; \
    glColorMaski(args->index, args->r, args->g, args->b, args->a);; \
} while(0)
void glColorMaski(glColorMaski_ARG_EXPAND);
packed_call_t *pack_glColorMaski(glColorMaski_PACKED *_dst glColorMaski_ARG_EXPAND_TAIL);
typedef void (*glColorMaski_PTR)(glColorMaski_ARG_EXPAND);
#endif
#ifndef glColorMaterial_RETURN
#define glColorMaterial_RETURN void
#define glColorMaterial_ARG_NAMES face, mode
#define glColorMaterial_ARG_EXPAND GLenum face, GLenum mode
#define glColorMaterial_ARG_NAMES_TAIL , face, mode
#define glColorMaterial_ARG_EXPAND_TAIL , GLenum face, GLenum mode
#define forward_glColorMaterial(_face, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glColorMaterial_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorMaterial(dst, _face, _mode), NULL); \
    });
#define call_glColorMaterial(packed, ret_v) do { \
    glColorMaterial_PACKED *unpacked = (glColorMaterial_PACKED *)packed; \
    glColorMaterial_ARGS *args = (glColorMaterial_ARGS *)&unpacked->args; \
    glColorMaterial(args->face, args->mode);; \
} while(0)
void glColorMaterial(glColorMaterial_ARG_EXPAND);
packed_call_t *pack_glColorMaterial(glColorMaterial_PACKED *_dst glColorMaterial_ARG_EXPAND_TAIL);
typedef void (*glColorMaterial_PTR)(glColorMaterial_ARG_EXPAND);
#endif
#ifndef glColorP3ui_RETURN
#define glColorP3ui_RETURN void
#define glColorP3ui_ARG_NAMES type, color
#define glColorP3ui_ARG_EXPAND GLenum type, GLuint color
#define glColorP3ui_ARG_NAMES_TAIL , type, color
#define glColorP3ui_ARG_EXPAND_TAIL , GLenum type, GLuint color
#define forward_glColorP3ui(_type, _color) \
    ({ \
        void *dst = remote_dma(sizeof(glColorP3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorP3ui(dst, _type, _color), NULL); \
    });
#define call_glColorP3ui(packed, ret_v) do { \
    glColorP3ui_PACKED *unpacked = (glColorP3ui_PACKED *)packed; \
    glColorP3ui_ARGS *args = (glColorP3ui_ARGS *)&unpacked->args; \
    glColorP3ui(args->type, args->color);; \
} while(0)
void glColorP3ui(glColorP3ui_ARG_EXPAND);
packed_call_t *pack_glColorP3ui(glColorP3ui_PACKED *_dst glColorP3ui_ARG_EXPAND_TAIL);
typedef void (*glColorP3ui_PTR)(glColorP3ui_ARG_EXPAND);
#endif
#ifndef glColorP3uiv_RETURN
#define glColorP3uiv_RETURN void
#define glColorP3uiv_ARG_NAMES type, color
#define glColorP3uiv_ARG_EXPAND GLenum type, const GLuint * color
#define glColorP3uiv_ARG_NAMES_TAIL , type, color
#define glColorP3uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * color
#define forward_glColorP3uiv(_type, _color) \
    ({ \
        void *dst = remote_dma(sizeof(glColorP3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorP3uiv(dst, _type, _color), NULL); \
    });
#define call_glColorP3uiv(packed, ret_v) do { \
    glColorP3uiv_PACKED *unpacked = (glColorP3uiv_PACKED *)packed; \
    glColorP3uiv_ARGS *args = (glColorP3uiv_ARGS *)&unpacked->args; \
    glColorP3uiv(args->type, args->color);; \
} while(0)
void glColorP3uiv(glColorP3uiv_ARG_EXPAND);
packed_call_t *pack_glColorP3uiv(glColorP3uiv_PACKED *_dst glColorP3uiv_ARG_EXPAND_TAIL);
typedef void (*glColorP3uiv_PTR)(glColorP3uiv_ARG_EXPAND);
#endif
#ifndef glColorP4ui_RETURN
#define glColorP4ui_RETURN void
#define glColorP4ui_ARG_NAMES type, color
#define glColorP4ui_ARG_EXPAND GLenum type, GLuint color
#define glColorP4ui_ARG_NAMES_TAIL , type, color
#define glColorP4ui_ARG_EXPAND_TAIL , GLenum type, GLuint color
#define forward_glColorP4ui(_type, _color) \
    ({ \
        void *dst = remote_dma(sizeof(glColorP4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorP4ui(dst, _type, _color), NULL); \
    });
#define call_glColorP4ui(packed, ret_v) do { \
    glColorP4ui_PACKED *unpacked = (glColorP4ui_PACKED *)packed; \
    glColorP4ui_ARGS *args = (glColorP4ui_ARGS *)&unpacked->args; \
    glColorP4ui(args->type, args->color);; \
} while(0)
void glColorP4ui(glColorP4ui_ARG_EXPAND);
packed_call_t *pack_glColorP4ui(glColorP4ui_PACKED *_dst glColorP4ui_ARG_EXPAND_TAIL);
typedef void (*glColorP4ui_PTR)(glColorP4ui_ARG_EXPAND);
#endif
#ifndef glColorP4uiv_RETURN
#define glColorP4uiv_RETURN void
#define glColorP4uiv_ARG_NAMES type, color
#define glColorP4uiv_ARG_EXPAND GLenum type, const GLuint * color
#define glColorP4uiv_ARG_NAMES_TAIL , type, color
#define glColorP4uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * color
#define forward_glColorP4uiv(_type, _color) \
    ({ \
        void *dst = remote_dma(sizeof(glColorP4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorP4uiv(dst, _type, _color), NULL); \
    });
#define call_glColorP4uiv(packed, ret_v) do { \
    glColorP4uiv_PACKED *unpacked = (glColorP4uiv_PACKED *)packed; \
    glColorP4uiv_ARGS *args = (glColorP4uiv_ARGS *)&unpacked->args; \
    glColorP4uiv(args->type, args->color);; \
} while(0)
void glColorP4uiv(glColorP4uiv_ARG_EXPAND);
packed_call_t *pack_glColorP4uiv(glColorP4uiv_PACKED *_dst glColorP4uiv_ARG_EXPAND_TAIL);
typedef void (*glColorP4uiv_PTR)(glColorP4uiv_ARG_EXPAND);
#endif
#ifndef glColorPointer_RETURN
#define glColorPointer_RETURN void
#define glColorPointer_ARG_NAMES size, type, stride, pointer
#define glColorPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glColorPointer_ARG_NAMES_TAIL , size, type, stride, pointer
#define glColorPointer_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glColorPointer(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glColorPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorPointer(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glColorPointer(packed, ret_v) do { \
    glColorPointer_PACKED *unpacked = (glColorPointer_PACKED *)packed; \
    glColorPointer_ARGS *args = (glColorPointer_ARGS *)&unpacked->args; \
    glColorPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glColorPointer(glColorPointer_ARG_EXPAND);
packed_call_t *pack_glColorPointer(glColorPointer_PACKED *_dst glColorPointer_ARG_EXPAND_TAIL);
typedef void (*glColorPointer_PTR)(glColorPointer_ARG_EXPAND);
#endif
#ifndef glColorPointerEXT_RETURN
#define glColorPointerEXT_RETURN void
#define glColorPointerEXT_ARG_NAMES size, type, stride, count, pointer
#define glColorPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glColorPointerEXT_ARG_NAMES_TAIL , size, type, stride, count, pointer
#define glColorPointerEXT_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define forward_glColorPointerEXT(_size, _type, _stride, _count, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glColorPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorPointerEXT(dst, _size, _type, _stride, _count, _pointer), NULL); \
    });
#define call_glColorPointerEXT(packed, ret_v) do { \
    glColorPointerEXT_PACKED *unpacked = (glColorPointerEXT_PACKED *)packed; \
    glColorPointerEXT_ARGS *args = (glColorPointerEXT_ARGS *)&unpacked->args; \
    glColorPointerEXT(args->size, args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glColorPointerEXT(glColorPointerEXT_ARG_EXPAND);
packed_call_t *pack_glColorPointerEXT(glColorPointerEXT_PACKED *_dst glColorPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glColorPointerEXT_PTR)(glColorPointerEXT_ARG_EXPAND);
#endif
#ifndef glColorPointerListIBM_RETURN
#define glColorPointerListIBM_RETURN void
#define glColorPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glColorPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glColorPointerListIBM_ARG_NAMES_TAIL , size, type, stride, pointer, ptrstride
#define glColorPointerListIBM_ARG_EXPAND_TAIL , GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define forward_glColorPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glColorPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorPointerListIBM(dst, _size, _type, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glColorPointerListIBM(packed, ret_v) do { \
    glColorPointerListIBM_PACKED *unpacked = (glColorPointerListIBM_PACKED *)packed; \
    glColorPointerListIBM_ARGS *args = (glColorPointerListIBM_ARGS *)&unpacked->args; \
    glColorPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glColorPointerListIBM(glColorPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glColorPointerListIBM(glColorPointerListIBM_PACKED *_dst glColorPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glColorPointerListIBM_PTR)(glColorPointerListIBM_ARG_EXPAND);
#endif
#ifndef glColorPointervINTEL_RETURN
#define glColorPointervINTEL_RETURN void
#define glColorPointervINTEL_ARG_NAMES size, type, pointer
#define glColorPointervINTEL_ARG_EXPAND GLint size, GLenum type, const GLvoid * pointer
#define glColorPointervINTEL_ARG_NAMES_TAIL , size, type, pointer
#define glColorPointervINTEL_ARG_EXPAND_TAIL , GLint size, GLenum type, const GLvoid * pointer
#define forward_glColorPointervINTEL(_size, _type, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glColorPointervINTEL_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorPointervINTEL(dst, _size, _type, _pointer), NULL); \
    });
#define call_glColorPointervINTEL(packed, ret_v) do { \
    glColorPointervINTEL_PACKED *unpacked = (glColorPointervINTEL_PACKED *)packed; \
    glColorPointervINTEL_ARGS *args = (glColorPointervINTEL_ARGS *)&unpacked->args; \
    glColorPointervINTEL(args->size, args->type, args->pointer);; \
} while(0)
void glColorPointervINTEL(glColorPointervINTEL_ARG_EXPAND);
packed_call_t *pack_glColorPointervINTEL(glColorPointervINTEL_PACKED *_dst glColorPointervINTEL_ARG_EXPAND_TAIL);
typedef void (*glColorPointervINTEL_PTR)(glColorPointervINTEL_ARG_EXPAND);
#endif
#ifndef glColorSubTable_RETURN
#define glColorSubTable_RETURN void
#define glColorSubTable_ARG_NAMES target, start, count, format, type, data
#define glColorSubTable_ARG_EXPAND GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data
#define glColorSubTable_ARG_NAMES_TAIL , target, start, count, format, type, data
#define glColorSubTable_ARG_EXPAND_TAIL , GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data
#define forward_glColorSubTable(_target, _start, _count, _format, _type, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glColorSubTable_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorSubTable(dst, _target, _start, _count, _format, _type, _data), NULL); \
    });
#define call_glColorSubTable(packed, ret_v) do { \
    glColorSubTable_PACKED *unpacked = (glColorSubTable_PACKED *)packed; \
    glColorSubTable_ARGS *args = (glColorSubTable_ARGS *)&unpacked->args; \
    glColorSubTable(args->target, args->start, args->count, args->format, args->type, args->data);; \
} while(0)
void glColorSubTable(glColorSubTable_ARG_EXPAND);
packed_call_t *pack_glColorSubTable(glColorSubTable_PACKED *_dst glColorSubTable_ARG_EXPAND_TAIL);
typedef void (*glColorSubTable_PTR)(glColorSubTable_ARG_EXPAND);
#endif
#ifndef glColorSubTableEXT_RETURN
#define glColorSubTableEXT_RETURN void
#define glColorSubTableEXT_ARG_NAMES target, start, count, format, type, data
#define glColorSubTableEXT_ARG_EXPAND GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data
#define glColorSubTableEXT_ARG_NAMES_TAIL , target, start, count, format, type, data
#define glColorSubTableEXT_ARG_EXPAND_TAIL , GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data
#define forward_glColorSubTableEXT(_target, _start, _count, _format, _type, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glColorSubTableEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorSubTableEXT(dst, _target, _start, _count, _format, _type, _data), NULL); \
    });
#define call_glColorSubTableEXT(packed, ret_v) do { \
    glColorSubTableEXT_PACKED *unpacked = (glColorSubTableEXT_PACKED *)packed; \
    glColorSubTableEXT_ARGS *args = (glColorSubTableEXT_ARGS *)&unpacked->args; \
    glColorSubTableEXT(args->target, args->start, args->count, args->format, args->type, args->data);; \
} while(0)
void glColorSubTableEXT(glColorSubTableEXT_ARG_EXPAND);
packed_call_t *pack_glColorSubTableEXT(glColorSubTableEXT_PACKED *_dst glColorSubTableEXT_ARG_EXPAND_TAIL);
typedef void (*glColorSubTableEXT_PTR)(glColorSubTableEXT_ARG_EXPAND);
#endif
#ifndef glColorTable_RETURN
#define glColorTable_RETURN void
#define glColorTable_ARG_NAMES target, internalformat, width, format, type, table
#define glColorTable_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define glColorTable_ARG_NAMES_TAIL , target, internalformat, width, format, type, table
#define glColorTable_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define forward_glColorTable(_target, _internalformat, _width, _format, _type, _table) \
    ({ \
        void *dst = remote_dma(sizeof(glColorTable_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorTable(dst, _target, _internalformat, _width, _format, _type, _table), NULL); \
    });
#define call_glColorTable(packed, ret_v) do { \
    glColorTable_PACKED *unpacked = (glColorTable_PACKED *)packed; \
    glColorTable_ARGS *args = (glColorTable_ARGS *)&unpacked->args; \
    glColorTable(args->target, args->internalformat, args->width, args->format, args->type, args->table);; \
} while(0)
void glColorTable(glColorTable_ARG_EXPAND);
packed_call_t *pack_glColorTable(glColorTable_PACKED *_dst glColorTable_ARG_EXPAND_TAIL);
typedef void (*glColorTable_PTR)(glColorTable_ARG_EXPAND);
#endif
#ifndef glColorTableEXT_RETURN
#define glColorTableEXT_RETURN void
#define glColorTableEXT_ARG_NAMES target, internalFormat, width, format, type, table
#define glColorTableEXT_ARG_EXPAND GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define glColorTableEXT_ARG_NAMES_TAIL , target, internalFormat, width, format, type, table
#define glColorTableEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define forward_glColorTableEXT(_target, _internalFormat, _width, _format, _type, _table) \
    ({ \
        void *dst = remote_dma(sizeof(glColorTableEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorTableEXT(dst, _target, _internalFormat, _width, _format, _type, _table), NULL); \
    });
#define call_glColorTableEXT(packed, ret_v) do { \
    glColorTableEXT_PACKED *unpacked = (glColorTableEXT_PACKED *)packed; \
    glColorTableEXT_ARGS *args = (glColorTableEXT_ARGS *)&unpacked->args; \
    glColorTableEXT(args->target, args->internalFormat, args->width, args->format, args->type, args->table);; \
} while(0)
void glColorTableEXT(glColorTableEXT_ARG_EXPAND);
packed_call_t *pack_glColorTableEXT(glColorTableEXT_PACKED *_dst glColorTableEXT_ARG_EXPAND_TAIL);
typedef void (*glColorTableEXT_PTR)(glColorTableEXT_ARG_EXPAND);
#endif
#ifndef glColorTableParameterfv_RETURN
#define glColorTableParameterfv_RETURN void
#define glColorTableParameterfv_ARG_NAMES target, pname, params
#define glColorTableParameterfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glColorTableParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glColorTableParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glColorTableParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glColorTableParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorTableParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glColorTableParameterfv(packed, ret_v) do { \
    glColorTableParameterfv_PACKED *unpacked = (glColorTableParameterfv_PACKED *)packed; \
    glColorTableParameterfv_ARGS *args = (glColorTableParameterfv_ARGS *)&unpacked->args; \
    glColorTableParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameterfv(glColorTableParameterfv_ARG_EXPAND);
packed_call_t *pack_glColorTableParameterfv(glColorTableParameterfv_PACKED *_dst glColorTableParameterfv_ARG_EXPAND_TAIL);
typedef void (*glColorTableParameterfv_PTR)(glColorTableParameterfv_ARG_EXPAND);
#endif
#ifndef glColorTableParameterfvSGI_RETURN
#define glColorTableParameterfvSGI_RETURN void
#define glColorTableParameterfvSGI_ARG_NAMES target, pname, params
#define glColorTableParameterfvSGI_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glColorTableParameterfvSGI_ARG_NAMES_TAIL , target, pname, params
#define glColorTableParameterfvSGI_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glColorTableParameterfvSGI(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glColorTableParameterfvSGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorTableParameterfvSGI(dst, _target, _pname, _params), NULL); \
    });
#define call_glColorTableParameterfvSGI(packed, ret_v) do { \
    glColorTableParameterfvSGI_PACKED *unpacked = (glColorTableParameterfvSGI_PACKED *)packed; \
    glColorTableParameterfvSGI_ARGS *args = (glColorTableParameterfvSGI_ARGS *)&unpacked->args; \
    glColorTableParameterfvSGI(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameterfvSGI(glColorTableParameterfvSGI_ARG_EXPAND);
packed_call_t *pack_glColorTableParameterfvSGI(glColorTableParameterfvSGI_PACKED *_dst glColorTableParameterfvSGI_ARG_EXPAND_TAIL);
typedef void (*glColorTableParameterfvSGI_PTR)(glColorTableParameterfvSGI_ARG_EXPAND);
#endif
#ifndef glColorTableParameteriv_RETURN
#define glColorTableParameteriv_RETURN void
#define glColorTableParameteriv_ARG_NAMES target, pname, params
#define glColorTableParameteriv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glColorTableParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glColorTableParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glColorTableParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glColorTableParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorTableParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glColorTableParameteriv(packed, ret_v) do { \
    glColorTableParameteriv_PACKED *unpacked = (glColorTableParameteriv_PACKED *)packed; \
    glColorTableParameteriv_ARGS *args = (glColorTableParameteriv_ARGS *)&unpacked->args; \
    glColorTableParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameteriv(glColorTableParameteriv_ARG_EXPAND);
packed_call_t *pack_glColorTableParameteriv(glColorTableParameteriv_PACKED *_dst glColorTableParameteriv_ARG_EXPAND_TAIL);
typedef void (*glColorTableParameteriv_PTR)(glColorTableParameteriv_ARG_EXPAND);
#endif
#ifndef glColorTableParameterivSGI_RETURN
#define glColorTableParameterivSGI_RETURN void
#define glColorTableParameterivSGI_ARG_NAMES target, pname, params
#define glColorTableParameterivSGI_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glColorTableParameterivSGI_ARG_NAMES_TAIL , target, pname, params
#define glColorTableParameterivSGI_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glColorTableParameterivSGI(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glColorTableParameterivSGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorTableParameterivSGI(dst, _target, _pname, _params), NULL); \
    });
#define call_glColorTableParameterivSGI(packed, ret_v) do { \
    glColorTableParameterivSGI_PACKED *unpacked = (glColorTableParameterivSGI_PACKED *)packed; \
    glColorTableParameterivSGI_ARGS *args = (glColorTableParameterivSGI_ARGS *)&unpacked->args; \
    glColorTableParameterivSGI(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameterivSGI(glColorTableParameterivSGI_ARG_EXPAND);
packed_call_t *pack_glColorTableParameterivSGI(glColorTableParameterivSGI_PACKED *_dst glColorTableParameterivSGI_ARG_EXPAND_TAIL);
typedef void (*glColorTableParameterivSGI_PTR)(glColorTableParameterivSGI_ARG_EXPAND);
#endif
#ifndef glColorTableSGI_RETURN
#define glColorTableSGI_RETURN void
#define glColorTableSGI_ARG_NAMES target, internalformat, width, format, type, table
#define glColorTableSGI_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define glColorTableSGI_ARG_NAMES_TAIL , target, internalformat, width, format, type, table
#define glColorTableSGI_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define forward_glColorTableSGI(_target, _internalformat, _width, _format, _type, _table) \
    ({ \
        void *dst = remote_dma(sizeof(glColorTableSGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glColorTableSGI(dst, _target, _internalformat, _width, _format, _type, _table), NULL); \
    });
#define call_glColorTableSGI(packed, ret_v) do { \
    glColorTableSGI_PACKED *unpacked = (glColorTableSGI_PACKED *)packed; \
    glColorTableSGI_ARGS *args = (glColorTableSGI_ARGS *)&unpacked->args; \
    glColorTableSGI(args->target, args->internalformat, args->width, args->format, args->type, args->table);; \
} while(0)
void glColorTableSGI(glColorTableSGI_ARG_EXPAND);
packed_call_t *pack_glColorTableSGI(glColorTableSGI_PACKED *_dst glColorTableSGI_ARG_EXPAND_TAIL);
typedef void (*glColorTableSGI_PTR)(glColorTableSGI_ARG_EXPAND);
#endif
#ifndef glCombinerInputNV_RETURN
#define glCombinerInputNV_RETURN void
#define glCombinerInputNV_ARG_NAMES stage, portion, variable, input, mapping, componentUsage
#define glCombinerInputNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage
#define glCombinerInputNV_ARG_NAMES_TAIL , stage, portion, variable, input, mapping, componentUsage
#define glCombinerInputNV_ARG_EXPAND_TAIL , GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage
#define forward_glCombinerInputNV(_stage, _portion, _variable, _input, _mapping, _componentUsage) \
    ({ \
        void *dst = remote_dma(sizeof(glCombinerInputNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCombinerInputNV(dst, _stage, _portion, _variable, _input, _mapping, _componentUsage), NULL); \
    });
#define call_glCombinerInputNV(packed, ret_v) do { \
    glCombinerInputNV_PACKED *unpacked = (glCombinerInputNV_PACKED *)packed; \
    glCombinerInputNV_ARGS *args = (glCombinerInputNV_ARGS *)&unpacked->args; \
    glCombinerInputNV(args->stage, args->portion, args->variable, args->input, args->mapping, args->componentUsage);; \
} while(0)
void glCombinerInputNV(glCombinerInputNV_ARG_EXPAND);
packed_call_t *pack_glCombinerInputNV(glCombinerInputNV_PACKED *_dst glCombinerInputNV_ARG_EXPAND_TAIL);
typedef void (*glCombinerInputNV_PTR)(glCombinerInputNV_ARG_EXPAND);
#endif
#ifndef glCombinerOutputNV_RETURN
#define glCombinerOutputNV_RETURN void
#define glCombinerOutputNV_ARG_NAMES stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum
#define glCombinerOutputNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum
#define glCombinerOutputNV_ARG_NAMES_TAIL , stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum
#define glCombinerOutputNV_ARG_EXPAND_TAIL , GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum
#define forward_glCombinerOutputNV(_stage, _portion, _abOutput, _cdOutput, _sumOutput, _scale, _bias, _abDotProduct, _cdDotProduct, _muxSum) \
    ({ \
        void *dst = remote_dma(sizeof(glCombinerOutputNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCombinerOutputNV(dst, _stage, _portion, _abOutput, _cdOutput, _sumOutput, _scale, _bias, _abDotProduct, _cdDotProduct, _muxSum), NULL); \
    });
#define call_glCombinerOutputNV(packed, ret_v) do { \
    glCombinerOutputNV_PACKED *unpacked = (glCombinerOutputNV_PACKED *)packed; \
    glCombinerOutputNV_ARGS *args = (glCombinerOutputNV_ARGS *)&unpacked->args; \
    glCombinerOutputNV(args->stage, args->portion, args->abOutput, args->cdOutput, args->sumOutput, args->scale, args->bias, args->abDotProduct, args->cdDotProduct, args->muxSum);; \
} while(0)
void glCombinerOutputNV(glCombinerOutputNV_ARG_EXPAND);
packed_call_t *pack_glCombinerOutputNV(glCombinerOutputNV_PACKED *_dst glCombinerOutputNV_ARG_EXPAND_TAIL);
typedef void (*glCombinerOutputNV_PTR)(glCombinerOutputNV_ARG_EXPAND);
#endif
#ifndef glCombinerParameterfNV_RETURN
#define glCombinerParameterfNV_RETURN void
#define glCombinerParameterfNV_ARG_NAMES pname, param
#define glCombinerParameterfNV_ARG_EXPAND GLenum pname, GLfloat param
#define glCombinerParameterfNV_ARG_NAMES_TAIL , pname, param
#define glCombinerParameterfNV_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glCombinerParameterfNV(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glCombinerParameterfNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCombinerParameterfNV(dst, _pname, _param), NULL); \
    });
#define call_glCombinerParameterfNV(packed, ret_v) do { \
    glCombinerParameterfNV_PACKED *unpacked = (glCombinerParameterfNV_PACKED *)packed; \
    glCombinerParameterfNV_ARGS *args = (glCombinerParameterfNV_ARGS *)&unpacked->args; \
    glCombinerParameterfNV(args->pname, args->param);; \
} while(0)
void glCombinerParameterfNV(glCombinerParameterfNV_ARG_EXPAND);
packed_call_t *pack_glCombinerParameterfNV(glCombinerParameterfNV_PACKED *_dst glCombinerParameterfNV_ARG_EXPAND_TAIL);
typedef void (*glCombinerParameterfNV_PTR)(glCombinerParameterfNV_ARG_EXPAND);
#endif
#ifndef glCombinerParameterfvNV_RETURN
#define glCombinerParameterfvNV_RETURN void
#define glCombinerParameterfvNV_ARG_NAMES pname, params
#define glCombinerParameterfvNV_ARG_EXPAND GLenum pname, const GLfloat * params
#define glCombinerParameterfvNV_ARG_NAMES_TAIL , pname, params
#define glCombinerParameterfvNV_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glCombinerParameterfvNV(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glCombinerParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCombinerParameterfvNV(dst, _pname, _params), NULL); \
    });
#define call_glCombinerParameterfvNV(packed, ret_v) do { \
    glCombinerParameterfvNV_PACKED *unpacked = (glCombinerParameterfvNV_PACKED *)packed; \
    glCombinerParameterfvNV_ARGS *args = (glCombinerParameterfvNV_ARGS *)&unpacked->args; \
    glCombinerParameterfvNV(args->pname, args->params);; \
} while(0)
void glCombinerParameterfvNV(glCombinerParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glCombinerParameterfvNV(glCombinerParameterfvNV_PACKED *_dst glCombinerParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glCombinerParameterfvNV_PTR)(glCombinerParameterfvNV_ARG_EXPAND);
#endif
#ifndef glCombinerParameteriNV_RETURN
#define glCombinerParameteriNV_RETURN void
#define glCombinerParameteriNV_ARG_NAMES pname, param
#define glCombinerParameteriNV_ARG_EXPAND GLenum pname, GLint param
#define glCombinerParameteriNV_ARG_NAMES_TAIL , pname, param
#define glCombinerParameteriNV_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glCombinerParameteriNV(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glCombinerParameteriNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCombinerParameteriNV(dst, _pname, _param), NULL); \
    });
#define call_glCombinerParameteriNV(packed, ret_v) do { \
    glCombinerParameteriNV_PACKED *unpacked = (glCombinerParameteriNV_PACKED *)packed; \
    glCombinerParameteriNV_ARGS *args = (glCombinerParameteriNV_ARGS *)&unpacked->args; \
    glCombinerParameteriNV(args->pname, args->param);; \
} while(0)
void glCombinerParameteriNV(glCombinerParameteriNV_ARG_EXPAND);
packed_call_t *pack_glCombinerParameteriNV(glCombinerParameteriNV_PACKED *_dst glCombinerParameteriNV_ARG_EXPAND_TAIL);
typedef void (*glCombinerParameteriNV_PTR)(glCombinerParameteriNV_ARG_EXPAND);
#endif
#ifndef glCombinerParameterivNV_RETURN
#define glCombinerParameterivNV_RETURN void
#define glCombinerParameterivNV_ARG_NAMES pname, params
#define glCombinerParameterivNV_ARG_EXPAND GLenum pname, const GLint * params
#define glCombinerParameterivNV_ARG_NAMES_TAIL , pname, params
#define glCombinerParameterivNV_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glCombinerParameterivNV(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glCombinerParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCombinerParameterivNV(dst, _pname, _params), NULL); \
    });
#define call_glCombinerParameterivNV(packed, ret_v) do { \
    glCombinerParameterivNV_PACKED *unpacked = (glCombinerParameterivNV_PACKED *)packed; \
    glCombinerParameterivNV_ARGS *args = (glCombinerParameterivNV_ARGS *)&unpacked->args; \
    glCombinerParameterivNV(args->pname, args->params);; \
} while(0)
void glCombinerParameterivNV(glCombinerParameterivNV_ARG_EXPAND);
packed_call_t *pack_glCombinerParameterivNV(glCombinerParameterivNV_PACKED *_dst glCombinerParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glCombinerParameterivNV_PTR)(glCombinerParameterivNV_ARG_EXPAND);
#endif
#ifndef glCombinerStageParameterfvNV_RETURN
#define glCombinerStageParameterfvNV_RETURN void
#define glCombinerStageParameterfvNV_ARG_NAMES stage, pname, params
#define glCombinerStageParameterfvNV_ARG_EXPAND GLenum stage, GLenum pname, const GLfloat * params
#define glCombinerStageParameterfvNV_ARG_NAMES_TAIL , stage, pname, params
#define glCombinerStageParameterfvNV_ARG_EXPAND_TAIL , GLenum stage, GLenum pname, const GLfloat * params
#define forward_glCombinerStageParameterfvNV(_stage, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glCombinerStageParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCombinerStageParameterfvNV(dst, _stage, _pname, _params), NULL); \
    });
#define call_glCombinerStageParameterfvNV(packed, ret_v) do { \
    glCombinerStageParameterfvNV_PACKED *unpacked = (glCombinerStageParameterfvNV_PACKED *)packed; \
    glCombinerStageParameterfvNV_ARGS *args = (glCombinerStageParameterfvNV_ARGS *)&unpacked->args; \
    glCombinerStageParameterfvNV(args->stage, args->pname, args->params);; \
} while(0)
void glCombinerStageParameterfvNV(glCombinerStageParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glCombinerStageParameterfvNV(glCombinerStageParameterfvNV_PACKED *_dst glCombinerStageParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glCombinerStageParameterfvNV_PTR)(glCombinerStageParameterfvNV_ARG_EXPAND);
#endif
#ifndef glCompileShader_RETURN
#define glCompileShader_RETURN void
#define glCompileShader_ARG_NAMES shader
#define glCompileShader_ARG_EXPAND GLuint shader
#define glCompileShader_ARG_NAMES_TAIL , shader
#define glCompileShader_ARG_EXPAND_TAIL , GLuint shader
#define forward_glCompileShader(_shader) \
    ({ \
        void *dst = remote_dma(sizeof(glCompileShader_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompileShader(dst, _shader), NULL); \
    });
#define call_glCompileShader(packed, ret_v) do { \
    glCompileShader_PACKED *unpacked = (glCompileShader_PACKED *)packed; \
    glCompileShader_ARGS *args = (glCompileShader_ARGS *)&unpacked->args; \
    glCompileShader(args->shader);; \
} while(0)
void glCompileShader(glCompileShader_ARG_EXPAND);
packed_call_t *pack_glCompileShader(glCompileShader_PACKED *_dst glCompileShader_ARG_EXPAND_TAIL);
typedef void (*glCompileShader_PTR)(glCompileShader_ARG_EXPAND);
#endif
#ifndef glCompileShaderARB_RETURN
#define glCompileShaderARB_RETURN void
#define glCompileShaderARB_ARG_NAMES shaderObj
#define glCompileShaderARB_ARG_EXPAND GLhandleARB shaderObj
#define glCompileShaderARB_ARG_NAMES_TAIL , shaderObj
#define glCompileShaderARB_ARG_EXPAND_TAIL , GLhandleARB shaderObj
#define forward_glCompileShaderARB(_shaderObj) \
    ({ \
        void *dst = remote_dma(sizeof(glCompileShaderARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompileShaderARB(dst, _shaderObj), NULL); \
    });
#define call_glCompileShaderARB(packed, ret_v) do { \
    glCompileShaderARB_PACKED *unpacked = (glCompileShaderARB_PACKED *)packed; \
    glCompileShaderARB_ARGS *args = (glCompileShaderARB_ARGS *)&unpacked->args; \
    glCompileShaderARB(args->shaderObj);; \
} while(0)
void glCompileShaderARB(glCompileShaderARB_ARG_EXPAND);
packed_call_t *pack_glCompileShaderARB(glCompileShaderARB_PACKED *_dst glCompileShaderARB_ARG_EXPAND_TAIL);
typedef void (*glCompileShaderARB_PTR)(glCompileShaderARB_ARG_EXPAND);
#endif
#ifndef glCompileShaderIncludeARB_RETURN
#define glCompileShaderIncludeARB_RETURN void
#define glCompileShaderIncludeARB_ARG_NAMES shader, count, path, length
#define glCompileShaderIncludeARB_ARG_EXPAND GLuint shader, GLsizei count, const GLchar * path, const GLint * length
#define glCompileShaderIncludeARB_ARG_NAMES_TAIL , shader, count, path, length
#define glCompileShaderIncludeARB_ARG_EXPAND_TAIL , GLuint shader, GLsizei count, const GLchar * path, const GLint * length
#define forward_glCompileShaderIncludeARB(_shader, _count, _path, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glCompileShaderIncludeARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompileShaderIncludeARB(dst, _shader, _count, _path, _length), NULL); \
    });
#define call_glCompileShaderIncludeARB(packed, ret_v) do { \
    glCompileShaderIncludeARB_PACKED *unpacked = (glCompileShaderIncludeARB_PACKED *)packed; \
    glCompileShaderIncludeARB_ARGS *args = (glCompileShaderIncludeARB_ARGS *)&unpacked->args; \
    glCompileShaderIncludeARB(args->shader, args->count, args->path, args->length);; \
} while(0)
void glCompileShaderIncludeARB(glCompileShaderIncludeARB_ARG_EXPAND);
packed_call_t *pack_glCompileShaderIncludeARB(glCompileShaderIncludeARB_PACKED *_dst glCompileShaderIncludeARB_ARG_EXPAND_TAIL);
typedef void (*glCompileShaderIncludeARB_PTR)(glCompileShaderIncludeARB_ARG_EXPAND);
#endif
#ifndef glCompressedMultiTexImage1DEXT_RETURN
#define glCompressedMultiTexImage1DEXT_RETURN void
#define glCompressedMultiTexImage1DEXT_ARG_NAMES texunit, target, level, internalformat, width, border, imageSize, bits
#define glCompressedMultiTexImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexImage1DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, width, border, imageSize, bits
#define glCompressedMultiTexImage1DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedMultiTexImage1DEXT(_texunit, _target, _level, _internalformat, _width, _border, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedMultiTexImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedMultiTexImage1DEXT(dst, _texunit, _target, _level, _internalformat, _width, _border, _imageSize, _bits), NULL); \
    });
#define call_glCompressedMultiTexImage1DEXT(packed, ret_v) do { \
    glCompressedMultiTexImage1DEXT_PACKED *unpacked = (glCompressedMultiTexImage1DEXT_PACKED *)packed; \
    glCompressedMultiTexImage1DEXT_ARGS *args = (glCompressedMultiTexImage1DEXT_ARGS *)&unpacked->args; \
    glCompressedMultiTexImage1DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexImage1DEXT(glCompressedMultiTexImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedMultiTexImage1DEXT(glCompressedMultiTexImage1DEXT_PACKED *_dst glCompressedMultiTexImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedMultiTexImage1DEXT_PTR)(glCompressedMultiTexImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedMultiTexImage2DEXT_RETURN
#define glCompressedMultiTexImage2DEXT_RETURN void
#define glCompressedMultiTexImage2DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, border, imageSize, bits
#define glCompressedMultiTexImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexImage2DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, width, height, border, imageSize, bits
#define glCompressedMultiTexImage2DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedMultiTexImage2DEXT(_texunit, _target, _level, _internalformat, _width, _height, _border, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedMultiTexImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedMultiTexImage2DEXT(dst, _texunit, _target, _level, _internalformat, _width, _height, _border, _imageSize, _bits), NULL); \
    });
#define call_glCompressedMultiTexImage2DEXT(packed, ret_v) do { \
    glCompressedMultiTexImage2DEXT_PACKED *unpacked = (glCompressedMultiTexImage2DEXT_PACKED *)packed; \
    glCompressedMultiTexImage2DEXT_ARGS *args = (glCompressedMultiTexImage2DEXT_ARGS *)&unpacked->args; \
    glCompressedMultiTexImage2DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexImage2DEXT(glCompressedMultiTexImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedMultiTexImage2DEXT(glCompressedMultiTexImage2DEXT_PACKED *_dst glCompressedMultiTexImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedMultiTexImage2DEXT_PTR)(glCompressedMultiTexImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedMultiTexImage3DEXT_RETURN
#define glCompressedMultiTexImage3DEXT_RETURN void
#define glCompressedMultiTexImage3DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, depth, border, imageSize, bits
#define glCompressedMultiTexImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexImage3DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, width, height, depth, border, imageSize, bits
#define glCompressedMultiTexImage3DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedMultiTexImage3DEXT(_texunit, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedMultiTexImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedMultiTexImage3DEXT(dst, _texunit, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _bits), NULL); \
    });
#define call_glCompressedMultiTexImage3DEXT(packed, ret_v) do { \
    glCompressedMultiTexImage3DEXT_PACKED *unpacked = (glCompressedMultiTexImage3DEXT_PACKED *)packed; \
    glCompressedMultiTexImage3DEXT_ARGS *args = (glCompressedMultiTexImage3DEXT_ARGS *)&unpacked->args; \
    glCompressedMultiTexImage3DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexImage3DEXT(glCompressedMultiTexImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedMultiTexImage3DEXT(glCompressedMultiTexImage3DEXT_PACKED *_dst glCompressedMultiTexImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedMultiTexImage3DEXT_PTR)(glCompressedMultiTexImage3DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedMultiTexSubImage1DEXT_RETURN
#define glCompressedMultiTexSubImage1DEXT_RETURN void
#define glCompressedMultiTexSubImage1DEXT_ARG_NAMES texunit, target, level, xoffset, width, format, imageSize, bits
#define glCompressedMultiTexSubImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexSubImage1DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, width, format, imageSize, bits
#define glCompressedMultiTexSubImage1DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedMultiTexSubImage1DEXT(_texunit, _target, _level, _xoffset, _width, _format, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedMultiTexSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedMultiTexSubImage1DEXT(dst, _texunit, _target, _level, _xoffset, _width, _format, _imageSize, _bits), NULL); \
    });
#define call_glCompressedMultiTexSubImage1DEXT(packed, ret_v) do { \
    glCompressedMultiTexSubImage1DEXT_PACKED *unpacked = (glCompressedMultiTexSubImage1DEXT_PACKED *)packed; \
    glCompressedMultiTexSubImage1DEXT_ARGS *args = (glCompressedMultiTexSubImage1DEXT_ARGS *)&unpacked->args; \
    glCompressedMultiTexSubImage1DEXT(args->texunit, args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexSubImage1DEXT(glCompressedMultiTexSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedMultiTexSubImage1DEXT(glCompressedMultiTexSubImage1DEXT_PACKED *_dst glCompressedMultiTexSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedMultiTexSubImage1DEXT_PTR)(glCompressedMultiTexSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedMultiTexSubImage2DEXT_RETURN
#define glCompressedMultiTexSubImage2DEXT_RETURN void
#define glCompressedMultiTexSubImage2DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits
#define glCompressedMultiTexSubImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexSubImage2DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits
#define glCompressedMultiTexSubImage2DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedMultiTexSubImage2DEXT(_texunit, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedMultiTexSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedMultiTexSubImage2DEXT(dst, _texunit, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _bits), NULL); \
    });
#define call_glCompressedMultiTexSubImage2DEXT(packed, ret_v) do { \
    glCompressedMultiTexSubImage2DEXT_PACKED *unpacked = (glCompressedMultiTexSubImage2DEXT_PACKED *)packed; \
    glCompressedMultiTexSubImage2DEXT_ARGS *args = (glCompressedMultiTexSubImage2DEXT_ARGS *)&unpacked->args; \
    glCompressedMultiTexSubImage2DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexSubImage2DEXT(glCompressedMultiTexSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedMultiTexSubImage2DEXT(glCompressedMultiTexSubImage2DEXT_PACKED *_dst glCompressedMultiTexSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedMultiTexSubImage2DEXT_PTR)(glCompressedMultiTexSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedMultiTexSubImage3DEXT_RETURN
#define glCompressedMultiTexSubImage3DEXT_RETURN void
#define glCompressedMultiTexSubImage3DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits
#define glCompressedMultiTexSubImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexSubImage3DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits
#define glCompressedMultiTexSubImage3DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedMultiTexSubImage3DEXT(_texunit, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedMultiTexSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedMultiTexSubImage3DEXT(dst, _texunit, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _bits), NULL); \
    });
#define call_glCompressedMultiTexSubImage3DEXT(packed, ret_v) do { \
    glCompressedMultiTexSubImage3DEXT_PACKED *unpacked = (glCompressedMultiTexSubImage3DEXT_PACKED *)packed; \
    glCompressedMultiTexSubImage3DEXT_ARGS *args = (glCompressedMultiTexSubImage3DEXT_ARGS *)&unpacked->args; \
    glCompressedMultiTexSubImage3DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexSubImage3DEXT(glCompressedMultiTexSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedMultiTexSubImage3DEXT(glCompressedMultiTexSubImage3DEXT_PACKED *_dst glCompressedMultiTexSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedMultiTexSubImage3DEXT_PTR)(glCompressedMultiTexSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedTexImage1D_RETURN
#define glCompressedTexImage1D_RETURN void
#define glCompressedTexImage1D_ARG_NAMES target, level, internalformat, width, border, imageSize, data
#define glCompressedTexImage1D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage1D_ARG_NAMES_TAIL , target, level, internalformat, width, border, imageSize, data
#define glCompressedTexImage1D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexImage1D(_target, _level, _internalformat, _width, _border, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexImage1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexImage1D(dst, _target, _level, _internalformat, _width, _border, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexImage1D(packed, ret_v) do { \
    glCompressedTexImage1D_PACKED *unpacked = (glCompressedTexImage1D_PACKED *)packed; \
    glCompressedTexImage1D_ARGS *args = (glCompressedTexImage1D_ARGS *)&unpacked->args; \
    glCompressedTexImage1D(args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage1D(glCompressedTexImage1D_ARG_EXPAND);
packed_call_t *pack_glCompressedTexImage1D(glCompressedTexImage1D_PACKED *_dst glCompressedTexImage1D_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexImage1D_PTR)(glCompressedTexImage1D_ARG_EXPAND);
#endif
#ifndef glCompressedTexImage1DARB_RETURN
#define glCompressedTexImage1DARB_RETURN void
#define glCompressedTexImage1DARB_ARG_NAMES target, level, internalformat, width, border, imageSize, data
#define glCompressedTexImage1DARB_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage1DARB_ARG_NAMES_TAIL , target, level, internalformat, width, border, imageSize, data
#define glCompressedTexImage1DARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexImage1DARB(_target, _level, _internalformat, _width, _border, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexImage1DARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexImage1DARB(dst, _target, _level, _internalformat, _width, _border, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexImage1DARB(packed, ret_v) do { \
    glCompressedTexImage1DARB_PACKED *unpacked = (glCompressedTexImage1DARB_PACKED *)packed; \
    glCompressedTexImage1DARB_ARGS *args = (glCompressedTexImage1DARB_ARGS *)&unpacked->args; \
    glCompressedTexImage1DARB(args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage1DARB(glCompressedTexImage1DARB_ARG_EXPAND);
packed_call_t *pack_glCompressedTexImage1DARB(glCompressedTexImage1DARB_PACKED *_dst glCompressedTexImage1DARB_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexImage1DARB_PTR)(glCompressedTexImage1DARB_ARG_EXPAND);
#endif
#ifndef glCompressedTexImage2D_RETURN
#define glCompressedTexImage2D_RETURN void
#define glCompressedTexImage2D_ARG_NAMES target, level, internalformat, width, height, border, imageSize, data
#define glCompressedTexImage2D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage2D_ARG_NAMES_TAIL , target, level, internalformat, width, height, border, imageSize, data
#define glCompressedTexImage2D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexImage2D(_target, _level, _internalformat, _width, _height, _border, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexImage2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexImage2D(dst, _target, _level, _internalformat, _width, _height, _border, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexImage2D(packed, ret_v) do { \
    glCompressedTexImage2D_PACKED *unpacked = (glCompressedTexImage2D_PACKED *)packed; \
    glCompressedTexImage2D_ARGS *args = (glCompressedTexImage2D_ARGS *)&unpacked->args; \
    glCompressedTexImage2D(args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage2D(glCompressedTexImage2D_ARG_EXPAND);
packed_call_t *pack_glCompressedTexImage2D(glCompressedTexImage2D_PACKED *_dst glCompressedTexImage2D_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexImage2D_PTR)(glCompressedTexImage2D_ARG_EXPAND);
#endif
#ifndef glCompressedTexImage2DARB_RETURN
#define glCompressedTexImage2DARB_RETURN void
#define glCompressedTexImage2DARB_ARG_NAMES target, level, internalformat, width, height, border, imageSize, data
#define glCompressedTexImage2DARB_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage2DARB_ARG_NAMES_TAIL , target, level, internalformat, width, height, border, imageSize, data
#define glCompressedTexImage2DARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexImage2DARB(_target, _level, _internalformat, _width, _height, _border, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexImage2DARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexImage2DARB(dst, _target, _level, _internalformat, _width, _height, _border, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexImage2DARB(packed, ret_v) do { \
    glCompressedTexImage2DARB_PACKED *unpacked = (glCompressedTexImage2DARB_PACKED *)packed; \
    glCompressedTexImage2DARB_ARGS *args = (glCompressedTexImage2DARB_ARGS *)&unpacked->args; \
    glCompressedTexImage2DARB(args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage2DARB(glCompressedTexImage2DARB_ARG_EXPAND);
packed_call_t *pack_glCompressedTexImage2DARB(glCompressedTexImage2DARB_PACKED *_dst glCompressedTexImage2DARB_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexImage2DARB_PTR)(glCompressedTexImage2DARB_ARG_EXPAND);
#endif
#ifndef glCompressedTexImage3D_RETURN
#define glCompressedTexImage3D_RETURN void
#define glCompressedTexImage3D_ARG_NAMES target, level, internalformat, width, height, depth, border, imageSize, data
#define glCompressedTexImage3D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage3D_ARG_NAMES_TAIL , target, level, internalformat, width, height, depth, border, imageSize, data
#define glCompressedTexImage3D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexImage3D(_target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexImage3D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexImage3D(dst, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexImage3D(packed, ret_v) do { \
    glCompressedTexImage3D_PACKED *unpacked = (glCompressedTexImage3D_PACKED *)packed; \
    glCompressedTexImage3D_ARGS *args = (glCompressedTexImage3D_ARGS *)&unpacked->args; \
    glCompressedTexImage3D(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage3D(glCompressedTexImage3D_ARG_EXPAND);
packed_call_t *pack_glCompressedTexImage3D(glCompressedTexImage3D_PACKED *_dst glCompressedTexImage3D_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexImage3D_PTR)(glCompressedTexImage3D_ARG_EXPAND);
#endif
#ifndef glCompressedTexImage3DARB_RETURN
#define glCompressedTexImage3DARB_RETURN void
#define glCompressedTexImage3DARB_ARG_NAMES target, level, internalformat, width, height, depth, border, imageSize, data
#define glCompressedTexImage3DARB_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage3DARB_ARG_NAMES_TAIL , target, level, internalformat, width, height, depth, border, imageSize, data
#define glCompressedTexImage3DARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexImage3DARB(_target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexImage3DARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexImage3DARB(dst, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexImage3DARB(packed, ret_v) do { \
    glCompressedTexImage3DARB_PACKED *unpacked = (glCompressedTexImage3DARB_PACKED *)packed; \
    glCompressedTexImage3DARB_ARGS *args = (glCompressedTexImage3DARB_ARGS *)&unpacked->args; \
    glCompressedTexImage3DARB(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage3DARB(glCompressedTexImage3DARB_ARG_EXPAND);
packed_call_t *pack_glCompressedTexImage3DARB(glCompressedTexImage3DARB_PACKED *_dst glCompressedTexImage3DARB_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexImage3DARB_PTR)(glCompressedTexImage3DARB_ARG_EXPAND);
#endif
#ifndef glCompressedTexSubImage1D_RETURN
#define glCompressedTexSubImage1D_RETURN void
#define glCompressedTexSubImage1D_ARG_NAMES target, level, xoffset, width, format, imageSize, data
#define glCompressedTexSubImage1D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage1D_ARG_NAMES_TAIL , target, level, xoffset, width, format, imageSize, data
#define glCompressedTexSubImage1D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexSubImage1D(_target, _level, _xoffset, _width, _format, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexSubImage1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexSubImage1D(dst, _target, _level, _xoffset, _width, _format, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexSubImage1D(packed, ret_v) do { \
    glCompressedTexSubImage1D_PACKED *unpacked = (glCompressedTexSubImage1D_PACKED *)packed; \
    glCompressedTexSubImage1D_ARGS *args = (glCompressedTexSubImage1D_ARGS *)&unpacked->args; \
    glCompressedTexSubImage1D(args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage1D(glCompressedTexSubImage1D_ARG_EXPAND);
packed_call_t *pack_glCompressedTexSubImage1D(glCompressedTexSubImage1D_PACKED *_dst glCompressedTexSubImage1D_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexSubImage1D_PTR)(glCompressedTexSubImage1D_ARG_EXPAND);
#endif
#ifndef glCompressedTexSubImage1DARB_RETURN
#define glCompressedTexSubImage1DARB_RETURN void
#define glCompressedTexSubImage1DARB_ARG_NAMES target, level, xoffset, width, format, imageSize, data
#define glCompressedTexSubImage1DARB_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage1DARB_ARG_NAMES_TAIL , target, level, xoffset, width, format, imageSize, data
#define glCompressedTexSubImage1DARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexSubImage1DARB(_target, _level, _xoffset, _width, _format, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexSubImage1DARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexSubImage1DARB(dst, _target, _level, _xoffset, _width, _format, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexSubImage1DARB(packed, ret_v) do { \
    glCompressedTexSubImage1DARB_PACKED *unpacked = (glCompressedTexSubImage1DARB_PACKED *)packed; \
    glCompressedTexSubImage1DARB_ARGS *args = (glCompressedTexSubImage1DARB_ARGS *)&unpacked->args; \
    glCompressedTexSubImage1DARB(args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage1DARB(glCompressedTexSubImage1DARB_ARG_EXPAND);
packed_call_t *pack_glCompressedTexSubImage1DARB(glCompressedTexSubImage1DARB_PACKED *_dst glCompressedTexSubImage1DARB_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexSubImage1DARB_PTR)(glCompressedTexSubImage1DARB_ARG_EXPAND);
#endif
#ifndef glCompressedTexSubImage2D_RETURN
#define glCompressedTexSubImage2D_RETURN void
#define glCompressedTexSubImage2D_ARG_NAMES target, level, xoffset, yoffset, width, height, format, imageSize, data
#define glCompressedTexSubImage2D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage2D_ARG_NAMES_TAIL , target, level, xoffset, yoffset, width, height, format, imageSize, data
#define glCompressedTexSubImage2D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexSubImage2D(_target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexSubImage2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexSubImage2D(dst, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexSubImage2D(packed, ret_v) do { \
    glCompressedTexSubImage2D_PACKED *unpacked = (glCompressedTexSubImage2D_PACKED *)packed; \
    glCompressedTexSubImage2D_ARGS *args = (glCompressedTexSubImage2D_ARGS *)&unpacked->args; \
    glCompressedTexSubImage2D(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage2D(glCompressedTexSubImage2D_ARG_EXPAND);
packed_call_t *pack_glCompressedTexSubImage2D(glCompressedTexSubImage2D_PACKED *_dst glCompressedTexSubImage2D_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexSubImage2D_PTR)(glCompressedTexSubImage2D_ARG_EXPAND);
#endif
#ifndef glCompressedTexSubImage2DARB_RETURN
#define glCompressedTexSubImage2DARB_RETURN void
#define glCompressedTexSubImage2DARB_ARG_NAMES target, level, xoffset, yoffset, width, height, format, imageSize, data
#define glCompressedTexSubImage2DARB_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage2DARB_ARG_NAMES_TAIL , target, level, xoffset, yoffset, width, height, format, imageSize, data
#define glCompressedTexSubImage2DARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexSubImage2DARB(_target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexSubImage2DARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexSubImage2DARB(dst, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexSubImage2DARB(packed, ret_v) do { \
    glCompressedTexSubImage2DARB_PACKED *unpacked = (glCompressedTexSubImage2DARB_PACKED *)packed; \
    glCompressedTexSubImage2DARB_ARGS *args = (glCompressedTexSubImage2DARB_ARGS *)&unpacked->args; \
    glCompressedTexSubImage2DARB(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage2DARB(glCompressedTexSubImage2DARB_ARG_EXPAND);
packed_call_t *pack_glCompressedTexSubImage2DARB(glCompressedTexSubImage2DARB_PACKED *_dst glCompressedTexSubImage2DARB_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexSubImage2DARB_PTR)(glCompressedTexSubImage2DARB_ARG_EXPAND);
#endif
#ifndef glCompressedTexSubImage3D_RETURN
#define glCompressedTexSubImage3D_RETURN void
#define glCompressedTexSubImage3D_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data
#define glCompressedTexSubImage3D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage3D_ARG_NAMES_TAIL , target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data
#define glCompressedTexSubImage3D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexSubImage3D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexSubImage3D(dst, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexSubImage3D(packed, ret_v) do { \
    glCompressedTexSubImage3D_PACKED *unpacked = (glCompressedTexSubImage3D_PACKED *)packed; \
    glCompressedTexSubImage3D_ARGS *args = (glCompressedTexSubImage3D_ARGS *)&unpacked->args; \
    glCompressedTexSubImage3D(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage3D(glCompressedTexSubImage3D_ARG_EXPAND);
packed_call_t *pack_glCompressedTexSubImage3D(glCompressedTexSubImage3D_PACKED *_dst glCompressedTexSubImage3D_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexSubImage3D_PTR)(glCompressedTexSubImage3D_ARG_EXPAND);
#endif
#ifndef glCompressedTexSubImage3DARB_RETURN
#define glCompressedTexSubImage3DARB_RETURN void
#define glCompressedTexSubImage3DARB_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data
#define glCompressedTexSubImage3DARB_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage3DARB_ARG_NAMES_TAIL , target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data
#define glCompressedTexSubImage3DARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data
#define forward_glCompressedTexSubImage3DARB(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTexSubImage3DARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTexSubImage3DARB(dst, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data), NULL); \
    });
#define call_glCompressedTexSubImage3DARB(packed, ret_v) do { \
    glCompressedTexSubImage3DARB_PACKED *unpacked = (glCompressedTexSubImage3DARB_PACKED *)packed; \
    glCompressedTexSubImage3DARB_ARGS *args = (glCompressedTexSubImage3DARB_ARGS *)&unpacked->args; \
    glCompressedTexSubImage3DARB(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage3DARB(glCompressedTexSubImage3DARB_ARG_EXPAND);
packed_call_t *pack_glCompressedTexSubImage3DARB(glCompressedTexSubImage3DARB_PACKED *_dst glCompressedTexSubImage3DARB_ARG_EXPAND_TAIL);
typedef void (*glCompressedTexSubImage3DARB_PTR)(glCompressedTexSubImage3DARB_ARG_EXPAND);
#endif
#ifndef glCompressedTextureImage1DEXT_RETURN
#define glCompressedTextureImage1DEXT_RETURN void
#define glCompressedTextureImage1DEXT_ARG_NAMES texture, target, level, internalformat, width, border, imageSize, bits
#define glCompressedTextureImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureImage1DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, width, border, imageSize, bits
#define glCompressedTextureImage1DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedTextureImage1DEXT(_texture, _target, _level, _internalformat, _width, _border, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTextureImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTextureImage1DEXT(dst, _texture, _target, _level, _internalformat, _width, _border, _imageSize, _bits), NULL); \
    });
#define call_glCompressedTextureImage1DEXT(packed, ret_v) do { \
    glCompressedTextureImage1DEXT_PACKED *unpacked = (glCompressedTextureImage1DEXT_PACKED *)packed; \
    glCompressedTextureImage1DEXT_ARGS *args = (glCompressedTextureImage1DEXT_ARGS *)&unpacked->args; \
    glCompressedTextureImage1DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureImage1DEXT(glCompressedTextureImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedTextureImage1DEXT(glCompressedTextureImage1DEXT_PACKED *_dst glCompressedTextureImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedTextureImage1DEXT_PTR)(glCompressedTextureImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedTextureImage2DEXT_RETURN
#define glCompressedTextureImage2DEXT_RETURN void
#define glCompressedTextureImage2DEXT_ARG_NAMES texture, target, level, internalformat, width, height, border, imageSize, bits
#define glCompressedTextureImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureImage2DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, width, height, border, imageSize, bits
#define glCompressedTextureImage2DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedTextureImage2DEXT(_texture, _target, _level, _internalformat, _width, _height, _border, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTextureImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTextureImage2DEXT(dst, _texture, _target, _level, _internalformat, _width, _height, _border, _imageSize, _bits), NULL); \
    });
#define call_glCompressedTextureImage2DEXT(packed, ret_v) do { \
    glCompressedTextureImage2DEXT_PACKED *unpacked = (glCompressedTextureImage2DEXT_PACKED *)packed; \
    glCompressedTextureImage2DEXT_ARGS *args = (glCompressedTextureImage2DEXT_ARGS *)&unpacked->args; \
    glCompressedTextureImage2DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureImage2DEXT(glCompressedTextureImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedTextureImage2DEXT(glCompressedTextureImage2DEXT_PACKED *_dst glCompressedTextureImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedTextureImage2DEXT_PTR)(glCompressedTextureImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedTextureImage3DEXT_RETURN
#define glCompressedTextureImage3DEXT_RETURN void
#define glCompressedTextureImage3DEXT_ARG_NAMES texture, target, level, internalformat, width, height, depth, border, imageSize, bits
#define glCompressedTextureImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureImage3DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, width, height, depth, border, imageSize, bits
#define glCompressedTextureImage3DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedTextureImage3DEXT(_texture, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTextureImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTextureImage3DEXT(dst, _texture, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _bits), NULL); \
    });
#define call_glCompressedTextureImage3DEXT(packed, ret_v) do { \
    glCompressedTextureImage3DEXT_PACKED *unpacked = (glCompressedTextureImage3DEXT_PACKED *)packed; \
    glCompressedTextureImage3DEXT_ARGS *args = (glCompressedTextureImage3DEXT_ARGS *)&unpacked->args; \
    glCompressedTextureImage3DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureImage3DEXT(glCompressedTextureImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedTextureImage3DEXT(glCompressedTextureImage3DEXT_PACKED *_dst glCompressedTextureImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedTextureImage3DEXT_PTR)(glCompressedTextureImage3DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedTextureSubImage1DEXT_RETURN
#define glCompressedTextureSubImage1DEXT_RETURN void
#define glCompressedTextureSubImage1DEXT_ARG_NAMES texture, target, level, xoffset, width, format, imageSize, bits
#define glCompressedTextureSubImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureSubImage1DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, width, format, imageSize, bits
#define glCompressedTextureSubImage1DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedTextureSubImage1DEXT(_texture, _target, _level, _xoffset, _width, _format, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTextureSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTextureSubImage1DEXT(dst, _texture, _target, _level, _xoffset, _width, _format, _imageSize, _bits), NULL); \
    });
#define call_glCompressedTextureSubImage1DEXT(packed, ret_v) do { \
    glCompressedTextureSubImage1DEXT_PACKED *unpacked = (glCompressedTextureSubImage1DEXT_PACKED *)packed; \
    glCompressedTextureSubImage1DEXT_ARGS *args = (glCompressedTextureSubImage1DEXT_ARGS *)&unpacked->args; \
    glCompressedTextureSubImage1DEXT(args->texture, args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureSubImage1DEXT(glCompressedTextureSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedTextureSubImage1DEXT(glCompressedTextureSubImage1DEXT_PACKED *_dst glCompressedTextureSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedTextureSubImage1DEXT_PTR)(glCompressedTextureSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedTextureSubImage2DEXT_RETURN
#define glCompressedTextureSubImage2DEXT_RETURN void
#define glCompressedTextureSubImage2DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits
#define glCompressedTextureSubImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureSubImage2DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits
#define glCompressedTextureSubImage2DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedTextureSubImage2DEXT(_texture, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTextureSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTextureSubImage2DEXT(dst, _texture, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _bits), NULL); \
    });
#define call_glCompressedTextureSubImage2DEXT(packed, ret_v) do { \
    glCompressedTextureSubImage2DEXT_PACKED *unpacked = (glCompressedTextureSubImage2DEXT_PACKED *)packed; \
    glCompressedTextureSubImage2DEXT_ARGS *args = (glCompressedTextureSubImage2DEXT_ARGS *)&unpacked->args; \
    glCompressedTextureSubImage2DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureSubImage2DEXT(glCompressedTextureSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedTextureSubImage2DEXT(glCompressedTextureSubImage2DEXT_PACKED *_dst glCompressedTextureSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedTextureSubImage2DEXT_PTR)(glCompressedTextureSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCompressedTextureSubImage3DEXT_RETURN
#define glCompressedTextureSubImage3DEXT_RETURN void
#define glCompressedTextureSubImage3DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits
#define glCompressedTextureSubImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureSubImage3DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits
#define glCompressedTextureSubImage3DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits
#define forward_glCompressedTextureSubImage3DEXT(_texture, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _bits) \
    ({ \
        void *dst = remote_dma(sizeof(glCompressedTextureSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCompressedTextureSubImage3DEXT(dst, _texture, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _bits), NULL); \
    });
#define call_glCompressedTextureSubImage3DEXT(packed, ret_v) do { \
    glCompressedTextureSubImage3DEXT_PACKED *unpacked = (glCompressedTextureSubImage3DEXT_PACKED *)packed; \
    glCompressedTextureSubImage3DEXT_ARGS *args = (glCompressedTextureSubImage3DEXT_ARGS *)&unpacked->args; \
    glCompressedTextureSubImage3DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureSubImage3DEXT(glCompressedTextureSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glCompressedTextureSubImage3DEXT(glCompressedTextureSubImage3DEXT_PACKED *_dst glCompressedTextureSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glCompressedTextureSubImage3DEXT_PTR)(glCompressedTextureSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glConvolutionFilter1D_RETURN
#define glConvolutionFilter1D_RETURN void
#define glConvolutionFilter1D_ARG_NAMES target, internalformat, width, format, type, image
#define glConvolutionFilter1D_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter1D_ARG_NAMES_TAIL , target, internalformat, width, format, type, image
#define glConvolutionFilter1D_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image
#define forward_glConvolutionFilter1D(_target, _internalformat, _width, _format, _type, _image) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionFilter1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionFilter1D(dst, _target, _internalformat, _width, _format, _type, _image), NULL); \
    });
#define call_glConvolutionFilter1D(packed, ret_v) do { \
    glConvolutionFilter1D_PACKED *unpacked = (glConvolutionFilter1D_PACKED *)packed; \
    glConvolutionFilter1D_ARGS *args = (glConvolutionFilter1D_ARGS *)&unpacked->args; \
    glConvolutionFilter1D(args->target, args->internalformat, args->width, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter1D(glConvolutionFilter1D_ARG_EXPAND);
packed_call_t *pack_glConvolutionFilter1D(glConvolutionFilter1D_PACKED *_dst glConvolutionFilter1D_ARG_EXPAND_TAIL);
typedef void (*glConvolutionFilter1D_PTR)(glConvolutionFilter1D_ARG_EXPAND);
#endif
#ifndef glConvolutionFilter1DEXT_RETURN
#define glConvolutionFilter1DEXT_RETURN void
#define glConvolutionFilter1DEXT_ARG_NAMES target, internalformat, width, format, type, image
#define glConvolutionFilter1DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter1DEXT_ARG_NAMES_TAIL , target, internalformat, width, format, type, image
#define glConvolutionFilter1DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image
#define forward_glConvolutionFilter1DEXT(_target, _internalformat, _width, _format, _type, _image) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionFilter1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionFilter1DEXT(dst, _target, _internalformat, _width, _format, _type, _image), NULL); \
    });
#define call_glConvolutionFilter1DEXT(packed, ret_v) do { \
    glConvolutionFilter1DEXT_PACKED *unpacked = (glConvolutionFilter1DEXT_PACKED *)packed; \
    glConvolutionFilter1DEXT_ARGS *args = (glConvolutionFilter1DEXT_ARGS *)&unpacked->args; \
    glConvolutionFilter1DEXT(args->target, args->internalformat, args->width, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter1DEXT(glConvolutionFilter1DEXT_ARG_EXPAND);
packed_call_t *pack_glConvolutionFilter1DEXT(glConvolutionFilter1DEXT_PACKED *_dst glConvolutionFilter1DEXT_ARG_EXPAND_TAIL);
typedef void (*glConvolutionFilter1DEXT_PTR)(glConvolutionFilter1DEXT_ARG_EXPAND);
#endif
#ifndef glConvolutionFilter2D_RETURN
#define glConvolutionFilter2D_RETURN void
#define glConvolutionFilter2D_ARG_NAMES target, internalformat, width, height, format, type, image
#define glConvolutionFilter2D_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter2D_ARG_NAMES_TAIL , target, internalformat, width, height, format, type, image
#define glConvolutionFilter2D_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image
#define forward_glConvolutionFilter2D(_target, _internalformat, _width, _height, _format, _type, _image) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionFilter2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionFilter2D(dst, _target, _internalformat, _width, _height, _format, _type, _image), NULL); \
    });
#define call_glConvolutionFilter2D(packed, ret_v) do { \
    glConvolutionFilter2D_PACKED *unpacked = (glConvolutionFilter2D_PACKED *)packed; \
    glConvolutionFilter2D_ARGS *args = (glConvolutionFilter2D_ARGS *)&unpacked->args; \
    glConvolutionFilter2D(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter2D(glConvolutionFilter2D_ARG_EXPAND);
packed_call_t *pack_glConvolutionFilter2D(glConvolutionFilter2D_PACKED *_dst glConvolutionFilter2D_ARG_EXPAND_TAIL);
typedef void (*glConvolutionFilter2D_PTR)(glConvolutionFilter2D_ARG_EXPAND);
#endif
#ifndef glConvolutionFilter2DEXT_RETURN
#define glConvolutionFilter2DEXT_RETURN void
#define glConvolutionFilter2DEXT_ARG_NAMES target, internalformat, width, height, format, type, image
#define glConvolutionFilter2DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter2DEXT_ARG_NAMES_TAIL , target, internalformat, width, height, format, type, image
#define glConvolutionFilter2DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image
#define forward_glConvolutionFilter2DEXT(_target, _internalformat, _width, _height, _format, _type, _image) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionFilter2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionFilter2DEXT(dst, _target, _internalformat, _width, _height, _format, _type, _image), NULL); \
    });
#define call_glConvolutionFilter2DEXT(packed, ret_v) do { \
    glConvolutionFilter2DEXT_PACKED *unpacked = (glConvolutionFilter2DEXT_PACKED *)packed; \
    glConvolutionFilter2DEXT_ARGS *args = (glConvolutionFilter2DEXT_ARGS *)&unpacked->args; \
    glConvolutionFilter2DEXT(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter2DEXT(glConvolutionFilter2DEXT_ARG_EXPAND);
packed_call_t *pack_glConvolutionFilter2DEXT(glConvolutionFilter2DEXT_PACKED *_dst glConvolutionFilter2DEXT_ARG_EXPAND_TAIL);
typedef void (*glConvolutionFilter2DEXT_PTR)(glConvolutionFilter2DEXT_ARG_EXPAND);
#endif
#ifndef glConvolutionParameterf_RETURN
#define glConvolutionParameterf_RETURN void
#define glConvolutionParameterf_ARG_NAMES target, pname, params
#define glConvolutionParameterf_ARG_EXPAND GLenum target, GLenum pname, GLfloat params
#define glConvolutionParameterf_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameterf_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat params
#define forward_glConvolutionParameterf(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameterf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameterf(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameterf(packed, ret_v) do { \
    glConvolutionParameterf_PACKED *unpacked = (glConvolutionParameterf_PACKED *)packed; \
    glConvolutionParameterf_ARGS *args = (glConvolutionParameterf_ARGS *)&unpacked->args; \
    glConvolutionParameterf(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterf(glConvolutionParameterf_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameterf(glConvolutionParameterf_PACKED *_dst glConvolutionParameterf_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameterf_PTR)(glConvolutionParameterf_ARG_EXPAND);
#endif
#ifndef glConvolutionParameterfEXT_RETURN
#define glConvolutionParameterfEXT_RETURN void
#define glConvolutionParameterfEXT_ARG_NAMES target, pname, params
#define glConvolutionParameterfEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat params
#define glConvolutionParameterfEXT_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameterfEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat params
#define forward_glConvolutionParameterfEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameterfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameterfEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameterfEXT(packed, ret_v) do { \
    glConvolutionParameterfEXT_PACKED *unpacked = (glConvolutionParameterfEXT_PACKED *)packed; \
    glConvolutionParameterfEXT_ARGS *args = (glConvolutionParameterfEXT_ARGS *)&unpacked->args; \
    glConvolutionParameterfEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterfEXT(glConvolutionParameterfEXT_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameterfEXT(glConvolutionParameterfEXT_PACKED *_dst glConvolutionParameterfEXT_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameterfEXT_PTR)(glConvolutionParameterfEXT_ARG_EXPAND);
#endif
#ifndef glConvolutionParameterfv_RETURN
#define glConvolutionParameterfv_RETURN void
#define glConvolutionParameterfv_ARG_NAMES target, pname, params
#define glConvolutionParameterfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glConvolutionParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glConvolutionParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameterfv(packed, ret_v) do { \
    glConvolutionParameterfv_PACKED *unpacked = (glConvolutionParameterfv_PACKED *)packed; \
    glConvolutionParameterfv_ARGS *args = (glConvolutionParameterfv_ARGS *)&unpacked->args; \
    glConvolutionParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterfv(glConvolutionParameterfv_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameterfv(glConvolutionParameterfv_PACKED *_dst glConvolutionParameterfv_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameterfv_PTR)(glConvolutionParameterfv_ARG_EXPAND);
#endif
#ifndef glConvolutionParameterfvEXT_RETURN
#define glConvolutionParameterfvEXT_RETURN void
#define glConvolutionParameterfvEXT_ARG_NAMES target, pname, params
#define glConvolutionParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glConvolutionParameterfvEXT_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameterfvEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glConvolutionParameterfvEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameterfvEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameterfvEXT(packed, ret_v) do { \
    glConvolutionParameterfvEXT_PACKED *unpacked = (glConvolutionParameterfvEXT_PACKED *)packed; \
    glConvolutionParameterfvEXT_ARGS *args = (glConvolutionParameterfvEXT_ARGS *)&unpacked->args; \
    glConvolutionParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterfvEXT(glConvolutionParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameterfvEXT(glConvolutionParameterfvEXT_PACKED *_dst glConvolutionParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameterfvEXT_PTR)(glConvolutionParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glConvolutionParameteri_RETURN
#define glConvolutionParameteri_RETURN void
#define glConvolutionParameteri_ARG_NAMES target, pname, params
#define glConvolutionParameteri_ARG_EXPAND GLenum target, GLenum pname, GLint params
#define glConvolutionParameteri_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameteri_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint params
#define forward_glConvolutionParameteri(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameteri_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameteri(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameteri(packed, ret_v) do { \
    glConvolutionParameteri_PACKED *unpacked = (glConvolutionParameteri_PACKED *)packed; \
    glConvolutionParameteri_ARGS *args = (glConvolutionParameteri_ARGS *)&unpacked->args; \
    glConvolutionParameteri(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameteri(glConvolutionParameteri_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameteri(glConvolutionParameteri_PACKED *_dst glConvolutionParameteri_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameteri_PTR)(glConvolutionParameteri_ARG_EXPAND);
#endif
#ifndef glConvolutionParameteriEXT_RETURN
#define glConvolutionParameteriEXT_RETURN void
#define glConvolutionParameteriEXT_ARG_NAMES target, pname, params
#define glConvolutionParameteriEXT_ARG_EXPAND GLenum target, GLenum pname, GLint params
#define glConvolutionParameteriEXT_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameteriEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint params
#define forward_glConvolutionParameteriEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameteriEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameteriEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameteriEXT(packed, ret_v) do { \
    glConvolutionParameteriEXT_PACKED *unpacked = (glConvolutionParameteriEXT_PACKED *)packed; \
    glConvolutionParameteriEXT_ARGS *args = (glConvolutionParameteriEXT_ARGS *)&unpacked->args; \
    glConvolutionParameteriEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameteriEXT(glConvolutionParameteriEXT_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameteriEXT(glConvolutionParameteriEXT_PACKED *_dst glConvolutionParameteriEXT_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameteriEXT_PTR)(glConvolutionParameteriEXT_ARG_EXPAND);
#endif
#ifndef glConvolutionParameteriv_RETURN
#define glConvolutionParameteriv_RETURN void
#define glConvolutionParameteriv_ARG_NAMES target, pname, params
#define glConvolutionParameteriv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glConvolutionParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glConvolutionParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameteriv(packed, ret_v) do { \
    glConvolutionParameteriv_PACKED *unpacked = (glConvolutionParameteriv_PACKED *)packed; \
    glConvolutionParameteriv_ARGS *args = (glConvolutionParameteriv_ARGS *)&unpacked->args; \
    glConvolutionParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameteriv(glConvolutionParameteriv_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameteriv(glConvolutionParameteriv_PACKED *_dst glConvolutionParameteriv_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameteriv_PTR)(glConvolutionParameteriv_ARG_EXPAND);
#endif
#ifndef glConvolutionParameterivEXT_RETURN
#define glConvolutionParameterivEXT_RETURN void
#define glConvolutionParameterivEXT_ARG_NAMES target, pname, params
#define glConvolutionParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glConvolutionParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glConvolutionParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameterivEXT(packed, ret_v) do { \
    glConvolutionParameterivEXT_PACKED *unpacked = (glConvolutionParameterivEXT_PACKED *)packed; \
    glConvolutionParameterivEXT_ARGS *args = (glConvolutionParameterivEXT_ARGS *)&unpacked->args; \
    glConvolutionParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterivEXT(glConvolutionParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameterivEXT(glConvolutionParameterivEXT_PACKED *_dst glConvolutionParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameterivEXT_PTR)(glConvolutionParameterivEXT_ARG_EXPAND);
#endif
#ifndef glConvolutionParameterxOES_RETURN
#define glConvolutionParameterxOES_RETURN void
#define glConvolutionParameterxOES_ARG_NAMES target, pname, param
#define glConvolutionParameterxOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glConvolutionParameterxOES_ARG_NAMES_TAIL , target, pname, param
#define glConvolutionParameterxOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfixed param
#define forward_glConvolutionParameterxOES(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameterxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameterxOES(dst, _target, _pname, _param), NULL); \
    });
#define call_glConvolutionParameterxOES(packed, ret_v) do { \
    glConvolutionParameterxOES_PACKED *unpacked = (glConvolutionParameterxOES_PACKED *)packed; \
    glConvolutionParameterxOES_ARGS *args = (glConvolutionParameterxOES_ARGS *)&unpacked->args; \
    glConvolutionParameterxOES(args->target, args->pname, args->param);; \
} while(0)
void glConvolutionParameterxOES(glConvolutionParameterxOES_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameterxOES(glConvolutionParameterxOES_PACKED *_dst glConvolutionParameterxOES_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameterxOES_PTR)(glConvolutionParameterxOES_ARG_EXPAND);
#endif
#ifndef glConvolutionParameterxvOES_RETURN
#define glConvolutionParameterxvOES_RETURN void
#define glConvolutionParameterxvOES_ARG_NAMES target, pname, params
#define glConvolutionParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glConvolutionParameterxvOES_ARG_NAMES_TAIL , target, pname, params
#define glConvolutionParameterxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfixed * params
#define forward_glConvolutionParameterxvOES(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glConvolutionParameterxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glConvolutionParameterxvOES(dst, _target, _pname, _params), NULL); \
    });
#define call_glConvolutionParameterxvOES(packed, ret_v) do { \
    glConvolutionParameterxvOES_PACKED *unpacked = (glConvolutionParameterxvOES_PACKED *)packed; \
    glConvolutionParameterxvOES_ARGS *args = (glConvolutionParameterxvOES_ARGS *)&unpacked->args; \
    glConvolutionParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterxvOES(glConvolutionParameterxvOES_ARG_EXPAND);
packed_call_t *pack_glConvolutionParameterxvOES(glConvolutionParameterxvOES_PACKED *_dst glConvolutionParameterxvOES_ARG_EXPAND_TAIL);
typedef void (*glConvolutionParameterxvOES_PTR)(glConvolutionParameterxvOES_ARG_EXPAND);
#endif
#ifndef glCopyBufferSubData_RETURN
#define glCopyBufferSubData_RETURN void
#define glCopyBufferSubData_ARG_NAMES readTarget, writeTarget, readOffset, writeOffset, size
#define glCopyBufferSubData_ARG_EXPAND GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size
#define glCopyBufferSubData_ARG_NAMES_TAIL , readTarget, writeTarget, readOffset, writeOffset, size
#define glCopyBufferSubData_ARG_EXPAND_TAIL , GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size
#define forward_glCopyBufferSubData(_readTarget, _writeTarget, _readOffset, _writeOffset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyBufferSubData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyBufferSubData(dst, _readTarget, _writeTarget, _readOffset, _writeOffset, _size), NULL); \
    });
#define call_glCopyBufferSubData(packed, ret_v) do { \
    glCopyBufferSubData_PACKED *unpacked = (glCopyBufferSubData_PACKED *)packed; \
    glCopyBufferSubData_ARGS *args = (glCopyBufferSubData_ARGS *)&unpacked->args; \
    glCopyBufferSubData(args->readTarget, args->writeTarget, args->readOffset, args->writeOffset, args->size);; \
} while(0)
void glCopyBufferSubData(glCopyBufferSubData_ARG_EXPAND);
packed_call_t *pack_glCopyBufferSubData(glCopyBufferSubData_PACKED *_dst glCopyBufferSubData_ARG_EXPAND_TAIL);
typedef void (*glCopyBufferSubData_PTR)(glCopyBufferSubData_ARG_EXPAND);
#endif
#ifndef glCopyColorSubTable_RETURN
#define glCopyColorSubTable_RETURN void
#define glCopyColorSubTable_ARG_NAMES target, start, x, y, width
#define glCopyColorSubTable_ARG_EXPAND GLenum target, GLsizei start, GLint x, GLint y, GLsizei width
#define glCopyColorSubTable_ARG_NAMES_TAIL , target, start, x, y, width
#define glCopyColorSubTable_ARG_EXPAND_TAIL , GLenum target, GLsizei start, GLint x, GLint y, GLsizei width
#define forward_glCopyColorSubTable(_target, _start, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyColorSubTable_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyColorSubTable(dst, _target, _start, _x, _y, _width), NULL); \
    });
#define call_glCopyColorSubTable(packed, ret_v) do { \
    glCopyColorSubTable_PACKED *unpacked = (glCopyColorSubTable_PACKED *)packed; \
    glCopyColorSubTable_ARGS *args = (glCopyColorSubTable_ARGS *)&unpacked->args; \
    glCopyColorSubTable(args->target, args->start, args->x, args->y, args->width);; \
} while(0)
void glCopyColorSubTable(glCopyColorSubTable_ARG_EXPAND);
packed_call_t *pack_glCopyColorSubTable(glCopyColorSubTable_PACKED *_dst glCopyColorSubTable_ARG_EXPAND_TAIL);
typedef void (*glCopyColorSubTable_PTR)(glCopyColorSubTable_ARG_EXPAND);
#endif
#ifndef glCopyColorSubTableEXT_RETURN
#define glCopyColorSubTableEXT_RETURN void
#define glCopyColorSubTableEXT_ARG_NAMES target, start, x, y, width
#define glCopyColorSubTableEXT_ARG_EXPAND GLenum target, GLsizei start, GLint x, GLint y, GLsizei width
#define glCopyColorSubTableEXT_ARG_NAMES_TAIL , target, start, x, y, width
#define glCopyColorSubTableEXT_ARG_EXPAND_TAIL , GLenum target, GLsizei start, GLint x, GLint y, GLsizei width
#define forward_glCopyColorSubTableEXT(_target, _start, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyColorSubTableEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyColorSubTableEXT(dst, _target, _start, _x, _y, _width), NULL); \
    });
#define call_glCopyColorSubTableEXT(packed, ret_v) do { \
    glCopyColorSubTableEXT_PACKED *unpacked = (glCopyColorSubTableEXT_PACKED *)packed; \
    glCopyColorSubTableEXT_ARGS *args = (glCopyColorSubTableEXT_ARGS *)&unpacked->args; \
    glCopyColorSubTableEXT(args->target, args->start, args->x, args->y, args->width);; \
} while(0)
void glCopyColorSubTableEXT(glCopyColorSubTableEXT_ARG_EXPAND);
packed_call_t *pack_glCopyColorSubTableEXT(glCopyColorSubTableEXT_PACKED *_dst glCopyColorSubTableEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyColorSubTableEXT_PTR)(glCopyColorSubTableEXT_ARG_EXPAND);
#endif
#ifndef glCopyColorTable_RETURN
#define glCopyColorTable_RETURN void
#define glCopyColorTable_ARG_NAMES target, internalformat, x, y, width
#define glCopyColorTable_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyColorTable_ARG_NAMES_TAIL , target, internalformat, x, y, width
#define glCopyColorTable_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define forward_glCopyColorTable(_target, _internalformat, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyColorTable_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyColorTable(dst, _target, _internalformat, _x, _y, _width), NULL); \
    });
#define call_glCopyColorTable(packed, ret_v) do { \
    glCopyColorTable_PACKED *unpacked = (glCopyColorTable_PACKED *)packed; \
    glCopyColorTable_ARGS *args = (glCopyColorTable_ARGS *)&unpacked->args; \
    glCopyColorTable(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyColorTable(glCopyColorTable_ARG_EXPAND);
packed_call_t *pack_glCopyColorTable(glCopyColorTable_PACKED *_dst glCopyColorTable_ARG_EXPAND_TAIL);
typedef void (*glCopyColorTable_PTR)(glCopyColorTable_ARG_EXPAND);
#endif
#ifndef glCopyColorTableSGI_RETURN
#define glCopyColorTableSGI_RETURN void
#define glCopyColorTableSGI_ARG_NAMES target, internalformat, x, y, width
#define glCopyColorTableSGI_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyColorTableSGI_ARG_NAMES_TAIL , target, internalformat, x, y, width
#define glCopyColorTableSGI_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define forward_glCopyColorTableSGI(_target, _internalformat, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyColorTableSGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyColorTableSGI(dst, _target, _internalformat, _x, _y, _width), NULL); \
    });
#define call_glCopyColorTableSGI(packed, ret_v) do { \
    glCopyColorTableSGI_PACKED *unpacked = (glCopyColorTableSGI_PACKED *)packed; \
    glCopyColorTableSGI_ARGS *args = (glCopyColorTableSGI_ARGS *)&unpacked->args; \
    glCopyColorTableSGI(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyColorTableSGI(glCopyColorTableSGI_ARG_EXPAND);
packed_call_t *pack_glCopyColorTableSGI(glCopyColorTableSGI_PACKED *_dst glCopyColorTableSGI_ARG_EXPAND_TAIL);
typedef void (*glCopyColorTableSGI_PTR)(glCopyColorTableSGI_ARG_EXPAND);
#endif
#ifndef glCopyConvolutionFilter1D_RETURN
#define glCopyConvolutionFilter1D_RETURN void
#define glCopyConvolutionFilter1D_ARG_NAMES target, internalformat, x, y, width
#define glCopyConvolutionFilter1D_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyConvolutionFilter1D_ARG_NAMES_TAIL , target, internalformat, x, y, width
#define glCopyConvolutionFilter1D_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define forward_glCopyConvolutionFilter1D(_target, _internalformat, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyConvolutionFilter1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyConvolutionFilter1D(dst, _target, _internalformat, _x, _y, _width), NULL); \
    });
#define call_glCopyConvolutionFilter1D(packed, ret_v) do { \
    glCopyConvolutionFilter1D_PACKED *unpacked = (glCopyConvolutionFilter1D_PACKED *)packed; \
    glCopyConvolutionFilter1D_ARGS *args = (glCopyConvolutionFilter1D_ARGS *)&unpacked->args; \
    glCopyConvolutionFilter1D(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyConvolutionFilter1D(glCopyConvolutionFilter1D_ARG_EXPAND);
packed_call_t *pack_glCopyConvolutionFilter1D(glCopyConvolutionFilter1D_PACKED *_dst glCopyConvolutionFilter1D_ARG_EXPAND_TAIL);
typedef void (*glCopyConvolutionFilter1D_PTR)(glCopyConvolutionFilter1D_ARG_EXPAND);
#endif
#ifndef glCopyConvolutionFilter1DEXT_RETURN
#define glCopyConvolutionFilter1DEXT_RETURN void
#define glCopyConvolutionFilter1DEXT_ARG_NAMES target, internalformat, x, y, width
#define glCopyConvolutionFilter1DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyConvolutionFilter1DEXT_ARG_NAMES_TAIL , target, internalformat, x, y, width
#define glCopyConvolutionFilter1DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define forward_glCopyConvolutionFilter1DEXT(_target, _internalformat, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyConvolutionFilter1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyConvolutionFilter1DEXT(dst, _target, _internalformat, _x, _y, _width), NULL); \
    });
#define call_glCopyConvolutionFilter1DEXT(packed, ret_v) do { \
    glCopyConvolutionFilter1DEXT_PACKED *unpacked = (glCopyConvolutionFilter1DEXT_PACKED *)packed; \
    glCopyConvolutionFilter1DEXT_ARGS *args = (glCopyConvolutionFilter1DEXT_ARGS *)&unpacked->args; \
    glCopyConvolutionFilter1DEXT(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyConvolutionFilter1DEXT(glCopyConvolutionFilter1DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyConvolutionFilter1DEXT(glCopyConvolutionFilter1DEXT_PACKED *_dst glCopyConvolutionFilter1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyConvolutionFilter1DEXT_PTR)(glCopyConvolutionFilter1DEXT_ARG_EXPAND);
#endif
#ifndef glCopyConvolutionFilter2D_RETURN
#define glCopyConvolutionFilter2D_RETURN void
#define glCopyConvolutionFilter2D_ARG_NAMES target, internalformat, x, y, width, height
#define glCopyConvolutionFilter2D_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyConvolutionFilter2D_ARG_NAMES_TAIL , target, internalformat, x, y, width, height
#define glCopyConvolutionFilter2D_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyConvolutionFilter2D(_target, _internalformat, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyConvolutionFilter2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyConvolutionFilter2D(dst, _target, _internalformat, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyConvolutionFilter2D(packed, ret_v) do { \
    glCopyConvolutionFilter2D_PACKED *unpacked = (glCopyConvolutionFilter2D_PACKED *)packed; \
    glCopyConvolutionFilter2D_ARGS *args = (glCopyConvolutionFilter2D_ARGS *)&unpacked->args; \
    glCopyConvolutionFilter2D(args->target, args->internalformat, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyConvolutionFilter2D(glCopyConvolutionFilter2D_ARG_EXPAND);
packed_call_t *pack_glCopyConvolutionFilter2D(glCopyConvolutionFilter2D_PACKED *_dst glCopyConvolutionFilter2D_ARG_EXPAND_TAIL);
typedef void (*glCopyConvolutionFilter2D_PTR)(glCopyConvolutionFilter2D_ARG_EXPAND);
#endif
#ifndef glCopyConvolutionFilter2DEXT_RETURN
#define glCopyConvolutionFilter2DEXT_RETURN void
#define glCopyConvolutionFilter2DEXT_ARG_NAMES target, internalformat, x, y, width, height
#define glCopyConvolutionFilter2DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyConvolutionFilter2DEXT_ARG_NAMES_TAIL , target, internalformat, x, y, width, height
#define glCopyConvolutionFilter2DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyConvolutionFilter2DEXT(_target, _internalformat, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyConvolutionFilter2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyConvolutionFilter2DEXT(dst, _target, _internalformat, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyConvolutionFilter2DEXT(packed, ret_v) do { \
    glCopyConvolutionFilter2DEXT_PACKED *unpacked = (glCopyConvolutionFilter2DEXT_PACKED *)packed; \
    glCopyConvolutionFilter2DEXT_ARGS *args = (glCopyConvolutionFilter2DEXT_ARGS *)&unpacked->args; \
    glCopyConvolutionFilter2DEXT(args->target, args->internalformat, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyConvolutionFilter2DEXT(glCopyConvolutionFilter2DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyConvolutionFilter2DEXT(glCopyConvolutionFilter2DEXT_PACKED *_dst glCopyConvolutionFilter2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyConvolutionFilter2DEXT_PTR)(glCopyConvolutionFilter2DEXT_ARG_EXPAND);
#endif
#ifndef glCopyImageSubData_RETURN
#define glCopyImageSubData_RETURN void
#define glCopyImageSubData_ARG_NAMES srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth
#define glCopyImageSubData_ARG_EXPAND GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth
#define glCopyImageSubData_ARG_NAMES_TAIL , srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth
#define glCopyImageSubData_ARG_EXPAND_TAIL , GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth
#define forward_glCopyImageSubData(_srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _srcWidth, _srcHeight, _srcDepth) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyImageSubData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyImageSubData(dst, _srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _srcWidth, _srcHeight, _srcDepth), NULL); \
    });
#define call_glCopyImageSubData(packed, ret_v) do { \
    glCopyImageSubData_PACKED *unpacked = (glCopyImageSubData_PACKED *)packed; \
    glCopyImageSubData_ARGS *args = (glCopyImageSubData_ARGS *)&unpacked->args; \
    glCopyImageSubData(args->srcName, args->srcTarget, args->srcLevel, args->srcX, args->srcY, args->srcZ, args->dstName, args->dstTarget, args->dstLevel, args->dstX, args->dstY, args->dstZ, args->srcWidth, args->srcHeight, args->srcDepth);; \
} while(0)
void glCopyImageSubData(glCopyImageSubData_ARG_EXPAND);
packed_call_t *pack_glCopyImageSubData(glCopyImageSubData_PACKED *_dst glCopyImageSubData_ARG_EXPAND_TAIL);
typedef void (*glCopyImageSubData_PTR)(glCopyImageSubData_ARG_EXPAND);
#endif
#ifndef glCopyImageSubDataNV_RETURN
#define glCopyImageSubDataNV_RETURN void
#define glCopyImageSubDataNV_ARG_NAMES srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth
#define glCopyImageSubDataNV_ARG_EXPAND GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth
#define glCopyImageSubDataNV_ARG_NAMES_TAIL , srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth
#define glCopyImageSubDataNV_ARG_EXPAND_TAIL , GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth
#define forward_glCopyImageSubDataNV(_srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _width, _height, _depth) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyImageSubDataNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyImageSubDataNV(dst, _srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _width, _height, _depth), NULL); \
    });
#define call_glCopyImageSubDataNV(packed, ret_v) do { \
    glCopyImageSubDataNV_PACKED *unpacked = (glCopyImageSubDataNV_PACKED *)packed; \
    glCopyImageSubDataNV_ARGS *args = (glCopyImageSubDataNV_ARGS *)&unpacked->args; \
    glCopyImageSubDataNV(args->srcName, args->srcTarget, args->srcLevel, args->srcX, args->srcY, args->srcZ, args->dstName, args->dstTarget, args->dstLevel, args->dstX, args->dstY, args->dstZ, args->width, args->height, args->depth);; \
} while(0)
void glCopyImageSubDataNV(glCopyImageSubDataNV_ARG_EXPAND);
packed_call_t *pack_glCopyImageSubDataNV(glCopyImageSubDataNV_PACKED *_dst glCopyImageSubDataNV_ARG_EXPAND_TAIL);
typedef void (*glCopyImageSubDataNV_PTR)(glCopyImageSubDataNV_ARG_EXPAND);
#endif
#ifndef glCopyMultiTexImage1DEXT_RETURN
#define glCopyMultiTexImage1DEXT_RETURN void
#define glCopyMultiTexImage1DEXT_ARG_NAMES texunit, target, level, internalformat, x, y, width, border
#define glCopyMultiTexImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyMultiTexImage1DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, x, y, width, border
#define glCopyMultiTexImage1DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define forward_glCopyMultiTexImage1DEXT(_texunit, _target, _level, _internalformat, _x, _y, _width, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyMultiTexImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyMultiTexImage1DEXT(dst, _texunit, _target, _level, _internalformat, _x, _y, _width, _border), NULL); \
    });
#define call_glCopyMultiTexImage1DEXT(packed, ret_v) do { \
    glCopyMultiTexImage1DEXT_PACKED *unpacked = (glCopyMultiTexImage1DEXT_PACKED *)packed; \
    glCopyMultiTexImage1DEXT_ARGS *args = (glCopyMultiTexImage1DEXT_ARGS *)&unpacked->args; \
    glCopyMultiTexImage1DEXT(args->texunit, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyMultiTexImage1DEXT(glCopyMultiTexImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyMultiTexImage1DEXT(glCopyMultiTexImage1DEXT_PACKED *_dst glCopyMultiTexImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyMultiTexImage1DEXT_PTR)(glCopyMultiTexImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCopyMultiTexImage2DEXT_RETURN
#define glCopyMultiTexImage2DEXT_RETURN void
#define glCopyMultiTexImage2DEXT_ARG_NAMES texunit, target, level, internalformat, x, y, width, height, border
#define glCopyMultiTexImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyMultiTexImage2DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, x, y, width, height, border
#define glCopyMultiTexImage2DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define forward_glCopyMultiTexImage2DEXT(_texunit, _target, _level, _internalformat, _x, _y, _width, _height, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyMultiTexImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyMultiTexImage2DEXT(dst, _texunit, _target, _level, _internalformat, _x, _y, _width, _height, _border), NULL); \
    });
#define call_glCopyMultiTexImage2DEXT(packed, ret_v) do { \
    glCopyMultiTexImage2DEXT_PACKED *unpacked = (glCopyMultiTexImage2DEXT_PACKED *)packed; \
    glCopyMultiTexImage2DEXT_ARGS *args = (glCopyMultiTexImage2DEXT_ARGS *)&unpacked->args; \
    glCopyMultiTexImage2DEXT(args->texunit, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyMultiTexImage2DEXT(glCopyMultiTexImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyMultiTexImage2DEXT(glCopyMultiTexImage2DEXT_PACKED *_dst glCopyMultiTexImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyMultiTexImage2DEXT_PTR)(glCopyMultiTexImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCopyMultiTexSubImage1DEXT_RETURN
#define glCopyMultiTexSubImage1DEXT_RETURN void
#define glCopyMultiTexSubImage1DEXT_ARG_NAMES texunit, target, level, xoffset, x, y, width
#define glCopyMultiTexSubImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyMultiTexSubImage1DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, x, y, width
#define glCopyMultiTexSubImage1DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define forward_glCopyMultiTexSubImage1DEXT(_texunit, _target, _level, _xoffset, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyMultiTexSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyMultiTexSubImage1DEXT(dst, _texunit, _target, _level, _xoffset, _x, _y, _width), NULL); \
    });
#define call_glCopyMultiTexSubImage1DEXT(packed, ret_v) do { \
    glCopyMultiTexSubImage1DEXT_PACKED *unpacked = (glCopyMultiTexSubImage1DEXT_PACKED *)packed; \
    glCopyMultiTexSubImage1DEXT_ARGS *args = (glCopyMultiTexSubImage1DEXT_ARGS *)&unpacked->args; \
    glCopyMultiTexSubImage1DEXT(args->texunit, args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyMultiTexSubImage1DEXT(glCopyMultiTexSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyMultiTexSubImage1DEXT(glCopyMultiTexSubImage1DEXT_PACKED *_dst glCopyMultiTexSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyMultiTexSubImage1DEXT_PTR)(glCopyMultiTexSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCopyMultiTexSubImage2DEXT_RETURN
#define glCopyMultiTexSubImage2DEXT_RETURN void
#define glCopyMultiTexSubImage2DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, x, y, width, height
#define glCopyMultiTexSubImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyMultiTexSubImage2DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, yoffset, x, y, width, height
#define glCopyMultiTexSubImage2DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyMultiTexSubImage2DEXT(_texunit, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyMultiTexSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyMultiTexSubImage2DEXT(dst, _texunit, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyMultiTexSubImage2DEXT(packed, ret_v) do { \
    glCopyMultiTexSubImage2DEXT_PACKED *unpacked = (glCopyMultiTexSubImage2DEXT_PACKED *)packed; \
    glCopyMultiTexSubImage2DEXT_ARGS *args = (glCopyMultiTexSubImage2DEXT_ARGS *)&unpacked->args; \
    glCopyMultiTexSubImage2DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyMultiTexSubImage2DEXT(glCopyMultiTexSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyMultiTexSubImage2DEXT(glCopyMultiTexSubImage2DEXT_PACKED *_dst glCopyMultiTexSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyMultiTexSubImage2DEXT_PTR)(glCopyMultiTexSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCopyMultiTexSubImage3DEXT_RETURN
#define glCopyMultiTexSubImage3DEXT_RETURN void
#define glCopyMultiTexSubImage3DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyMultiTexSubImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyMultiTexSubImage3DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyMultiTexSubImage3DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyMultiTexSubImage3DEXT(_texunit, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyMultiTexSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyMultiTexSubImage3DEXT(dst, _texunit, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyMultiTexSubImage3DEXT(packed, ret_v) do { \
    glCopyMultiTexSubImage3DEXT_PACKED *unpacked = (glCopyMultiTexSubImage3DEXT_PACKED *)packed; \
    glCopyMultiTexSubImage3DEXT_ARGS *args = (glCopyMultiTexSubImage3DEXT_ARGS *)&unpacked->args; \
    glCopyMultiTexSubImage3DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyMultiTexSubImage3DEXT(glCopyMultiTexSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyMultiTexSubImage3DEXT(glCopyMultiTexSubImage3DEXT_PACKED *_dst glCopyMultiTexSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyMultiTexSubImage3DEXT_PTR)(glCopyMultiTexSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glCopyPathNV_RETURN
#define glCopyPathNV_RETURN void
#define glCopyPathNV_ARG_NAMES resultPath, srcPath
#define glCopyPathNV_ARG_EXPAND GLuint resultPath, GLuint srcPath
#define glCopyPathNV_ARG_NAMES_TAIL , resultPath, srcPath
#define glCopyPathNV_ARG_EXPAND_TAIL , GLuint resultPath, GLuint srcPath
#define forward_glCopyPathNV(_resultPath, _srcPath) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyPathNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyPathNV(dst, _resultPath, _srcPath), NULL); \
    });
#define call_glCopyPathNV(packed, ret_v) do { \
    glCopyPathNV_PACKED *unpacked = (glCopyPathNV_PACKED *)packed; \
    glCopyPathNV_ARGS *args = (glCopyPathNV_ARGS *)&unpacked->args; \
    glCopyPathNV(args->resultPath, args->srcPath);; \
} while(0)
void glCopyPathNV(glCopyPathNV_ARG_EXPAND);
packed_call_t *pack_glCopyPathNV(glCopyPathNV_PACKED *_dst glCopyPathNV_ARG_EXPAND_TAIL);
typedef void (*glCopyPathNV_PTR)(glCopyPathNV_ARG_EXPAND);
#endif
#ifndef glCopyPixels_RETURN
#define glCopyPixels_RETURN void
#define glCopyPixels_ARG_NAMES x, y, width, height, type
#define glCopyPixels_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height, GLenum type
#define glCopyPixels_ARG_NAMES_TAIL , x, y, width, height, type
#define glCopyPixels_ARG_EXPAND_TAIL , GLint x, GLint y, GLsizei width, GLsizei height, GLenum type
#define forward_glCopyPixels(_x, _y, _width, _height, _type) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyPixels_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyPixels(dst, _x, _y, _width, _height, _type), NULL); \
    });
#define call_glCopyPixels(packed, ret_v) do { \
    glCopyPixels_PACKED *unpacked = (glCopyPixels_PACKED *)packed; \
    glCopyPixels_ARGS *args = (glCopyPixels_ARGS *)&unpacked->args; \
    glCopyPixels(args->x, args->y, args->width, args->height, args->type);; \
} while(0)
void glCopyPixels(glCopyPixels_ARG_EXPAND);
packed_call_t *pack_glCopyPixels(glCopyPixels_PACKED *_dst glCopyPixels_ARG_EXPAND_TAIL);
typedef void (*glCopyPixels_PTR)(glCopyPixels_ARG_EXPAND);
#endif
#ifndef glCopyTexImage1D_RETURN
#define glCopyTexImage1D_RETURN void
#define glCopyTexImage1D_ARG_NAMES target, level, internalformat, x, y, width, border
#define glCopyTexImage1D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyTexImage1D_ARG_NAMES_TAIL , target, level, internalformat, x, y, width, border
#define glCopyTexImage1D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define forward_glCopyTexImage1D(_target, _level, _internalformat, _x, _y, _width, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexImage1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexImage1D(dst, _target, _level, _internalformat, _x, _y, _width, _border), NULL); \
    });
#define call_glCopyTexImage1D(packed, ret_v) do { \
    glCopyTexImage1D_PACKED *unpacked = (glCopyTexImage1D_PACKED *)packed; \
    glCopyTexImage1D_ARGS *args = (glCopyTexImage1D_ARGS *)&unpacked->args; \
    glCopyTexImage1D(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyTexImage1D(glCopyTexImage1D_ARG_EXPAND);
packed_call_t *pack_glCopyTexImage1D(glCopyTexImage1D_PACKED *_dst glCopyTexImage1D_ARG_EXPAND_TAIL);
typedef void (*glCopyTexImage1D_PTR)(glCopyTexImage1D_ARG_EXPAND);
#endif
#ifndef glCopyTexImage1DEXT_RETURN
#define glCopyTexImage1DEXT_RETURN void
#define glCopyTexImage1DEXT_ARG_NAMES target, level, internalformat, x, y, width, border
#define glCopyTexImage1DEXT_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyTexImage1DEXT_ARG_NAMES_TAIL , target, level, internalformat, x, y, width, border
#define glCopyTexImage1DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define forward_glCopyTexImage1DEXT(_target, _level, _internalformat, _x, _y, _width, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexImage1DEXT(dst, _target, _level, _internalformat, _x, _y, _width, _border), NULL); \
    });
#define call_glCopyTexImage1DEXT(packed, ret_v) do { \
    glCopyTexImage1DEXT_PACKED *unpacked = (glCopyTexImage1DEXT_PACKED *)packed; \
    glCopyTexImage1DEXT_ARGS *args = (glCopyTexImage1DEXT_ARGS *)&unpacked->args; \
    glCopyTexImage1DEXT(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyTexImage1DEXT(glCopyTexImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTexImage1DEXT(glCopyTexImage1DEXT_PACKED *_dst glCopyTexImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTexImage1DEXT_PTR)(glCopyTexImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTexImage2D_RETURN
#define glCopyTexImage2D_RETURN void
#define glCopyTexImage2D_ARG_NAMES target, level, internalformat, x, y, width, height, border
#define glCopyTexImage2D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyTexImage2D_ARG_NAMES_TAIL , target, level, internalformat, x, y, width, height, border
#define glCopyTexImage2D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define forward_glCopyTexImage2D(_target, _level, _internalformat, _x, _y, _width, _height, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexImage2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexImage2D(dst, _target, _level, _internalformat, _x, _y, _width, _height, _border), NULL); \
    });
#define call_glCopyTexImage2D(packed, ret_v) do { \
    glCopyTexImage2D_PACKED *unpacked = (glCopyTexImage2D_PACKED *)packed; \
    glCopyTexImage2D_ARGS *args = (glCopyTexImage2D_ARGS *)&unpacked->args; \
    glCopyTexImage2D(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyTexImage2D(glCopyTexImage2D_ARG_EXPAND);
packed_call_t *pack_glCopyTexImage2D(glCopyTexImage2D_PACKED *_dst glCopyTexImage2D_ARG_EXPAND_TAIL);
typedef void (*glCopyTexImage2D_PTR)(glCopyTexImage2D_ARG_EXPAND);
#endif
#ifndef glCopyTexImage2DEXT_RETURN
#define glCopyTexImage2DEXT_RETURN void
#define glCopyTexImage2DEXT_ARG_NAMES target, level, internalformat, x, y, width, height, border
#define glCopyTexImage2DEXT_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyTexImage2DEXT_ARG_NAMES_TAIL , target, level, internalformat, x, y, width, height, border
#define glCopyTexImage2DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define forward_glCopyTexImage2DEXT(_target, _level, _internalformat, _x, _y, _width, _height, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexImage2DEXT(dst, _target, _level, _internalformat, _x, _y, _width, _height, _border), NULL); \
    });
#define call_glCopyTexImage2DEXT(packed, ret_v) do { \
    glCopyTexImage2DEXT_PACKED *unpacked = (glCopyTexImage2DEXT_PACKED *)packed; \
    glCopyTexImage2DEXT_ARGS *args = (glCopyTexImage2DEXT_ARGS *)&unpacked->args; \
    glCopyTexImage2DEXT(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyTexImage2DEXT(glCopyTexImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTexImage2DEXT(glCopyTexImage2DEXT_PACKED *_dst glCopyTexImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTexImage2DEXT_PTR)(glCopyTexImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTexSubImage1D_RETURN
#define glCopyTexSubImage1D_RETURN void
#define glCopyTexSubImage1D_ARG_NAMES target, level, xoffset, x, y, width
#define glCopyTexSubImage1D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyTexSubImage1D_ARG_NAMES_TAIL , target, level, xoffset, x, y, width
#define glCopyTexSubImage1D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define forward_glCopyTexSubImage1D(_target, _level, _xoffset, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexSubImage1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexSubImage1D(dst, _target, _level, _xoffset, _x, _y, _width), NULL); \
    });
#define call_glCopyTexSubImage1D(packed, ret_v) do { \
    glCopyTexSubImage1D_PACKED *unpacked = (glCopyTexSubImage1D_PACKED *)packed; \
    glCopyTexSubImage1D_ARGS *args = (glCopyTexSubImage1D_ARGS *)&unpacked->args; \
    glCopyTexSubImage1D(args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyTexSubImage1D(glCopyTexSubImage1D_ARG_EXPAND);
packed_call_t *pack_glCopyTexSubImage1D(glCopyTexSubImage1D_PACKED *_dst glCopyTexSubImage1D_ARG_EXPAND_TAIL);
typedef void (*glCopyTexSubImage1D_PTR)(glCopyTexSubImage1D_ARG_EXPAND);
#endif
#ifndef glCopyTexSubImage1DEXT_RETURN
#define glCopyTexSubImage1DEXT_RETURN void
#define glCopyTexSubImage1DEXT_ARG_NAMES target, level, xoffset, x, y, width
#define glCopyTexSubImage1DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyTexSubImage1DEXT_ARG_NAMES_TAIL , target, level, xoffset, x, y, width
#define glCopyTexSubImage1DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define forward_glCopyTexSubImage1DEXT(_target, _level, _xoffset, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexSubImage1DEXT(dst, _target, _level, _xoffset, _x, _y, _width), NULL); \
    });
#define call_glCopyTexSubImage1DEXT(packed, ret_v) do { \
    glCopyTexSubImage1DEXT_PACKED *unpacked = (glCopyTexSubImage1DEXT_PACKED *)packed; \
    glCopyTexSubImage1DEXT_ARGS *args = (glCopyTexSubImage1DEXT_ARGS *)&unpacked->args; \
    glCopyTexSubImage1DEXT(args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyTexSubImage1DEXT(glCopyTexSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTexSubImage1DEXT(glCopyTexSubImage1DEXT_PACKED *_dst glCopyTexSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTexSubImage1DEXT_PTR)(glCopyTexSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTexSubImage2D_RETURN
#define glCopyTexSubImage2D_RETURN void
#define glCopyTexSubImage2D_ARG_NAMES target, level, xoffset, yoffset, x, y, width, height
#define glCopyTexSubImage2D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage2D_ARG_NAMES_TAIL , target, level, xoffset, yoffset, x, y, width, height
#define glCopyTexSubImage2D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyTexSubImage2D(_target, _level, _xoffset, _yoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexSubImage2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexSubImage2D(dst, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyTexSubImage2D(packed, ret_v) do { \
    glCopyTexSubImage2D_PACKED *unpacked = (glCopyTexSubImage2D_PACKED *)packed; \
    glCopyTexSubImage2D_ARGS *args = (glCopyTexSubImage2D_ARGS *)&unpacked->args; \
    glCopyTexSubImage2D(args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage2D(glCopyTexSubImage2D_ARG_EXPAND);
packed_call_t *pack_glCopyTexSubImage2D(glCopyTexSubImage2D_PACKED *_dst glCopyTexSubImage2D_ARG_EXPAND_TAIL);
typedef void (*glCopyTexSubImage2D_PTR)(glCopyTexSubImage2D_ARG_EXPAND);
#endif
#ifndef glCopyTexSubImage2DEXT_RETURN
#define glCopyTexSubImage2DEXT_RETURN void
#define glCopyTexSubImage2DEXT_ARG_NAMES target, level, xoffset, yoffset, x, y, width, height
#define glCopyTexSubImage2DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage2DEXT_ARG_NAMES_TAIL , target, level, xoffset, yoffset, x, y, width, height
#define glCopyTexSubImage2DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyTexSubImage2DEXT(_target, _level, _xoffset, _yoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexSubImage2DEXT(dst, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyTexSubImage2DEXT(packed, ret_v) do { \
    glCopyTexSubImage2DEXT_PACKED *unpacked = (glCopyTexSubImage2DEXT_PACKED *)packed; \
    glCopyTexSubImage2DEXT_ARGS *args = (glCopyTexSubImage2DEXT_ARGS *)&unpacked->args; \
    glCopyTexSubImage2DEXT(args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage2DEXT(glCopyTexSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTexSubImage2DEXT(glCopyTexSubImage2DEXT_PACKED *_dst glCopyTexSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTexSubImage2DEXT_PTR)(glCopyTexSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTexSubImage3D_RETURN
#define glCopyTexSubImage3D_RETURN void
#define glCopyTexSubImage3D_ARG_NAMES target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTexSubImage3D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage3D_ARG_NAMES_TAIL , target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTexSubImage3D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexSubImage3D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexSubImage3D(dst, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyTexSubImage3D(packed, ret_v) do { \
    glCopyTexSubImage3D_PACKED *unpacked = (glCopyTexSubImage3D_PACKED *)packed; \
    glCopyTexSubImage3D_ARGS *args = (glCopyTexSubImage3D_ARGS *)&unpacked->args; \
    glCopyTexSubImage3D(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage3D(glCopyTexSubImage3D_ARG_EXPAND);
packed_call_t *pack_glCopyTexSubImage3D(glCopyTexSubImage3D_PACKED *_dst glCopyTexSubImage3D_ARG_EXPAND_TAIL);
typedef void (*glCopyTexSubImage3D_PTR)(glCopyTexSubImage3D_ARG_EXPAND);
#endif
#ifndef glCopyTexSubImage3DEXT_RETURN
#define glCopyTexSubImage3DEXT_RETURN void
#define glCopyTexSubImage3DEXT_ARG_NAMES target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTexSubImage3DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage3DEXT_ARG_NAMES_TAIL , target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTexSubImage3DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyTexSubImage3DEXT(_target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTexSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTexSubImage3DEXT(dst, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyTexSubImage3DEXT(packed, ret_v) do { \
    glCopyTexSubImage3DEXT_PACKED *unpacked = (glCopyTexSubImage3DEXT_PACKED *)packed; \
    glCopyTexSubImage3DEXT_ARGS *args = (glCopyTexSubImage3DEXT_ARGS *)&unpacked->args; \
    glCopyTexSubImage3DEXT(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage3DEXT(glCopyTexSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTexSubImage3DEXT(glCopyTexSubImage3DEXT_PACKED *_dst glCopyTexSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTexSubImage3DEXT_PTR)(glCopyTexSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTextureImage1DEXT_RETURN
#define glCopyTextureImage1DEXT_RETURN void
#define glCopyTextureImage1DEXT_ARG_NAMES texture, target, level, internalformat, x, y, width, border
#define glCopyTextureImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyTextureImage1DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, x, y, width, border
#define glCopyTextureImage1DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define forward_glCopyTextureImage1DEXT(_texture, _target, _level, _internalformat, _x, _y, _width, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTextureImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTextureImage1DEXT(dst, _texture, _target, _level, _internalformat, _x, _y, _width, _border), NULL); \
    });
#define call_glCopyTextureImage1DEXT(packed, ret_v) do { \
    glCopyTextureImage1DEXT_PACKED *unpacked = (glCopyTextureImage1DEXT_PACKED *)packed; \
    glCopyTextureImage1DEXT_ARGS *args = (glCopyTextureImage1DEXT_ARGS *)&unpacked->args; \
    glCopyTextureImage1DEXT(args->texture, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyTextureImage1DEXT(glCopyTextureImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTextureImage1DEXT(glCopyTextureImage1DEXT_PACKED *_dst glCopyTextureImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTextureImage1DEXT_PTR)(glCopyTextureImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTextureImage2DEXT_RETURN
#define glCopyTextureImage2DEXT_RETURN void
#define glCopyTextureImage2DEXT_ARG_NAMES texture, target, level, internalformat, x, y, width, height, border
#define glCopyTextureImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyTextureImage2DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, x, y, width, height, border
#define glCopyTextureImage2DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define forward_glCopyTextureImage2DEXT(_texture, _target, _level, _internalformat, _x, _y, _width, _height, _border) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTextureImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTextureImage2DEXT(dst, _texture, _target, _level, _internalformat, _x, _y, _width, _height, _border), NULL); \
    });
#define call_glCopyTextureImage2DEXT(packed, ret_v) do { \
    glCopyTextureImage2DEXT_PACKED *unpacked = (glCopyTextureImage2DEXT_PACKED *)packed; \
    glCopyTextureImage2DEXT_ARGS *args = (glCopyTextureImage2DEXT_ARGS *)&unpacked->args; \
    glCopyTextureImage2DEXT(args->texture, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyTextureImage2DEXT(glCopyTextureImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTextureImage2DEXT(glCopyTextureImage2DEXT_PACKED *_dst glCopyTextureImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTextureImage2DEXT_PTR)(glCopyTextureImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTextureSubImage1DEXT_RETURN
#define glCopyTextureSubImage1DEXT_RETURN void
#define glCopyTextureSubImage1DEXT_ARG_NAMES texture, target, level, xoffset, x, y, width
#define glCopyTextureSubImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyTextureSubImage1DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, x, y, width
#define glCopyTextureSubImage1DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define forward_glCopyTextureSubImage1DEXT(_texture, _target, _level, _xoffset, _x, _y, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTextureSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTextureSubImage1DEXT(dst, _texture, _target, _level, _xoffset, _x, _y, _width), NULL); \
    });
#define call_glCopyTextureSubImage1DEXT(packed, ret_v) do { \
    glCopyTextureSubImage1DEXT_PACKED *unpacked = (glCopyTextureSubImage1DEXT_PACKED *)packed; \
    glCopyTextureSubImage1DEXT_ARGS *args = (glCopyTextureSubImage1DEXT_ARGS *)&unpacked->args; \
    glCopyTextureSubImage1DEXT(args->texture, args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyTextureSubImage1DEXT(glCopyTextureSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTextureSubImage1DEXT(glCopyTextureSubImage1DEXT_PACKED *_dst glCopyTextureSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTextureSubImage1DEXT_PTR)(glCopyTextureSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTextureSubImage2DEXT_RETURN
#define glCopyTextureSubImage2DEXT_RETURN void
#define glCopyTextureSubImage2DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, x, y, width, height
#define glCopyTextureSubImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTextureSubImage2DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, yoffset, x, y, width, height
#define glCopyTextureSubImage2DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyTextureSubImage2DEXT(_texture, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTextureSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTextureSubImage2DEXT(dst, _texture, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyTextureSubImage2DEXT(packed, ret_v) do { \
    glCopyTextureSubImage2DEXT_PACKED *unpacked = (glCopyTextureSubImage2DEXT_PACKED *)packed; \
    glCopyTextureSubImage2DEXT_ARGS *args = (glCopyTextureSubImage2DEXT_ARGS *)&unpacked->args; \
    glCopyTextureSubImage2DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTextureSubImage2DEXT(glCopyTextureSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTextureSubImage2DEXT(glCopyTextureSubImage2DEXT_PACKED *_dst glCopyTextureSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTextureSubImage2DEXT_PTR)(glCopyTextureSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glCopyTextureSubImage3DEXT_RETURN
#define glCopyTextureSubImage3DEXT_RETURN void
#define glCopyTextureSubImage3DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTextureSubImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTextureSubImage3DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTextureSubImage3DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glCopyTextureSubImage3DEXT(_texture, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glCopyTextureSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCopyTextureSubImage3DEXT(dst, _texture, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height), NULL); \
    });
#define call_glCopyTextureSubImage3DEXT(packed, ret_v) do { \
    glCopyTextureSubImage3DEXT_PACKED *unpacked = (glCopyTextureSubImage3DEXT_PACKED *)packed; \
    glCopyTextureSubImage3DEXT_ARGS *args = (glCopyTextureSubImage3DEXT_ARGS *)&unpacked->args; \
    glCopyTextureSubImage3DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTextureSubImage3DEXT(glCopyTextureSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glCopyTextureSubImage3DEXT(glCopyTextureSubImage3DEXT_PACKED *_dst glCopyTextureSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glCopyTextureSubImage3DEXT_PTR)(glCopyTextureSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glCoverFillPathInstancedNV_RETURN
#define glCoverFillPathInstancedNV_RETURN void
#define glCoverFillPathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues
#define glCoverFillPathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues
#define glCoverFillPathInstancedNV_ARG_NAMES_TAIL , numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues
#define glCoverFillPathInstancedNV_ARG_EXPAND_TAIL , GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues
#define forward_glCoverFillPathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _coverMode, _transformType, _transformValues) \
    ({ \
        void *dst = remote_dma(sizeof(glCoverFillPathInstancedNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCoverFillPathInstancedNV(dst, _numPaths, _pathNameType, _paths, _pathBase, _coverMode, _transformType, _transformValues), NULL); \
    });
#define call_glCoverFillPathInstancedNV(packed, ret_v) do { \
    glCoverFillPathInstancedNV_PACKED *unpacked = (glCoverFillPathInstancedNV_PACKED *)packed; \
    glCoverFillPathInstancedNV_ARGS *args = (glCoverFillPathInstancedNV_ARGS *)&unpacked->args; \
    glCoverFillPathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->coverMode, args->transformType, args->transformValues);; \
} while(0)
void glCoverFillPathInstancedNV(glCoverFillPathInstancedNV_ARG_EXPAND);
packed_call_t *pack_glCoverFillPathInstancedNV(glCoverFillPathInstancedNV_PACKED *_dst glCoverFillPathInstancedNV_ARG_EXPAND_TAIL);
typedef void (*glCoverFillPathInstancedNV_PTR)(glCoverFillPathInstancedNV_ARG_EXPAND);
#endif
#ifndef glCoverFillPathNV_RETURN
#define glCoverFillPathNV_RETURN void
#define glCoverFillPathNV_ARG_NAMES path, coverMode
#define glCoverFillPathNV_ARG_EXPAND GLuint path, GLenum coverMode
#define glCoverFillPathNV_ARG_NAMES_TAIL , path, coverMode
#define glCoverFillPathNV_ARG_EXPAND_TAIL , GLuint path, GLenum coverMode
#define forward_glCoverFillPathNV(_path, _coverMode) \
    ({ \
        void *dst = remote_dma(sizeof(glCoverFillPathNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCoverFillPathNV(dst, _path, _coverMode), NULL); \
    });
#define call_glCoverFillPathNV(packed, ret_v) do { \
    glCoverFillPathNV_PACKED *unpacked = (glCoverFillPathNV_PACKED *)packed; \
    glCoverFillPathNV_ARGS *args = (glCoverFillPathNV_ARGS *)&unpacked->args; \
    glCoverFillPathNV(args->path, args->coverMode);; \
} while(0)
void glCoverFillPathNV(glCoverFillPathNV_ARG_EXPAND);
packed_call_t *pack_glCoverFillPathNV(glCoverFillPathNV_PACKED *_dst glCoverFillPathNV_ARG_EXPAND_TAIL);
typedef void (*glCoverFillPathNV_PTR)(glCoverFillPathNV_ARG_EXPAND);
#endif
#ifndef glCoverStrokePathInstancedNV_RETURN
#define glCoverStrokePathInstancedNV_RETURN void
#define glCoverStrokePathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues
#define glCoverStrokePathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues
#define glCoverStrokePathInstancedNV_ARG_NAMES_TAIL , numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues
#define glCoverStrokePathInstancedNV_ARG_EXPAND_TAIL , GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues
#define forward_glCoverStrokePathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _coverMode, _transformType, _transformValues) \
    ({ \
        void *dst = remote_dma(sizeof(glCoverStrokePathInstancedNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCoverStrokePathInstancedNV(dst, _numPaths, _pathNameType, _paths, _pathBase, _coverMode, _transformType, _transformValues), NULL); \
    });
#define call_glCoverStrokePathInstancedNV(packed, ret_v) do { \
    glCoverStrokePathInstancedNV_PACKED *unpacked = (glCoverStrokePathInstancedNV_PACKED *)packed; \
    glCoverStrokePathInstancedNV_ARGS *args = (glCoverStrokePathInstancedNV_ARGS *)&unpacked->args; \
    glCoverStrokePathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->coverMode, args->transformType, args->transformValues);; \
} while(0)
void glCoverStrokePathInstancedNV(glCoverStrokePathInstancedNV_ARG_EXPAND);
packed_call_t *pack_glCoverStrokePathInstancedNV(glCoverStrokePathInstancedNV_PACKED *_dst glCoverStrokePathInstancedNV_ARG_EXPAND_TAIL);
typedef void (*glCoverStrokePathInstancedNV_PTR)(glCoverStrokePathInstancedNV_ARG_EXPAND);
#endif
#ifndef glCoverStrokePathNV_RETURN
#define glCoverStrokePathNV_RETURN void
#define glCoverStrokePathNV_ARG_NAMES path, coverMode
#define glCoverStrokePathNV_ARG_EXPAND GLuint path, GLenum coverMode
#define glCoverStrokePathNV_ARG_NAMES_TAIL , path, coverMode
#define glCoverStrokePathNV_ARG_EXPAND_TAIL , GLuint path, GLenum coverMode
#define forward_glCoverStrokePathNV(_path, _coverMode) \
    ({ \
        void *dst = remote_dma(sizeof(glCoverStrokePathNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCoverStrokePathNV(dst, _path, _coverMode), NULL); \
    });
#define call_glCoverStrokePathNV(packed, ret_v) do { \
    glCoverStrokePathNV_PACKED *unpacked = (glCoverStrokePathNV_PACKED *)packed; \
    glCoverStrokePathNV_ARGS *args = (glCoverStrokePathNV_ARGS *)&unpacked->args; \
    glCoverStrokePathNV(args->path, args->coverMode);; \
} while(0)
void glCoverStrokePathNV(glCoverStrokePathNV_ARG_EXPAND);
packed_call_t *pack_glCoverStrokePathNV(glCoverStrokePathNV_PACKED *_dst glCoverStrokePathNV_ARG_EXPAND_TAIL);
typedef void (*glCoverStrokePathNV_PTR)(glCoverStrokePathNV_ARG_EXPAND);
#endif
#ifndef glCreateProgram_RETURN
#define glCreateProgram_RETURN GLuint
#define glCreateProgram_ARG_NAMES 
#define glCreateProgram_ARG_EXPAND 
#define glCreateProgram_ARG_NAMES_TAIL 
#define glCreateProgram_ARG_EXPAND_TAIL 
#define forward_glCreateProgram() \
    ({ \
        void *dst = remote_dma(sizeof(glCreateProgram_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glCreateProgram(dst), &ret); \
        ret; \
    });
#define call_glCreateProgram(packed, ret_v) do { \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateProgram();; \
    } else { \
        glCreateProgram();; \
    } \
} while(0)
GLuint glCreateProgram(glCreateProgram_ARG_EXPAND);
packed_call_t *pack_glCreateProgram(glCreateProgram_PACKED *_dst glCreateProgram_ARG_EXPAND_TAIL);
typedef GLuint (*glCreateProgram_PTR)(glCreateProgram_ARG_EXPAND);
#endif
#ifndef glCreateProgramObjectARB_RETURN
#define glCreateProgramObjectARB_RETURN GLhandleARB
#define glCreateProgramObjectARB_ARG_NAMES 
#define glCreateProgramObjectARB_ARG_EXPAND 
#define glCreateProgramObjectARB_ARG_NAMES_TAIL 
#define glCreateProgramObjectARB_ARG_EXPAND_TAIL 
#define forward_glCreateProgramObjectARB() \
    ({ \
        void *dst = remote_dma(sizeof(glCreateProgramObjectARB_PACKED)); \
        GLhandleARB ret = (GLhandleARB)0; \
        remote_dma_send((packed_call_t *)pack_glCreateProgramObjectARB(dst), &ret); \
        ret; \
    });
#define call_glCreateProgramObjectARB(packed, ret_v) do { \
    GLhandleARB *ret = (GLhandleARB *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateProgramObjectARB();; \
    } else { \
        glCreateProgramObjectARB();; \
    } \
} while(0)
GLhandleARB glCreateProgramObjectARB(glCreateProgramObjectARB_ARG_EXPAND);
packed_call_t *pack_glCreateProgramObjectARB(glCreateProgramObjectARB_PACKED *_dst glCreateProgramObjectARB_ARG_EXPAND_TAIL);
typedef GLhandleARB (*glCreateProgramObjectARB_PTR)(glCreateProgramObjectARB_ARG_EXPAND);
#endif
#ifndef glCreateShader_RETURN
#define glCreateShader_RETURN GLuint
#define glCreateShader_ARG_NAMES type
#define glCreateShader_ARG_EXPAND GLenum type
#define glCreateShader_ARG_NAMES_TAIL , type
#define glCreateShader_ARG_EXPAND_TAIL , GLenum type
#define forward_glCreateShader(_type) \
    ({ \
        void *dst = remote_dma(sizeof(glCreateShader_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glCreateShader(dst, _type), &ret); \
        ret; \
    });
#define call_glCreateShader(packed, ret_v) do { \
    glCreateShader_PACKED *unpacked = (glCreateShader_PACKED *)packed; \
    glCreateShader_ARGS *args = (glCreateShader_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShader(args->type);; \
    } else { \
        glCreateShader(args->type);; \
    } \
} while(0)
GLuint glCreateShader(glCreateShader_ARG_EXPAND);
packed_call_t *pack_glCreateShader(glCreateShader_PACKED *_dst glCreateShader_ARG_EXPAND_TAIL);
typedef GLuint (*glCreateShader_PTR)(glCreateShader_ARG_EXPAND);
#endif
#ifndef glCreateShaderObjectARB_RETURN
#define glCreateShaderObjectARB_RETURN GLhandleARB
#define glCreateShaderObjectARB_ARG_NAMES shaderType
#define glCreateShaderObjectARB_ARG_EXPAND GLenum shaderType
#define glCreateShaderObjectARB_ARG_NAMES_TAIL , shaderType
#define glCreateShaderObjectARB_ARG_EXPAND_TAIL , GLenum shaderType
#define forward_glCreateShaderObjectARB(_shaderType) \
    ({ \
        void *dst = remote_dma(sizeof(glCreateShaderObjectARB_PACKED)); \
        GLhandleARB ret = (GLhandleARB)0; \
        remote_dma_send((packed_call_t *)pack_glCreateShaderObjectARB(dst, _shaderType), &ret); \
        ret; \
    });
#define call_glCreateShaderObjectARB(packed, ret_v) do { \
    glCreateShaderObjectARB_PACKED *unpacked = (glCreateShaderObjectARB_PACKED *)packed; \
    glCreateShaderObjectARB_ARGS *args = (glCreateShaderObjectARB_ARGS *)&unpacked->args; \
    GLhandleARB *ret = (GLhandleARB *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShaderObjectARB(args->shaderType);; \
    } else { \
        glCreateShaderObjectARB(args->shaderType);; \
    } \
} while(0)
GLhandleARB glCreateShaderObjectARB(glCreateShaderObjectARB_ARG_EXPAND);
packed_call_t *pack_glCreateShaderObjectARB(glCreateShaderObjectARB_PACKED *_dst glCreateShaderObjectARB_ARG_EXPAND_TAIL);
typedef GLhandleARB (*glCreateShaderObjectARB_PTR)(glCreateShaderObjectARB_ARG_EXPAND);
#endif
#ifndef glCreateShaderProgramEXT_RETURN
#define glCreateShaderProgramEXT_RETURN GLuint
#define glCreateShaderProgramEXT_ARG_NAMES type, string
#define glCreateShaderProgramEXT_ARG_EXPAND GLenum type, const GLchar * string
#define glCreateShaderProgramEXT_ARG_NAMES_TAIL , type, string
#define glCreateShaderProgramEXT_ARG_EXPAND_TAIL , GLenum type, const GLchar * string
#define forward_glCreateShaderProgramEXT(_type, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glCreateShaderProgramEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glCreateShaderProgramEXT(dst, _type, _string), &ret); \
        ret; \
    });
#define call_glCreateShaderProgramEXT(packed, ret_v) do { \
    glCreateShaderProgramEXT_PACKED *unpacked = (glCreateShaderProgramEXT_PACKED *)packed; \
    glCreateShaderProgramEXT_ARGS *args = (glCreateShaderProgramEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShaderProgramEXT(args->type, args->string);; \
    } else { \
        glCreateShaderProgramEXT(args->type, args->string);; \
    } \
} while(0)
GLuint glCreateShaderProgramEXT(glCreateShaderProgramEXT_ARG_EXPAND);
packed_call_t *pack_glCreateShaderProgramEXT(glCreateShaderProgramEXT_PACKED *_dst glCreateShaderProgramEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glCreateShaderProgramEXT_PTR)(glCreateShaderProgramEXT_ARG_EXPAND);
#endif
#ifndef glCreateShaderProgramv_RETURN
#define glCreateShaderProgramv_RETURN GLuint
#define glCreateShaderProgramv_ARG_NAMES type, count, strings
#define glCreateShaderProgramv_ARG_EXPAND GLenum type, GLsizei count, GLchar*const * strings
#define glCreateShaderProgramv_ARG_NAMES_TAIL , type, count, strings
#define glCreateShaderProgramv_ARG_EXPAND_TAIL , GLenum type, GLsizei count, GLchar*const * strings
#define forward_glCreateShaderProgramv(_type, _count, _strings) \
    ({ \
        void *dst = remote_dma(sizeof(glCreateShaderProgramv_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glCreateShaderProgramv(dst, _type, _count, _strings), &ret); \
        ret; \
    });
#define call_glCreateShaderProgramv(packed, ret_v) do { \
    glCreateShaderProgramv_PACKED *unpacked = (glCreateShaderProgramv_PACKED *)packed; \
    glCreateShaderProgramv_ARGS *args = (glCreateShaderProgramv_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShaderProgramv(args->type, args->count, args->strings);; \
    } else { \
        glCreateShaderProgramv(args->type, args->count, args->strings);; \
    } \
} while(0)
GLuint glCreateShaderProgramv(glCreateShaderProgramv_ARG_EXPAND);
packed_call_t *pack_glCreateShaderProgramv(glCreateShaderProgramv_PACKED *_dst glCreateShaderProgramv_ARG_EXPAND_TAIL);
typedef GLuint (*glCreateShaderProgramv_PTR)(glCreateShaderProgramv_ARG_EXPAND);
#endif
#ifndef glCreateSyncFromCLeventARB_RETURN
#define glCreateSyncFromCLeventARB_RETURN GLsync
#define glCreateSyncFromCLeventARB_ARG_NAMES context, event, flags
#define glCreateSyncFromCLeventARB_ARG_EXPAND struct _cl_context * context, struct _cl_event * event, GLbitfield flags
#define glCreateSyncFromCLeventARB_ARG_NAMES_TAIL , context, event, flags
#define glCreateSyncFromCLeventARB_ARG_EXPAND_TAIL , struct _cl_context * context, struct _cl_event * event, GLbitfield flags
#define forward_glCreateSyncFromCLeventARB(_context, _event, _flags) \
    ({ \
        void *dst = remote_dma(sizeof(glCreateSyncFromCLeventARB_PACKED)); \
        GLsync ret = (GLsync)0; \
        remote_dma_send((packed_call_t *)pack_glCreateSyncFromCLeventARB(dst, _context, _event, _flags), &ret); \
        ret; \
    });
#define call_glCreateSyncFromCLeventARB(packed, ret_v) do { \
    glCreateSyncFromCLeventARB_PACKED *unpacked = (glCreateSyncFromCLeventARB_PACKED *)packed; \
    glCreateSyncFromCLeventARB_ARGS *args = (glCreateSyncFromCLeventARB_ARGS *)&unpacked->args; \
    GLsync *ret = (GLsync *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateSyncFromCLeventARB(args->context, args->event, args->flags);; \
    } else { \
        glCreateSyncFromCLeventARB(args->context, args->event, args->flags);; \
    } \
} while(0)
GLsync glCreateSyncFromCLeventARB(glCreateSyncFromCLeventARB_ARG_EXPAND);
packed_call_t *pack_glCreateSyncFromCLeventARB(glCreateSyncFromCLeventARB_PACKED *_dst glCreateSyncFromCLeventARB_ARG_EXPAND_TAIL);
typedef GLsync (*glCreateSyncFromCLeventARB_PTR)(glCreateSyncFromCLeventARB_ARG_EXPAND);
#endif
#ifndef glCullFace_RETURN
#define glCullFace_RETURN void
#define glCullFace_ARG_NAMES mode
#define glCullFace_ARG_EXPAND GLenum mode
#define glCullFace_ARG_NAMES_TAIL , mode
#define glCullFace_ARG_EXPAND_TAIL , GLenum mode
#define forward_glCullFace(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glCullFace_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCullFace(dst, _mode), NULL); \
    });
#define call_glCullFace(packed, ret_v) do { \
    glCullFace_PACKED *unpacked = (glCullFace_PACKED *)packed; \
    glCullFace_ARGS *args = (glCullFace_ARGS *)&unpacked->args; \
    glCullFace(args->mode);; \
} while(0)
void glCullFace(glCullFace_ARG_EXPAND);
packed_call_t *pack_glCullFace(glCullFace_PACKED *_dst glCullFace_ARG_EXPAND_TAIL);
typedef void (*glCullFace_PTR)(glCullFace_ARG_EXPAND);
#endif
#ifndef glCullParameterdvEXT_RETURN
#define glCullParameterdvEXT_RETURN void
#define glCullParameterdvEXT_ARG_NAMES pname, params
#define glCullParameterdvEXT_ARG_EXPAND GLenum pname, GLdouble * params
#define glCullParameterdvEXT_ARG_NAMES_TAIL , pname, params
#define glCullParameterdvEXT_ARG_EXPAND_TAIL , GLenum pname, GLdouble * params
#define forward_glCullParameterdvEXT(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glCullParameterdvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCullParameterdvEXT(dst, _pname, _params), NULL); \
    });
#define call_glCullParameterdvEXT(packed, ret_v) do { \
    glCullParameterdvEXT_PACKED *unpacked = (glCullParameterdvEXT_PACKED *)packed; \
    glCullParameterdvEXT_ARGS *args = (glCullParameterdvEXT_ARGS *)&unpacked->args; \
    glCullParameterdvEXT(args->pname, args->params);; \
} while(0)
void glCullParameterdvEXT(glCullParameterdvEXT_ARG_EXPAND);
packed_call_t *pack_glCullParameterdvEXT(glCullParameterdvEXT_PACKED *_dst glCullParameterdvEXT_ARG_EXPAND_TAIL);
typedef void (*glCullParameterdvEXT_PTR)(glCullParameterdvEXT_ARG_EXPAND);
#endif
#ifndef glCullParameterfvEXT_RETURN
#define glCullParameterfvEXT_RETURN void
#define glCullParameterfvEXT_ARG_NAMES pname, params
#define glCullParameterfvEXT_ARG_EXPAND GLenum pname, GLfloat * params
#define glCullParameterfvEXT_ARG_NAMES_TAIL , pname, params
#define glCullParameterfvEXT_ARG_EXPAND_TAIL , GLenum pname, GLfloat * params
#define forward_glCullParameterfvEXT(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glCullParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCullParameterfvEXT(dst, _pname, _params), NULL); \
    });
#define call_glCullParameterfvEXT(packed, ret_v) do { \
    glCullParameterfvEXT_PACKED *unpacked = (glCullParameterfvEXT_PACKED *)packed; \
    glCullParameterfvEXT_ARGS *args = (glCullParameterfvEXT_ARGS *)&unpacked->args; \
    glCullParameterfvEXT(args->pname, args->params);; \
} while(0)
void glCullParameterfvEXT(glCullParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glCullParameterfvEXT(glCullParameterfvEXT_PACKED *_dst glCullParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glCullParameterfvEXT_PTR)(glCullParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glCurrentPaletteMatrixARB_RETURN
#define glCurrentPaletteMatrixARB_RETURN void
#define glCurrentPaletteMatrixARB_ARG_NAMES index
#define glCurrentPaletteMatrixARB_ARG_EXPAND GLint index
#define glCurrentPaletteMatrixARB_ARG_NAMES_TAIL , index
#define glCurrentPaletteMatrixARB_ARG_EXPAND_TAIL , GLint index
#define forward_glCurrentPaletteMatrixARB(_index) \
    ({ \
        void *dst = remote_dma(sizeof(glCurrentPaletteMatrixARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glCurrentPaletteMatrixARB(dst, _index), NULL); \
    });
#define call_glCurrentPaletteMatrixARB(packed, ret_v) do { \
    glCurrentPaletteMatrixARB_PACKED *unpacked = (glCurrentPaletteMatrixARB_PACKED *)packed; \
    glCurrentPaletteMatrixARB_ARGS *args = (glCurrentPaletteMatrixARB_ARGS *)&unpacked->args; \
    glCurrentPaletteMatrixARB(args->index);; \
} while(0)
void glCurrentPaletteMatrixARB(glCurrentPaletteMatrixARB_ARG_EXPAND);
packed_call_t *pack_glCurrentPaletteMatrixARB(glCurrentPaletteMatrixARB_PACKED *_dst glCurrentPaletteMatrixARB_ARG_EXPAND_TAIL);
typedef void (*glCurrentPaletteMatrixARB_PTR)(glCurrentPaletteMatrixARB_ARG_EXPAND);
#endif
#ifndef glDebugMessageCallback_RETURN
#define glDebugMessageCallback_RETURN void
#define glDebugMessageCallback_ARG_NAMES callback, userParam
#define glDebugMessageCallback_ARG_EXPAND GLDEBUGPROC callback, const void * userParam
#define glDebugMessageCallback_ARG_NAMES_TAIL , callback, userParam
#define glDebugMessageCallback_ARG_EXPAND_TAIL , GLDEBUGPROC callback, const void * userParam
#define forward_glDebugMessageCallback(_callback, _userParam) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageCallback_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageCallback(dst, _callback, _userParam), NULL); \
    });
#define call_glDebugMessageCallback(packed, ret_v) do { \
    glDebugMessageCallback_PACKED *unpacked = (glDebugMessageCallback_PACKED *)packed; \
    glDebugMessageCallback_ARGS *args = (glDebugMessageCallback_ARGS *)&unpacked->args; \
    glDebugMessageCallback(args->callback, args->userParam);; \
} while(0)
void glDebugMessageCallback(glDebugMessageCallback_ARG_EXPAND);
packed_call_t *pack_glDebugMessageCallback(glDebugMessageCallback_PACKED *_dst glDebugMessageCallback_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageCallback_PTR)(glDebugMessageCallback_ARG_EXPAND);
#endif
#ifndef glDebugMessageCallbackAMD_RETURN
#define glDebugMessageCallbackAMD_RETURN void
#define glDebugMessageCallbackAMD_ARG_NAMES callback, userParam
#define glDebugMessageCallbackAMD_ARG_EXPAND GLDEBUGPROCAMD callback, GLvoid * userParam
#define glDebugMessageCallbackAMD_ARG_NAMES_TAIL , callback, userParam
#define glDebugMessageCallbackAMD_ARG_EXPAND_TAIL , GLDEBUGPROCAMD callback, GLvoid * userParam
#define forward_glDebugMessageCallbackAMD(_callback, _userParam) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageCallbackAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageCallbackAMD(dst, _callback, _userParam), NULL); \
    });
#define call_glDebugMessageCallbackAMD(packed, ret_v) do { \
    glDebugMessageCallbackAMD_PACKED *unpacked = (glDebugMessageCallbackAMD_PACKED *)packed; \
    glDebugMessageCallbackAMD_ARGS *args = (glDebugMessageCallbackAMD_ARGS *)&unpacked->args; \
    glDebugMessageCallbackAMD(args->callback, args->userParam);; \
} while(0)
void glDebugMessageCallbackAMD(glDebugMessageCallbackAMD_ARG_EXPAND);
packed_call_t *pack_glDebugMessageCallbackAMD(glDebugMessageCallbackAMD_PACKED *_dst glDebugMessageCallbackAMD_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageCallbackAMD_PTR)(glDebugMessageCallbackAMD_ARG_EXPAND);
#endif
#ifndef glDebugMessageCallbackARB_RETURN
#define glDebugMessageCallbackARB_RETURN void
#define glDebugMessageCallbackARB_ARG_NAMES callback, userParam
#define glDebugMessageCallbackARB_ARG_EXPAND GLDEBUGPROCARB callback, const GLvoid * userParam
#define glDebugMessageCallbackARB_ARG_NAMES_TAIL , callback, userParam
#define glDebugMessageCallbackARB_ARG_EXPAND_TAIL , GLDEBUGPROCARB callback, const GLvoid * userParam
#define forward_glDebugMessageCallbackARB(_callback, _userParam) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageCallbackARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageCallbackARB(dst, _callback, _userParam), NULL); \
    });
#define call_glDebugMessageCallbackARB(packed, ret_v) do { \
    glDebugMessageCallbackARB_PACKED *unpacked = (glDebugMessageCallbackARB_PACKED *)packed; \
    glDebugMessageCallbackARB_ARGS *args = (glDebugMessageCallbackARB_ARGS *)&unpacked->args; \
    glDebugMessageCallbackARB(args->callback, args->userParam);; \
} while(0)
void glDebugMessageCallbackARB(glDebugMessageCallbackARB_ARG_EXPAND);
packed_call_t *pack_glDebugMessageCallbackARB(glDebugMessageCallbackARB_PACKED *_dst glDebugMessageCallbackARB_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageCallbackARB_PTR)(glDebugMessageCallbackARB_ARG_EXPAND);
#endif
#ifndef glDebugMessageControl_RETURN
#define glDebugMessageControl_RETURN void
#define glDebugMessageControl_ARG_NAMES source, type, severity, count, ids, enabled
#define glDebugMessageControl_ARG_EXPAND GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define glDebugMessageControl_ARG_NAMES_TAIL , source, type, severity, count, ids, enabled
#define glDebugMessageControl_ARG_EXPAND_TAIL , GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define forward_glDebugMessageControl(_source, _type, _severity, _count, _ids, _enabled) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageControl_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageControl(dst, _source, _type, _severity, _count, _ids, _enabled), NULL); \
    });
#define call_glDebugMessageControl(packed, ret_v) do { \
    glDebugMessageControl_PACKED *unpacked = (glDebugMessageControl_PACKED *)packed; \
    glDebugMessageControl_ARGS *args = (glDebugMessageControl_ARGS *)&unpacked->args; \
    glDebugMessageControl(args->source, args->type, args->severity, args->count, args->ids, args->enabled);; \
} while(0)
void glDebugMessageControl(glDebugMessageControl_ARG_EXPAND);
packed_call_t *pack_glDebugMessageControl(glDebugMessageControl_PACKED *_dst glDebugMessageControl_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageControl_PTR)(glDebugMessageControl_ARG_EXPAND);
#endif
#ifndef glDebugMessageControlARB_RETURN
#define glDebugMessageControlARB_RETURN void
#define glDebugMessageControlARB_ARG_NAMES source, type, severity, count, ids, enabled
#define glDebugMessageControlARB_ARG_EXPAND GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define glDebugMessageControlARB_ARG_NAMES_TAIL , source, type, severity, count, ids, enabled
#define glDebugMessageControlARB_ARG_EXPAND_TAIL , GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define forward_glDebugMessageControlARB(_source, _type, _severity, _count, _ids, _enabled) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageControlARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageControlARB(dst, _source, _type, _severity, _count, _ids, _enabled), NULL); \
    });
#define call_glDebugMessageControlARB(packed, ret_v) do { \
    glDebugMessageControlARB_PACKED *unpacked = (glDebugMessageControlARB_PACKED *)packed; \
    glDebugMessageControlARB_ARGS *args = (glDebugMessageControlARB_ARGS *)&unpacked->args; \
    glDebugMessageControlARB(args->source, args->type, args->severity, args->count, args->ids, args->enabled);; \
} while(0)
void glDebugMessageControlARB(glDebugMessageControlARB_ARG_EXPAND);
packed_call_t *pack_glDebugMessageControlARB(glDebugMessageControlARB_PACKED *_dst glDebugMessageControlARB_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageControlARB_PTR)(glDebugMessageControlARB_ARG_EXPAND);
#endif
#ifndef glDebugMessageEnableAMD_RETURN
#define glDebugMessageEnableAMD_RETURN void
#define glDebugMessageEnableAMD_ARG_NAMES category, severity, count, ids, enabled
#define glDebugMessageEnableAMD_ARG_EXPAND GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define glDebugMessageEnableAMD_ARG_NAMES_TAIL , category, severity, count, ids, enabled
#define glDebugMessageEnableAMD_ARG_EXPAND_TAIL , GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define forward_glDebugMessageEnableAMD(_category, _severity, _count, _ids, _enabled) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageEnableAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageEnableAMD(dst, _category, _severity, _count, _ids, _enabled), NULL); \
    });
#define call_glDebugMessageEnableAMD(packed, ret_v) do { \
    glDebugMessageEnableAMD_PACKED *unpacked = (glDebugMessageEnableAMD_PACKED *)packed; \
    glDebugMessageEnableAMD_ARGS *args = (glDebugMessageEnableAMD_ARGS *)&unpacked->args; \
    glDebugMessageEnableAMD(args->category, args->severity, args->count, args->ids, args->enabled);; \
} while(0)
void glDebugMessageEnableAMD(glDebugMessageEnableAMD_ARG_EXPAND);
packed_call_t *pack_glDebugMessageEnableAMD(glDebugMessageEnableAMD_PACKED *_dst glDebugMessageEnableAMD_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageEnableAMD_PTR)(glDebugMessageEnableAMD_ARG_EXPAND);
#endif
#ifndef glDebugMessageInsert_RETURN
#define glDebugMessageInsert_RETURN void
#define glDebugMessageInsert_ARG_NAMES source, type, id, severity, length, buf
#define glDebugMessageInsert_ARG_EXPAND GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf
#define glDebugMessageInsert_ARG_NAMES_TAIL , source, type, id, severity, length, buf
#define glDebugMessageInsert_ARG_EXPAND_TAIL , GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf
#define forward_glDebugMessageInsert(_source, _type, _id, _severity, _length, _buf) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageInsert_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageInsert(dst, _source, _type, _id, _severity, _length, _buf), NULL); \
    });
#define call_glDebugMessageInsert(packed, ret_v) do { \
    glDebugMessageInsert_PACKED *unpacked = (glDebugMessageInsert_PACKED *)packed; \
    glDebugMessageInsert_ARGS *args = (glDebugMessageInsert_ARGS *)&unpacked->args; \
    glDebugMessageInsert(args->source, args->type, args->id, args->severity, args->length, args->buf);; \
} while(0)
void glDebugMessageInsert(glDebugMessageInsert_ARG_EXPAND);
packed_call_t *pack_glDebugMessageInsert(glDebugMessageInsert_PACKED *_dst glDebugMessageInsert_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageInsert_PTR)(glDebugMessageInsert_ARG_EXPAND);
#endif
#ifndef glDebugMessageInsertAMD_RETURN
#define glDebugMessageInsertAMD_RETURN void
#define glDebugMessageInsertAMD_ARG_NAMES category, severity, id, length, buf
#define glDebugMessageInsertAMD_ARG_EXPAND GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf
#define glDebugMessageInsertAMD_ARG_NAMES_TAIL , category, severity, id, length, buf
#define glDebugMessageInsertAMD_ARG_EXPAND_TAIL , GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf
#define forward_glDebugMessageInsertAMD(_category, _severity, _id, _length, _buf) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageInsertAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageInsertAMD(dst, _category, _severity, _id, _length, _buf), NULL); \
    });
#define call_glDebugMessageInsertAMD(packed, ret_v) do { \
    glDebugMessageInsertAMD_PACKED *unpacked = (glDebugMessageInsertAMD_PACKED *)packed; \
    glDebugMessageInsertAMD_ARGS *args = (glDebugMessageInsertAMD_ARGS *)&unpacked->args; \
    glDebugMessageInsertAMD(args->category, args->severity, args->id, args->length, args->buf);; \
} while(0)
void glDebugMessageInsertAMD(glDebugMessageInsertAMD_ARG_EXPAND);
packed_call_t *pack_glDebugMessageInsertAMD(glDebugMessageInsertAMD_PACKED *_dst glDebugMessageInsertAMD_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageInsertAMD_PTR)(glDebugMessageInsertAMD_ARG_EXPAND);
#endif
#ifndef glDebugMessageInsertARB_RETURN
#define glDebugMessageInsertARB_RETURN void
#define glDebugMessageInsertARB_ARG_NAMES source, type, id, severity, length, buf
#define glDebugMessageInsertARB_ARG_EXPAND GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf
#define glDebugMessageInsertARB_ARG_NAMES_TAIL , source, type, id, severity, length, buf
#define glDebugMessageInsertARB_ARG_EXPAND_TAIL , GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf
#define forward_glDebugMessageInsertARB(_source, _type, _id, _severity, _length, _buf) \
    ({ \
        void *dst = remote_dma(sizeof(glDebugMessageInsertARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDebugMessageInsertARB(dst, _source, _type, _id, _severity, _length, _buf), NULL); \
    });
#define call_glDebugMessageInsertARB(packed, ret_v) do { \
    glDebugMessageInsertARB_PACKED *unpacked = (glDebugMessageInsertARB_PACKED *)packed; \
    glDebugMessageInsertARB_ARGS *args = (glDebugMessageInsertARB_ARGS *)&unpacked->args; \
    glDebugMessageInsertARB(args->source, args->type, args->id, args->severity, args->length, args->buf);; \
} while(0)
void glDebugMessageInsertARB(glDebugMessageInsertARB_ARG_EXPAND);
packed_call_t *pack_glDebugMessageInsertARB(glDebugMessageInsertARB_PACKED *_dst glDebugMessageInsertARB_ARG_EXPAND_TAIL);
typedef void (*glDebugMessageInsertARB_PTR)(glDebugMessageInsertARB_ARG_EXPAND);
#endif
#ifndef glDeformSGIX_RETURN
#define glDeformSGIX_RETURN void
#define glDeformSGIX_ARG_NAMES mask
#define glDeformSGIX_ARG_EXPAND GLbitfield mask
#define glDeformSGIX_ARG_NAMES_TAIL , mask
#define glDeformSGIX_ARG_EXPAND_TAIL , GLbitfield mask
#define forward_glDeformSGIX(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glDeformSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeformSGIX(dst, _mask), NULL); \
    });
#define call_glDeformSGIX(packed, ret_v) do { \
    glDeformSGIX_PACKED *unpacked = (glDeformSGIX_PACKED *)packed; \
    glDeformSGIX_ARGS *args = (glDeformSGIX_ARGS *)&unpacked->args; \
    glDeformSGIX(args->mask);; \
} while(0)
void glDeformSGIX(glDeformSGIX_ARG_EXPAND);
packed_call_t *pack_glDeformSGIX(glDeformSGIX_PACKED *_dst glDeformSGIX_ARG_EXPAND_TAIL);
typedef void (*glDeformSGIX_PTR)(glDeformSGIX_ARG_EXPAND);
#endif
#ifndef glDeformationMap3dSGIX_RETURN
#define glDeformationMap3dSGIX_RETURN void
#define glDeformationMap3dSGIX_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points
#define glDeformationMap3dSGIX_ARG_EXPAND GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points
#define glDeformationMap3dSGIX_ARG_NAMES_TAIL , target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points
#define glDeformationMap3dSGIX_ARG_EXPAND_TAIL , GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points
#define forward_glDeformationMap3dSGIX(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _w1, _w2, _wstride, _worder, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glDeformationMap3dSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeformationMap3dSGIX(dst, _target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _w1, _w2, _wstride, _worder, _points), NULL); \
    });
#define call_glDeformationMap3dSGIX(packed, ret_v) do { \
    glDeformationMap3dSGIX_PACKED *unpacked = (glDeformationMap3dSGIX_PACKED *)packed; \
    glDeformationMap3dSGIX_ARGS *args = (glDeformationMap3dSGIX_ARGS *)&unpacked->args; \
    glDeformationMap3dSGIX(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->w1, args->w2, args->wstride, args->worder, args->points);; \
} while(0)
void glDeformationMap3dSGIX(glDeformationMap3dSGIX_ARG_EXPAND);
packed_call_t *pack_glDeformationMap3dSGIX(glDeformationMap3dSGIX_PACKED *_dst glDeformationMap3dSGIX_ARG_EXPAND_TAIL);
typedef void (*glDeformationMap3dSGIX_PTR)(glDeformationMap3dSGIX_ARG_EXPAND);
#endif
#ifndef glDeformationMap3fSGIX_RETURN
#define glDeformationMap3fSGIX_RETURN void
#define glDeformationMap3fSGIX_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points
#define glDeformationMap3fSGIX_ARG_EXPAND GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points
#define glDeformationMap3fSGIX_ARG_NAMES_TAIL , target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points
#define glDeformationMap3fSGIX_ARG_EXPAND_TAIL , GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points
#define forward_glDeformationMap3fSGIX(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _w1, _w2, _wstride, _worder, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glDeformationMap3fSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeformationMap3fSGIX(dst, _target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _w1, _w2, _wstride, _worder, _points), NULL); \
    });
#define call_glDeformationMap3fSGIX(packed, ret_v) do { \
    glDeformationMap3fSGIX_PACKED *unpacked = (glDeformationMap3fSGIX_PACKED *)packed; \
    glDeformationMap3fSGIX_ARGS *args = (glDeformationMap3fSGIX_ARGS *)&unpacked->args; \
    glDeformationMap3fSGIX(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->w1, args->w2, args->wstride, args->worder, args->points);; \
} while(0)
void glDeformationMap3fSGIX(glDeformationMap3fSGIX_ARG_EXPAND);
packed_call_t *pack_glDeformationMap3fSGIX(glDeformationMap3fSGIX_PACKED *_dst glDeformationMap3fSGIX_ARG_EXPAND_TAIL);
typedef void (*glDeformationMap3fSGIX_PTR)(glDeformationMap3fSGIX_ARG_EXPAND);
#endif
#ifndef glDeleteAsyncMarkersSGIX_RETURN
#define glDeleteAsyncMarkersSGIX_RETURN void
#define glDeleteAsyncMarkersSGIX_ARG_NAMES marker, range
#define glDeleteAsyncMarkersSGIX_ARG_EXPAND GLuint marker, GLsizei range
#define glDeleteAsyncMarkersSGIX_ARG_NAMES_TAIL , marker, range
#define glDeleteAsyncMarkersSGIX_ARG_EXPAND_TAIL , GLuint marker, GLsizei range
#define forward_glDeleteAsyncMarkersSGIX(_marker, _range) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteAsyncMarkersSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteAsyncMarkersSGIX(dst, _marker, _range), NULL); \
    });
#define call_glDeleteAsyncMarkersSGIX(packed, ret_v) do { \
    glDeleteAsyncMarkersSGIX_PACKED *unpacked = (glDeleteAsyncMarkersSGIX_PACKED *)packed; \
    glDeleteAsyncMarkersSGIX_ARGS *args = (glDeleteAsyncMarkersSGIX_ARGS *)&unpacked->args; \
    glDeleteAsyncMarkersSGIX(args->marker, args->range);; \
} while(0)
void glDeleteAsyncMarkersSGIX(glDeleteAsyncMarkersSGIX_ARG_EXPAND);
packed_call_t *pack_glDeleteAsyncMarkersSGIX(glDeleteAsyncMarkersSGIX_PACKED *_dst glDeleteAsyncMarkersSGIX_ARG_EXPAND_TAIL);
typedef void (*glDeleteAsyncMarkersSGIX_PTR)(glDeleteAsyncMarkersSGIX_ARG_EXPAND);
#endif
#ifndef glDeleteBuffers_RETURN
#define glDeleteBuffers_RETURN void
#define glDeleteBuffers_ARG_NAMES n, buffers
#define glDeleteBuffers_ARG_EXPAND GLsizei n, const GLuint * buffers
#define glDeleteBuffers_ARG_NAMES_TAIL , n, buffers
#define glDeleteBuffers_ARG_EXPAND_TAIL , GLsizei n, const GLuint * buffers
#define forward_glDeleteBuffers(_n, _buffers) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteBuffers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteBuffers(dst, _n, _buffers), NULL); \
    });
#define call_glDeleteBuffers(packed, ret_v) do { \
    glDeleteBuffers_PACKED *unpacked = (glDeleteBuffers_PACKED *)packed; \
    glDeleteBuffers_ARGS *args = (glDeleteBuffers_ARGS *)&unpacked->args; \
    glDeleteBuffers(args->n, args->buffers);; \
} while(0)
void glDeleteBuffers(glDeleteBuffers_ARG_EXPAND);
packed_call_t *pack_glDeleteBuffers(glDeleteBuffers_PACKED *_dst glDeleteBuffers_ARG_EXPAND_TAIL);
typedef void (*glDeleteBuffers_PTR)(glDeleteBuffers_ARG_EXPAND);
#endif
#ifndef glDeleteBuffersARB_RETURN
#define glDeleteBuffersARB_RETURN void
#define glDeleteBuffersARB_ARG_NAMES n, buffers
#define glDeleteBuffersARB_ARG_EXPAND GLsizei n, const GLuint * buffers
#define glDeleteBuffersARB_ARG_NAMES_TAIL , n, buffers
#define glDeleteBuffersARB_ARG_EXPAND_TAIL , GLsizei n, const GLuint * buffers
#define forward_glDeleteBuffersARB(_n, _buffers) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteBuffersARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteBuffersARB(dst, _n, _buffers), NULL); \
    });
#define call_glDeleteBuffersARB(packed, ret_v) do { \
    glDeleteBuffersARB_PACKED *unpacked = (glDeleteBuffersARB_PACKED *)packed; \
    glDeleteBuffersARB_ARGS *args = (glDeleteBuffersARB_ARGS *)&unpacked->args; \
    glDeleteBuffersARB(args->n, args->buffers);; \
} while(0)
void glDeleteBuffersARB(glDeleteBuffersARB_ARG_EXPAND);
packed_call_t *pack_glDeleteBuffersARB(glDeleteBuffersARB_PACKED *_dst glDeleteBuffersARB_ARG_EXPAND_TAIL);
typedef void (*glDeleteBuffersARB_PTR)(glDeleteBuffersARB_ARG_EXPAND);
#endif
#ifndef glDeleteFencesAPPLE_RETURN
#define glDeleteFencesAPPLE_RETURN void
#define glDeleteFencesAPPLE_ARG_NAMES n, fences
#define glDeleteFencesAPPLE_ARG_EXPAND GLsizei n, const GLuint * fences
#define glDeleteFencesAPPLE_ARG_NAMES_TAIL , n, fences
#define glDeleteFencesAPPLE_ARG_EXPAND_TAIL , GLsizei n, const GLuint * fences
#define forward_glDeleteFencesAPPLE(_n, _fences) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteFencesAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteFencesAPPLE(dst, _n, _fences), NULL); \
    });
#define call_glDeleteFencesAPPLE(packed, ret_v) do { \
    glDeleteFencesAPPLE_PACKED *unpacked = (glDeleteFencesAPPLE_PACKED *)packed; \
    glDeleteFencesAPPLE_ARGS *args = (glDeleteFencesAPPLE_ARGS *)&unpacked->args; \
    glDeleteFencesAPPLE(args->n, args->fences);; \
} while(0)
void glDeleteFencesAPPLE(glDeleteFencesAPPLE_ARG_EXPAND);
packed_call_t *pack_glDeleteFencesAPPLE(glDeleteFencesAPPLE_PACKED *_dst glDeleteFencesAPPLE_ARG_EXPAND_TAIL);
typedef void (*glDeleteFencesAPPLE_PTR)(glDeleteFencesAPPLE_ARG_EXPAND);
#endif
#ifndef glDeleteFencesNV_RETURN
#define glDeleteFencesNV_RETURN void
#define glDeleteFencesNV_ARG_NAMES n, fences
#define glDeleteFencesNV_ARG_EXPAND GLsizei n, const GLuint * fences
#define glDeleteFencesNV_ARG_NAMES_TAIL , n, fences
#define glDeleteFencesNV_ARG_EXPAND_TAIL , GLsizei n, const GLuint * fences
#define forward_glDeleteFencesNV(_n, _fences) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteFencesNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteFencesNV(dst, _n, _fences), NULL); \
    });
#define call_glDeleteFencesNV(packed, ret_v) do { \
    glDeleteFencesNV_PACKED *unpacked = (glDeleteFencesNV_PACKED *)packed; \
    glDeleteFencesNV_ARGS *args = (glDeleteFencesNV_ARGS *)&unpacked->args; \
    glDeleteFencesNV(args->n, args->fences);; \
} while(0)
void glDeleteFencesNV(glDeleteFencesNV_ARG_EXPAND);
packed_call_t *pack_glDeleteFencesNV(glDeleteFencesNV_PACKED *_dst glDeleteFencesNV_ARG_EXPAND_TAIL);
typedef void (*glDeleteFencesNV_PTR)(glDeleteFencesNV_ARG_EXPAND);
#endif
#ifndef glDeleteFragmentShaderATI_RETURN
#define glDeleteFragmentShaderATI_RETURN void
#define glDeleteFragmentShaderATI_ARG_NAMES id
#define glDeleteFragmentShaderATI_ARG_EXPAND GLuint id
#define glDeleteFragmentShaderATI_ARG_NAMES_TAIL , id
#define glDeleteFragmentShaderATI_ARG_EXPAND_TAIL , GLuint id
#define forward_glDeleteFragmentShaderATI(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteFragmentShaderATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteFragmentShaderATI(dst, _id), NULL); \
    });
#define call_glDeleteFragmentShaderATI(packed, ret_v) do { \
    glDeleteFragmentShaderATI_PACKED *unpacked = (glDeleteFragmentShaderATI_PACKED *)packed; \
    glDeleteFragmentShaderATI_ARGS *args = (glDeleteFragmentShaderATI_ARGS *)&unpacked->args; \
    glDeleteFragmentShaderATI(args->id);; \
} while(0)
void glDeleteFragmentShaderATI(glDeleteFragmentShaderATI_ARG_EXPAND);
packed_call_t *pack_glDeleteFragmentShaderATI(glDeleteFragmentShaderATI_PACKED *_dst glDeleteFragmentShaderATI_ARG_EXPAND_TAIL);
typedef void (*glDeleteFragmentShaderATI_PTR)(glDeleteFragmentShaderATI_ARG_EXPAND);
#endif
#ifndef glDeleteFramebuffers_RETURN
#define glDeleteFramebuffers_RETURN void
#define glDeleteFramebuffers_ARG_NAMES n, framebuffers
#define glDeleteFramebuffers_ARG_EXPAND GLsizei n, const GLuint * framebuffers
#define glDeleteFramebuffers_ARG_NAMES_TAIL , n, framebuffers
#define glDeleteFramebuffers_ARG_EXPAND_TAIL , GLsizei n, const GLuint * framebuffers
#define forward_glDeleteFramebuffers(_n, _framebuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteFramebuffers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteFramebuffers(dst, _n, _framebuffers), NULL); \
    });
#define call_glDeleteFramebuffers(packed, ret_v) do { \
    glDeleteFramebuffers_PACKED *unpacked = (glDeleteFramebuffers_PACKED *)packed; \
    glDeleteFramebuffers_ARGS *args = (glDeleteFramebuffers_ARGS *)&unpacked->args; \
    glDeleteFramebuffers(args->n, args->framebuffers);; \
} while(0)
void glDeleteFramebuffers(glDeleteFramebuffers_ARG_EXPAND);
packed_call_t *pack_glDeleteFramebuffers(glDeleteFramebuffers_PACKED *_dst glDeleteFramebuffers_ARG_EXPAND_TAIL);
typedef void (*glDeleteFramebuffers_PTR)(glDeleteFramebuffers_ARG_EXPAND);
#endif
#ifndef glDeleteFramebuffersEXT_RETURN
#define glDeleteFramebuffersEXT_RETURN void
#define glDeleteFramebuffersEXT_ARG_NAMES n, framebuffers
#define glDeleteFramebuffersEXT_ARG_EXPAND GLsizei n, const GLuint * framebuffers
#define glDeleteFramebuffersEXT_ARG_NAMES_TAIL , n, framebuffers
#define glDeleteFramebuffersEXT_ARG_EXPAND_TAIL , GLsizei n, const GLuint * framebuffers
#define forward_glDeleteFramebuffersEXT(_n, _framebuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteFramebuffersEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteFramebuffersEXT(dst, _n, _framebuffers), NULL); \
    });
#define call_glDeleteFramebuffersEXT(packed, ret_v) do { \
    glDeleteFramebuffersEXT_PACKED *unpacked = (glDeleteFramebuffersEXT_PACKED *)packed; \
    glDeleteFramebuffersEXT_ARGS *args = (glDeleteFramebuffersEXT_ARGS *)&unpacked->args; \
    glDeleteFramebuffersEXT(args->n, args->framebuffers);; \
} while(0)
void glDeleteFramebuffersEXT(glDeleteFramebuffersEXT_ARG_EXPAND);
packed_call_t *pack_glDeleteFramebuffersEXT(glDeleteFramebuffersEXT_PACKED *_dst glDeleteFramebuffersEXT_ARG_EXPAND_TAIL);
typedef void (*glDeleteFramebuffersEXT_PTR)(glDeleteFramebuffersEXT_ARG_EXPAND);
#endif
#ifndef glDeleteLists_RETURN
#define glDeleteLists_RETURN void
#define glDeleteLists_ARG_NAMES list, range
#define glDeleteLists_ARG_EXPAND GLuint list, GLsizei range
#define glDeleteLists_ARG_NAMES_TAIL , list, range
#define glDeleteLists_ARG_EXPAND_TAIL , GLuint list, GLsizei range
#define forward_glDeleteLists(_list, _range) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteLists_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteLists(dst, _list, _range), NULL); \
    });
#define call_glDeleteLists(packed, ret_v) do { \
    glDeleteLists_PACKED *unpacked = (glDeleteLists_PACKED *)packed; \
    glDeleteLists_ARGS *args = (glDeleteLists_ARGS *)&unpacked->args; \
    glDeleteLists(args->list, args->range);; \
} while(0)
void glDeleteLists(glDeleteLists_ARG_EXPAND);
packed_call_t *pack_glDeleteLists(glDeleteLists_PACKED *_dst glDeleteLists_ARG_EXPAND_TAIL);
typedef void (*glDeleteLists_PTR)(glDeleteLists_ARG_EXPAND);
#endif
#ifndef glDeleteNamedStringARB_RETURN
#define glDeleteNamedStringARB_RETURN void
#define glDeleteNamedStringARB_ARG_NAMES namelen, name
#define glDeleteNamedStringARB_ARG_EXPAND GLint namelen, const GLchar * name
#define glDeleteNamedStringARB_ARG_NAMES_TAIL , namelen, name
#define glDeleteNamedStringARB_ARG_EXPAND_TAIL , GLint namelen, const GLchar * name
#define forward_glDeleteNamedStringARB(_namelen, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteNamedStringARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteNamedStringARB(dst, _namelen, _name), NULL); \
    });
#define call_glDeleteNamedStringARB(packed, ret_v) do { \
    glDeleteNamedStringARB_PACKED *unpacked = (glDeleteNamedStringARB_PACKED *)packed; \
    glDeleteNamedStringARB_ARGS *args = (glDeleteNamedStringARB_ARGS *)&unpacked->args; \
    glDeleteNamedStringARB(args->namelen, args->name);; \
} while(0)
void glDeleteNamedStringARB(glDeleteNamedStringARB_ARG_EXPAND);
packed_call_t *pack_glDeleteNamedStringARB(glDeleteNamedStringARB_PACKED *_dst glDeleteNamedStringARB_ARG_EXPAND_TAIL);
typedef void (*glDeleteNamedStringARB_PTR)(glDeleteNamedStringARB_ARG_EXPAND);
#endif
#ifndef glDeleteNamesAMD_RETURN
#define glDeleteNamesAMD_RETURN void
#define glDeleteNamesAMD_ARG_NAMES identifier, num, names
#define glDeleteNamesAMD_ARG_EXPAND GLenum identifier, GLuint num, const GLuint * names
#define glDeleteNamesAMD_ARG_NAMES_TAIL , identifier, num, names
#define glDeleteNamesAMD_ARG_EXPAND_TAIL , GLenum identifier, GLuint num, const GLuint * names
#define forward_glDeleteNamesAMD(_identifier, _num, _names) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteNamesAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteNamesAMD(dst, _identifier, _num, _names), NULL); \
    });
#define call_glDeleteNamesAMD(packed, ret_v) do { \
    glDeleteNamesAMD_PACKED *unpacked = (glDeleteNamesAMD_PACKED *)packed; \
    glDeleteNamesAMD_ARGS *args = (glDeleteNamesAMD_ARGS *)&unpacked->args; \
    glDeleteNamesAMD(args->identifier, args->num, args->names);; \
} while(0)
void glDeleteNamesAMD(glDeleteNamesAMD_ARG_EXPAND);
packed_call_t *pack_glDeleteNamesAMD(glDeleteNamesAMD_PACKED *_dst glDeleteNamesAMD_ARG_EXPAND_TAIL);
typedef void (*glDeleteNamesAMD_PTR)(glDeleteNamesAMD_ARG_EXPAND);
#endif
#ifndef glDeleteObjectARB_RETURN
#define glDeleteObjectARB_RETURN void
#define glDeleteObjectARB_ARG_NAMES obj
#define glDeleteObjectARB_ARG_EXPAND GLhandleARB obj
#define glDeleteObjectARB_ARG_NAMES_TAIL , obj
#define glDeleteObjectARB_ARG_EXPAND_TAIL , GLhandleARB obj
#define forward_glDeleteObjectARB(_obj) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteObjectARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteObjectARB(dst, _obj), NULL); \
    });
#define call_glDeleteObjectARB(packed, ret_v) do { \
    glDeleteObjectARB_PACKED *unpacked = (glDeleteObjectARB_PACKED *)packed; \
    glDeleteObjectARB_ARGS *args = (glDeleteObjectARB_ARGS *)&unpacked->args; \
    glDeleteObjectARB(args->obj);; \
} while(0)
void glDeleteObjectARB(glDeleteObjectARB_ARG_EXPAND);
packed_call_t *pack_glDeleteObjectARB(glDeleteObjectARB_PACKED *_dst glDeleteObjectARB_ARG_EXPAND_TAIL);
typedef void (*glDeleteObjectARB_PTR)(glDeleteObjectARB_ARG_EXPAND);
#endif
#ifndef glDeleteOcclusionQueriesNV_RETURN
#define glDeleteOcclusionQueriesNV_RETURN void
#define glDeleteOcclusionQueriesNV_ARG_NAMES n, ids
#define glDeleteOcclusionQueriesNV_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteOcclusionQueriesNV_ARG_NAMES_TAIL , n, ids
#define glDeleteOcclusionQueriesNV_ARG_EXPAND_TAIL , GLsizei n, const GLuint * ids
#define forward_glDeleteOcclusionQueriesNV(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteOcclusionQueriesNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteOcclusionQueriesNV(dst, _n, _ids), NULL); \
    });
#define call_glDeleteOcclusionQueriesNV(packed, ret_v) do { \
    glDeleteOcclusionQueriesNV_PACKED *unpacked = (glDeleteOcclusionQueriesNV_PACKED *)packed; \
    glDeleteOcclusionQueriesNV_ARGS *args = (glDeleteOcclusionQueriesNV_ARGS *)&unpacked->args; \
    glDeleteOcclusionQueriesNV(args->n, args->ids);; \
} while(0)
void glDeleteOcclusionQueriesNV(glDeleteOcclusionQueriesNV_ARG_EXPAND);
packed_call_t *pack_glDeleteOcclusionQueriesNV(glDeleteOcclusionQueriesNV_PACKED *_dst glDeleteOcclusionQueriesNV_ARG_EXPAND_TAIL);
typedef void (*glDeleteOcclusionQueriesNV_PTR)(glDeleteOcclusionQueriesNV_ARG_EXPAND);
#endif
#ifndef glDeletePathsNV_RETURN
#define glDeletePathsNV_RETURN void
#define glDeletePathsNV_ARG_NAMES path, range
#define glDeletePathsNV_ARG_EXPAND GLuint path, GLsizei range
#define glDeletePathsNV_ARG_NAMES_TAIL , path, range
#define glDeletePathsNV_ARG_EXPAND_TAIL , GLuint path, GLsizei range
#define forward_glDeletePathsNV(_path, _range) \
    ({ \
        void *dst = remote_dma(sizeof(glDeletePathsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeletePathsNV(dst, _path, _range), NULL); \
    });
#define call_glDeletePathsNV(packed, ret_v) do { \
    glDeletePathsNV_PACKED *unpacked = (glDeletePathsNV_PACKED *)packed; \
    glDeletePathsNV_ARGS *args = (glDeletePathsNV_ARGS *)&unpacked->args; \
    glDeletePathsNV(args->path, args->range);; \
} while(0)
void glDeletePathsNV(glDeletePathsNV_ARG_EXPAND);
packed_call_t *pack_glDeletePathsNV(glDeletePathsNV_PACKED *_dst glDeletePathsNV_ARG_EXPAND_TAIL);
typedef void (*glDeletePathsNV_PTR)(glDeletePathsNV_ARG_EXPAND);
#endif
#ifndef glDeletePerfMonitorsAMD_RETURN
#define glDeletePerfMonitorsAMD_RETURN void
#define glDeletePerfMonitorsAMD_ARG_NAMES n, monitors
#define glDeletePerfMonitorsAMD_ARG_EXPAND GLsizei n, GLuint * monitors
#define glDeletePerfMonitorsAMD_ARG_NAMES_TAIL , n, monitors
#define glDeletePerfMonitorsAMD_ARG_EXPAND_TAIL , GLsizei n, GLuint * monitors
#define forward_glDeletePerfMonitorsAMD(_n, _monitors) \
    ({ \
        void *dst = remote_dma(sizeof(glDeletePerfMonitorsAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeletePerfMonitorsAMD(dst, _n, _monitors), NULL); \
    });
#define call_glDeletePerfMonitorsAMD(packed, ret_v) do { \
    glDeletePerfMonitorsAMD_PACKED *unpacked = (glDeletePerfMonitorsAMD_PACKED *)packed; \
    glDeletePerfMonitorsAMD_ARGS *args = (glDeletePerfMonitorsAMD_ARGS *)&unpacked->args; \
    glDeletePerfMonitorsAMD(args->n, args->monitors);; \
} while(0)
void glDeletePerfMonitorsAMD(glDeletePerfMonitorsAMD_ARG_EXPAND);
packed_call_t *pack_glDeletePerfMonitorsAMD(glDeletePerfMonitorsAMD_PACKED *_dst glDeletePerfMonitorsAMD_ARG_EXPAND_TAIL);
typedef void (*glDeletePerfMonitorsAMD_PTR)(glDeletePerfMonitorsAMD_ARG_EXPAND);
#endif
#ifndef glDeleteProgram_RETURN
#define glDeleteProgram_RETURN void
#define glDeleteProgram_ARG_NAMES program
#define glDeleteProgram_ARG_EXPAND GLuint program
#define glDeleteProgram_ARG_NAMES_TAIL , program
#define glDeleteProgram_ARG_EXPAND_TAIL , GLuint program
#define forward_glDeleteProgram(_program) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteProgram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteProgram(dst, _program), NULL); \
    });
#define call_glDeleteProgram(packed, ret_v) do { \
    glDeleteProgram_PACKED *unpacked = (glDeleteProgram_PACKED *)packed; \
    glDeleteProgram_ARGS *args = (glDeleteProgram_ARGS *)&unpacked->args; \
    glDeleteProgram(args->program);; \
} while(0)
void glDeleteProgram(glDeleteProgram_ARG_EXPAND);
packed_call_t *pack_glDeleteProgram(glDeleteProgram_PACKED *_dst glDeleteProgram_ARG_EXPAND_TAIL);
typedef void (*glDeleteProgram_PTR)(glDeleteProgram_ARG_EXPAND);
#endif
#ifndef glDeleteProgramPipelines_RETURN
#define glDeleteProgramPipelines_RETURN void
#define glDeleteProgramPipelines_ARG_NAMES n, pipelines
#define glDeleteProgramPipelines_ARG_EXPAND GLsizei n, const GLuint * pipelines
#define glDeleteProgramPipelines_ARG_NAMES_TAIL , n, pipelines
#define glDeleteProgramPipelines_ARG_EXPAND_TAIL , GLsizei n, const GLuint * pipelines
#define forward_glDeleteProgramPipelines(_n, _pipelines) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteProgramPipelines_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteProgramPipelines(dst, _n, _pipelines), NULL); \
    });
#define call_glDeleteProgramPipelines(packed, ret_v) do { \
    glDeleteProgramPipelines_PACKED *unpacked = (glDeleteProgramPipelines_PACKED *)packed; \
    glDeleteProgramPipelines_ARGS *args = (glDeleteProgramPipelines_ARGS *)&unpacked->args; \
    glDeleteProgramPipelines(args->n, args->pipelines);; \
} while(0)
void glDeleteProgramPipelines(glDeleteProgramPipelines_ARG_EXPAND);
packed_call_t *pack_glDeleteProgramPipelines(glDeleteProgramPipelines_PACKED *_dst glDeleteProgramPipelines_ARG_EXPAND_TAIL);
typedef void (*glDeleteProgramPipelines_PTR)(glDeleteProgramPipelines_ARG_EXPAND);
#endif
#ifndef glDeleteProgramsARB_RETURN
#define glDeleteProgramsARB_RETURN void
#define glDeleteProgramsARB_ARG_NAMES n, programs
#define glDeleteProgramsARB_ARG_EXPAND GLsizei n, const GLuint * programs
#define glDeleteProgramsARB_ARG_NAMES_TAIL , n, programs
#define glDeleteProgramsARB_ARG_EXPAND_TAIL , GLsizei n, const GLuint * programs
#define forward_glDeleteProgramsARB(_n, _programs) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteProgramsARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteProgramsARB(dst, _n, _programs), NULL); \
    });
#define call_glDeleteProgramsARB(packed, ret_v) do { \
    glDeleteProgramsARB_PACKED *unpacked = (glDeleteProgramsARB_PACKED *)packed; \
    glDeleteProgramsARB_ARGS *args = (glDeleteProgramsARB_ARGS *)&unpacked->args; \
    glDeleteProgramsARB(args->n, args->programs);; \
} while(0)
void glDeleteProgramsARB(glDeleteProgramsARB_ARG_EXPAND);
packed_call_t *pack_glDeleteProgramsARB(glDeleteProgramsARB_PACKED *_dst glDeleteProgramsARB_ARG_EXPAND_TAIL);
typedef void (*glDeleteProgramsARB_PTR)(glDeleteProgramsARB_ARG_EXPAND);
#endif
#ifndef glDeleteProgramsNV_RETURN
#define glDeleteProgramsNV_RETURN void
#define glDeleteProgramsNV_ARG_NAMES n, programs
#define glDeleteProgramsNV_ARG_EXPAND GLsizei n, const GLuint * programs
#define glDeleteProgramsNV_ARG_NAMES_TAIL , n, programs
#define glDeleteProgramsNV_ARG_EXPAND_TAIL , GLsizei n, const GLuint * programs
#define forward_glDeleteProgramsNV(_n, _programs) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteProgramsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteProgramsNV(dst, _n, _programs), NULL); \
    });
#define call_glDeleteProgramsNV(packed, ret_v) do { \
    glDeleteProgramsNV_PACKED *unpacked = (glDeleteProgramsNV_PACKED *)packed; \
    glDeleteProgramsNV_ARGS *args = (glDeleteProgramsNV_ARGS *)&unpacked->args; \
    glDeleteProgramsNV(args->n, args->programs);; \
} while(0)
void glDeleteProgramsNV(glDeleteProgramsNV_ARG_EXPAND);
packed_call_t *pack_glDeleteProgramsNV(glDeleteProgramsNV_PACKED *_dst glDeleteProgramsNV_ARG_EXPAND_TAIL);
typedef void (*glDeleteProgramsNV_PTR)(glDeleteProgramsNV_ARG_EXPAND);
#endif
#ifndef glDeleteQueries_RETURN
#define glDeleteQueries_RETURN void
#define glDeleteQueries_ARG_NAMES n, ids
#define glDeleteQueries_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteQueries_ARG_NAMES_TAIL , n, ids
#define glDeleteQueries_ARG_EXPAND_TAIL , GLsizei n, const GLuint * ids
#define forward_glDeleteQueries(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteQueries_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteQueries(dst, _n, _ids), NULL); \
    });
#define call_glDeleteQueries(packed, ret_v) do { \
    glDeleteQueries_PACKED *unpacked = (glDeleteQueries_PACKED *)packed; \
    glDeleteQueries_ARGS *args = (glDeleteQueries_ARGS *)&unpacked->args; \
    glDeleteQueries(args->n, args->ids);; \
} while(0)
void glDeleteQueries(glDeleteQueries_ARG_EXPAND);
packed_call_t *pack_glDeleteQueries(glDeleteQueries_PACKED *_dst glDeleteQueries_ARG_EXPAND_TAIL);
typedef void (*glDeleteQueries_PTR)(glDeleteQueries_ARG_EXPAND);
#endif
#ifndef glDeleteQueriesARB_RETURN
#define glDeleteQueriesARB_RETURN void
#define glDeleteQueriesARB_ARG_NAMES n, ids
#define glDeleteQueriesARB_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteQueriesARB_ARG_NAMES_TAIL , n, ids
#define glDeleteQueriesARB_ARG_EXPAND_TAIL , GLsizei n, const GLuint * ids
#define forward_glDeleteQueriesARB(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteQueriesARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteQueriesARB(dst, _n, _ids), NULL); \
    });
#define call_glDeleteQueriesARB(packed, ret_v) do { \
    glDeleteQueriesARB_PACKED *unpacked = (glDeleteQueriesARB_PACKED *)packed; \
    glDeleteQueriesARB_ARGS *args = (glDeleteQueriesARB_ARGS *)&unpacked->args; \
    glDeleteQueriesARB(args->n, args->ids);; \
} while(0)
void glDeleteQueriesARB(glDeleteQueriesARB_ARG_EXPAND);
packed_call_t *pack_glDeleteQueriesARB(glDeleteQueriesARB_PACKED *_dst glDeleteQueriesARB_ARG_EXPAND_TAIL);
typedef void (*glDeleteQueriesARB_PTR)(glDeleteQueriesARB_ARG_EXPAND);
#endif
#ifndef glDeleteRenderbuffers_RETURN
#define glDeleteRenderbuffers_RETURN void
#define glDeleteRenderbuffers_ARG_NAMES n, renderbuffers
#define glDeleteRenderbuffers_ARG_EXPAND GLsizei n, const GLuint * renderbuffers
#define glDeleteRenderbuffers_ARG_NAMES_TAIL , n, renderbuffers
#define glDeleteRenderbuffers_ARG_EXPAND_TAIL , GLsizei n, const GLuint * renderbuffers
#define forward_glDeleteRenderbuffers(_n, _renderbuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteRenderbuffers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteRenderbuffers(dst, _n, _renderbuffers), NULL); \
    });
#define call_glDeleteRenderbuffers(packed, ret_v) do { \
    glDeleteRenderbuffers_PACKED *unpacked = (glDeleteRenderbuffers_PACKED *)packed; \
    glDeleteRenderbuffers_ARGS *args = (glDeleteRenderbuffers_ARGS *)&unpacked->args; \
    glDeleteRenderbuffers(args->n, args->renderbuffers);; \
} while(0)
void glDeleteRenderbuffers(glDeleteRenderbuffers_ARG_EXPAND);
packed_call_t *pack_glDeleteRenderbuffers(glDeleteRenderbuffers_PACKED *_dst glDeleteRenderbuffers_ARG_EXPAND_TAIL);
typedef void (*glDeleteRenderbuffers_PTR)(glDeleteRenderbuffers_ARG_EXPAND);
#endif
#ifndef glDeleteRenderbuffersEXT_RETURN
#define glDeleteRenderbuffersEXT_RETURN void
#define glDeleteRenderbuffersEXT_ARG_NAMES n, renderbuffers
#define glDeleteRenderbuffersEXT_ARG_EXPAND GLsizei n, const GLuint * renderbuffers
#define glDeleteRenderbuffersEXT_ARG_NAMES_TAIL , n, renderbuffers
#define glDeleteRenderbuffersEXT_ARG_EXPAND_TAIL , GLsizei n, const GLuint * renderbuffers
#define forward_glDeleteRenderbuffersEXT(_n, _renderbuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteRenderbuffersEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteRenderbuffersEXT(dst, _n, _renderbuffers), NULL); \
    });
#define call_glDeleteRenderbuffersEXT(packed, ret_v) do { \
    glDeleteRenderbuffersEXT_PACKED *unpacked = (glDeleteRenderbuffersEXT_PACKED *)packed; \
    glDeleteRenderbuffersEXT_ARGS *args = (glDeleteRenderbuffersEXT_ARGS *)&unpacked->args; \
    glDeleteRenderbuffersEXT(args->n, args->renderbuffers);; \
} while(0)
void glDeleteRenderbuffersEXT(glDeleteRenderbuffersEXT_ARG_EXPAND);
packed_call_t *pack_glDeleteRenderbuffersEXT(glDeleteRenderbuffersEXT_PACKED *_dst glDeleteRenderbuffersEXT_ARG_EXPAND_TAIL);
typedef void (*glDeleteRenderbuffersEXT_PTR)(glDeleteRenderbuffersEXT_ARG_EXPAND);
#endif
#ifndef glDeleteSamplers_RETURN
#define glDeleteSamplers_RETURN void
#define glDeleteSamplers_ARG_NAMES count, samplers
#define glDeleteSamplers_ARG_EXPAND GLsizei count, const GLuint * samplers
#define glDeleteSamplers_ARG_NAMES_TAIL , count, samplers
#define glDeleteSamplers_ARG_EXPAND_TAIL , GLsizei count, const GLuint * samplers
#define forward_glDeleteSamplers(_count, _samplers) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteSamplers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteSamplers(dst, _count, _samplers), NULL); \
    });
#define call_glDeleteSamplers(packed, ret_v) do { \
    glDeleteSamplers_PACKED *unpacked = (glDeleteSamplers_PACKED *)packed; \
    glDeleteSamplers_ARGS *args = (glDeleteSamplers_ARGS *)&unpacked->args; \
    glDeleteSamplers(args->count, args->samplers);; \
} while(0)
void glDeleteSamplers(glDeleteSamplers_ARG_EXPAND);
packed_call_t *pack_glDeleteSamplers(glDeleteSamplers_PACKED *_dst glDeleteSamplers_ARG_EXPAND_TAIL);
typedef void (*glDeleteSamplers_PTR)(glDeleteSamplers_ARG_EXPAND);
#endif
#ifndef glDeleteShader_RETURN
#define glDeleteShader_RETURN void
#define glDeleteShader_ARG_NAMES shader
#define glDeleteShader_ARG_EXPAND GLuint shader
#define glDeleteShader_ARG_NAMES_TAIL , shader
#define glDeleteShader_ARG_EXPAND_TAIL , GLuint shader
#define forward_glDeleteShader(_shader) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteShader_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteShader(dst, _shader), NULL); \
    });
#define call_glDeleteShader(packed, ret_v) do { \
    glDeleteShader_PACKED *unpacked = (glDeleteShader_PACKED *)packed; \
    glDeleteShader_ARGS *args = (glDeleteShader_ARGS *)&unpacked->args; \
    glDeleteShader(args->shader);; \
} while(0)
void glDeleteShader(glDeleteShader_ARG_EXPAND);
packed_call_t *pack_glDeleteShader(glDeleteShader_PACKED *_dst glDeleteShader_ARG_EXPAND_TAIL);
typedef void (*glDeleteShader_PTR)(glDeleteShader_ARG_EXPAND);
#endif
#ifndef glDeleteSync_RETURN
#define glDeleteSync_RETURN void
#define glDeleteSync_ARG_NAMES sync
#define glDeleteSync_ARG_EXPAND GLsync sync
#define glDeleteSync_ARG_NAMES_TAIL , sync
#define glDeleteSync_ARG_EXPAND_TAIL , GLsync sync
#define forward_glDeleteSync(_sync) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteSync_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteSync(dst, _sync), NULL); \
    });
#define call_glDeleteSync(packed, ret_v) do { \
    glDeleteSync_PACKED *unpacked = (glDeleteSync_PACKED *)packed; \
    glDeleteSync_ARGS *args = (glDeleteSync_ARGS *)&unpacked->args; \
    glDeleteSync(args->sync);; \
} while(0)
void glDeleteSync(glDeleteSync_ARG_EXPAND);
packed_call_t *pack_glDeleteSync(glDeleteSync_PACKED *_dst glDeleteSync_ARG_EXPAND_TAIL);
typedef void (*glDeleteSync_PTR)(glDeleteSync_ARG_EXPAND);
#endif
#ifndef glDeleteTextures_RETURN
#define glDeleteTextures_RETURN void
#define glDeleteTextures_ARG_NAMES n, textures
#define glDeleteTextures_ARG_EXPAND GLsizei n, const GLuint * textures
#define glDeleteTextures_ARG_NAMES_TAIL , n, textures
#define glDeleteTextures_ARG_EXPAND_TAIL , GLsizei n, const GLuint * textures
#define forward_glDeleteTextures(_n, _textures) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteTextures_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteTextures(dst, _n, _textures), NULL); \
    });
#define call_glDeleteTextures(packed, ret_v) do { \
    glDeleteTextures_PACKED *unpacked = (glDeleteTextures_PACKED *)packed; \
    glDeleteTextures_ARGS *args = (glDeleteTextures_ARGS *)&unpacked->args; \
    glDeleteTextures(args->n, args->textures);; \
} while(0)
void glDeleteTextures(glDeleteTextures_ARG_EXPAND);
packed_call_t *pack_glDeleteTextures(glDeleteTextures_PACKED *_dst glDeleteTextures_ARG_EXPAND_TAIL);
typedef void (*glDeleteTextures_PTR)(glDeleteTextures_ARG_EXPAND);
#endif
#ifndef glDeleteTexturesEXT_RETURN
#define glDeleteTexturesEXT_RETURN void
#define glDeleteTexturesEXT_ARG_NAMES n, textures
#define glDeleteTexturesEXT_ARG_EXPAND GLsizei n, const GLuint * textures
#define glDeleteTexturesEXT_ARG_NAMES_TAIL , n, textures
#define glDeleteTexturesEXT_ARG_EXPAND_TAIL , GLsizei n, const GLuint * textures
#define forward_glDeleteTexturesEXT(_n, _textures) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteTexturesEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteTexturesEXT(dst, _n, _textures), NULL); \
    });
#define call_glDeleteTexturesEXT(packed, ret_v) do { \
    glDeleteTexturesEXT_PACKED *unpacked = (glDeleteTexturesEXT_PACKED *)packed; \
    glDeleteTexturesEXT_ARGS *args = (glDeleteTexturesEXT_ARGS *)&unpacked->args; \
    glDeleteTexturesEXT(args->n, args->textures);; \
} while(0)
void glDeleteTexturesEXT(glDeleteTexturesEXT_ARG_EXPAND);
packed_call_t *pack_glDeleteTexturesEXT(glDeleteTexturesEXT_PACKED *_dst glDeleteTexturesEXT_ARG_EXPAND_TAIL);
typedef void (*glDeleteTexturesEXT_PTR)(glDeleteTexturesEXT_ARG_EXPAND);
#endif
#ifndef glDeleteTransformFeedbacks_RETURN
#define glDeleteTransformFeedbacks_RETURN void
#define glDeleteTransformFeedbacks_ARG_NAMES n, ids
#define glDeleteTransformFeedbacks_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteTransformFeedbacks_ARG_NAMES_TAIL , n, ids
#define glDeleteTransformFeedbacks_ARG_EXPAND_TAIL , GLsizei n, const GLuint * ids
#define forward_glDeleteTransformFeedbacks(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteTransformFeedbacks_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteTransformFeedbacks(dst, _n, _ids), NULL); \
    });
#define call_glDeleteTransformFeedbacks(packed, ret_v) do { \
    glDeleteTransformFeedbacks_PACKED *unpacked = (glDeleteTransformFeedbacks_PACKED *)packed; \
    glDeleteTransformFeedbacks_ARGS *args = (glDeleteTransformFeedbacks_ARGS *)&unpacked->args; \
    glDeleteTransformFeedbacks(args->n, args->ids);; \
} while(0)
void glDeleteTransformFeedbacks(glDeleteTransformFeedbacks_ARG_EXPAND);
packed_call_t *pack_glDeleteTransformFeedbacks(glDeleteTransformFeedbacks_PACKED *_dst glDeleteTransformFeedbacks_ARG_EXPAND_TAIL);
typedef void (*glDeleteTransformFeedbacks_PTR)(glDeleteTransformFeedbacks_ARG_EXPAND);
#endif
#ifndef glDeleteTransformFeedbacksNV_RETURN
#define glDeleteTransformFeedbacksNV_RETURN void
#define glDeleteTransformFeedbacksNV_ARG_NAMES n, ids
#define glDeleteTransformFeedbacksNV_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteTransformFeedbacksNV_ARG_NAMES_TAIL , n, ids
#define glDeleteTransformFeedbacksNV_ARG_EXPAND_TAIL , GLsizei n, const GLuint * ids
#define forward_glDeleteTransformFeedbacksNV(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteTransformFeedbacksNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteTransformFeedbacksNV(dst, _n, _ids), NULL); \
    });
#define call_glDeleteTransformFeedbacksNV(packed, ret_v) do { \
    glDeleteTransformFeedbacksNV_PACKED *unpacked = (glDeleteTransformFeedbacksNV_PACKED *)packed; \
    glDeleteTransformFeedbacksNV_ARGS *args = (glDeleteTransformFeedbacksNV_ARGS *)&unpacked->args; \
    glDeleteTransformFeedbacksNV(args->n, args->ids);; \
} while(0)
void glDeleteTransformFeedbacksNV(glDeleteTransformFeedbacksNV_ARG_EXPAND);
packed_call_t *pack_glDeleteTransformFeedbacksNV(glDeleteTransformFeedbacksNV_PACKED *_dst glDeleteTransformFeedbacksNV_ARG_EXPAND_TAIL);
typedef void (*glDeleteTransformFeedbacksNV_PTR)(glDeleteTransformFeedbacksNV_ARG_EXPAND);
#endif
#ifndef glDeleteVertexArrays_RETURN
#define glDeleteVertexArrays_RETURN void
#define glDeleteVertexArrays_ARG_NAMES n, arrays
#define glDeleteVertexArrays_ARG_EXPAND GLsizei n, const GLuint * arrays
#define glDeleteVertexArrays_ARG_NAMES_TAIL , n, arrays
#define glDeleteVertexArrays_ARG_EXPAND_TAIL , GLsizei n, const GLuint * arrays
#define forward_glDeleteVertexArrays(_n, _arrays) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteVertexArrays_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteVertexArrays(dst, _n, _arrays), NULL); \
    });
#define call_glDeleteVertexArrays(packed, ret_v) do { \
    glDeleteVertexArrays_PACKED *unpacked = (glDeleteVertexArrays_PACKED *)packed; \
    glDeleteVertexArrays_ARGS *args = (glDeleteVertexArrays_ARGS *)&unpacked->args; \
    glDeleteVertexArrays(args->n, args->arrays);; \
} while(0)
void glDeleteVertexArrays(glDeleteVertexArrays_ARG_EXPAND);
packed_call_t *pack_glDeleteVertexArrays(glDeleteVertexArrays_PACKED *_dst glDeleteVertexArrays_ARG_EXPAND_TAIL);
typedef void (*glDeleteVertexArrays_PTR)(glDeleteVertexArrays_ARG_EXPAND);
#endif
#ifndef glDeleteVertexArraysAPPLE_RETURN
#define glDeleteVertexArraysAPPLE_RETURN void
#define glDeleteVertexArraysAPPLE_ARG_NAMES n, arrays
#define glDeleteVertexArraysAPPLE_ARG_EXPAND GLsizei n, const GLuint * arrays
#define glDeleteVertexArraysAPPLE_ARG_NAMES_TAIL , n, arrays
#define glDeleteVertexArraysAPPLE_ARG_EXPAND_TAIL , GLsizei n, const GLuint * arrays
#define forward_glDeleteVertexArraysAPPLE(_n, _arrays) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteVertexArraysAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteVertexArraysAPPLE(dst, _n, _arrays), NULL); \
    });
#define call_glDeleteVertexArraysAPPLE(packed, ret_v) do { \
    glDeleteVertexArraysAPPLE_PACKED *unpacked = (glDeleteVertexArraysAPPLE_PACKED *)packed; \
    glDeleteVertexArraysAPPLE_ARGS *args = (glDeleteVertexArraysAPPLE_ARGS *)&unpacked->args; \
    glDeleteVertexArraysAPPLE(args->n, args->arrays);; \
} while(0)
void glDeleteVertexArraysAPPLE(glDeleteVertexArraysAPPLE_ARG_EXPAND);
packed_call_t *pack_glDeleteVertexArraysAPPLE(glDeleteVertexArraysAPPLE_PACKED *_dst glDeleteVertexArraysAPPLE_ARG_EXPAND_TAIL);
typedef void (*glDeleteVertexArraysAPPLE_PTR)(glDeleteVertexArraysAPPLE_ARG_EXPAND);
#endif
#ifndef glDeleteVertexShaderEXT_RETURN
#define glDeleteVertexShaderEXT_RETURN void
#define glDeleteVertexShaderEXT_ARG_NAMES id
#define glDeleteVertexShaderEXT_ARG_EXPAND GLuint id
#define glDeleteVertexShaderEXT_ARG_NAMES_TAIL , id
#define glDeleteVertexShaderEXT_ARG_EXPAND_TAIL , GLuint id
#define forward_glDeleteVertexShaderEXT(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glDeleteVertexShaderEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDeleteVertexShaderEXT(dst, _id), NULL); \
    });
#define call_glDeleteVertexShaderEXT(packed, ret_v) do { \
    glDeleteVertexShaderEXT_PACKED *unpacked = (glDeleteVertexShaderEXT_PACKED *)packed; \
    glDeleteVertexShaderEXT_ARGS *args = (glDeleteVertexShaderEXT_ARGS *)&unpacked->args; \
    glDeleteVertexShaderEXT(args->id);; \
} while(0)
void glDeleteVertexShaderEXT(glDeleteVertexShaderEXT_ARG_EXPAND);
packed_call_t *pack_glDeleteVertexShaderEXT(glDeleteVertexShaderEXT_PACKED *_dst glDeleteVertexShaderEXT_ARG_EXPAND_TAIL);
typedef void (*glDeleteVertexShaderEXT_PTR)(glDeleteVertexShaderEXT_ARG_EXPAND);
#endif
#ifndef glDepthBoundsEXT_RETURN
#define glDepthBoundsEXT_RETURN void
#define glDepthBoundsEXT_ARG_NAMES zmin, zmax
#define glDepthBoundsEXT_ARG_EXPAND GLclampd zmin, GLclampd zmax
#define glDepthBoundsEXT_ARG_NAMES_TAIL , zmin, zmax
#define glDepthBoundsEXT_ARG_EXPAND_TAIL , GLclampd zmin, GLclampd zmax
#define forward_glDepthBoundsEXT(_zmin, _zmax) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthBoundsEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthBoundsEXT(dst, _zmin, _zmax), NULL); \
    });
#define call_glDepthBoundsEXT(packed, ret_v) do { \
    glDepthBoundsEXT_PACKED *unpacked = (glDepthBoundsEXT_PACKED *)packed; \
    glDepthBoundsEXT_ARGS *args = (glDepthBoundsEXT_ARGS *)&unpacked->args; \
    glDepthBoundsEXT(args->zmin, args->zmax);; \
} while(0)
void glDepthBoundsEXT(glDepthBoundsEXT_ARG_EXPAND);
packed_call_t *pack_glDepthBoundsEXT(glDepthBoundsEXT_PACKED *_dst glDepthBoundsEXT_ARG_EXPAND_TAIL);
typedef void (*glDepthBoundsEXT_PTR)(glDepthBoundsEXT_ARG_EXPAND);
#endif
#ifndef glDepthBoundsdNV_RETURN
#define glDepthBoundsdNV_RETURN void
#define glDepthBoundsdNV_ARG_NAMES zmin, zmax
#define glDepthBoundsdNV_ARG_EXPAND GLdouble zmin, GLdouble zmax
#define glDepthBoundsdNV_ARG_NAMES_TAIL , zmin, zmax
#define glDepthBoundsdNV_ARG_EXPAND_TAIL , GLdouble zmin, GLdouble zmax
#define forward_glDepthBoundsdNV(_zmin, _zmax) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthBoundsdNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthBoundsdNV(dst, _zmin, _zmax), NULL); \
    });
#define call_glDepthBoundsdNV(packed, ret_v) do { \
    glDepthBoundsdNV_PACKED *unpacked = (glDepthBoundsdNV_PACKED *)packed; \
    glDepthBoundsdNV_ARGS *args = (glDepthBoundsdNV_ARGS *)&unpacked->args; \
    glDepthBoundsdNV(args->zmin, args->zmax);; \
} while(0)
void glDepthBoundsdNV(glDepthBoundsdNV_ARG_EXPAND);
packed_call_t *pack_glDepthBoundsdNV(glDepthBoundsdNV_PACKED *_dst glDepthBoundsdNV_ARG_EXPAND_TAIL);
typedef void (*glDepthBoundsdNV_PTR)(glDepthBoundsdNV_ARG_EXPAND);
#endif
#ifndef glDepthFunc_RETURN
#define glDepthFunc_RETURN void
#define glDepthFunc_ARG_NAMES func
#define glDepthFunc_ARG_EXPAND GLenum func
#define glDepthFunc_ARG_NAMES_TAIL , func
#define glDepthFunc_ARG_EXPAND_TAIL , GLenum func
#define forward_glDepthFunc(_func) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthFunc_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthFunc(dst, _func), NULL); \
    });
#define call_glDepthFunc(packed, ret_v) do { \
    glDepthFunc_PACKED *unpacked = (glDepthFunc_PACKED *)packed; \
    glDepthFunc_ARGS *args = (glDepthFunc_ARGS *)&unpacked->args; \
    glDepthFunc(args->func);; \
} while(0)
void glDepthFunc(glDepthFunc_ARG_EXPAND);
packed_call_t *pack_glDepthFunc(glDepthFunc_PACKED *_dst glDepthFunc_ARG_EXPAND_TAIL);
typedef void (*glDepthFunc_PTR)(glDepthFunc_ARG_EXPAND);
#endif
#ifndef glDepthMask_RETURN
#define glDepthMask_RETURN void
#define glDepthMask_ARG_NAMES flag
#define glDepthMask_ARG_EXPAND GLboolean flag
#define glDepthMask_ARG_NAMES_TAIL , flag
#define glDepthMask_ARG_EXPAND_TAIL , GLboolean flag
#define forward_glDepthMask(_flag) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthMask_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthMask(dst, _flag), NULL); \
    });
#define call_glDepthMask(packed, ret_v) do { \
    glDepthMask_PACKED *unpacked = (glDepthMask_PACKED *)packed; \
    glDepthMask_ARGS *args = (glDepthMask_ARGS *)&unpacked->args; \
    glDepthMask(args->flag);; \
} while(0)
void glDepthMask(glDepthMask_ARG_EXPAND);
packed_call_t *pack_glDepthMask(glDepthMask_PACKED *_dst glDepthMask_ARG_EXPAND_TAIL);
typedef void (*glDepthMask_PTR)(glDepthMask_ARG_EXPAND);
#endif
#ifndef glDepthRange_RETURN
#define glDepthRange_RETURN void
#define glDepthRange_ARG_NAMES near, far
#define glDepthRange_ARG_EXPAND GLdouble near, GLdouble far
#define glDepthRange_ARG_NAMES_TAIL , near, far
#define glDepthRange_ARG_EXPAND_TAIL , GLdouble near, GLdouble far
#define forward_glDepthRange(_near, _far) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthRange_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthRange(dst, _near, _far), NULL); \
    });
#define call_glDepthRange(packed, ret_v) do { \
    glDepthRange_PACKED *unpacked = (glDepthRange_PACKED *)packed; \
    glDepthRange_ARGS *args = (glDepthRange_ARGS *)&unpacked->args; \
    glDepthRange(args->near, args->far);; \
} while(0)
void glDepthRange(glDepthRange_ARG_EXPAND);
packed_call_t *pack_glDepthRange(glDepthRange_PACKED *_dst glDepthRange_ARG_EXPAND_TAIL);
typedef void (*glDepthRange_PTR)(glDepthRange_ARG_EXPAND);
#endif
#ifndef glDepthRangeArrayv_RETURN
#define glDepthRangeArrayv_RETURN void
#define glDepthRangeArrayv_ARG_NAMES first, count, v
#define glDepthRangeArrayv_ARG_EXPAND GLuint first, GLsizei count, const GLdouble * v
#define glDepthRangeArrayv_ARG_NAMES_TAIL , first, count, v
#define glDepthRangeArrayv_ARG_EXPAND_TAIL , GLuint first, GLsizei count, const GLdouble * v
#define forward_glDepthRangeArrayv(_first, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthRangeArrayv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthRangeArrayv(dst, _first, _count, _v), NULL); \
    });
#define call_glDepthRangeArrayv(packed, ret_v) do { \
    glDepthRangeArrayv_PACKED *unpacked = (glDepthRangeArrayv_PACKED *)packed; \
    glDepthRangeArrayv_ARGS *args = (glDepthRangeArrayv_ARGS *)&unpacked->args; \
    glDepthRangeArrayv(args->first, args->count, args->v);; \
} while(0)
void glDepthRangeArrayv(glDepthRangeArrayv_ARG_EXPAND);
packed_call_t *pack_glDepthRangeArrayv(glDepthRangeArrayv_PACKED *_dst glDepthRangeArrayv_ARG_EXPAND_TAIL);
typedef void (*glDepthRangeArrayv_PTR)(glDepthRangeArrayv_ARG_EXPAND);
#endif
#ifndef glDepthRangeIndexed_RETURN
#define glDepthRangeIndexed_RETURN void
#define glDepthRangeIndexed_ARG_NAMES index, n, f
#define glDepthRangeIndexed_ARG_EXPAND GLuint index, GLdouble n, GLdouble f
#define glDepthRangeIndexed_ARG_NAMES_TAIL , index, n, f
#define glDepthRangeIndexed_ARG_EXPAND_TAIL , GLuint index, GLdouble n, GLdouble f
#define forward_glDepthRangeIndexed(_index, _n, _f) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthRangeIndexed_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthRangeIndexed(dst, _index, _n, _f), NULL); \
    });
#define call_glDepthRangeIndexed(packed, ret_v) do { \
    glDepthRangeIndexed_PACKED *unpacked = (glDepthRangeIndexed_PACKED *)packed; \
    glDepthRangeIndexed_ARGS *args = (glDepthRangeIndexed_ARGS *)&unpacked->args; \
    glDepthRangeIndexed(args->index, args->n, args->f);; \
} while(0)
void glDepthRangeIndexed(glDepthRangeIndexed_ARG_EXPAND);
packed_call_t *pack_glDepthRangeIndexed(glDepthRangeIndexed_PACKED *_dst glDepthRangeIndexed_ARG_EXPAND_TAIL);
typedef void (*glDepthRangeIndexed_PTR)(glDepthRangeIndexed_ARG_EXPAND);
#endif
#ifndef glDepthRangedNV_RETURN
#define glDepthRangedNV_RETURN void
#define glDepthRangedNV_ARG_NAMES zNear, zFar
#define glDepthRangedNV_ARG_EXPAND GLdouble zNear, GLdouble zFar
#define glDepthRangedNV_ARG_NAMES_TAIL , zNear, zFar
#define glDepthRangedNV_ARG_EXPAND_TAIL , GLdouble zNear, GLdouble zFar
#define forward_glDepthRangedNV(_zNear, _zFar) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthRangedNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthRangedNV(dst, _zNear, _zFar), NULL); \
    });
#define call_glDepthRangedNV(packed, ret_v) do { \
    glDepthRangedNV_PACKED *unpacked = (glDepthRangedNV_PACKED *)packed; \
    glDepthRangedNV_ARGS *args = (glDepthRangedNV_ARGS *)&unpacked->args; \
    glDepthRangedNV(args->zNear, args->zFar);; \
} while(0)
void glDepthRangedNV(glDepthRangedNV_ARG_EXPAND);
packed_call_t *pack_glDepthRangedNV(glDepthRangedNV_PACKED *_dst glDepthRangedNV_ARG_EXPAND_TAIL);
typedef void (*glDepthRangedNV_PTR)(glDepthRangedNV_ARG_EXPAND);
#endif
#ifndef glDepthRangef_RETURN
#define glDepthRangef_RETURN void
#define glDepthRangef_ARG_NAMES near, far
#define glDepthRangef_ARG_EXPAND GLfloat near, GLfloat far
#define glDepthRangef_ARG_NAMES_TAIL , near, far
#define glDepthRangef_ARG_EXPAND_TAIL , GLfloat near, GLfloat far
#define forward_glDepthRangef(_near, _far) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthRangef_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthRangef(dst, _near, _far), NULL); \
    });
#define call_glDepthRangef(packed, ret_v) do { \
    glDepthRangef_PACKED *unpacked = (glDepthRangef_PACKED *)packed; \
    glDepthRangef_ARGS *args = (glDepthRangef_ARGS *)&unpacked->args; \
    glDepthRangef(args->near, args->far);; \
} while(0)
void glDepthRangef(glDepthRangef_ARG_EXPAND);
packed_call_t *pack_glDepthRangef(glDepthRangef_PACKED *_dst glDepthRangef_ARG_EXPAND_TAIL);
typedef void (*glDepthRangef_PTR)(glDepthRangef_ARG_EXPAND);
#endif
#ifndef glDepthRangefOES_RETURN
#define glDepthRangefOES_RETURN void
#define glDepthRangefOES_ARG_NAMES n, f
#define glDepthRangefOES_ARG_EXPAND GLclampf n, GLclampf f
#define glDepthRangefOES_ARG_NAMES_TAIL , n, f
#define glDepthRangefOES_ARG_EXPAND_TAIL , GLclampf n, GLclampf f
#define forward_glDepthRangefOES(_n, _f) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthRangefOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthRangefOES(dst, _n, _f), NULL); \
    });
#define call_glDepthRangefOES(packed, ret_v) do { \
    glDepthRangefOES_PACKED *unpacked = (glDepthRangefOES_PACKED *)packed; \
    glDepthRangefOES_ARGS *args = (glDepthRangefOES_ARGS *)&unpacked->args; \
    glDepthRangefOES(args->n, args->f);; \
} while(0)
void glDepthRangefOES(glDepthRangefOES_ARG_EXPAND);
packed_call_t *pack_glDepthRangefOES(glDepthRangefOES_PACKED *_dst glDepthRangefOES_ARG_EXPAND_TAIL);
typedef void (*glDepthRangefOES_PTR)(glDepthRangefOES_ARG_EXPAND);
#endif
#ifndef glDepthRangexOES_RETURN
#define glDepthRangexOES_RETURN void
#define glDepthRangexOES_ARG_NAMES n, f
#define glDepthRangexOES_ARG_EXPAND GLfixed n, GLfixed f
#define glDepthRangexOES_ARG_NAMES_TAIL , n, f
#define glDepthRangexOES_ARG_EXPAND_TAIL , GLfixed n, GLfixed f
#define forward_glDepthRangexOES(_n, _f) \
    ({ \
        void *dst = remote_dma(sizeof(glDepthRangexOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDepthRangexOES(dst, _n, _f), NULL); \
    });
#define call_glDepthRangexOES(packed, ret_v) do { \
    glDepthRangexOES_PACKED *unpacked = (glDepthRangexOES_PACKED *)packed; \
    glDepthRangexOES_ARGS *args = (glDepthRangexOES_ARGS *)&unpacked->args; \
    glDepthRangexOES(args->n, args->f);; \
} while(0)
void glDepthRangexOES(glDepthRangexOES_ARG_EXPAND);
packed_call_t *pack_glDepthRangexOES(glDepthRangexOES_PACKED *_dst glDepthRangexOES_ARG_EXPAND_TAIL);
typedef void (*glDepthRangexOES_PTR)(glDepthRangexOES_ARG_EXPAND);
#endif
#ifndef glDetachObjectARB_RETURN
#define glDetachObjectARB_RETURN void
#define glDetachObjectARB_ARG_NAMES containerObj, attachedObj
#define glDetachObjectARB_ARG_EXPAND GLhandleARB containerObj, GLhandleARB attachedObj
#define glDetachObjectARB_ARG_NAMES_TAIL , containerObj, attachedObj
#define glDetachObjectARB_ARG_EXPAND_TAIL , GLhandleARB containerObj, GLhandleARB attachedObj
#define forward_glDetachObjectARB(_containerObj, _attachedObj) \
    ({ \
        void *dst = remote_dma(sizeof(glDetachObjectARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDetachObjectARB(dst, _containerObj, _attachedObj), NULL); \
    });
#define call_glDetachObjectARB(packed, ret_v) do { \
    glDetachObjectARB_PACKED *unpacked = (glDetachObjectARB_PACKED *)packed; \
    glDetachObjectARB_ARGS *args = (glDetachObjectARB_ARGS *)&unpacked->args; \
    glDetachObjectARB(args->containerObj, args->attachedObj);; \
} while(0)
void glDetachObjectARB(glDetachObjectARB_ARG_EXPAND);
packed_call_t *pack_glDetachObjectARB(glDetachObjectARB_PACKED *_dst glDetachObjectARB_ARG_EXPAND_TAIL);
typedef void (*glDetachObjectARB_PTR)(glDetachObjectARB_ARG_EXPAND);
#endif
#ifndef glDetachShader_RETURN
#define glDetachShader_RETURN void
#define glDetachShader_ARG_NAMES program, shader
#define glDetachShader_ARG_EXPAND GLuint program, GLuint shader
#define glDetachShader_ARG_NAMES_TAIL , program, shader
#define glDetachShader_ARG_EXPAND_TAIL , GLuint program, GLuint shader
#define forward_glDetachShader(_program, _shader) \
    ({ \
        void *dst = remote_dma(sizeof(glDetachShader_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDetachShader(dst, _program, _shader), NULL); \
    });
#define call_glDetachShader(packed, ret_v) do { \
    glDetachShader_PACKED *unpacked = (glDetachShader_PACKED *)packed; \
    glDetachShader_ARGS *args = (glDetachShader_ARGS *)&unpacked->args; \
    glDetachShader(args->program, args->shader);; \
} while(0)
void glDetachShader(glDetachShader_ARG_EXPAND);
packed_call_t *pack_glDetachShader(glDetachShader_PACKED *_dst glDetachShader_ARG_EXPAND_TAIL);
typedef void (*glDetachShader_PTR)(glDetachShader_ARG_EXPAND);
#endif
#ifndef glDetailTexFuncSGIS_RETURN
#define glDetailTexFuncSGIS_RETURN void
#define glDetailTexFuncSGIS_ARG_NAMES target, n, points
#define glDetailTexFuncSGIS_ARG_EXPAND GLenum target, GLsizei n, const GLfloat * points
#define glDetailTexFuncSGIS_ARG_NAMES_TAIL , target, n, points
#define glDetailTexFuncSGIS_ARG_EXPAND_TAIL , GLenum target, GLsizei n, const GLfloat * points
#define forward_glDetailTexFuncSGIS(_target, _n, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glDetailTexFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDetailTexFuncSGIS(dst, _target, _n, _points), NULL); \
    });
#define call_glDetailTexFuncSGIS(packed, ret_v) do { \
    glDetailTexFuncSGIS_PACKED *unpacked = (glDetailTexFuncSGIS_PACKED *)packed; \
    glDetailTexFuncSGIS_ARGS *args = (glDetailTexFuncSGIS_ARGS *)&unpacked->args; \
    glDetailTexFuncSGIS(args->target, args->n, args->points);; \
} while(0)
void glDetailTexFuncSGIS(glDetailTexFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glDetailTexFuncSGIS(glDetailTexFuncSGIS_PACKED *_dst glDetailTexFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glDetailTexFuncSGIS_PTR)(glDetailTexFuncSGIS_ARG_EXPAND);
#endif
#ifndef glDisable_RETURN
#define glDisable_RETURN void
#define glDisable_ARG_NAMES cap
#define glDisable_ARG_EXPAND GLenum cap
#define glDisable_ARG_NAMES_TAIL , cap
#define glDisable_ARG_EXPAND_TAIL , GLenum cap
#define forward_glDisable(_cap) \
    ({ \
        void *dst = remote_dma(sizeof(glDisable_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisable(dst, _cap), NULL); \
    });
#define call_glDisable(packed, ret_v) do { \
    glDisable_PACKED *unpacked = (glDisable_PACKED *)packed; \
    glDisable_ARGS *args = (glDisable_ARGS *)&unpacked->args; \
    glDisable(args->cap);; \
} while(0)
void glDisable(glDisable_ARG_EXPAND);
packed_call_t *pack_glDisable(glDisable_PACKED *_dst glDisable_ARG_EXPAND_TAIL);
typedef void (*glDisable_PTR)(glDisable_ARG_EXPAND);
#endif
#ifndef glDisableClientState_RETURN
#define glDisableClientState_RETURN void
#define glDisableClientState_ARG_NAMES array
#define glDisableClientState_ARG_EXPAND GLenum array
#define glDisableClientState_ARG_NAMES_TAIL , array
#define glDisableClientState_ARG_EXPAND_TAIL , GLenum array
#define forward_glDisableClientState(_array) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableClientState_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableClientState(dst, _array), NULL); \
    });
#define call_glDisableClientState(packed, ret_v) do { \
    glDisableClientState_PACKED *unpacked = (glDisableClientState_PACKED *)packed; \
    glDisableClientState_ARGS *args = (glDisableClientState_ARGS *)&unpacked->args; \
    glDisableClientState(args->array);; \
} while(0)
void glDisableClientState(glDisableClientState_ARG_EXPAND);
packed_call_t *pack_glDisableClientState(glDisableClientState_PACKED *_dst glDisableClientState_ARG_EXPAND_TAIL);
typedef void (*glDisableClientState_PTR)(glDisableClientState_ARG_EXPAND);
#endif
#ifndef glDisableClientStateIndexedEXT_RETURN
#define glDisableClientStateIndexedEXT_RETURN void
#define glDisableClientStateIndexedEXT_ARG_NAMES array, index
#define glDisableClientStateIndexedEXT_ARG_EXPAND GLenum array, GLuint index
#define glDisableClientStateIndexedEXT_ARG_NAMES_TAIL , array, index
#define glDisableClientStateIndexedEXT_ARG_EXPAND_TAIL , GLenum array, GLuint index
#define forward_glDisableClientStateIndexedEXT(_array, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableClientStateIndexedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableClientStateIndexedEXT(dst, _array, _index), NULL); \
    });
#define call_glDisableClientStateIndexedEXT(packed, ret_v) do { \
    glDisableClientStateIndexedEXT_PACKED *unpacked = (glDisableClientStateIndexedEXT_PACKED *)packed; \
    glDisableClientStateIndexedEXT_ARGS *args = (glDisableClientStateIndexedEXT_ARGS *)&unpacked->args; \
    glDisableClientStateIndexedEXT(args->array, args->index);; \
} while(0)
void glDisableClientStateIndexedEXT(glDisableClientStateIndexedEXT_ARG_EXPAND);
packed_call_t *pack_glDisableClientStateIndexedEXT(glDisableClientStateIndexedEXT_PACKED *_dst glDisableClientStateIndexedEXT_ARG_EXPAND_TAIL);
typedef void (*glDisableClientStateIndexedEXT_PTR)(glDisableClientStateIndexedEXT_ARG_EXPAND);
#endif
#ifndef glDisableClientStateiEXT_RETURN
#define glDisableClientStateiEXT_RETURN void
#define glDisableClientStateiEXT_ARG_NAMES array, index
#define glDisableClientStateiEXT_ARG_EXPAND GLenum array, GLuint index
#define glDisableClientStateiEXT_ARG_NAMES_TAIL , array, index
#define glDisableClientStateiEXT_ARG_EXPAND_TAIL , GLenum array, GLuint index
#define forward_glDisableClientStateiEXT(_array, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableClientStateiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableClientStateiEXT(dst, _array, _index), NULL); \
    });
#define call_glDisableClientStateiEXT(packed, ret_v) do { \
    glDisableClientStateiEXT_PACKED *unpacked = (glDisableClientStateiEXT_PACKED *)packed; \
    glDisableClientStateiEXT_ARGS *args = (glDisableClientStateiEXT_ARGS *)&unpacked->args; \
    glDisableClientStateiEXT(args->array, args->index);; \
} while(0)
void glDisableClientStateiEXT(glDisableClientStateiEXT_ARG_EXPAND);
packed_call_t *pack_glDisableClientStateiEXT(glDisableClientStateiEXT_PACKED *_dst glDisableClientStateiEXT_ARG_EXPAND_TAIL);
typedef void (*glDisableClientStateiEXT_PTR)(glDisableClientStateiEXT_ARG_EXPAND);
#endif
#ifndef glDisableIndexedEXT_RETURN
#define glDisableIndexedEXT_RETURN void
#define glDisableIndexedEXT_ARG_NAMES target, index
#define glDisableIndexedEXT_ARG_EXPAND GLenum target, GLuint index
#define glDisableIndexedEXT_ARG_NAMES_TAIL , target, index
#define glDisableIndexedEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index
#define forward_glDisableIndexedEXT(_target, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableIndexedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableIndexedEXT(dst, _target, _index), NULL); \
    });
#define call_glDisableIndexedEXT(packed, ret_v) do { \
    glDisableIndexedEXT_PACKED *unpacked = (glDisableIndexedEXT_PACKED *)packed; \
    glDisableIndexedEXT_ARGS *args = (glDisableIndexedEXT_ARGS *)&unpacked->args; \
    glDisableIndexedEXT(args->target, args->index);; \
} while(0)
void glDisableIndexedEXT(glDisableIndexedEXT_ARG_EXPAND);
packed_call_t *pack_glDisableIndexedEXT(glDisableIndexedEXT_PACKED *_dst glDisableIndexedEXT_ARG_EXPAND_TAIL);
typedef void (*glDisableIndexedEXT_PTR)(glDisableIndexedEXT_ARG_EXPAND);
#endif
#ifndef glDisableVariantClientStateEXT_RETURN
#define glDisableVariantClientStateEXT_RETURN void
#define glDisableVariantClientStateEXT_ARG_NAMES id
#define glDisableVariantClientStateEXT_ARG_EXPAND GLuint id
#define glDisableVariantClientStateEXT_ARG_NAMES_TAIL , id
#define glDisableVariantClientStateEXT_ARG_EXPAND_TAIL , GLuint id
#define forward_glDisableVariantClientStateEXT(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableVariantClientStateEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableVariantClientStateEXT(dst, _id), NULL); \
    });
#define call_glDisableVariantClientStateEXT(packed, ret_v) do { \
    glDisableVariantClientStateEXT_PACKED *unpacked = (glDisableVariantClientStateEXT_PACKED *)packed; \
    glDisableVariantClientStateEXT_ARGS *args = (glDisableVariantClientStateEXT_ARGS *)&unpacked->args; \
    glDisableVariantClientStateEXT(args->id);; \
} while(0)
void glDisableVariantClientStateEXT(glDisableVariantClientStateEXT_ARG_EXPAND);
packed_call_t *pack_glDisableVariantClientStateEXT(glDisableVariantClientStateEXT_PACKED *_dst glDisableVariantClientStateEXT_ARG_EXPAND_TAIL);
typedef void (*glDisableVariantClientStateEXT_PTR)(glDisableVariantClientStateEXT_ARG_EXPAND);
#endif
#ifndef glDisableVertexArrayAttribEXT_RETURN
#define glDisableVertexArrayAttribEXT_RETURN void
#define glDisableVertexArrayAttribEXT_ARG_NAMES vaobj, index
#define glDisableVertexArrayAttribEXT_ARG_EXPAND GLuint vaobj, GLuint index
#define glDisableVertexArrayAttribEXT_ARG_NAMES_TAIL , vaobj, index
#define glDisableVertexArrayAttribEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint index
#define forward_glDisableVertexArrayAttribEXT(_vaobj, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableVertexArrayAttribEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableVertexArrayAttribEXT(dst, _vaobj, _index), NULL); \
    });
#define call_glDisableVertexArrayAttribEXT(packed, ret_v) do { \
    glDisableVertexArrayAttribEXT_PACKED *unpacked = (glDisableVertexArrayAttribEXT_PACKED *)packed; \
    glDisableVertexArrayAttribEXT_ARGS *args = (glDisableVertexArrayAttribEXT_ARGS *)&unpacked->args; \
    glDisableVertexArrayAttribEXT(args->vaobj, args->index);; \
} while(0)
void glDisableVertexArrayAttribEXT(glDisableVertexArrayAttribEXT_ARG_EXPAND);
packed_call_t *pack_glDisableVertexArrayAttribEXT(glDisableVertexArrayAttribEXT_PACKED *_dst glDisableVertexArrayAttribEXT_ARG_EXPAND_TAIL);
typedef void (*glDisableVertexArrayAttribEXT_PTR)(glDisableVertexArrayAttribEXT_ARG_EXPAND);
#endif
#ifndef glDisableVertexArrayEXT_RETURN
#define glDisableVertexArrayEXT_RETURN void
#define glDisableVertexArrayEXT_ARG_NAMES vaobj, array
#define glDisableVertexArrayEXT_ARG_EXPAND GLuint vaobj, GLenum array
#define glDisableVertexArrayEXT_ARG_NAMES_TAIL , vaobj, array
#define glDisableVertexArrayEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLenum array
#define forward_glDisableVertexArrayEXT(_vaobj, _array) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableVertexArrayEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableVertexArrayEXT(dst, _vaobj, _array), NULL); \
    });
#define call_glDisableVertexArrayEXT(packed, ret_v) do { \
    glDisableVertexArrayEXT_PACKED *unpacked = (glDisableVertexArrayEXT_PACKED *)packed; \
    glDisableVertexArrayEXT_ARGS *args = (glDisableVertexArrayEXT_ARGS *)&unpacked->args; \
    glDisableVertexArrayEXT(args->vaobj, args->array);; \
} while(0)
void glDisableVertexArrayEXT(glDisableVertexArrayEXT_ARG_EXPAND);
packed_call_t *pack_glDisableVertexArrayEXT(glDisableVertexArrayEXT_PACKED *_dst glDisableVertexArrayEXT_ARG_EXPAND_TAIL);
typedef void (*glDisableVertexArrayEXT_PTR)(glDisableVertexArrayEXT_ARG_EXPAND);
#endif
#ifndef glDisableVertexAttribAPPLE_RETURN
#define glDisableVertexAttribAPPLE_RETURN void
#define glDisableVertexAttribAPPLE_ARG_NAMES index, pname
#define glDisableVertexAttribAPPLE_ARG_EXPAND GLuint index, GLenum pname
#define glDisableVertexAttribAPPLE_ARG_NAMES_TAIL , index, pname
#define glDisableVertexAttribAPPLE_ARG_EXPAND_TAIL , GLuint index, GLenum pname
#define forward_glDisableVertexAttribAPPLE(_index, _pname) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableVertexAttribAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableVertexAttribAPPLE(dst, _index, _pname), NULL); \
    });
#define call_glDisableVertexAttribAPPLE(packed, ret_v) do { \
    glDisableVertexAttribAPPLE_PACKED *unpacked = (glDisableVertexAttribAPPLE_PACKED *)packed; \
    glDisableVertexAttribAPPLE_ARGS *args = (glDisableVertexAttribAPPLE_ARGS *)&unpacked->args; \
    glDisableVertexAttribAPPLE(args->index, args->pname);; \
} while(0)
void glDisableVertexAttribAPPLE(glDisableVertexAttribAPPLE_ARG_EXPAND);
packed_call_t *pack_glDisableVertexAttribAPPLE(glDisableVertexAttribAPPLE_PACKED *_dst glDisableVertexAttribAPPLE_ARG_EXPAND_TAIL);
typedef void (*glDisableVertexAttribAPPLE_PTR)(glDisableVertexAttribAPPLE_ARG_EXPAND);
#endif
#ifndef glDisableVertexAttribArray_RETURN
#define glDisableVertexAttribArray_RETURN void
#define glDisableVertexAttribArray_ARG_NAMES index
#define glDisableVertexAttribArray_ARG_EXPAND GLuint index
#define glDisableVertexAttribArray_ARG_NAMES_TAIL , index
#define glDisableVertexAttribArray_ARG_EXPAND_TAIL , GLuint index
#define forward_glDisableVertexAttribArray(_index) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableVertexAttribArray_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableVertexAttribArray(dst, _index), NULL); \
    });
#define call_glDisableVertexAttribArray(packed, ret_v) do { \
    glDisableVertexAttribArray_PACKED *unpacked = (glDisableVertexAttribArray_PACKED *)packed; \
    glDisableVertexAttribArray_ARGS *args = (glDisableVertexAttribArray_ARGS *)&unpacked->args; \
    glDisableVertexAttribArray(args->index);; \
} while(0)
void glDisableVertexAttribArray(glDisableVertexAttribArray_ARG_EXPAND);
packed_call_t *pack_glDisableVertexAttribArray(glDisableVertexAttribArray_PACKED *_dst glDisableVertexAttribArray_ARG_EXPAND_TAIL);
typedef void (*glDisableVertexAttribArray_PTR)(glDisableVertexAttribArray_ARG_EXPAND);
#endif
#ifndef glDisableVertexAttribArrayARB_RETURN
#define glDisableVertexAttribArrayARB_RETURN void
#define glDisableVertexAttribArrayARB_ARG_NAMES index
#define glDisableVertexAttribArrayARB_ARG_EXPAND GLuint index
#define glDisableVertexAttribArrayARB_ARG_NAMES_TAIL , index
#define glDisableVertexAttribArrayARB_ARG_EXPAND_TAIL , GLuint index
#define forward_glDisableVertexAttribArrayARB(_index) \
    ({ \
        void *dst = remote_dma(sizeof(glDisableVertexAttribArrayARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisableVertexAttribArrayARB(dst, _index), NULL); \
    });
#define call_glDisableVertexAttribArrayARB(packed, ret_v) do { \
    glDisableVertexAttribArrayARB_PACKED *unpacked = (glDisableVertexAttribArrayARB_PACKED *)packed; \
    glDisableVertexAttribArrayARB_ARGS *args = (glDisableVertexAttribArrayARB_ARGS *)&unpacked->args; \
    glDisableVertexAttribArrayARB(args->index);; \
} while(0)
void glDisableVertexAttribArrayARB(glDisableVertexAttribArrayARB_ARG_EXPAND);
packed_call_t *pack_glDisableVertexAttribArrayARB(glDisableVertexAttribArrayARB_PACKED *_dst glDisableVertexAttribArrayARB_ARG_EXPAND_TAIL);
typedef void (*glDisableVertexAttribArrayARB_PTR)(glDisableVertexAttribArrayARB_ARG_EXPAND);
#endif
#ifndef glDisablei_RETURN
#define glDisablei_RETURN void
#define glDisablei_ARG_NAMES target, index
#define glDisablei_ARG_EXPAND GLenum target, GLuint index
#define glDisablei_ARG_NAMES_TAIL , target, index
#define glDisablei_ARG_EXPAND_TAIL , GLenum target, GLuint index
#define forward_glDisablei(_target, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glDisablei_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDisablei(dst, _target, _index), NULL); \
    });
#define call_glDisablei(packed, ret_v) do { \
    glDisablei_PACKED *unpacked = (glDisablei_PACKED *)packed; \
    glDisablei_ARGS *args = (glDisablei_ARGS *)&unpacked->args; \
    glDisablei(args->target, args->index);; \
} while(0)
void glDisablei(glDisablei_ARG_EXPAND);
packed_call_t *pack_glDisablei(glDisablei_PACKED *_dst glDisablei_ARG_EXPAND_TAIL);
typedef void (*glDisablei_PTR)(glDisablei_ARG_EXPAND);
#endif
#ifndef glDispatchCompute_RETURN
#define glDispatchCompute_RETURN void
#define glDispatchCompute_ARG_NAMES num_groups_x, num_groups_y, num_groups_z
#define glDispatchCompute_ARG_EXPAND GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z
#define glDispatchCompute_ARG_NAMES_TAIL , num_groups_x, num_groups_y, num_groups_z
#define glDispatchCompute_ARG_EXPAND_TAIL , GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z
#define forward_glDispatchCompute(_num_groups_x, _num_groups_y, _num_groups_z) \
    ({ \
        void *dst = remote_dma(sizeof(glDispatchCompute_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDispatchCompute(dst, _num_groups_x, _num_groups_y, _num_groups_z), NULL); \
    });
#define call_glDispatchCompute(packed, ret_v) do { \
    glDispatchCompute_PACKED *unpacked = (glDispatchCompute_PACKED *)packed; \
    glDispatchCompute_ARGS *args = (glDispatchCompute_ARGS *)&unpacked->args; \
    glDispatchCompute(args->num_groups_x, args->num_groups_y, args->num_groups_z);; \
} while(0)
void glDispatchCompute(glDispatchCompute_ARG_EXPAND);
packed_call_t *pack_glDispatchCompute(glDispatchCompute_PACKED *_dst glDispatchCompute_ARG_EXPAND_TAIL);
typedef void (*glDispatchCompute_PTR)(glDispatchCompute_ARG_EXPAND);
#endif
#ifndef glDispatchComputeIndirect_RETURN
#define glDispatchComputeIndirect_RETURN void
#define glDispatchComputeIndirect_ARG_NAMES indirect
#define glDispatchComputeIndirect_ARG_EXPAND GLintptr indirect
#define glDispatchComputeIndirect_ARG_NAMES_TAIL , indirect
#define glDispatchComputeIndirect_ARG_EXPAND_TAIL , GLintptr indirect
#define forward_glDispatchComputeIndirect(_indirect) \
    ({ \
        void *dst = remote_dma(sizeof(glDispatchComputeIndirect_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDispatchComputeIndirect(dst, _indirect), NULL); \
    });
#define call_glDispatchComputeIndirect(packed, ret_v) do { \
    glDispatchComputeIndirect_PACKED *unpacked = (glDispatchComputeIndirect_PACKED *)packed; \
    glDispatchComputeIndirect_ARGS *args = (glDispatchComputeIndirect_ARGS *)&unpacked->args; \
    glDispatchComputeIndirect(args->indirect);; \
} while(0)
void glDispatchComputeIndirect(glDispatchComputeIndirect_ARG_EXPAND);
packed_call_t *pack_glDispatchComputeIndirect(glDispatchComputeIndirect_PACKED *_dst glDispatchComputeIndirect_ARG_EXPAND_TAIL);
typedef void (*glDispatchComputeIndirect_PTR)(glDispatchComputeIndirect_ARG_EXPAND);
#endif
#ifndef glDrawArrays_RETURN
#define glDrawArrays_RETURN void
#define glDrawArrays_ARG_NAMES mode, first, count
#define glDrawArrays_ARG_EXPAND GLenum mode, GLint first, GLsizei count
#define glDrawArrays_ARG_NAMES_TAIL , mode, first, count
#define glDrawArrays_ARG_EXPAND_TAIL , GLenum mode, GLint first, GLsizei count
#define forward_glDrawArrays(_mode, _first, _count) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawArrays_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawArrays(dst, _mode, _first, _count), NULL); \
    });
#define call_glDrawArrays(packed, ret_v) do { \
    glDrawArrays_PACKED *unpacked = (glDrawArrays_PACKED *)packed; \
    glDrawArrays_ARGS *args = (glDrawArrays_ARGS *)&unpacked->args; \
    glDrawArrays(args->mode, args->first, args->count);; \
} while(0)
void glDrawArrays(glDrawArrays_ARG_EXPAND);
packed_call_t *pack_glDrawArrays(glDrawArrays_PACKED *_dst glDrawArrays_ARG_EXPAND_TAIL);
typedef void (*glDrawArrays_PTR)(glDrawArrays_ARG_EXPAND);
#endif
#ifndef glDrawArraysEXT_RETURN
#define glDrawArraysEXT_RETURN void
#define glDrawArraysEXT_ARG_NAMES mode, first, count
#define glDrawArraysEXT_ARG_EXPAND GLenum mode, GLint first, GLsizei count
#define glDrawArraysEXT_ARG_NAMES_TAIL , mode, first, count
#define glDrawArraysEXT_ARG_EXPAND_TAIL , GLenum mode, GLint first, GLsizei count
#define forward_glDrawArraysEXT(_mode, _first, _count) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawArraysEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawArraysEXT(dst, _mode, _first, _count), NULL); \
    });
#define call_glDrawArraysEXT(packed, ret_v) do { \
    glDrawArraysEXT_PACKED *unpacked = (glDrawArraysEXT_PACKED *)packed; \
    glDrawArraysEXT_ARGS *args = (glDrawArraysEXT_ARGS *)&unpacked->args; \
    glDrawArraysEXT(args->mode, args->first, args->count);; \
} while(0)
void glDrawArraysEXT(glDrawArraysEXT_ARG_EXPAND);
packed_call_t *pack_glDrawArraysEXT(glDrawArraysEXT_PACKED *_dst glDrawArraysEXT_ARG_EXPAND_TAIL);
typedef void (*glDrawArraysEXT_PTR)(glDrawArraysEXT_ARG_EXPAND);
#endif
#ifndef glDrawArraysIndirect_RETURN
#define glDrawArraysIndirect_RETURN void
#define glDrawArraysIndirect_ARG_NAMES mode, indirect
#define glDrawArraysIndirect_ARG_EXPAND GLenum mode, const GLvoid * indirect
#define glDrawArraysIndirect_ARG_NAMES_TAIL , mode, indirect
#define glDrawArraysIndirect_ARG_EXPAND_TAIL , GLenum mode, const GLvoid * indirect
#define forward_glDrawArraysIndirect(_mode, _indirect) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawArraysIndirect_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawArraysIndirect(dst, _mode, _indirect), NULL); \
    });
#define call_glDrawArraysIndirect(packed, ret_v) do { \
    glDrawArraysIndirect_PACKED *unpacked = (glDrawArraysIndirect_PACKED *)packed; \
    glDrawArraysIndirect_ARGS *args = (glDrawArraysIndirect_ARGS *)&unpacked->args; \
    glDrawArraysIndirect(args->mode, args->indirect);; \
} while(0)
void glDrawArraysIndirect(glDrawArraysIndirect_ARG_EXPAND);
packed_call_t *pack_glDrawArraysIndirect(glDrawArraysIndirect_PACKED *_dst glDrawArraysIndirect_ARG_EXPAND_TAIL);
typedef void (*glDrawArraysIndirect_PTR)(glDrawArraysIndirect_ARG_EXPAND);
#endif
#ifndef glDrawArraysInstanced_RETURN
#define glDrawArraysInstanced_RETURN void
#define glDrawArraysInstanced_ARG_NAMES mode, first, count, instancecount
#define glDrawArraysInstanced_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei instancecount
#define glDrawArraysInstanced_ARG_NAMES_TAIL , mode, first, count, instancecount
#define glDrawArraysInstanced_ARG_EXPAND_TAIL , GLenum mode, GLint first, GLsizei count, GLsizei instancecount
#define forward_glDrawArraysInstanced(_mode, _first, _count, _instancecount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawArraysInstanced_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawArraysInstanced(dst, _mode, _first, _count, _instancecount), NULL); \
    });
#define call_glDrawArraysInstanced(packed, ret_v) do { \
    glDrawArraysInstanced_PACKED *unpacked = (glDrawArraysInstanced_PACKED *)packed; \
    glDrawArraysInstanced_ARGS *args = (glDrawArraysInstanced_ARGS *)&unpacked->args; \
    glDrawArraysInstanced(args->mode, args->first, args->count, args->instancecount);; \
} while(0)
void glDrawArraysInstanced(glDrawArraysInstanced_ARG_EXPAND);
packed_call_t *pack_glDrawArraysInstanced(glDrawArraysInstanced_PACKED *_dst glDrawArraysInstanced_ARG_EXPAND_TAIL);
typedef void (*glDrawArraysInstanced_PTR)(glDrawArraysInstanced_ARG_EXPAND);
#endif
#ifndef glDrawArraysInstancedARB_RETURN
#define glDrawArraysInstancedARB_RETURN void
#define glDrawArraysInstancedARB_ARG_NAMES mode, first, count, primcount
#define glDrawArraysInstancedARB_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei primcount
#define glDrawArraysInstancedARB_ARG_NAMES_TAIL , mode, first, count, primcount
#define glDrawArraysInstancedARB_ARG_EXPAND_TAIL , GLenum mode, GLint first, GLsizei count, GLsizei primcount
#define forward_glDrawArraysInstancedARB(_mode, _first, _count, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawArraysInstancedARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawArraysInstancedARB(dst, _mode, _first, _count, _primcount), NULL); \
    });
#define call_glDrawArraysInstancedARB(packed, ret_v) do { \
    glDrawArraysInstancedARB_PACKED *unpacked = (glDrawArraysInstancedARB_PACKED *)packed; \
    glDrawArraysInstancedARB_ARGS *args = (glDrawArraysInstancedARB_ARGS *)&unpacked->args; \
    glDrawArraysInstancedARB(args->mode, args->first, args->count, args->primcount);; \
} while(0)
void glDrawArraysInstancedARB(glDrawArraysInstancedARB_ARG_EXPAND);
packed_call_t *pack_glDrawArraysInstancedARB(glDrawArraysInstancedARB_PACKED *_dst glDrawArraysInstancedARB_ARG_EXPAND_TAIL);
typedef void (*glDrawArraysInstancedARB_PTR)(glDrawArraysInstancedARB_ARG_EXPAND);
#endif
#ifndef glDrawArraysInstancedBaseInstance_RETURN
#define glDrawArraysInstancedBaseInstance_RETURN void
#define glDrawArraysInstancedBaseInstance_ARG_NAMES mode, first, count, instancecount, baseinstance
#define glDrawArraysInstancedBaseInstance_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance
#define glDrawArraysInstancedBaseInstance_ARG_NAMES_TAIL , mode, first, count, instancecount, baseinstance
#define glDrawArraysInstancedBaseInstance_ARG_EXPAND_TAIL , GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance
#define forward_glDrawArraysInstancedBaseInstance(_mode, _first, _count, _instancecount, _baseinstance) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawArraysInstancedBaseInstance_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawArraysInstancedBaseInstance(dst, _mode, _first, _count, _instancecount, _baseinstance), NULL); \
    });
#define call_glDrawArraysInstancedBaseInstance(packed, ret_v) do { \
    glDrawArraysInstancedBaseInstance_PACKED *unpacked = (glDrawArraysInstancedBaseInstance_PACKED *)packed; \
    glDrawArraysInstancedBaseInstance_ARGS *args = (glDrawArraysInstancedBaseInstance_ARGS *)&unpacked->args; \
    glDrawArraysInstancedBaseInstance(args->mode, args->first, args->count, args->instancecount, args->baseinstance);; \
} while(0)
void glDrawArraysInstancedBaseInstance(glDrawArraysInstancedBaseInstance_ARG_EXPAND);
packed_call_t *pack_glDrawArraysInstancedBaseInstance(glDrawArraysInstancedBaseInstance_PACKED *_dst glDrawArraysInstancedBaseInstance_ARG_EXPAND_TAIL);
typedef void (*glDrawArraysInstancedBaseInstance_PTR)(glDrawArraysInstancedBaseInstance_ARG_EXPAND);
#endif
#ifndef glDrawArraysInstancedEXT_RETURN
#define glDrawArraysInstancedEXT_RETURN void
#define glDrawArraysInstancedEXT_ARG_NAMES mode, start, count, primcount
#define glDrawArraysInstancedEXT_ARG_EXPAND GLenum mode, GLint start, GLsizei count, GLsizei primcount
#define glDrawArraysInstancedEXT_ARG_NAMES_TAIL , mode, start, count, primcount
#define glDrawArraysInstancedEXT_ARG_EXPAND_TAIL , GLenum mode, GLint start, GLsizei count, GLsizei primcount
#define forward_glDrawArraysInstancedEXT(_mode, _start, _count, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawArraysInstancedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawArraysInstancedEXT(dst, _mode, _start, _count, _primcount), NULL); \
    });
#define call_glDrawArraysInstancedEXT(packed, ret_v) do { \
    glDrawArraysInstancedEXT_PACKED *unpacked = (glDrawArraysInstancedEXT_PACKED *)packed; \
    glDrawArraysInstancedEXT_ARGS *args = (glDrawArraysInstancedEXT_ARGS *)&unpacked->args; \
    glDrawArraysInstancedEXT(args->mode, args->start, args->count, args->primcount);; \
} while(0)
void glDrawArraysInstancedEXT(glDrawArraysInstancedEXT_ARG_EXPAND);
packed_call_t *pack_glDrawArraysInstancedEXT(glDrawArraysInstancedEXT_PACKED *_dst glDrawArraysInstancedEXT_ARG_EXPAND_TAIL);
typedef void (*glDrawArraysInstancedEXT_PTR)(glDrawArraysInstancedEXT_ARG_EXPAND);
#endif
#ifndef glDrawBuffer_RETURN
#define glDrawBuffer_RETURN void
#define glDrawBuffer_ARG_NAMES mode
#define glDrawBuffer_ARG_EXPAND GLenum mode
#define glDrawBuffer_ARG_NAMES_TAIL , mode
#define glDrawBuffer_ARG_EXPAND_TAIL , GLenum mode
#define forward_glDrawBuffer(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawBuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawBuffer(dst, _mode), NULL); \
    });
#define call_glDrawBuffer(packed, ret_v) do { \
    glDrawBuffer_PACKED *unpacked = (glDrawBuffer_PACKED *)packed; \
    glDrawBuffer_ARGS *args = (glDrawBuffer_ARGS *)&unpacked->args; \
    glDrawBuffer(args->mode);; \
} while(0)
void glDrawBuffer(glDrawBuffer_ARG_EXPAND);
packed_call_t *pack_glDrawBuffer(glDrawBuffer_PACKED *_dst glDrawBuffer_ARG_EXPAND_TAIL);
typedef void (*glDrawBuffer_PTR)(glDrawBuffer_ARG_EXPAND);
#endif
#ifndef glDrawBuffers_RETURN
#define glDrawBuffers_RETURN void
#define glDrawBuffers_ARG_NAMES n, bufs
#define glDrawBuffers_ARG_EXPAND GLsizei n, const GLenum * bufs
#define glDrawBuffers_ARG_NAMES_TAIL , n, bufs
#define glDrawBuffers_ARG_EXPAND_TAIL , GLsizei n, const GLenum * bufs
#define forward_glDrawBuffers(_n, _bufs) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawBuffers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawBuffers(dst, _n, _bufs), NULL); \
    });
#define call_glDrawBuffers(packed, ret_v) do { \
    glDrawBuffers_PACKED *unpacked = (glDrawBuffers_PACKED *)packed; \
    glDrawBuffers_ARGS *args = (glDrawBuffers_ARGS *)&unpacked->args; \
    glDrawBuffers(args->n, args->bufs);; \
} while(0)
void glDrawBuffers(glDrawBuffers_ARG_EXPAND);
packed_call_t *pack_glDrawBuffers(glDrawBuffers_PACKED *_dst glDrawBuffers_ARG_EXPAND_TAIL);
typedef void (*glDrawBuffers_PTR)(glDrawBuffers_ARG_EXPAND);
#endif
#ifndef glDrawBuffersARB_RETURN
#define glDrawBuffersARB_RETURN void
#define glDrawBuffersARB_ARG_NAMES n, bufs
#define glDrawBuffersARB_ARG_EXPAND GLsizei n, const GLenum * bufs
#define glDrawBuffersARB_ARG_NAMES_TAIL , n, bufs
#define glDrawBuffersARB_ARG_EXPAND_TAIL , GLsizei n, const GLenum * bufs
#define forward_glDrawBuffersARB(_n, _bufs) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawBuffersARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawBuffersARB(dst, _n, _bufs), NULL); \
    });
#define call_glDrawBuffersARB(packed, ret_v) do { \
    glDrawBuffersARB_PACKED *unpacked = (glDrawBuffersARB_PACKED *)packed; \
    glDrawBuffersARB_ARGS *args = (glDrawBuffersARB_ARGS *)&unpacked->args; \
    glDrawBuffersARB(args->n, args->bufs);; \
} while(0)
void glDrawBuffersARB(glDrawBuffersARB_ARG_EXPAND);
packed_call_t *pack_glDrawBuffersARB(glDrawBuffersARB_PACKED *_dst glDrawBuffersARB_ARG_EXPAND_TAIL);
typedef void (*glDrawBuffersARB_PTR)(glDrawBuffersARB_ARG_EXPAND);
#endif
#ifndef glDrawBuffersATI_RETURN
#define glDrawBuffersATI_RETURN void
#define glDrawBuffersATI_ARG_NAMES n, bufs
#define glDrawBuffersATI_ARG_EXPAND GLsizei n, const GLenum * bufs
#define glDrawBuffersATI_ARG_NAMES_TAIL , n, bufs
#define glDrawBuffersATI_ARG_EXPAND_TAIL , GLsizei n, const GLenum * bufs
#define forward_glDrawBuffersATI(_n, _bufs) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawBuffersATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawBuffersATI(dst, _n, _bufs), NULL); \
    });
#define call_glDrawBuffersATI(packed, ret_v) do { \
    glDrawBuffersATI_PACKED *unpacked = (glDrawBuffersATI_PACKED *)packed; \
    glDrawBuffersATI_ARGS *args = (glDrawBuffersATI_ARGS *)&unpacked->args; \
    glDrawBuffersATI(args->n, args->bufs);; \
} while(0)
void glDrawBuffersATI(glDrawBuffersATI_ARG_EXPAND);
packed_call_t *pack_glDrawBuffersATI(glDrawBuffersATI_PACKED *_dst glDrawBuffersATI_ARG_EXPAND_TAIL);
typedef void (*glDrawBuffersATI_PTR)(glDrawBuffersATI_ARG_EXPAND);
#endif
#ifndef glDrawElementArrayAPPLE_RETURN
#define glDrawElementArrayAPPLE_RETURN void
#define glDrawElementArrayAPPLE_ARG_NAMES mode, first, count
#define glDrawElementArrayAPPLE_ARG_EXPAND GLenum mode, GLint first, GLsizei count
#define glDrawElementArrayAPPLE_ARG_NAMES_TAIL , mode, first, count
#define glDrawElementArrayAPPLE_ARG_EXPAND_TAIL , GLenum mode, GLint first, GLsizei count
#define forward_glDrawElementArrayAPPLE(_mode, _first, _count) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementArrayAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementArrayAPPLE(dst, _mode, _first, _count), NULL); \
    });
#define call_glDrawElementArrayAPPLE(packed, ret_v) do { \
    glDrawElementArrayAPPLE_PACKED *unpacked = (glDrawElementArrayAPPLE_PACKED *)packed; \
    glDrawElementArrayAPPLE_ARGS *args = (glDrawElementArrayAPPLE_ARGS *)&unpacked->args; \
    glDrawElementArrayAPPLE(args->mode, args->first, args->count);; \
} while(0)
void glDrawElementArrayAPPLE(glDrawElementArrayAPPLE_ARG_EXPAND);
packed_call_t *pack_glDrawElementArrayAPPLE(glDrawElementArrayAPPLE_PACKED *_dst glDrawElementArrayAPPLE_ARG_EXPAND_TAIL);
typedef void (*glDrawElementArrayAPPLE_PTR)(glDrawElementArrayAPPLE_ARG_EXPAND);
#endif
#ifndef glDrawElementArrayATI_RETURN
#define glDrawElementArrayATI_RETURN void
#define glDrawElementArrayATI_ARG_NAMES mode, count
#define glDrawElementArrayATI_ARG_EXPAND GLenum mode, GLsizei count
#define glDrawElementArrayATI_ARG_NAMES_TAIL , mode, count
#define glDrawElementArrayATI_ARG_EXPAND_TAIL , GLenum mode, GLsizei count
#define forward_glDrawElementArrayATI(_mode, _count) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementArrayATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementArrayATI(dst, _mode, _count), NULL); \
    });
#define call_glDrawElementArrayATI(packed, ret_v) do { \
    glDrawElementArrayATI_PACKED *unpacked = (glDrawElementArrayATI_PACKED *)packed; \
    glDrawElementArrayATI_ARGS *args = (glDrawElementArrayATI_ARGS *)&unpacked->args; \
    glDrawElementArrayATI(args->mode, args->count);; \
} while(0)
void glDrawElementArrayATI(glDrawElementArrayATI_ARG_EXPAND);
packed_call_t *pack_glDrawElementArrayATI(glDrawElementArrayATI_PACKED *_dst glDrawElementArrayATI_ARG_EXPAND_TAIL);
typedef void (*glDrawElementArrayATI_PTR)(glDrawElementArrayATI_ARG_EXPAND);
#endif
#ifndef glDrawElements_RETURN
#define glDrawElements_RETURN void
#define glDrawElements_ARG_NAMES mode, count, type, indices
#define glDrawElements_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices
#define glDrawElements_ARG_NAMES_TAIL , mode, count, type, indices
#define glDrawElements_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const GLvoid * indices
#define forward_glDrawElements(_mode, _count, _type, _indices) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElements_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElements(dst, _mode, _count, _type, _indices), NULL); \
    });
#define call_glDrawElements(packed, ret_v) do { \
    glDrawElements_PACKED *unpacked = (glDrawElements_PACKED *)packed; \
    glDrawElements_ARGS *args = (glDrawElements_ARGS *)&unpacked->args; \
    glDrawElements(args->mode, args->count, args->type, args->indices);; \
} while(0)
void glDrawElements(glDrawElements_ARG_EXPAND);
packed_call_t *pack_glDrawElements(glDrawElements_PACKED *_dst glDrawElements_ARG_EXPAND_TAIL);
typedef void (*glDrawElements_PTR)(glDrawElements_ARG_EXPAND);
#endif
#ifndef glDrawElementsBaseVertex_RETURN
#define glDrawElementsBaseVertex_RETURN void
#define glDrawElementsBaseVertex_ARG_NAMES mode, count, type, indices, basevertex
#define glDrawElementsBaseVertex_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex
#define glDrawElementsBaseVertex_ARG_NAMES_TAIL , mode, count, type, indices, basevertex
#define glDrawElementsBaseVertex_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex
#define forward_glDrawElementsBaseVertex(_mode, _count, _type, _indices, _basevertex) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsBaseVertex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsBaseVertex(dst, _mode, _count, _type, _indices, _basevertex), NULL); \
    });
#define call_glDrawElementsBaseVertex(packed, ret_v) do { \
    glDrawElementsBaseVertex_PACKED *unpacked = (glDrawElementsBaseVertex_PACKED *)packed; \
    glDrawElementsBaseVertex_ARGS *args = (glDrawElementsBaseVertex_ARGS *)&unpacked->args; \
    glDrawElementsBaseVertex(args->mode, args->count, args->type, args->indices, args->basevertex);; \
} while(0)
void glDrawElementsBaseVertex(glDrawElementsBaseVertex_ARG_EXPAND);
packed_call_t *pack_glDrawElementsBaseVertex(glDrawElementsBaseVertex_PACKED *_dst glDrawElementsBaseVertex_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsBaseVertex_PTR)(glDrawElementsBaseVertex_ARG_EXPAND);
#endif
#ifndef glDrawElementsIndirect_RETURN
#define glDrawElementsIndirect_RETURN void
#define glDrawElementsIndirect_ARG_NAMES mode, type, indirect
#define glDrawElementsIndirect_ARG_EXPAND GLenum mode, GLenum type, const GLvoid * indirect
#define glDrawElementsIndirect_ARG_NAMES_TAIL , mode, type, indirect
#define glDrawElementsIndirect_ARG_EXPAND_TAIL , GLenum mode, GLenum type, const GLvoid * indirect
#define forward_glDrawElementsIndirect(_mode, _type, _indirect) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsIndirect_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsIndirect(dst, _mode, _type, _indirect), NULL); \
    });
#define call_glDrawElementsIndirect(packed, ret_v) do { \
    glDrawElementsIndirect_PACKED *unpacked = (glDrawElementsIndirect_PACKED *)packed; \
    glDrawElementsIndirect_ARGS *args = (glDrawElementsIndirect_ARGS *)&unpacked->args; \
    glDrawElementsIndirect(args->mode, args->type, args->indirect);; \
} while(0)
void glDrawElementsIndirect(glDrawElementsIndirect_ARG_EXPAND);
packed_call_t *pack_glDrawElementsIndirect(glDrawElementsIndirect_PACKED *_dst glDrawElementsIndirect_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsIndirect_PTR)(glDrawElementsIndirect_ARG_EXPAND);
#endif
#ifndef glDrawElementsInstanced_RETURN
#define glDrawElementsInstanced_RETURN void
#define glDrawElementsInstanced_ARG_NAMES mode, count, type, indices, instancecount
#define glDrawElementsInstanced_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei instancecount
#define glDrawElementsInstanced_ARG_NAMES_TAIL , mode, count, type, indices, instancecount
#define glDrawElementsInstanced_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei instancecount
#define forward_glDrawElementsInstanced(_mode, _count, _type, _indices, _instancecount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsInstanced_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsInstanced(dst, _mode, _count, _type, _indices, _instancecount), NULL); \
    });
#define call_glDrawElementsInstanced(packed, ret_v) do { \
    glDrawElementsInstanced_PACKED *unpacked = (glDrawElementsInstanced_PACKED *)packed; \
    glDrawElementsInstanced_ARGS *args = (glDrawElementsInstanced_ARGS *)&unpacked->args; \
    glDrawElementsInstanced(args->mode, args->count, args->type, args->indices, args->instancecount);; \
} while(0)
void glDrawElementsInstanced(glDrawElementsInstanced_ARG_EXPAND);
packed_call_t *pack_glDrawElementsInstanced(glDrawElementsInstanced_PACKED *_dst glDrawElementsInstanced_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsInstanced_PTR)(glDrawElementsInstanced_ARG_EXPAND);
#endif
#ifndef glDrawElementsInstancedARB_RETURN
#define glDrawElementsInstancedARB_RETURN void
#define glDrawElementsInstancedARB_ARG_NAMES mode, count, type, indices, primcount
#define glDrawElementsInstancedARB_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount
#define glDrawElementsInstancedARB_ARG_NAMES_TAIL , mode, count, type, indices, primcount
#define glDrawElementsInstancedARB_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount
#define forward_glDrawElementsInstancedARB(_mode, _count, _type, _indices, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsInstancedARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsInstancedARB(dst, _mode, _count, _type, _indices, _primcount), NULL); \
    });
#define call_glDrawElementsInstancedARB(packed, ret_v) do { \
    glDrawElementsInstancedARB_PACKED *unpacked = (glDrawElementsInstancedARB_PACKED *)packed; \
    glDrawElementsInstancedARB_ARGS *args = (glDrawElementsInstancedARB_ARGS *)&unpacked->args; \
    glDrawElementsInstancedARB(args->mode, args->count, args->type, args->indices, args->primcount);; \
} while(0)
void glDrawElementsInstancedARB(glDrawElementsInstancedARB_ARG_EXPAND);
packed_call_t *pack_glDrawElementsInstancedARB(glDrawElementsInstancedARB_PACKED *_dst glDrawElementsInstancedARB_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsInstancedARB_PTR)(glDrawElementsInstancedARB_ARG_EXPAND);
#endif
#ifndef glDrawElementsInstancedBaseInstance_RETURN
#define glDrawElementsInstancedBaseInstance_RETURN void
#define glDrawElementsInstancedBaseInstance_ARG_NAMES mode, count, type, indices, instancecount, baseinstance
#define glDrawElementsInstancedBaseInstance_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance
#define glDrawElementsInstancedBaseInstance_ARG_NAMES_TAIL , mode, count, type, indices, instancecount, baseinstance
#define glDrawElementsInstancedBaseInstance_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance
#define forward_glDrawElementsInstancedBaseInstance(_mode, _count, _type, _indices, _instancecount, _baseinstance) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsInstancedBaseInstance_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsInstancedBaseInstance(dst, _mode, _count, _type, _indices, _instancecount, _baseinstance), NULL); \
    });
#define call_glDrawElementsInstancedBaseInstance(packed, ret_v) do { \
    glDrawElementsInstancedBaseInstance_PACKED *unpacked = (glDrawElementsInstancedBaseInstance_PACKED *)packed; \
    glDrawElementsInstancedBaseInstance_ARGS *args = (glDrawElementsInstancedBaseInstance_ARGS *)&unpacked->args; \
    glDrawElementsInstancedBaseInstance(args->mode, args->count, args->type, args->indices, args->instancecount, args->baseinstance);; \
} while(0)
void glDrawElementsInstancedBaseInstance(glDrawElementsInstancedBaseInstance_ARG_EXPAND);
packed_call_t *pack_glDrawElementsInstancedBaseInstance(glDrawElementsInstancedBaseInstance_PACKED *_dst glDrawElementsInstancedBaseInstance_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsInstancedBaseInstance_PTR)(glDrawElementsInstancedBaseInstance_ARG_EXPAND);
#endif
#ifndef glDrawElementsInstancedBaseVertex_RETURN
#define glDrawElementsInstancedBaseVertex_RETURN void
#define glDrawElementsInstancedBaseVertex_ARG_NAMES mode, count, type, indices, instancecount, basevertex
#define glDrawElementsInstancedBaseVertex_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei instancecount, GLint basevertex
#define glDrawElementsInstancedBaseVertex_ARG_NAMES_TAIL , mode, count, type, indices, instancecount, basevertex
#define glDrawElementsInstancedBaseVertex_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei instancecount, GLint basevertex
#define forward_glDrawElementsInstancedBaseVertex(_mode, _count, _type, _indices, _instancecount, _basevertex) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsInstancedBaseVertex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsInstancedBaseVertex(dst, _mode, _count, _type, _indices, _instancecount, _basevertex), NULL); \
    });
#define call_glDrawElementsInstancedBaseVertex(packed, ret_v) do { \
    glDrawElementsInstancedBaseVertex_PACKED *unpacked = (glDrawElementsInstancedBaseVertex_PACKED *)packed; \
    glDrawElementsInstancedBaseVertex_ARGS *args = (glDrawElementsInstancedBaseVertex_ARGS *)&unpacked->args; \
    glDrawElementsInstancedBaseVertex(args->mode, args->count, args->type, args->indices, args->instancecount, args->basevertex);; \
} while(0)
void glDrawElementsInstancedBaseVertex(glDrawElementsInstancedBaseVertex_ARG_EXPAND);
packed_call_t *pack_glDrawElementsInstancedBaseVertex(glDrawElementsInstancedBaseVertex_PACKED *_dst glDrawElementsInstancedBaseVertex_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsInstancedBaseVertex_PTR)(glDrawElementsInstancedBaseVertex_ARG_EXPAND);
#endif
#ifndef glDrawElementsInstancedBaseVertexBaseInstance_RETURN
#define glDrawElementsInstancedBaseVertexBaseInstance_RETURN void
#define glDrawElementsInstancedBaseVertexBaseInstance_ARG_NAMES mode, count, type, indices, instancecount, basevertex, baseinstance
#define glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance
#define glDrawElementsInstancedBaseVertexBaseInstance_ARG_NAMES_TAIL , mode, count, type, indices, instancecount, basevertex, baseinstance
#define glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance
#define forward_glDrawElementsInstancedBaseVertexBaseInstance(_mode, _count, _type, _indices, _instancecount, _basevertex, _baseinstance) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsInstancedBaseVertexBaseInstance_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsInstancedBaseVertexBaseInstance(dst, _mode, _count, _type, _indices, _instancecount, _basevertex, _baseinstance), NULL); \
    });
#define call_glDrawElementsInstancedBaseVertexBaseInstance(packed, ret_v) do { \
    glDrawElementsInstancedBaseVertexBaseInstance_PACKED *unpacked = (glDrawElementsInstancedBaseVertexBaseInstance_PACKED *)packed; \
    glDrawElementsInstancedBaseVertexBaseInstance_ARGS *args = (glDrawElementsInstancedBaseVertexBaseInstance_ARGS *)&unpacked->args; \
    glDrawElementsInstancedBaseVertexBaseInstance(args->mode, args->count, args->type, args->indices, args->instancecount, args->basevertex, args->baseinstance);; \
} while(0)
void glDrawElementsInstancedBaseVertexBaseInstance(glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND);
packed_call_t *pack_glDrawElementsInstancedBaseVertexBaseInstance(glDrawElementsInstancedBaseVertexBaseInstance_PACKED *_dst glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsInstancedBaseVertexBaseInstance_PTR)(glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND);
#endif
#ifndef glDrawElementsInstancedEXT_RETURN
#define glDrawElementsInstancedEXT_RETURN void
#define glDrawElementsInstancedEXT_ARG_NAMES mode, count, type, indices, primcount
#define glDrawElementsInstancedEXT_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount
#define glDrawElementsInstancedEXT_ARG_NAMES_TAIL , mode, count, type, indices, primcount
#define glDrawElementsInstancedEXT_ARG_EXPAND_TAIL , GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount
#define forward_glDrawElementsInstancedEXT(_mode, _count, _type, _indices, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawElementsInstancedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawElementsInstancedEXT(dst, _mode, _count, _type, _indices, _primcount), NULL); \
    });
#define call_glDrawElementsInstancedEXT(packed, ret_v) do { \
    glDrawElementsInstancedEXT_PACKED *unpacked = (glDrawElementsInstancedEXT_PACKED *)packed; \
    glDrawElementsInstancedEXT_ARGS *args = (glDrawElementsInstancedEXT_ARGS *)&unpacked->args; \
    glDrawElementsInstancedEXT(args->mode, args->count, args->type, args->indices, args->primcount);; \
} while(0)
void glDrawElementsInstancedEXT(glDrawElementsInstancedEXT_ARG_EXPAND);
packed_call_t *pack_glDrawElementsInstancedEXT(glDrawElementsInstancedEXT_PACKED *_dst glDrawElementsInstancedEXT_ARG_EXPAND_TAIL);
typedef void (*glDrawElementsInstancedEXT_PTR)(glDrawElementsInstancedEXT_ARG_EXPAND);
#endif
#ifndef glDrawMeshArraysSUN_RETURN
#define glDrawMeshArraysSUN_RETURN void
#define glDrawMeshArraysSUN_ARG_NAMES mode, first, count, width
#define glDrawMeshArraysSUN_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei width
#define glDrawMeshArraysSUN_ARG_NAMES_TAIL , mode, first, count, width
#define glDrawMeshArraysSUN_ARG_EXPAND_TAIL , GLenum mode, GLint first, GLsizei count, GLsizei width
#define forward_glDrawMeshArraysSUN(_mode, _first, _count, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawMeshArraysSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawMeshArraysSUN(dst, _mode, _first, _count, _width), NULL); \
    });
#define call_glDrawMeshArraysSUN(packed, ret_v) do { \
    glDrawMeshArraysSUN_PACKED *unpacked = (glDrawMeshArraysSUN_PACKED *)packed; \
    glDrawMeshArraysSUN_ARGS *args = (glDrawMeshArraysSUN_ARGS *)&unpacked->args; \
    glDrawMeshArraysSUN(args->mode, args->first, args->count, args->width);; \
} while(0)
void glDrawMeshArraysSUN(glDrawMeshArraysSUN_ARG_EXPAND);
packed_call_t *pack_glDrawMeshArraysSUN(glDrawMeshArraysSUN_PACKED *_dst glDrawMeshArraysSUN_ARG_EXPAND_TAIL);
typedef void (*glDrawMeshArraysSUN_PTR)(glDrawMeshArraysSUN_ARG_EXPAND);
#endif
#ifndef glDrawPixels_RETURN
#define glDrawPixels_RETURN void
#define glDrawPixels_ARG_NAMES width, height, format, type, pixels
#define glDrawPixels_ARG_EXPAND GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glDrawPixels_ARG_NAMES_TAIL , width, height, format, type, pixels
#define glDrawPixels_ARG_EXPAND_TAIL , GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glDrawPixels(_width, _height, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawPixels_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawPixels(dst, _width, _height, _format, _type, _pixels), NULL); \
    });
#define call_glDrawPixels(packed, ret_v) do { \
    glDrawPixels_PACKED *unpacked = (glDrawPixels_PACKED *)packed; \
    glDrawPixels_ARGS *args = (glDrawPixels_ARGS *)&unpacked->args; \
    glDrawPixels(args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glDrawPixels(glDrawPixels_ARG_EXPAND);
packed_call_t *pack_glDrawPixels(glDrawPixels_PACKED *_dst glDrawPixels_ARG_EXPAND_TAIL);
typedef void (*glDrawPixels_PTR)(glDrawPixels_ARG_EXPAND);
#endif
#ifndef glDrawRangeElementArrayAPPLE_RETURN
#define glDrawRangeElementArrayAPPLE_RETURN void
#define glDrawRangeElementArrayAPPLE_ARG_NAMES mode, start, end, first, count
#define glDrawRangeElementArrayAPPLE_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count
#define glDrawRangeElementArrayAPPLE_ARG_NAMES_TAIL , mode, start, end, first, count
#define glDrawRangeElementArrayAPPLE_ARG_EXPAND_TAIL , GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count
#define forward_glDrawRangeElementArrayAPPLE(_mode, _start, _end, _first, _count) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawRangeElementArrayAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawRangeElementArrayAPPLE(dst, _mode, _start, _end, _first, _count), NULL); \
    });
#define call_glDrawRangeElementArrayAPPLE(packed, ret_v) do { \
    glDrawRangeElementArrayAPPLE_PACKED *unpacked = (glDrawRangeElementArrayAPPLE_PACKED *)packed; \
    glDrawRangeElementArrayAPPLE_ARGS *args = (glDrawRangeElementArrayAPPLE_ARGS *)&unpacked->args; \
    glDrawRangeElementArrayAPPLE(args->mode, args->start, args->end, args->first, args->count);; \
} while(0)
void glDrawRangeElementArrayAPPLE(glDrawRangeElementArrayAPPLE_ARG_EXPAND);
packed_call_t *pack_glDrawRangeElementArrayAPPLE(glDrawRangeElementArrayAPPLE_PACKED *_dst glDrawRangeElementArrayAPPLE_ARG_EXPAND_TAIL);
typedef void (*glDrawRangeElementArrayAPPLE_PTR)(glDrawRangeElementArrayAPPLE_ARG_EXPAND);
#endif
#ifndef glDrawRangeElementArrayATI_RETURN
#define glDrawRangeElementArrayATI_RETURN void
#define glDrawRangeElementArrayATI_ARG_NAMES mode, start, end, count
#define glDrawRangeElementArrayATI_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count
#define glDrawRangeElementArrayATI_ARG_NAMES_TAIL , mode, start, end, count
#define glDrawRangeElementArrayATI_ARG_EXPAND_TAIL , GLenum mode, GLuint start, GLuint end, GLsizei count
#define forward_glDrawRangeElementArrayATI(_mode, _start, _end, _count) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawRangeElementArrayATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawRangeElementArrayATI(dst, _mode, _start, _end, _count), NULL); \
    });
#define call_glDrawRangeElementArrayATI(packed, ret_v) do { \
    glDrawRangeElementArrayATI_PACKED *unpacked = (glDrawRangeElementArrayATI_PACKED *)packed; \
    glDrawRangeElementArrayATI_ARGS *args = (glDrawRangeElementArrayATI_ARGS *)&unpacked->args; \
    glDrawRangeElementArrayATI(args->mode, args->start, args->end, args->count);; \
} while(0)
void glDrawRangeElementArrayATI(glDrawRangeElementArrayATI_ARG_EXPAND);
packed_call_t *pack_glDrawRangeElementArrayATI(glDrawRangeElementArrayATI_PACKED *_dst glDrawRangeElementArrayATI_ARG_EXPAND_TAIL);
typedef void (*glDrawRangeElementArrayATI_PTR)(glDrawRangeElementArrayATI_ARG_EXPAND);
#endif
#ifndef glDrawRangeElements_RETURN
#define glDrawRangeElements_RETURN void
#define glDrawRangeElements_ARG_NAMES mode, start, end, count, type, indices
#define glDrawRangeElements_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices
#define glDrawRangeElements_ARG_NAMES_TAIL , mode, start, end, count, type, indices
#define glDrawRangeElements_ARG_EXPAND_TAIL , GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices
#define forward_glDrawRangeElements(_mode, _start, _end, _count, _type, _indices) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawRangeElements_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawRangeElements(dst, _mode, _start, _end, _count, _type, _indices), NULL); \
    });
#define call_glDrawRangeElements(packed, ret_v) do { \
    glDrawRangeElements_PACKED *unpacked = (glDrawRangeElements_PACKED *)packed; \
    glDrawRangeElements_ARGS *args = (glDrawRangeElements_ARGS *)&unpacked->args; \
    glDrawRangeElements(args->mode, args->start, args->end, args->count, args->type, args->indices);; \
} while(0)
void glDrawRangeElements(glDrawRangeElements_ARG_EXPAND);
packed_call_t *pack_glDrawRangeElements(glDrawRangeElements_PACKED *_dst glDrawRangeElements_ARG_EXPAND_TAIL);
typedef void (*glDrawRangeElements_PTR)(glDrawRangeElements_ARG_EXPAND);
#endif
#ifndef glDrawRangeElementsBaseVertex_RETURN
#define glDrawRangeElementsBaseVertex_RETURN void
#define glDrawRangeElementsBaseVertex_ARG_NAMES mode, start, end, count, type, indices, basevertex
#define glDrawRangeElementsBaseVertex_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex
#define glDrawRangeElementsBaseVertex_ARG_NAMES_TAIL , mode, start, end, count, type, indices, basevertex
#define glDrawRangeElementsBaseVertex_ARG_EXPAND_TAIL , GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex
#define forward_glDrawRangeElementsBaseVertex(_mode, _start, _end, _count, _type, _indices, _basevertex) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawRangeElementsBaseVertex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawRangeElementsBaseVertex(dst, _mode, _start, _end, _count, _type, _indices, _basevertex), NULL); \
    });
#define call_glDrawRangeElementsBaseVertex(packed, ret_v) do { \
    glDrawRangeElementsBaseVertex_PACKED *unpacked = (glDrawRangeElementsBaseVertex_PACKED *)packed; \
    glDrawRangeElementsBaseVertex_ARGS *args = (glDrawRangeElementsBaseVertex_ARGS *)&unpacked->args; \
    glDrawRangeElementsBaseVertex(args->mode, args->start, args->end, args->count, args->type, args->indices, args->basevertex);; \
} while(0)
void glDrawRangeElementsBaseVertex(glDrawRangeElementsBaseVertex_ARG_EXPAND);
packed_call_t *pack_glDrawRangeElementsBaseVertex(glDrawRangeElementsBaseVertex_PACKED *_dst glDrawRangeElementsBaseVertex_ARG_EXPAND_TAIL);
typedef void (*glDrawRangeElementsBaseVertex_PTR)(glDrawRangeElementsBaseVertex_ARG_EXPAND);
#endif
#ifndef glDrawRangeElementsEXT_RETURN
#define glDrawRangeElementsEXT_RETURN void
#define glDrawRangeElementsEXT_ARG_NAMES mode, start, end, count, type, indices
#define glDrawRangeElementsEXT_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices
#define glDrawRangeElementsEXT_ARG_NAMES_TAIL , mode, start, end, count, type, indices
#define glDrawRangeElementsEXT_ARG_EXPAND_TAIL , GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices
#define forward_glDrawRangeElementsEXT(_mode, _start, _end, _count, _type, _indices) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawRangeElementsEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawRangeElementsEXT(dst, _mode, _start, _end, _count, _type, _indices), NULL); \
    });
#define call_glDrawRangeElementsEXT(packed, ret_v) do { \
    glDrawRangeElementsEXT_PACKED *unpacked = (glDrawRangeElementsEXT_PACKED *)packed; \
    glDrawRangeElementsEXT_ARGS *args = (glDrawRangeElementsEXT_ARGS *)&unpacked->args; \
    glDrawRangeElementsEXT(args->mode, args->start, args->end, args->count, args->type, args->indices);; \
} while(0)
void glDrawRangeElementsEXT(glDrawRangeElementsEXT_ARG_EXPAND);
packed_call_t *pack_glDrawRangeElementsEXT(glDrawRangeElementsEXT_PACKED *_dst glDrawRangeElementsEXT_ARG_EXPAND_TAIL);
typedef void (*glDrawRangeElementsEXT_PTR)(glDrawRangeElementsEXT_ARG_EXPAND);
#endif
#ifndef glDrawTextureNV_RETURN
#define glDrawTextureNV_RETURN void
#define glDrawTextureNV_ARG_NAMES texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1
#define glDrawTextureNV_ARG_EXPAND GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1
#define glDrawTextureNV_ARG_NAMES_TAIL , texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1
#define glDrawTextureNV_ARG_EXPAND_TAIL , GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1
#define forward_glDrawTextureNV(_texture, _sampler, _x0, _y0, _x1, _y1, _z, _s0, _t0, _s1, _t1) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawTextureNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawTextureNV(dst, _texture, _sampler, _x0, _y0, _x1, _y1, _z, _s0, _t0, _s1, _t1), NULL); \
    });
#define call_glDrawTextureNV(packed, ret_v) do { \
    glDrawTextureNV_PACKED *unpacked = (glDrawTextureNV_PACKED *)packed; \
    glDrawTextureNV_ARGS *args = (glDrawTextureNV_ARGS *)&unpacked->args; \
    glDrawTextureNV(args->texture, args->sampler, args->x0, args->y0, args->x1, args->y1, args->z, args->s0, args->t0, args->s1, args->t1);; \
} while(0)
void glDrawTextureNV(glDrawTextureNV_ARG_EXPAND);
packed_call_t *pack_glDrawTextureNV(glDrawTextureNV_PACKED *_dst glDrawTextureNV_ARG_EXPAND_TAIL);
typedef void (*glDrawTextureNV_PTR)(glDrawTextureNV_ARG_EXPAND);
#endif
#ifndef glDrawTransformFeedback_RETURN
#define glDrawTransformFeedback_RETURN void
#define glDrawTransformFeedback_ARG_NAMES mode, id
#define glDrawTransformFeedback_ARG_EXPAND GLenum mode, GLuint id
#define glDrawTransformFeedback_ARG_NAMES_TAIL , mode, id
#define glDrawTransformFeedback_ARG_EXPAND_TAIL , GLenum mode, GLuint id
#define forward_glDrawTransformFeedback(_mode, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawTransformFeedback_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawTransformFeedback(dst, _mode, _id), NULL); \
    });
#define call_glDrawTransformFeedback(packed, ret_v) do { \
    glDrawTransformFeedback_PACKED *unpacked = (glDrawTransformFeedback_PACKED *)packed; \
    glDrawTransformFeedback_ARGS *args = (glDrawTransformFeedback_ARGS *)&unpacked->args; \
    glDrawTransformFeedback(args->mode, args->id);; \
} while(0)
void glDrawTransformFeedback(glDrawTransformFeedback_ARG_EXPAND);
packed_call_t *pack_glDrawTransformFeedback(glDrawTransformFeedback_PACKED *_dst glDrawTransformFeedback_ARG_EXPAND_TAIL);
typedef void (*glDrawTransformFeedback_PTR)(glDrawTransformFeedback_ARG_EXPAND);
#endif
#ifndef glDrawTransformFeedbackInstanced_RETURN
#define glDrawTransformFeedbackInstanced_RETURN void
#define glDrawTransformFeedbackInstanced_ARG_NAMES mode, id, instancecount
#define glDrawTransformFeedbackInstanced_ARG_EXPAND GLenum mode, GLuint id, GLsizei instancecount
#define glDrawTransformFeedbackInstanced_ARG_NAMES_TAIL , mode, id, instancecount
#define glDrawTransformFeedbackInstanced_ARG_EXPAND_TAIL , GLenum mode, GLuint id, GLsizei instancecount
#define forward_glDrawTransformFeedbackInstanced(_mode, _id, _instancecount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawTransformFeedbackInstanced_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawTransformFeedbackInstanced(dst, _mode, _id, _instancecount), NULL); \
    });
#define call_glDrawTransformFeedbackInstanced(packed, ret_v) do { \
    glDrawTransformFeedbackInstanced_PACKED *unpacked = (glDrawTransformFeedbackInstanced_PACKED *)packed; \
    glDrawTransformFeedbackInstanced_ARGS *args = (glDrawTransformFeedbackInstanced_ARGS *)&unpacked->args; \
    glDrawTransformFeedbackInstanced(args->mode, args->id, args->instancecount);; \
} while(0)
void glDrawTransformFeedbackInstanced(glDrawTransformFeedbackInstanced_ARG_EXPAND);
packed_call_t *pack_glDrawTransformFeedbackInstanced(glDrawTransformFeedbackInstanced_PACKED *_dst glDrawTransformFeedbackInstanced_ARG_EXPAND_TAIL);
typedef void (*glDrawTransformFeedbackInstanced_PTR)(glDrawTransformFeedbackInstanced_ARG_EXPAND);
#endif
#ifndef glDrawTransformFeedbackNV_RETURN
#define glDrawTransformFeedbackNV_RETURN void
#define glDrawTransformFeedbackNV_ARG_NAMES mode, id
#define glDrawTransformFeedbackNV_ARG_EXPAND GLenum mode, GLuint id
#define glDrawTransformFeedbackNV_ARG_NAMES_TAIL , mode, id
#define glDrawTransformFeedbackNV_ARG_EXPAND_TAIL , GLenum mode, GLuint id
#define forward_glDrawTransformFeedbackNV(_mode, _id) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawTransformFeedbackNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawTransformFeedbackNV(dst, _mode, _id), NULL); \
    });
#define call_glDrawTransformFeedbackNV(packed, ret_v) do { \
    glDrawTransformFeedbackNV_PACKED *unpacked = (glDrawTransformFeedbackNV_PACKED *)packed; \
    glDrawTransformFeedbackNV_ARGS *args = (glDrawTransformFeedbackNV_ARGS *)&unpacked->args; \
    glDrawTransformFeedbackNV(args->mode, args->id);; \
} while(0)
void glDrawTransformFeedbackNV(glDrawTransformFeedbackNV_ARG_EXPAND);
packed_call_t *pack_glDrawTransformFeedbackNV(glDrawTransformFeedbackNV_PACKED *_dst glDrawTransformFeedbackNV_ARG_EXPAND_TAIL);
typedef void (*glDrawTransformFeedbackNV_PTR)(glDrawTransformFeedbackNV_ARG_EXPAND);
#endif
#ifndef glDrawTransformFeedbackStream_RETURN
#define glDrawTransformFeedbackStream_RETURN void
#define glDrawTransformFeedbackStream_ARG_NAMES mode, id, stream
#define glDrawTransformFeedbackStream_ARG_EXPAND GLenum mode, GLuint id, GLuint stream
#define glDrawTransformFeedbackStream_ARG_NAMES_TAIL , mode, id, stream
#define glDrawTransformFeedbackStream_ARG_EXPAND_TAIL , GLenum mode, GLuint id, GLuint stream
#define forward_glDrawTransformFeedbackStream(_mode, _id, _stream) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawTransformFeedbackStream_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawTransformFeedbackStream(dst, _mode, _id, _stream), NULL); \
    });
#define call_glDrawTransformFeedbackStream(packed, ret_v) do { \
    glDrawTransformFeedbackStream_PACKED *unpacked = (glDrawTransformFeedbackStream_PACKED *)packed; \
    glDrawTransformFeedbackStream_ARGS *args = (glDrawTransformFeedbackStream_ARGS *)&unpacked->args; \
    glDrawTransformFeedbackStream(args->mode, args->id, args->stream);; \
} while(0)
void glDrawTransformFeedbackStream(glDrawTransformFeedbackStream_ARG_EXPAND);
packed_call_t *pack_glDrawTransformFeedbackStream(glDrawTransformFeedbackStream_PACKED *_dst glDrawTransformFeedbackStream_ARG_EXPAND_TAIL);
typedef void (*glDrawTransformFeedbackStream_PTR)(glDrawTransformFeedbackStream_ARG_EXPAND);
#endif
#ifndef glDrawTransformFeedbackStreamInstanced_RETURN
#define glDrawTransformFeedbackStreamInstanced_RETURN void
#define glDrawTransformFeedbackStreamInstanced_ARG_NAMES mode, id, stream, instancecount
#define glDrawTransformFeedbackStreamInstanced_ARG_EXPAND GLenum mode, GLuint id, GLuint stream, GLsizei instancecount
#define glDrawTransformFeedbackStreamInstanced_ARG_NAMES_TAIL , mode, id, stream, instancecount
#define glDrawTransformFeedbackStreamInstanced_ARG_EXPAND_TAIL , GLenum mode, GLuint id, GLuint stream, GLsizei instancecount
#define forward_glDrawTransformFeedbackStreamInstanced(_mode, _id, _stream, _instancecount) \
    ({ \
        void *dst = remote_dma(sizeof(glDrawTransformFeedbackStreamInstanced_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glDrawTransformFeedbackStreamInstanced(dst, _mode, _id, _stream, _instancecount), NULL); \
    });
#define call_glDrawTransformFeedbackStreamInstanced(packed, ret_v) do { \
    glDrawTransformFeedbackStreamInstanced_PACKED *unpacked = (glDrawTransformFeedbackStreamInstanced_PACKED *)packed; \
    glDrawTransformFeedbackStreamInstanced_ARGS *args = (glDrawTransformFeedbackStreamInstanced_ARGS *)&unpacked->args; \
    glDrawTransformFeedbackStreamInstanced(args->mode, args->id, args->stream, args->instancecount);; \
} while(0)
void glDrawTransformFeedbackStreamInstanced(glDrawTransformFeedbackStreamInstanced_ARG_EXPAND);
packed_call_t *pack_glDrawTransformFeedbackStreamInstanced(glDrawTransformFeedbackStreamInstanced_PACKED *_dst glDrawTransformFeedbackStreamInstanced_ARG_EXPAND_TAIL);
typedef void (*glDrawTransformFeedbackStreamInstanced_PTR)(glDrawTransformFeedbackStreamInstanced_ARG_EXPAND);
#endif
#ifndef glEdgeFlag_RETURN
#define glEdgeFlag_RETURN void
#define glEdgeFlag_ARG_NAMES flag
#define glEdgeFlag_ARG_EXPAND GLboolean flag
#define glEdgeFlag_ARG_NAMES_TAIL , flag
#define glEdgeFlag_ARG_EXPAND_TAIL , GLboolean flag
#define forward_glEdgeFlag(_flag) \
    ({ \
        void *dst = remote_dma(sizeof(glEdgeFlag_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEdgeFlag(dst, _flag), NULL); \
    });
#define call_glEdgeFlag(packed, ret_v) do { \
    glEdgeFlag_PACKED *unpacked = (glEdgeFlag_PACKED *)packed; \
    glEdgeFlag_ARGS *args = (glEdgeFlag_ARGS *)&unpacked->args; \
    glEdgeFlag(args->flag);; \
} while(0)
void glEdgeFlag(glEdgeFlag_ARG_EXPAND);
packed_call_t *pack_glEdgeFlag(glEdgeFlag_PACKED *_dst glEdgeFlag_ARG_EXPAND_TAIL);
typedef void (*glEdgeFlag_PTR)(glEdgeFlag_ARG_EXPAND);
#endif
#ifndef glEdgeFlagFormatNV_RETURN
#define glEdgeFlagFormatNV_RETURN void
#define glEdgeFlagFormatNV_ARG_NAMES stride
#define glEdgeFlagFormatNV_ARG_EXPAND GLsizei stride
#define glEdgeFlagFormatNV_ARG_NAMES_TAIL , stride
#define glEdgeFlagFormatNV_ARG_EXPAND_TAIL , GLsizei stride
#define forward_glEdgeFlagFormatNV(_stride) \
    ({ \
        void *dst = remote_dma(sizeof(glEdgeFlagFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEdgeFlagFormatNV(dst, _stride), NULL); \
    });
#define call_glEdgeFlagFormatNV(packed, ret_v) do { \
    glEdgeFlagFormatNV_PACKED *unpacked = (glEdgeFlagFormatNV_PACKED *)packed; \
    glEdgeFlagFormatNV_ARGS *args = (glEdgeFlagFormatNV_ARGS *)&unpacked->args; \
    glEdgeFlagFormatNV(args->stride);; \
} while(0)
void glEdgeFlagFormatNV(glEdgeFlagFormatNV_ARG_EXPAND);
packed_call_t *pack_glEdgeFlagFormatNV(glEdgeFlagFormatNV_PACKED *_dst glEdgeFlagFormatNV_ARG_EXPAND_TAIL);
typedef void (*glEdgeFlagFormatNV_PTR)(glEdgeFlagFormatNV_ARG_EXPAND);
#endif
#ifndef glEdgeFlagPointer_RETURN
#define glEdgeFlagPointer_RETURN void
#define glEdgeFlagPointer_ARG_NAMES stride, pointer
#define glEdgeFlagPointer_ARG_EXPAND GLsizei stride, const GLvoid * pointer
#define glEdgeFlagPointer_ARG_NAMES_TAIL , stride, pointer
#define glEdgeFlagPointer_ARG_EXPAND_TAIL , GLsizei stride, const GLvoid * pointer
#define forward_glEdgeFlagPointer(_stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glEdgeFlagPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEdgeFlagPointer(dst, _stride, _pointer), NULL); \
    });
#define call_glEdgeFlagPointer(packed, ret_v) do { \
    glEdgeFlagPointer_PACKED *unpacked = (glEdgeFlagPointer_PACKED *)packed; \
    glEdgeFlagPointer_ARGS *args = (glEdgeFlagPointer_ARGS *)&unpacked->args; \
    glEdgeFlagPointer(args->stride, args->pointer);; \
} while(0)
void glEdgeFlagPointer(glEdgeFlagPointer_ARG_EXPAND);
packed_call_t *pack_glEdgeFlagPointer(glEdgeFlagPointer_PACKED *_dst glEdgeFlagPointer_ARG_EXPAND_TAIL);
typedef void (*glEdgeFlagPointer_PTR)(glEdgeFlagPointer_ARG_EXPAND);
#endif
#ifndef glEdgeFlagPointerEXT_RETURN
#define glEdgeFlagPointerEXT_RETURN void
#define glEdgeFlagPointerEXT_ARG_NAMES stride, count, pointer
#define glEdgeFlagPointerEXT_ARG_EXPAND GLsizei stride, GLsizei count, const GLboolean * pointer
#define glEdgeFlagPointerEXT_ARG_NAMES_TAIL , stride, count, pointer
#define glEdgeFlagPointerEXT_ARG_EXPAND_TAIL , GLsizei stride, GLsizei count, const GLboolean * pointer
#define forward_glEdgeFlagPointerEXT(_stride, _count, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glEdgeFlagPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEdgeFlagPointerEXT(dst, _stride, _count, _pointer), NULL); \
    });
#define call_glEdgeFlagPointerEXT(packed, ret_v) do { \
    glEdgeFlagPointerEXT_PACKED *unpacked = (glEdgeFlagPointerEXT_PACKED *)packed; \
    glEdgeFlagPointerEXT_ARGS *args = (glEdgeFlagPointerEXT_ARGS *)&unpacked->args; \
    glEdgeFlagPointerEXT(args->stride, args->count, args->pointer);; \
} while(0)
void glEdgeFlagPointerEXT(glEdgeFlagPointerEXT_ARG_EXPAND);
packed_call_t *pack_glEdgeFlagPointerEXT(glEdgeFlagPointerEXT_PACKED *_dst glEdgeFlagPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glEdgeFlagPointerEXT_PTR)(glEdgeFlagPointerEXT_ARG_EXPAND);
#endif
#ifndef glEdgeFlagPointerListIBM_RETURN
#define glEdgeFlagPointerListIBM_RETURN void
#define glEdgeFlagPointerListIBM_ARG_NAMES stride, pointer, ptrstride
#define glEdgeFlagPointerListIBM_ARG_EXPAND GLint stride, const GLboolean * pointer, GLint ptrstride
#define glEdgeFlagPointerListIBM_ARG_NAMES_TAIL , stride, pointer, ptrstride
#define glEdgeFlagPointerListIBM_ARG_EXPAND_TAIL , GLint stride, const GLboolean * pointer, GLint ptrstride
#define forward_glEdgeFlagPointerListIBM(_stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glEdgeFlagPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEdgeFlagPointerListIBM(dst, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glEdgeFlagPointerListIBM(packed, ret_v) do { \
    glEdgeFlagPointerListIBM_PACKED *unpacked = (glEdgeFlagPointerListIBM_PACKED *)packed; \
    glEdgeFlagPointerListIBM_ARGS *args = (glEdgeFlagPointerListIBM_ARGS *)&unpacked->args; \
    glEdgeFlagPointerListIBM(args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glEdgeFlagPointerListIBM(glEdgeFlagPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glEdgeFlagPointerListIBM(glEdgeFlagPointerListIBM_PACKED *_dst glEdgeFlagPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glEdgeFlagPointerListIBM_PTR)(glEdgeFlagPointerListIBM_ARG_EXPAND);
#endif
#ifndef glEdgeFlagv_RETURN
#define glEdgeFlagv_RETURN void
#define glEdgeFlagv_ARG_NAMES flag
#define glEdgeFlagv_ARG_EXPAND const GLboolean * flag
#define glEdgeFlagv_ARG_NAMES_TAIL , flag
#define glEdgeFlagv_ARG_EXPAND_TAIL , const GLboolean * flag
#define forward_glEdgeFlagv(_flag) \
    ({ \
        void *dst = remote_dma(sizeof(glEdgeFlagv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEdgeFlagv(dst, _flag), NULL); \
    });
#define call_glEdgeFlagv(packed, ret_v) do { \
    glEdgeFlagv_PACKED *unpacked = (glEdgeFlagv_PACKED *)packed; \
    glEdgeFlagv_ARGS *args = (glEdgeFlagv_ARGS *)&unpacked->args; \
    glEdgeFlagv(args->flag);; \
} while(0)
void glEdgeFlagv(glEdgeFlagv_ARG_EXPAND);
packed_call_t *pack_glEdgeFlagv(glEdgeFlagv_PACKED *_dst glEdgeFlagv_ARG_EXPAND_TAIL);
typedef void (*glEdgeFlagv_PTR)(glEdgeFlagv_ARG_EXPAND);
#endif
#ifndef glElementPointerAPPLE_RETURN
#define glElementPointerAPPLE_RETURN void
#define glElementPointerAPPLE_ARG_NAMES type, pointer
#define glElementPointerAPPLE_ARG_EXPAND GLenum type, const GLvoid * pointer
#define glElementPointerAPPLE_ARG_NAMES_TAIL , type, pointer
#define glElementPointerAPPLE_ARG_EXPAND_TAIL , GLenum type, const GLvoid * pointer
#define forward_glElementPointerAPPLE(_type, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glElementPointerAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glElementPointerAPPLE(dst, _type, _pointer), NULL); \
    });
#define call_glElementPointerAPPLE(packed, ret_v) do { \
    glElementPointerAPPLE_PACKED *unpacked = (glElementPointerAPPLE_PACKED *)packed; \
    glElementPointerAPPLE_ARGS *args = (glElementPointerAPPLE_ARGS *)&unpacked->args; \
    glElementPointerAPPLE(args->type, args->pointer);; \
} while(0)
void glElementPointerAPPLE(glElementPointerAPPLE_ARG_EXPAND);
packed_call_t *pack_glElementPointerAPPLE(glElementPointerAPPLE_PACKED *_dst glElementPointerAPPLE_ARG_EXPAND_TAIL);
typedef void (*glElementPointerAPPLE_PTR)(glElementPointerAPPLE_ARG_EXPAND);
#endif
#ifndef glElementPointerATI_RETURN
#define glElementPointerATI_RETURN void
#define glElementPointerATI_ARG_NAMES type, pointer
#define glElementPointerATI_ARG_EXPAND GLenum type, const GLvoid * pointer
#define glElementPointerATI_ARG_NAMES_TAIL , type, pointer
#define glElementPointerATI_ARG_EXPAND_TAIL , GLenum type, const GLvoid * pointer
#define forward_glElementPointerATI(_type, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glElementPointerATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glElementPointerATI(dst, _type, _pointer), NULL); \
    });
#define call_glElementPointerATI(packed, ret_v) do { \
    glElementPointerATI_PACKED *unpacked = (glElementPointerATI_PACKED *)packed; \
    glElementPointerATI_ARGS *args = (glElementPointerATI_ARGS *)&unpacked->args; \
    glElementPointerATI(args->type, args->pointer);; \
} while(0)
void glElementPointerATI(glElementPointerATI_ARG_EXPAND);
packed_call_t *pack_glElementPointerATI(glElementPointerATI_PACKED *_dst glElementPointerATI_ARG_EXPAND_TAIL);
typedef void (*glElementPointerATI_PTR)(glElementPointerATI_ARG_EXPAND);
#endif
#ifndef glEnable_RETURN
#define glEnable_RETURN void
#define glEnable_ARG_NAMES cap
#define glEnable_ARG_EXPAND GLenum cap
#define glEnable_ARG_NAMES_TAIL , cap
#define glEnable_ARG_EXPAND_TAIL , GLenum cap
#define forward_glEnable(_cap) \
    ({ \
        void *dst = remote_dma(sizeof(glEnable_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnable(dst, _cap), NULL); \
    });
#define call_glEnable(packed, ret_v) do { \
    glEnable_PACKED *unpacked = (glEnable_PACKED *)packed; \
    glEnable_ARGS *args = (glEnable_ARGS *)&unpacked->args; \
    glEnable(args->cap);; \
} while(0)
void glEnable(glEnable_ARG_EXPAND);
packed_call_t *pack_glEnable(glEnable_PACKED *_dst glEnable_ARG_EXPAND_TAIL);
typedef void (*glEnable_PTR)(glEnable_ARG_EXPAND);
#endif
#ifndef glEnableClientState_RETURN
#define glEnableClientState_RETURN void
#define glEnableClientState_ARG_NAMES array
#define glEnableClientState_ARG_EXPAND GLenum array
#define glEnableClientState_ARG_NAMES_TAIL , array
#define glEnableClientState_ARG_EXPAND_TAIL , GLenum array
#define forward_glEnableClientState(_array) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableClientState_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableClientState(dst, _array), NULL); \
    });
#define call_glEnableClientState(packed, ret_v) do { \
    glEnableClientState_PACKED *unpacked = (glEnableClientState_PACKED *)packed; \
    glEnableClientState_ARGS *args = (glEnableClientState_ARGS *)&unpacked->args; \
    glEnableClientState(args->array);; \
} while(0)
void glEnableClientState(glEnableClientState_ARG_EXPAND);
packed_call_t *pack_glEnableClientState(glEnableClientState_PACKED *_dst glEnableClientState_ARG_EXPAND_TAIL);
typedef void (*glEnableClientState_PTR)(glEnableClientState_ARG_EXPAND);
#endif
#ifndef glEnableClientStateIndexedEXT_RETURN
#define glEnableClientStateIndexedEXT_RETURN void
#define glEnableClientStateIndexedEXT_ARG_NAMES array, index
#define glEnableClientStateIndexedEXT_ARG_EXPAND GLenum array, GLuint index
#define glEnableClientStateIndexedEXT_ARG_NAMES_TAIL , array, index
#define glEnableClientStateIndexedEXT_ARG_EXPAND_TAIL , GLenum array, GLuint index
#define forward_glEnableClientStateIndexedEXT(_array, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableClientStateIndexedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableClientStateIndexedEXT(dst, _array, _index), NULL); \
    });
#define call_glEnableClientStateIndexedEXT(packed, ret_v) do { \
    glEnableClientStateIndexedEXT_PACKED *unpacked = (glEnableClientStateIndexedEXT_PACKED *)packed; \
    glEnableClientStateIndexedEXT_ARGS *args = (glEnableClientStateIndexedEXT_ARGS *)&unpacked->args; \
    glEnableClientStateIndexedEXT(args->array, args->index);; \
} while(0)
void glEnableClientStateIndexedEXT(glEnableClientStateIndexedEXT_ARG_EXPAND);
packed_call_t *pack_glEnableClientStateIndexedEXT(glEnableClientStateIndexedEXT_PACKED *_dst glEnableClientStateIndexedEXT_ARG_EXPAND_TAIL);
typedef void (*glEnableClientStateIndexedEXT_PTR)(glEnableClientStateIndexedEXT_ARG_EXPAND);
#endif
#ifndef glEnableClientStateiEXT_RETURN
#define glEnableClientStateiEXT_RETURN void
#define glEnableClientStateiEXT_ARG_NAMES array, index
#define glEnableClientStateiEXT_ARG_EXPAND GLenum array, GLuint index
#define glEnableClientStateiEXT_ARG_NAMES_TAIL , array, index
#define glEnableClientStateiEXT_ARG_EXPAND_TAIL , GLenum array, GLuint index
#define forward_glEnableClientStateiEXT(_array, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableClientStateiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableClientStateiEXT(dst, _array, _index), NULL); \
    });
#define call_glEnableClientStateiEXT(packed, ret_v) do { \
    glEnableClientStateiEXT_PACKED *unpacked = (glEnableClientStateiEXT_PACKED *)packed; \
    glEnableClientStateiEXT_ARGS *args = (glEnableClientStateiEXT_ARGS *)&unpacked->args; \
    glEnableClientStateiEXT(args->array, args->index);; \
} while(0)
void glEnableClientStateiEXT(glEnableClientStateiEXT_ARG_EXPAND);
packed_call_t *pack_glEnableClientStateiEXT(glEnableClientStateiEXT_PACKED *_dst glEnableClientStateiEXT_ARG_EXPAND_TAIL);
typedef void (*glEnableClientStateiEXT_PTR)(glEnableClientStateiEXT_ARG_EXPAND);
#endif
#ifndef glEnableIndexedEXT_RETURN
#define glEnableIndexedEXT_RETURN void
#define glEnableIndexedEXT_ARG_NAMES target, index
#define glEnableIndexedEXT_ARG_EXPAND GLenum target, GLuint index
#define glEnableIndexedEXT_ARG_NAMES_TAIL , target, index
#define glEnableIndexedEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index
#define forward_glEnableIndexedEXT(_target, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableIndexedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableIndexedEXT(dst, _target, _index), NULL); \
    });
#define call_glEnableIndexedEXT(packed, ret_v) do { \
    glEnableIndexedEXT_PACKED *unpacked = (glEnableIndexedEXT_PACKED *)packed; \
    glEnableIndexedEXT_ARGS *args = (glEnableIndexedEXT_ARGS *)&unpacked->args; \
    glEnableIndexedEXT(args->target, args->index);; \
} while(0)
void glEnableIndexedEXT(glEnableIndexedEXT_ARG_EXPAND);
packed_call_t *pack_glEnableIndexedEXT(glEnableIndexedEXT_PACKED *_dst glEnableIndexedEXT_ARG_EXPAND_TAIL);
typedef void (*glEnableIndexedEXT_PTR)(glEnableIndexedEXT_ARG_EXPAND);
#endif
#ifndef glEnableVariantClientStateEXT_RETURN
#define glEnableVariantClientStateEXT_RETURN void
#define glEnableVariantClientStateEXT_ARG_NAMES id
#define glEnableVariantClientStateEXT_ARG_EXPAND GLuint id
#define glEnableVariantClientStateEXT_ARG_NAMES_TAIL , id
#define glEnableVariantClientStateEXT_ARG_EXPAND_TAIL , GLuint id
#define forward_glEnableVariantClientStateEXT(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableVariantClientStateEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableVariantClientStateEXT(dst, _id), NULL); \
    });
#define call_glEnableVariantClientStateEXT(packed, ret_v) do { \
    glEnableVariantClientStateEXT_PACKED *unpacked = (glEnableVariantClientStateEXT_PACKED *)packed; \
    glEnableVariantClientStateEXT_ARGS *args = (glEnableVariantClientStateEXT_ARGS *)&unpacked->args; \
    glEnableVariantClientStateEXT(args->id);; \
} while(0)
void glEnableVariantClientStateEXT(glEnableVariantClientStateEXT_ARG_EXPAND);
packed_call_t *pack_glEnableVariantClientStateEXT(glEnableVariantClientStateEXT_PACKED *_dst glEnableVariantClientStateEXT_ARG_EXPAND_TAIL);
typedef void (*glEnableVariantClientStateEXT_PTR)(glEnableVariantClientStateEXT_ARG_EXPAND);
#endif
#ifndef glEnableVertexArrayAttribEXT_RETURN
#define glEnableVertexArrayAttribEXT_RETURN void
#define glEnableVertexArrayAttribEXT_ARG_NAMES vaobj, index
#define glEnableVertexArrayAttribEXT_ARG_EXPAND GLuint vaobj, GLuint index
#define glEnableVertexArrayAttribEXT_ARG_NAMES_TAIL , vaobj, index
#define glEnableVertexArrayAttribEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint index
#define forward_glEnableVertexArrayAttribEXT(_vaobj, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableVertexArrayAttribEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableVertexArrayAttribEXT(dst, _vaobj, _index), NULL); \
    });
#define call_glEnableVertexArrayAttribEXT(packed, ret_v) do { \
    glEnableVertexArrayAttribEXT_PACKED *unpacked = (glEnableVertexArrayAttribEXT_PACKED *)packed; \
    glEnableVertexArrayAttribEXT_ARGS *args = (glEnableVertexArrayAttribEXT_ARGS *)&unpacked->args; \
    glEnableVertexArrayAttribEXT(args->vaobj, args->index);; \
} while(0)
void glEnableVertexArrayAttribEXT(glEnableVertexArrayAttribEXT_ARG_EXPAND);
packed_call_t *pack_glEnableVertexArrayAttribEXT(glEnableVertexArrayAttribEXT_PACKED *_dst glEnableVertexArrayAttribEXT_ARG_EXPAND_TAIL);
typedef void (*glEnableVertexArrayAttribEXT_PTR)(glEnableVertexArrayAttribEXT_ARG_EXPAND);
#endif
#ifndef glEnableVertexArrayEXT_RETURN
#define glEnableVertexArrayEXT_RETURN void
#define glEnableVertexArrayEXT_ARG_NAMES vaobj, array
#define glEnableVertexArrayEXT_ARG_EXPAND GLuint vaobj, GLenum array
#define glEnableVertexArrayEXT_ARG_NAMES_TAIL , vaobj, array
#define glEnableVertexArrayEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLenum array
#define forward_glEnableVertexArrayEXT(_vaobj, _array) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableVertexArrayEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableVertexArrayEXT(dst, _vaobj, _array), NULL); \
    });
#define call_glEnableVertexArrayEXT(packed, ret_v) do { \
    glEnableVertexArrayEXT_PACKED *unpacked = (glEnableVertexArrayEXT_PACKED *)packed; \
    glEnableVertexArrayEXT_ARGS *args = (glEnableVertexArrayEXT_ARGS *)&unpacked->args; \
    glEnableVertexArrayEXT(args->vaobj, args->array);; \
} while(0)
void glEnableVertexArrayEXT(glEnableVertexArrayEXT_ARG_EXPAND);
packed_call_t *pack_glEnableVertexArrayEXT(glEnableVertexArrayEXT_PACKED *_dst glEnableVertexArrayEXT_ARG_EXPAND_TAIL);
typedef void (*glEnableVertexArrayEXT_PTR)(glEnableVertexArrayEXT_ARG_EXPAND);
#endif
#ifndef glEnableVertexAttribAPPLE_RETURN
#define glEnableVertexAttribAPPLE_RETURN void
#define glEnableVertexAttribAPPLE_ARG_NAMES index, pname
#define glEnableVertexAttribAPPLE_ARG_EXPAND GLuint index, GLenum pname
#define glEnableVertexAttribAPPLE_ARG_NAMES_TAIL , index, pname
#define glEnableVertexAttribAPPLE_ARG_EXPAND_TAIL , GLuint index, GLenum pname
#define forward_glEnableVertexAttribAPPLE(_index, _pname) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableVertexAttribAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableVertexAttribAPPLE(dst, _index, _pname), NULL); \
    });
#define call_glEnableVertexAttribAPPLE(packed, ret_v) do { \
    glEnableVertexAttribAPPLE_PACKED *unpacked = (glEnableVertexAttribAPPLE_PACKED *)packed; \
    glEnableVertexAttribAPPLE_ARGS *args = (glEnableVertexAttribAPPLE_ARGS *)&unpacked->args; \
    glEnableVertexAttribAPPLE(args->index, args->pname);; \
} while(0)
void glEnableVertexAttribAPPLE(glEnableVertexAttribAPPLE_ARG_EXPAND);
packed_call_t *pack_glEnableVertexAttribAPPLE(glEnableVertexAttribAPPLE_PACKED *_dst glEnableVertexAttribAPPLE_ARG_EXPAND_TAIL);
typedef void (*glEnableVertexAttribAPPLE_PTR)(glEnableVertexAttribAPPLE_ARG_EXPAND);
#endif
#ifndef glEnableVertexAttribArray_RETURN
#define glEnableVertexAttribArray_RETURN void
#define glEnableVertexAttribArray_ARG_NAMES index
#define glEnableVertexAttribArray_ARG_EXPAND GLuint index
#define glEnableVertexAttribArray_ARG_NAMES_TAIL , index
#define glEnableVertexAttribArray_ARG_EXPAND_TAIL , GLuint index
#define forward_glEnableVertexAttribArray(_index) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableVertexAttribArray_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableVertexAttribArray(dst, _index), NULL); \
    });
#define call_glEnableVertexAttribArray(packed, ret_v) do { \
    glEnableVertexAttribArray_PACKED *unpacked = (glEnableVertexAttribArray_PACKED *)packed; \
    glEnableVertexAttribArray_ARGS *args = (glEnableVertexAttribArray_ARGS *)&unpacked->args; \
    glEnableVertexAttribArray(args->index);; \
} while(0)
void glEnableVertexAttribArray(glEnableVertexAttribArray_ARG_EXPAND);
packed_call_t *pack_glEnableVertexAttribArray(glEnableVertexAttribArray_PACKED *_dst glEnableVertexAttribArray_ARG_EXPAND_TAIL);
typedef void (*glEnableVertexAttribArray_PTR)(glEnableVertexAttribArray_ARG_EXPAND);
#endif
#ifndef glEnableVertexAttribArrayARB_RETURN
#define glEnableVertexAttribArrayARB_RETURN void
#define glEnableVertexAttribArrayARB_ARG_NAMES index
#define glEnableVertexAttribArrayARB_ARG_EXPAND GLuint index
#define glEnableVertexAttribArrayARB_ARG_NAMES_TAIL , index
#define glEnableVertexAttribArrayARB_ARG_EXPAND_TAIL , GLuint index
#define forward_glEnableVertexAttribArrayARB(_index) \
    ({ \
        void *dst = remote_dma(sizeof(glEnableVertexAttribArrayARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnableVertexAttribArrayARB(dst, _index), NULL); \
    });
#define call_glEnableVertexAttribArrayARB(packed, ret_v) do { \
    glEnableVertexAttribArrayARB_PACKED *unpacked = (glEnableVertexAttribArrayARB_PACKED *)packed; \
    glEnableVertexAttribArrayARB_ARGS *args = (glEnableVertexAttribArrayARB_ARGS *)&unpacked->args; \
    glEnableVertexAttribArrayARB(args->index);; \
} while(0)
void glEnableVertexAttribArrayARB(glEnableVertexAttribArrayARB_ARG_EXPAND);
packed_call_t *pack_glEnableVertexAttribArrayARB(glEnableVertexAttribArrayARB_PACKED *_dst glEnableVertexAttribArrayARB_ARG_EXPAND_TAIL);
typedef void (*glEnableVertexAttribArrayARB_PTR)(glEnableVertexAttribArrayARB_ARG_EXPAND);
#endif
#ifndef glEnablei_RETURN
#define glEnablei_RETURN void
#define glEnablei_ARG_NAMES target, index
#define glEnablei_ARG_EXPAND GLenum target, GLuint index
#define glEnablei_ARG_NAMES_TAIL , target, index
#define glEnablei_ARG_EXPAND_TAIL , GLenum target, GLuint index
#define forward_glEnablei(_target, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glEnablei_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnablei(dst, _target, _index), NULL); \
    });
#define call_glEnablei(packed, ret_v) do { \
    glEnablei_PACKED *unpacked = (glEnablei_PACKED *)packed; \
    glEnablei_ARGS *args = (glEnablei_ARGS *)&unpacked->args; \
    glEnablei(args->target, args->index);; \
} while(0)
void glEnablei(glEnablei_ARG_EXPAND);
packed_call_t *pack_glEnablei(glEnablei_PACKED *_dst glEnablei_ARG_EXPAND_TAIL);
typedef void (*glEnablei_PTR)(glEnablei_ARG_EXPAND);
#endif
#ifndef glEnd_RETURN
#define glEnd_RETURN void
#define glEnd_ARG_NAMES 
#define glEnd_ARG_EXPAND 
#define glEnd_ARG_NAMES_TAIL 
#define glEnd_ARG_EXPAND_TAIL 
#define forward_glEnd() \
    ({ \
        void *dst = remote_dma(sizeof(glEnd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEnd(dst), NULL); \
    });
#define call_glEnd(packed, ret_v) do { \
    glEnd();; \
} while(0)
void glEnd(glEnd_ARG_EXPAND);
packed_call_t *pack_glEnd(glEnd_PACKED *_dst glEnd_ARG_EXPAND_TAIL);
typedef void (*glEnd_PTR)(glEnd_ARG_EXPAND);
#endif
#ifndef glEndConditionalRender_RETURN
#define glEndConditionalRender_RETURN void
#define glEndConditionalRender_ARG_NAMES 
#define glEndConditionalRender_ARG_EXPAND 
#define glEndConditionalRender_ARG_NAMES_TAIL 
#define glEndConditionalRender_ARG_EXPAND_TAIL 
#define forward_glEndConditionalRender() \
    ({ \
        void *dst = remote_dma(sizeof(glEndConditionalRender_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndConditionalRender(dst), NULL); \
    });
#define call_glEndConditionalRender(packed, ret_v) do { \
    glEndConditionalRender();; \
} while(0)
void glEndConditionalRender(glEndConditionalRender_ARG_EXPAND);
packed_call_t *pack_glEndConditionalRender(glEndConditionalRender_PACKED *_dst glEndConditionalRender_ARG_EXPAND_TAIL);
typedef void (*glEndConditionalRender_PTR)(glEndConditionalRender_ARG_EXPAND);
#endif
#ifndef glEndConditionalRenderNV_RETURN
#define glEndConditionalRenderNV_RETURN void
#define glEndConditionalRenderNV_ARG_NAMES 
#define glEndConditionalRenderNV_ARG_EXPAND 
#define glEndConditionalRenderNV_ARG_NAMES_TAIL 
#define glEndConditionalRenderNV_ARG_EXPAND_TAIL 
#define forward_glEndConditionalRenderNV() \
    ({ \
        void *dst = remote_dma(sizeof(glEndConditionalRenderNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndConditionalRenderNV(dst), NULL); \
    });
#define call_glEndConditionalRenderNV(packed, ret_v) do { \
    glEndConditionalRenderNV();; \
} while(0)
void glEndConditionalRenderNV(glEndConditionalRenderNV_ARG_EXPAND);
packed_call_t *pack_glEndConditionalRenderNV(glEndConditionalRenderNV_PACKED *_dst glEndConditionalRenderNV_ARG_EXPAND_TAIL);
typedef void (*glEndConditionalRenderNV_PTR)(glEndConditionalRenderNV_ARG_EXPAND);
#endif
#ifndef glEndConditionalRenderNVX_RETURN
#define glEndConditionalRenderNVX_RETURN void
#define glEndConditionalRenderNVX_ARG_NAMES 
#define glEndConditionalRenderNVX_ARG_EXPAND 
#define glEndConditionalRenderNVX_ARG_NAMES_TAIL 
#define glEndConditionalRenderNVX_ARG_EXPAND_TAIL 
#define forward_glEndConditionalRenderNVX() \
    ({ \
        void *dst = remote_dma(sizeof(glEndConditionalRenderNVX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndConditionalRenderNVX(dst), NULL); \
    });
#define call_glEndConditionalRenderNVX(packed, ret_v) do { \
    glEndConditionalRenderNVX();; \
} while(0)
void glEndConditionalRenderNVX(glEndConditionalRenderNVX_ARG_EXPAND);
packed_call_t *pack_glEndConditionalRenderNVX(glEndConditionalRenderNVX_PACKED *_dst glEndConditionalRenderNVX_ARG_EXPAND_TAIL);
typedef void (*glEndConditionalRenderNVX_PTR)(glEndConditionalRenderNVX_ARG_EXPAND);
#endif
#ifndef glEndFragmentShaderATI_RETURN
#define glEndFragmentShaderATI_RETURN void
#define glEndFragmentShaderATI_ARG_NAMES 
#define glEndFragmentShaderATI_ARG_EXPAND 
#define glEndFragmentShaderATI_ARG_NAMES_TAIL 
#define glEndFragmentShaderATI_ARG_EXPAND_TAIL 
#define forward_glEndFragmentShaderATI() \
    ({ \
        void *dst = remote_dma(sizeof(glEndFragmentShaderATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndFragmentShaderATI(dst), NULL); \
    });
#define call_glEndFragmentShaderATI(packed, ret_v) do { \
    glEndFragmentShaderATI();; \
} while(0)
void glEndFragmentShaderATI(glEndFragmentShaderATI_ARG_EXPAND);
packed_call_t *pack_glEndFragmentShaderATI(glEndFragmentShaderATI_PACKED *_dst glEndFragmentShaderATI_ARG_EXPAND_TAIL);
typedef void (*glEndFragmentShaderATI_PTR)(glEndFragmentShaderATI_ARG_EXPAND);
#endif
#ifndef glEndList_RETURN
#define glEndList_RETURN void
#define glEndList_ARG_NAMES 
#define glEndList_ARG_EXPAND 
#define glEndList_ARG_NAMES_TAIL 
#define glEndList_ARG_EXPAND_TAIL 
#define forward_glEndList() \
    ({ \
        void *dst = remote_dma(sizeof(glEndList_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndList(dst), NULL); \
    });
#define call_glEndList(packed, ret_v) do { \
    glEndList();; \
} while(0)
void glEndList(glEndList_ARG_EXPAND);
packed_call_t *pack_glEndList(glEndList_PACKED *_dst glEndList_ARG_EXPAND_TAIL);
typedef void (*glEndList_PTR)(glEndList_ARG_EXPAND);
#endif
#ifndef glEndOcclusionQueryNV_RETURN
#define glEndOcclusionQueryNV_RETURN void
#define glEndOcclusionQueryNV_ARG_NAMES 
#define glEndOcclusionQueryNV_ARG_EXPAND 
#define glEndOcclusionQueryNV_ARG_NAMES_TAIL 
#define glEndOcclusionQueryNV_ARG_EXPAND_TAIL 
#define forward_glEndOcclusionQueryNV() \
    ({ \
        void *dst = remote_dma(sizeof(glEndOcclusionQueryNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndOcclusionQueryNV(dst), NULL); \
    });
#define call_glEndOcclusionQueryNV(packed, ret_v) do { \
    glEndOcclusionQueryNV();; \
} while(0)
void glEndOcclusionQueryNV(glEndOcclusionQueryNV_ARG_EXPAND);
packed_call_t *pack_glEndOcclusionQueryNV(glEndOcclusionQueryNV_PACKED *_dst glEndOcclusionQueryNV_ARG_EXPAND_TAIL);
typedef void (*glEndOcclusionQueryNV_PTR)(glEndOcclusionQueryNV_ARG_EXPAND);
#endif
#ifndef glEndPerfMonitorAMD_RETURN
#define glEndPerfMonitorAMD_RETURN void
#define glEndPerfMonitorAMD_ARG_NAMES monitor
#define glEndPerfMonitorAMD_ARG_EXPAND GLuint monitor
#define glEndPerfMonitorAMD_ARG_NAMES_TAIL , monitor
#define glEndPerfMonitorAMD_ARG_EXPAND_TAIL , GLuint monitor
#define forward_glEndPerfMonitorAMD(_monitor) \
    ({ \
        void *dst = remote_dma(sizeof(glEndPerfMonitorAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndPerfMonitorAMD(dst, _monitor), NULL); \
    });
#define call_glEndPerfMonitorAMD(packed, ret_v) do { \
    glEndPerfMonitorAMD_PACKED *unpacked = (glEndPerfMonitorAMD_PACKED *)packed; \
    glEndPerfMonitorAMD_ARGS *args = (glEndPerfMonitorAMD_ARGS *)&unpacked->args; \
    glEndPerfMonitorAMD(args->monitor);; \
} while(0)
void glEndPerfMonitorAMD(glEndPerfMonitorAMD_ARG_EXPAND);
packed_call_t *pack_glEndPerfMonitorAMD(glEndPerfMonitorAMD_PACKED *_dst glEndPerfMonitorAMD_ARG_EXPAND_TAIL);
typedef void (*glEndPerfMonitorAMD_PTR)(glEndPerfMonitorAMD_ARG_EXPAND);
#endif
#ifndef glEndQuery_RETURN
#define glEndQuery_RETURN void
#define glEndQuery_ARG_NAMES target
#define glEndQuery_ARG_EXPAND GLenum target
#define glEndQuery_ARG_NAMES_TAIL , target
#define glEndQuery_ARG_EXPAND_TAIL , GLenum target
#define forward_glEndQuery(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glEndQuery_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndQuery(dst, _target), NULL); \
    });
#define call_glEndQuery(packed, ret_v) do { \
    glEndQuery_PACKED *unpacked = (glEndQuery_PACKED *)packed; \
    glEndQuery_ARGS *args = (glEndQuery_ARGS *)&unpacked->args; \
    glEndQuery(args->target);; \
} while(0)
void glEndQuery(glEndQuery_ARG_EXPAND);
packed_call_t *pack_glEndQuery(glEndQuery_PACKED *_dst glEndQuery_ARG_EXPAND_TAIL);
typedef void (*glEndQuery_PTR)(glEndQuery_ARG_EXPAND);
#endif
#ifndef glEndQueryARB_RETURN
#define glEndQueryARB_RETURN void
#define glEndQueryARB_ARG_NAMES target
#define glEndQueryARB_ARG_EXPAND GLenum target
#define glEndQueryARB_ARG_NAMES_TAIL , target
#define glEndQueryARB_ARG_EXPAND_TAIL , GLenum target
#define forward_glEndQueryARB(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glEndQueryARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndQueryARB(dst, _target), NULL); \
    });
#define call_glEndQueryARB(packed, ret_v) do { \
    glEndQueryARB_PACKED *unpacked = (glEndQueryARB_PACKED *)packed; \
    glEndQueryARB_ARGS *args = (glEndQueryARB_ARGS *)&unpacked->args; \
    glEndQueryARB(args->target);; \
} while(0)
void glEndQueryARB(glEndQueryARB_ARG_EXPAND);
packed_call_t *pack_glEndQueryARB(glEndQueryARB_PACKED *_dst glEndQueryARB_ARG_EXPAND_TAIL);
typedef void (*glEndQueryARB_PTR)(glEndQueryARB_ARG_EXPAND);
#endif
#ifndef glEndQueryIndexed_RETURN
#define glEndQueryIndexed_RETURN void
#define glEndQueryIndexed_ARG_NAMES target, index
#define glEndQueryIndexed_ARG_EXPAND GLenum target, GLuint index
#define glEndQueryIndexed_ARG_NAMES_TAIL , target, index
#define glEndQueryIndexed_ARG_EXPAND_TAIL , GLenum target, GLuint index
#define forward_glEndQueryIndexed(_target, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glEndQueryIndexed_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndQueryIndexed(dst, _target, _index), NULL); \
    });
#define call_glEndQueryIndexed(packed, ret_v) do { \
    glEndQueryIndexed_PACKED *unpacked = (glEndQueryIndexed_PACKED *)packed; \
    glEndQueryIndexed_ARGS *args = (glEndQueryIndexed_ARGS *)&unpacked->args; \
    glEndQueryIndexed(args->target, args->index);; \
} while(0)
void glEndQueryIndexed(glEndQueryIndexed_ARG_EXPAND);
packed_call_t *pack_glEndQueryIndexed(glEndQueryIndexed_PACKED *_dst glEndQueryIndexed_ARG_EXPAND_TAIL);
typedef void (*glEndQueryIndexed_PTR)(glEndQueryIndexed_ARG_EXPAND);
#endif
#ifndef glEndTransformFeedback_RETURN
#define glEndTransformFeedback_RETURN void
#define glEndTransformFeedback_ARG_NAMES 
#define glEndTransformFeedback_ARG_EXPAND 
#define glEndTransformFeedback_ARG_NAMES_TAIL 
#define glEndTransformFeedback_ARG_EXPAND_TAIL 
#define forward_glEndTransformFeedback() \
    ({ \
        void *dst = remote_dma(sizeof(glEndTransformFeedback_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndTransformFeedback(dst), NULL); \
    });
#define call_glEndTransformFeedback(packed, ret_v) do { \
    glEndTransformFeedback();; \
} while(0)
void glEndTransformFeedback(glEndTransformFeedback_ARG_EXPAND);
packed_call_t *pack_glEndTransformFeedback(glEndTransformFeedback_PACKED *_dst glEndTransformFeedback_ARG_EXPAND_TAIL);
typedef void (*glEndTransformFeedback_PTR)(glEndTransformFeedback_ARG_EXPAND);
#endif
#ifndef glEndTransformFeedbackEXT_RETURN
#define glEndTransformFeedbackEXT_RETURN void
#define glEndTransformFeedbackEXT_ARG_NAMES 
#define glEndTransformFeedbackEXT_ARG_EXPAND 
#define glEndTransformFeedbackEXT_ARG_NAMES_TAIL 
#define glEndTransformFeedbackEXT_ARG_EXPAND_TAIL 
#define forward_glEndTransformFeedbackEXT() \
    ({ \
        void *dst = remote_dma(sizeof(glEndTransformFeedbackEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndTransformFeedbackEXT(dst), NULL); \
    });
#define call_glEndTransformFeedbackEXT(packed, ret_v) do { \
    glEndTransformFeedbackEXT();; \
} while(0)
void glEndTransformFeedbackEXT(glEndTransformFeedbackEXT_ARG_EXPAND);
packed_call_t *pack_glEndTransformFeedbackEXT(glEndTransformFeedbackEXT_PACKED *_dst glEndTransformFeedbackEXT_ARG_EXPAND_TAIL);
typedef void (*glEndTransformFeedbackEXT_PTR)(glEndTransformFeedbackEXT_ARG_EXPAND);
#endif
#ifndef glEndTransformFeedbackNV_RETURN
#define glEndTransformFeedbackNV_RETURN void
#define glEndTransformFeedbackNV_ARG_NAMES 
#define glEndTransformFeedbackNV_ARG_EXPAND 
#define glEndTransformFeedbackNV_ARG_NAMES_TAIL 
#define glEndTransformFeedbackNV_ARG_EXPAND_TAIL 
#define forward_glEndTransformFeedbackNV() \
    ({ \
        void *dst = remote_dma(sizeof(glEndTransformFeedbackNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndTransformFeedbackNV(dst), NULL); \
    });
#define call_glEndTransformFeedbackNV(packed, ret_v) do { \
    glEndTransformFeedbackNV();; \
} while(0)
void glEndTransformFeedbackNV(glEndTransformFeedbackNV_ARG_EXPAND);
packed_call_t *pack_glEndTransformFeedbackNV(glEndTransformFeedbackNV_PACKED *_dst glEndTransformFeedbackNV_ARG_EXPAND_TAIL);
typedef void (*glEndTransformFeedbackNV_PTR)(glEndTransformFeedbackNV_ARG_EXPAND);
#endif
#ifndef glEndVertexShaderEXT_RETURN
#define glEndVertexShaderEXT_RETURN void
#define glEndVertexShaderEXT_ARG_NAMES 
#define glEndVertexShaderEXT_ARG_EXPAND 
#define glEndVertexShaderEXT_ARG_NAMES_TAIL 
#define glEndVertexShaderEXT_ARG_EXPAND_TAIL 
#define forward_glEndVertexShaderEXT() \
    ({ \
        void *dst = remote_dma(sizeof(glEndVertexShaderEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndVertexShaderEXT(dst), NULL); \
    });
#define call_glEndVertexShaderEXT(packed, ret_v) do { \
    glEndVertexShaderEXT();; \
} while(0)
void glEndVertexShaderEXT(glEndVertexShaderEXT_ARG_EXPAND);
packed_call_t *pack_glEndVertexShaderEXT(glEndVertexShaderEXT_PACKED *_dst glEndVertexShaderEXT_ARG_EXPAND_TAIL);
typedef void (*glEndVertexShaderEXT_PTR)(glEndVertexShaderEXT_ARG_EXPAND);
#endif
#ifndef glEndVideoCaptureNV_RETURN
#define glEndVideoCaptureNV_RETURN void
#define glEndVideoCaptureNV_ARG_NAMES video_capture_slot
#define glEndVideoCaptureNV_ARG_EXPAND GLuint video_capture_slot
#define glEndVideoCaptureNV_ARG_NAMES_TAIL , video_capture_slot
#define glEndVideoCaptureNV_ARG_EXPAND_TAIL , GLuint video_capture_slot
#define forward_glEndVideoCaptureNV(_video_capture_slot) \
    ({ \
        void *dst = remote_dma(sizeof(glEndVideoCaptureNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEndVideoCaptureNV(dst, _video_capture_slot), NULL); \
    });
#define call_glEndVideoCaptureNV(packed, ret_v) do { \
    glEndVideoCaptureNV_PACKED *unpacked = (glEndVideoCaptureNV_PACKED *)packed; \
    glEndVideoCaptureNV_ARGS *args = (glEndVideoCaptureNV_ARGS *)&unpacked->args; \
    glEndVideoCaptureNV(args->video_capture_slot);; \
} while(0)
void glEndVideoCaptureNV(glEndVideoCaptureNV_ARG_EXPAND);
packed_call_t *pack_glEndVideoCaptureNV(glEndVideoCaptureNV_PACKED *_dst glEndVideoCaptureNV_ARG_EXPAND_TAIL);
typedef void (*glEndVideoCaptureNV_PTR)(glEndVideoCaptureNV_ARG_EXPAND);
#endif
#ifndef glEvalCoord1d_RETURN
#define glEvalCoord1d_RETURN void
#define glEvalCoord1d_ARG_NAMES u
#define glEvalCoord1d_ARG_EXPAND GLdouble u
#define glEvalCoord1d_ARG_NAMES_TAIL , u
#define glEvalCoord1d_ARG_EXPAND_TAIL , GLdouble u
#define forward_glEvalCoord1d(_u) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord1d(dst, _u), NULL); \
    });
#define call_glEvalCoord1d(packed, ret_v) do { \
    glEvalCoord1d_PACKED *unpacked = (glEvalCoord1d_PACKED *)packed; \
    glEvalCoord1d_ARGS *args = (glEvalCoord1d_ARGS *)&unpacked->args; \
    glEvalCoord1d(args->u);; \
} while(0)
void glEvalCoord1d(glEvalCoord1d_ARG_EXPAND);
packed_call_t *pack_glEvalCoord1d(glEvalCoord1d_PACKED *_dst glEvalCoord1d_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord1d_PTR)(glEvalCoord1d_ARG_EXPAND);
#endif
#ifndef glEvalCoord1dv_RETURN
#define glEvalCoord1dv_RETURN void
#define glEvalCoord1dv_ARG_NAMES u
#define glEvalCoord1dv_ARG_EXPAND const GLdouble * u
#define glEvalCoord1dv_ARG_NAMES_TAIL , u
#define glEvalCoord1dv_ARG_EXPAND_TAIL , const GLdouble * u
#define forward_glEvalCoord1dv(_u) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord1dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord1dv(dst, _u), NULL); \
    });
#define call_glEvalCoord1dv(packed, ret_v) do { \
    glEvalCoord1dv_PACKED *unpacked = (glEvalCoord1dv_PACKED *)packed; \
    glEvalCoord1dv_ARGS *args = (glEvalCoord1dv_ARGS *)&unpacked->args; \
    glEvalCoord1dv(args->u);; \
} while(0)
void glEvalCoord1dv(glEvalCoord1dv_ARG_EXPAND);
packed_call_t *pack_glEvalCoord1dv(glEvalCoord1dv_PACKED *_dst glEvalCoord1dv_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord1dv_PTR)(glEvalCoord1dv_ARG_EXPAND);
#endif
#ifndef glEvalCoord1f_RETURN
#define glEvalCoord1f_RETURN void
#define glEvalCoord1f_ARG_NAMES u
#define glEvalCoord1f_ARG_EXPAND GLfloat u
#define glEvalCoord1f_ARG_NAMES_TAIL , u
#define glEvalCoord1f_ARG_EXPAND_TAIL , GLfloat u
#define forward_glEvalCoord1f(_u) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord1f(dst, _u), NULL); \
    });
#define call_glEvalCoord1f(packed, ret_v) do { \
    glEvalCoord1f_PACKED *unpacked = (glEvalCoord1f_PACKED *)packed; \
    glEvalCoord1f_ARGS *args = (glEvalCoord1f_ARGS *)&unpacked->args; \
    glEvalCoord1f(args->u);; \
} while(0)
void glEvalCoord1f(glEvalCoord1f_ARG_EXPAND);
packed_call_t *pack_glEvalCoord1f(glEvalCoord1f_PACKED *_dst glEvalCoord1f_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord1f_PTR)(glEvalCoord1f_ARG_EXPAND);
#endif
#ifndef glEvalCoord1fv_RETURN
#define glEvalCoord1fv_RETURN void
#define glEvalCoord1fv_ARG_NAMES u
#define glEvalCoord1fv_ARG_EXPAND const GLfloat * u
#define glEvalCoord1fv_ARG_NAMES_TAIL , u
#define glEvalCoord1fv_ARG_EXPAND_TAIL , const GLfloat * u
#define forward_glEvalCoord1fv(_u) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord1fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord1fv(dst, _u), NULL); \
    });
#define call_glEvalCoord1fv(packed, ret_v) do { \
    glEvalCoord1fv_PACKED *unpacked = (glEvalCoord1fv_PACKED *)packed; \
    glEvalCoord1fv_ARGS *args = (glEvalCoord1fv_ARGS *)&unpacked->args; \
    glEvalCoord1fv(args->u);; \
} while(0)
void glEvalCoord1fv(glEvalCoord1fv_ARG_EXPAND);
packed_call_t *pack_glEvalCoord1fv(glEvalCoord1fv_PACKED *_dst glEvalCoord1fv_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord1fv_PTR)(glEvalCoord1fv_ARG_EXPAND);
#endif
#ifndef glEvalCoord1xOES_RETURN
#define glEvalCoord1xOES_RETURN void
#define glEvalCoord1xOES_ARG_NAMES u
#define glEvalCoord1xOES_ARG_EXPAND GLfixed u
#define glEvalCoord1xOES_ARG_NAMES_TAIL , u
#define glEvalCoord1xOES_ARG_EXPAND_TAIL , GLfixed u
#define forward_glEvalCoord1xOES(_u) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord1xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord1xOES(dst, _u), NULL); \
    });
#define call_glEvalCoord1xOES(packed, ret_v) do { \
    glEvalCoord1xOES_PACKED *unpacked = (glEvalCoord1xOES_PACKED *)packed; \
    glEvalCoord1xOES_ARGS *args = (glEvalCoord1xOES_ARGS *)&unpacked->args; \
    glEvalCoord1xOES(args->u);; \
} while(0)
void glEvalCoord1xOES(glEvalCoord1xOES_ARG_EXPAND);
packed_call_t *pack_glEvalCoord1xOES(glEvalCoord1xOES_PACKED *_dst glEvalCoord1xOES_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord1xOES_PTR)(glEvalCoord1xOES_ARG_EXPAND);
#endif
#ifndef glEvalCoord1xvOES_RETURN
#define glEvalCoord1xvOES_RETURN void
#define glEvalCoord1xvOES_ARG_NAMES coords
#define glEvalCoord1xvOES_ARG_EXPAND const GLfixed * coords
#define glEvalCoord1xvOES_ARG_NAMES_TAIL , coords
#define glEvalCoord1xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glEvalCoord1xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord1xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord1xvOES(dst, _coords), NULL); \
    });
#define call_glEvalCoord1xvOES(packed, ret_v) do { \
    glEvalCoord1xvOES_PACKED *unpacked = (glEvalCoord1xvOES_PACKED *)packed; \
    glEvalCoord1xvOES_ARGS *args = (glEvalCoord1xvOES_ARGS *)&unpacked->args; \
    glEvalCoord1xvOES(args->coords);; \
} while(0)
void glEvalCoord1xvOES(glEvalCoord1xvOES_ARG_EXPAND);
packed_call_t *pack_glEvalCoord1xvOES(glEvalCoord1xvOES_PACKED *_dst glEvalCoord1xvOES_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord1xvOES_PTR)(glEvalCoord1xvOES_ARG_EXPAND);
#endif
#ifndef glEvalCoord2d_RETURN
#define glEvalCoord2d_RETURN void
#define glEvalCoord2d_ARG_NAMES u, v
#define glEvalCoord2d_ARG_EXPAND GLdouble u, GLdouble v
#define glEvalCoord2d_ARG_NAMES_TAIL , u, v
#define glEvalCoord2d_ARG_EXPAND_TAIL , GLdouble u, GLdouble v
#define forward_glEvalCoord2d(_u, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord2d(dst, _u, _v), NULL); \
    });
#define call_glEvalCoord2d(packed, ret_v) do { \
    glEvalCoord2d_PACKED *unpacked = (glEvalCoord2d_PACKED *)packed; \
    glEvalCoord2d_ARGS *args = (glEvalCoord2d_ARGS *)&unpacked->args; \
    glEvalCoord2d(args->u, args->v);; \
} while(0)
void glEvalCoord2d(glEvalCoord2d_ARG_EXPAND);
packed_call_t *pack_glEvalCoord2d(glEvalCoord2d_PACKED *_dst glEvalCoord2d_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord2d_PTR)(glEvalCoord2d_ARG_EXPAND);
#endif
#ifndef glEvalCoord2dv_RETURN
#define glEvalCoord2dv_RETURN void
#define glEvalCoord2dv_ARG_NAMES u
#define glEvalCoord2dv_ARG_EXPAND const GLdouble * u
#define glEvalCoord2dv_ARG_NAMES_TAIL , u
#define glEvalCoord2dv_ARG_EXPAND_TAIL , const GLdouble * u
#define forward_glEvalCoord2dv(_u) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord2dv(dst, _u), NULL); \
    });
#define call_glEvalCoord2dv(packed, ret_v) do { \
    glEvalCoord2dv_PACKED *unpacked = (glEvalCoord2dv_PACKED *)packed; \
    glEvalCoord2dv_ARGS *args = (glEvalCoord2dv_ARGS *)&unpacked->args; \
    glEvalCoord2dv(args->u);; \
} while(0)
void glEvalCoord2dv(glEvalCoord2dv_ARG_EXPAND);
packed_call_t *pack_glEvalCoord2dv(glEvalCoord2dv_PACKED *_dst glEvalCoord2dv_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord2dv_PTR)(glEvalCoord2dv_ARG_EXPAND);
#endif
#ifndef glEvalCoord2f_RETURN
#define glEvalCoord2f_RETURN void
#define glEvalCoord2f_ARG_NAMES u, v
#define glEvalCoord2f_ARG_EXPAND GLfloat u, GLfloat v
#define glEvalCoord2f_ARG_NAMES_TAIL , u, v
#define glEvalCoord2f_ARG_EXPAND_TAIL , GLfloat u, GLfloat v
#define forward_glEvalCoord2f(_u, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord2f(dst, _u, _v), NULL); \
    });
#define call_glEvalCoord2f(packed, ret_v) do { \
    glEvalCoord2f_PACKED *unpacked = (glEvalCoord2f_PACKED *)packed; \
    glEvalCoord2f_ARGS *args = (glEvalCoord2f_ARGS *)&unpacked->args; \
    glEvalCoord2f(args->u, args->v);; \
} while(0)
void glEvalCoord2f(glEvalCoord2f_ARG_EXPAND);
packed_call_t *pack_glEvalCoord2f(glEvalCoord2f_PACKED *_dst glEvalCoord2f_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord2f_PTR)(glEvalCoord2f_ARG_EXPAND);
#endif
#ifndef glEvalCoord2fv_RETURN
#define glEvalCoord2fv_RETURN void
#define glEvalCoord2fv_ARG_NAMES u
#define glEvalCoord2fv_ARG_EXPAND const GLfloat * u
#define glEvalCoord2fv_ARG_NAMES_TAIL , u
#define glEvalCoord2fv_ARG_EXPAND_TAIL , const GLfloat * u
#define forward_glEvalCoord2fv(_u) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord2fv(dst, _u), NULL); \
    });
#define call_glEvalCoord2fv(packed, ret_v) do { \
    glEvalCoord2fv_PACKED *unpacked = (glEvalCoord2fv_PACKED *)packed; \
    glEvalCoord2fv_ARGS *args = (glEvalCoord2fv_ARGS *)&unpacked->args; \
    glEvalCoord2fv(args->u);; \
} while(0)
void glEvalCoord2fv(glEvalCoord2fv_ARG_EXPAND);
packed_call_t *pack_glEvalCoord2fv(glEvalCoord2fv_PACKED *_dst glEvalCoord2fv_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord2fv_PTR)(glEvalCoord2fv_ARG_EXPAND);
#endif
#ifndef glEvalCoord2xOES_RETURN
#define glEvalCoord2xOES_RETURN void
#define glEvalCoord2xOES_ARG_NAMES u, v
#define glEvalCoord2xOES_ARG_EXPAND GLfixed u, GLfixed v
#define glEvalCoord2xOES_ARG_NAMES_TAIL , u, v
#define glEvalCoord2xOES_ARG_EXPAND_TAIL , GLfixed u, GLfixed v
#define forward_glEvalCoord2xOES(_u, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord2xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord2xOES(dst, _u, _v), NULL); \
    });
#define call_glEvalCoord2xOES(packed, ret_v) do { \
    glEvalCoord2xOES_PACKED *unpacked = (glEvalCoord2xOES_PACKED *)packed; \
    glEvalCoord2xOES_ARGS *args = (glEvalCoord2xOES_ARGS *)&unpacked->args; \
    glEvalCoord2xOES(args->u, args->v);; \
} while(0)
void glEvalCoord2xOES(glEvalCoord2xOES_ARG_EXPAND);
packed_call_t *pack_glEvalCoord2xOES(glEvalCoord2xOES_PACKED *_dst glEvalCoord2xOES_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord2xOES_PTR)(glEvalCoord2xOES_ARG_EXPAND);
#endif
#ifndef glEvalCoord2xvOES_RETURN
#define glEvalCoord2xvOES_RETURN void
#define glEvalCoord2xvOES_ARG_NAMES coords
#define glEvalCoord2xvOES_ARG_EXPAND const GLfixed * coords
#define glEvalCoord2xvOES_ARG_NAMES_TAIL , coords
#define glEvalCoord2xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glEvalCoord2xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalCoord2xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalCoord2xvOES(dst, _coords), NULL); \
    });
#define call_glEvalCoord2xvOES(packed, ret_v) do { \
    glEvalCoord2xvOES_PACKED *unpacked = (glEvalCoord2xvOES_PACKED *)packed; \
    glEvalCoord2xvOES_ARGS *args = (glEvalCoord2xvOES_ARGS *)&unpacked->args; \
    glEvalCoord2xvOES(args->coords);; \
} while(0)
void glEvalCoord2xvOES(glEvalCoord2xvOES_ARG_EXPAND);
packed_call_t *pack_glEvalCoord2xvOES(glEvalCoord2xvOES_PACKED *_dst glEvalCoord2xvOES_ARG_EXPAND_TAIL);
typedef void (*glEvalCoord2xvOES_PTR)(glEvalCoord2xvOES_ARG_EXPAND);
#endif
#ifndef glEvalMapsNV_RETURN
#define glEvalMapsNV_RETURN void
#define glEvalMapsNV_ARG_NAMES target, mode
#define glEvalMapsNV_ARG_EXPAND GLenum target, GLenum mode
#define glEvalMapsNV_ARG_NAMES_TAIL , target, mode
#define glEvalMapsNV_ARG_EXPAND_TAIL , GLenum target, GLenum mode
#define forward_glEvalMapsNV(_target, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalMapsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalMapsNV(dst, _target, _mode), NULL); \
    });
#define call_glEvalMapsNV(packed, ret_v) do { \
    glEvalMapsNV_PACKED *unpacked = (glEvalMapsNV_PACKED *)packed; \
    glEvalMapsNV_ARGS *args = (glEvalMapsNV_ARGS *)&unpacked->args; \
    glEvalMapsNV(args->target, args->mode);; \
} while(0)
void glEvalMapsNV(glEvalMapsNV_ARG_EXPAND);
packed_call_t *pack_glEvalMapsNV(glEvalMapsNV_PACKED *_dst glEvalMapsNV_ARG_EXPAND_TAIL);
typedef void (*glEvalMapsNV_PTR)(glEvalMapsNV_ARG_EXPAND);
#endif
#ifndef glEvalMesh1_RETURN
#define glEvalMesh1_RETURN void
#define glEvalMesh1_ARG_NAMES mode, i1, i2
#define glEvalMesh1_ARG_EXPAND GLenum mode, GLint i1, GLint i2
#define glEvalMesh1_ARG_NAMES_TAIL , mode, i1, i2
#define glEvalMesh1_ARG_EXPAND_TAIL , GLenum mode, GLint i1, GLint i2
#define forward_glEvalMesh1(_mode, _i1, _i2) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalMesh1_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalMesh1(dst, _mode, _i1, _i2), NULL); \
    });
#define call_glEvalMesh1(packed, ret_v) do { \
    glEvalMesh1_PACKED *unpacked = (glEvalMesh1_PACKED *)packed; \
    glEvalMesh1_ARGS *args = (glEvalMesh1_ARGS *)&unpacked->args; \
    glEvalMesh1(args->mode, args->i1, args->i2);; \
} while(0)
void glEvalMesh1(glEvalMesh1_ARG_EXPAND);
packed_call_t *pack_glEvalMesh1(glEvalMesh1_PACKED *_dst glEvalMesh1_ARG_EXPAND_TAIL);
typedef void (*glEvalMesh1_PTR)(glEvalMesh1_ARG_EXPAND);
#endif
#ifndef glEvalMesh2_RETURN
#define glEvalMesh2_RETURN void
#define glEvalMesh2_ARG_NAMES mode, i1, i2, j1, j2
#define glEvalMesh2_ARG_EXPAND GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2
#define glEvalMesh2_ARG_NAMES_TAIL , mode, i1, i2, j1, j2
#define glEvalMesh2_ARG_EXPAND_TAIL , GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2
#define forward_glEvalMesh2(_mode, _i1, _i2, _j1, _j2) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalMesh2_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalMesh2(dst, _mode, _i1, _i2, _j1, _j2), NULL); \
    });
#define call_glEvalMesh2(packed, ret_v) do { \
    glEvalMesh2_PACKED *unpacked = (glEvalMesh2_PACKED *)packed; \
    glEvalMesh2_ARGS *args = (glEvalMesh2_ARGS *)&unpacked->args; \
    glEvalMesh2(args->mode, args->i1, args->i2, args->j1, args->j2);; \
} while(0)
void glEvalMesh2(glEvalMesh2_ARG_EXPAND);
packed_call_t *pack_glEvalMesh2(glEvalMesh2_PACKED *_dst glEvalMesh2_ARG_EXPAND_TAIL);
typedef void (*glEvalMesh2_PTR)(glEvalMesh2_ARG_EXPAND);
#endif
#ifndef glEvalPoint1_RETURN
#define glEvalPoint1_RETURN void
#define glEvalPoint1_ARG_NAMES i
#define glEvalPoint1_ARG_EXPAND GLint i
#define glEvalPoint1_ARG_NAMES_TAIL , i
#define glEvalPoint1_ARG_EXPAND_TAIL , GLint i
#define forward_glEvalPoint1(_i) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalPoint1_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalPoint1(dst, _i), NULL); \
    });
#define call_glEvalPoint1(packed, ret_v) do { \
    glEvalPoint1_PACKED *unpacked = (glEvalPoint1_PACKED *)packed; \
    glEvalPoint1_ARGS *args = (glEvalPoint1_ARGS *)&unpacked->args; \
    glEvalPoint1(args->i);; \
} while(0)
void glEvalPoint1(glEvalPoint1_ARG_EXPAND);
packed_call_t *pack_glEvalPoint1(glEvalPoint1_PACKED *_dst glEvalPoint1_ARG_EXPAND_TAIL);
typedef void (*glEvalPoint1_PTR)(glEvalPoint1_ARG_EXPAND);
#endif
#ifndef glEvalPoint2_RETURN
#define glEvalPoint2_RETURN void
#define glEvalPoint2_ARG_NAMES i, j
#define glEvalPoint2_ARG_EXPAND GLint i, GLint j
#define glEvalPoint2_ARG_NAMES_TAIL , i, j
#define glEvalPoint2_ARG_EXPAND_TAIL , GLint i, GLint j
#define forward_glEvalPoint2(_i, _j) \
    ({ \
        void *dst = remote_dma(sizeof(glEvalPoint2_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glEvalPoint2(dst, _i, _j), NULL); \
    });
#define call_glEvalPoint2(packed, ret_v) do { \
    glEvalPoint2_PACKED *unpacked = (glEvalPoint2_PACKED *)packed; \
    glEvalPoint2_ARGS *args = (glEvalPoint2_ARGS *)&unpacked->args; \
    glEvalPoint2(args->i, args->j);; \
} while(0)
void glEvalPoint2(glEvalPoint2_ARG_EXPAND);
packed_call_t *pack_glEvalPoint2(glEvalPoint2_PACKED *_dst glEvalPoint2_ARG_EXPAND_TAIL);
typedef void (*glEvalPoint2_PTR)(glEvalPoint2_ARG_EXPAND);
#endif
#ifndef glExecuteProgramNV_RETURN
#define glExecuteProgramNV_RETURN void
#define glExecuteProgramNV_ARG_NAMES target, id, params
#define glExecuteProgramNV_ARG_EXPAND GLenum target, GLuint id, const GLfloat * params
#define glExecuteProgramNV_ARG_NAMES_TAIL , target, id, params
#define glExecuteProgramNV_ARG_EXPAND_TAIL , GLenum target, GLuint id, const GLfloat * params
#define forward_glExecuteProgramNV(_target, _id, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glExecuteProgramNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glExecuteProgramNV(dst, _target, _id, _params), NULL); \
    });
#define call_glExecuteProgramNV(packed, ret_v) do { \
    glExecuteProgramNV_PACKED *unpacked = (glExecuteProgramNV_PACKED *)packed; \
    glExecuteProgramNV_ARGS *args = (glExecuteProgramNV_ARGS *)&unpacked->args; \
    glExecuteProgramNV(args->target, args->id, args->params);; \
} while(0)
void glExecuteProgramNV(glExecuteProgramNV_ARG_EXPAND);
packed_call_t *pack_glExecuteProgramNV(glExecuteProgramNV_PACKED *_dst glExecuteProgramNV_ARG_EXPAND_TAIL);
typedef void (*glExecuteProgramNV_PTR)(glExecuteProgramNV_ARG_EXPAND);
#endif
#ifndef glExtractComponentEXT_RETURN
#define glExtractComponentEXT_RETURN void
#define glExtractComponentEXT_ARG_NAMES res, src, num
#define glExtractComponentEXT_ARG_EXPAND GLuint res, GLuint src, GLuint num
#define glExtractComponentEXT_ARG_NAMES_TAIL , res, src, num
#define glExtractComponentEXT_ARG_EXPAND_TAIL , GLuint res, GLuint src, GLuint num
#define forward_glExtractComponentEXT(_res, _src, _num) \
    ({ \
        void *dst = remote_dma(sizeof(glExtractComponentEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glExtractComponentEXT(dst, _res, _src, _num), NULL); \
    });
#define call_glExtractComponentEXT(packed, ret_v) do { \
    glExtractComponentEXT_PACKED *unpacked = (glExtractComponentEXT_PACKED *)packed; \
    glExtractComponentEXT_ARGS *args = (glExtractComponentEXT_ARGS *)&unpacked->args; \
    glExtractComponentEXT(args->res, args->src, args->num);; \
} while(0)
void glExtractComponentEXT(glExtractComponentEXT_ARG_EXPAND);
packed_call_t *pack_glExtractComponentEXT(glExtractComponentEXT_PACKED *_dst glExtractComponentEXT_ARG_EXPAND_TAIL);
typedef void (*glExtractComponentEXT_PTR)(glExtractComponentEXT_ARG_EXPAND);
#endif
#ifndef glFeedbackBuffer_RETURN
#define glFeedbackBuffer_RETURN void
#define glFeedbackBuffer_ARG_NAMES size, type, buffer
#define glFeedbackBuffer_ARG_EXPAND GLsizei size, GLenum type, GLfloat * buffer
#define glFeedbackBuffer_ARG_NAMES_TAIL , size, type, buffer
#define glFeedbackBuffer_ARG_EXPAND_TAIL , GLsizei size, GLenum type, GLfloat * buffer
#define forward_glFeedbackBuffer(_size, _type, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glFeedbackBuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFeedbackBuffer(dst, _size, _type, _buffer), NULL); \
    });
#define call_glFeedbackBuffer(packed, ret_v) do { \
    glFeedbackBuffer_PACKED *unpacked = (glFeedbackBuffer_PACKED *)packed; \
    glFeedbackBuffer_ARGS *args = (glFeedbackBuffer_ARGS *)&unpacked->args; \
    glFeedbackBuffer(args->size, args->type, args->buffer);; \
} while(0)
void glFeedbackBuffer(glFeedbackBuffer_ARG_EXPAND);
packed_call_t *pack_glFeedbackBuffer(glFeedbackBuffer_PACKED *_dst glFeedbackBuffer_ARG_EXPAND_TAIL);
typedef void (*glFeedbackBuffer_PTR)(glFeedbackBuffer_ARG_EXPAND);
#endif
#ifndef glFeedbackBufferxOES_RETURN
#define glFeedbackBufferxOES_RETURN void
#define glFeedbackBufferxOES_ARG_NAMES n, type, buffer
#define glFeedbackBufferxOES_ARG_EXPAND GLsizei n, GLenum type, const GLfixed * buffer
#define glFeedbackBufferxOES_ARG_NAMES_TAIL , n, type, buffer
#define glFeedbackBufferxOES_ARG_EXPAND_TAIL , GLsizei n, GLenum type, const GLfixed * buffer
#define forward_glFeedbackBufferxOES(_n, _type, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glFeedbackBufferxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFeedbackBufferxOES(dst, _n, _type, _buffer), NULL); \
    });
#define call_glFeedbackBufferxOES(packed, ret_v) do { \
    glFeedbackBufferxOES_PACKED *unpacked = (glFeedbackBufferxOES_PACKED *)packed; \
    glFeedbackBufferxOES_ARGS *args = (glFeedbackBufferxOES_ARGS *)&unpacked->args; \
    glFeedbackBufferxOES(args->n, args->type, args->buffer);; \
} while(0)
void glFeedbackBufferxOES(glFeedbackBufferxOES_ARG_EXPAND);
packed_call_t *pack_glFeedbackBufferxOES(glFeedbackBufferxOES_PACKED *_dst glFeedbackBufferxOES_ARG_EXPAND_TAIL);
typedef void (*glFeedbackBufferxOES_PTR)(glFeedbackBufferxOES_ARG_EXPAND);
#endif
#ifndef glFenceSync_RETURN
#define glFenceSync_RETURN GLsync
#define glFenceSync_ARG_NAMES condition, flags
#define glFenceSync_ARG_EXPAND GLenum condition, GLbitfield flags
#define glFenceSync_ARG_NAMES_TAIL , condition, flags
#define glFenceSync_ARG_EXPAND_TAIL , GLenum condition, GLbitfield flags
#define forward_glFenceSync(_condition, _flags) \
    ({ \
        void *dst = remote_dma(sizeof(glFenceSync_PACKED)); \
        GLsync ret = (GLsync)0; \
        remote_dma_send((packed_call_t *)pack_glFenceSync(dst, _condition, _flags), &ret); \
        ret; \
    });
#define call_glFenceSync(packed, ret_v) do { \
    glFenceSync_PACKED *unpacked = (glFenceSync_PACKED *)packed; \
    glFenceSync_ARGS *args = (glFenceSync_ARGS *)&unpacked->args; \
    GLsync *ret = (GLsync *)ret_v; \
    if (ret != NULL) { \
        *ret = glFenceSync(args->condition, args->flags);; \
    } else { \
        glFenceSync(args->condition, args->flags);; \
    } \
} while(0)
GLsync glFenceSync(glFenceSync_ARG_EXPAND);
packed_call_t *pack_glFenceSync(glFenceSync_PACKED *_dst glFenceSync_ARG_EXPAND_TAIL);
typedef GLsync (*glFenceSync_PTR)(glFenceSync_ARG_EXPAND);
#endif
#ifndef glFinalCombinerInputNV_RETURN
#define glFinalCombinerInputNV_RETURN void
#define glFinalCombinerInputNV_ARG_NAMES variable, input, mapping, componentUsage
#define glFinalCombinerInputNV_ARG_EXPAND GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage
#define glFinalCombinerInputNV_ARG_NAMES_TAIL , variable, input, mapping, componentUsage
#define glFinalCombinerInputNV_ARG_EXPAND_TAIL , GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage
#define forward_glFinalCombinerInputNV(_variable, _input, _mapping, _componentUsage) \
    ({ \
        void *dst = remote_dma(sizeof(glFinalCombinerInputNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFinalCombinerInputNV(dst, _variable, _input, _mapping, _componentUsage), NULL); \
    });
#define call_glFinalCombinerInputNV(packed, ret_v) do { \
    glFinalCombinerInputNV_PACKED *unpacked = (glFinalCombinerInputNV_PACKED *)packed; \
    glFinalCombinerInputNV_ARGS *args = (glFinalCombinerInputNV_ARGS *)&unpacked->args; \
    glFinalCombinerInputNV(args->variable, args->input, args->mapping, args->componentUsage);; \
} while(0)
void glFinalCombinerInputNV(glFinalCombinerInputNV_ARG_EXPAND);
packed_call_t *pack_glFinalCombinerInputNV(glFinalCombinerInputNV_PACKED *_dst glFinalCombinerInputNV_ARG_EXPAND_TAIL);
typedef void (*glFinalCombinerInputNV_PTR)(glFinalCombinerInputNV_ARG_EXPAND);
#endif
#ifndef glFinish_RETURN
#define glFinish_RETURN void
#define glFinish_ARG_NAMES 
#define glFinish_ARG_EXPAND 
#define glFinish_ARG_NAMES_TAIL 
#define glFinish_ARG_EXPAND_TAIL 
#define forward_glFinish() \
    ({ \
        void *dst = remote_dma(sizeof(glFinish_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFinish(dst), NULL); \
    });
#define call_glFinish(packed, ret_v) do { \
    glFinish();; \
} while(0)
void glFinish(glFinish_ARG_EXPAND);
packed_call_t *pack_glFinish(glFinish_PACKED *_dst glFinish_ARG_EXPAND_TAIL);
typedef void (*glFinish_PTR)(glFinish_ARG_EXPAND);
#endif
#ifndef glFinishAsyncSGIX_RETURN
#define glFinishAsyncSGIX_RETURN GLint
#define glFinishAsyncSGIX_ARG_NAMES markerp
#define glFinishAsyncSGIX_ARG_EXPAND GLuint * markerp
#define glFinishAsyncSGIX_ARG_NAMES_TAIL , markerp
#define glFinishAsyncSGIX_ARG_EXPAND_TAIL , GLuint * markerp
#define forward_glFinishAsyncSGIX(_markerp) \
    ({ \
        void *dst = remote_dma(sizeof(glFinishAsyncSGIX_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glFinishAsyncSGIX(dst, _markerp), &ret); \
        ret; \
    });
#define call_glFinishAsyncSGIX(packed, ret_v) do { \
    glFinishAsyncSGIX_PACKED *unpacked = (glFinishAsyncSGIX_PACKED *)packed; \
    glFinishAsyncSGIX_ARGS *args = (glFinishAsyncSGIX_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glFinishAsyncSGIX(args->markerp);; \
    } else { \
        glFinishAsyncSGIX(args->markerp);; \
    } \
} while(0)
GLint glFinishAsyncSGIX(glFinishAsyncSGIX_ARG_EXPAND);
packed_call_t *pack_glFinishAsyncSGIX(glFinishAsyncSGIX_PACKED *_dst glFinishAsyncSGIX_ARG_EXPAND_TAIL);
typedef GLint (*glFinishAsyncSGIX_PTR)(glFinishAsyncSGIX_ARG_EXPAND);
#endif
#ifndef glFinishFenceAPPLE_RETURN
#define glFinishFenceAPPLE_RETURN void
#define glFinishFenceAPPLE_ARG_NAMES fence
#define glFinishFenceAPPLE_ARG_EXPAND GLuint fence
#define glFinishFenceAPPLE_ARG_NAMES_TAIL , fence
#define glFinishFenceAPPLE_ARG_EXPAND_TAIL , GLuint fence
#define forward_glFinishFenceAPPLE(_fence) \
    ({ \
        void *dst = remote_dma(sizeof(glFinishFenceAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFinishFenceAPPLE(dst, _fence), NULL); \
    });
#define call_glFinishFenceAPPLE(packed, ret_v) do { \
    glFinishFenceAPPLE_PACKED *unpacked = (glFinishFenceAPPLE_PACKED *)packed; \
    glFinishFenceAPPLE_ARGS *args = (glFinishFenceAPPLE_ARGS *)&unpacked->args; \
    glFinishFenceAPPLE(args->fence);; \
} while(0)
void glFinishFenceAPPLE(glFinishFenceAPPLE_ARG_EXPAND);
packed_call_t *pack_glFinishFenceAPPLE(glFinishFenceAPPLE_PACKED *_dst glFinishFenceAPPLE_ARG_EXPAND_TAIL);
typedef void (*glFinishFenceAPPLE_PTR)(glFinishFenceAPPLE_ARG_EXPAND);
#endif
#ifndef glFinishFenceNV_RETURN
#define glFinishFenceNV_RETURN void
#define glFinishFenceNV_ARG_NAMES fence
#define glFinishFenceNV_ARG_EXPAND GLuint fence
#define glFinishFenceNV_ARG_NAMES_TAIL , fence
#define glFinishFenceNV_ARG_EXPAND_TAIL , GLuint fence
#define forward_glFinishFenceNV(_fence) \
    ({ \
        void *dst = remote_dma(sizeof(glFinishFenceNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFinishFenceNV(dst, _fence), NULL); \
    });
#define call_glFinishFenceNV(packed, ret_v) do { \
    glFinishFenceNV_PACKED *unpacked = (glFinishFenceNV_PACKED *)packed; \
    glFinishFenceNV_ARGS *args = (glFinishFenceNV_ARGS *)&unpacked->args; \
    glFinishFenceNV(args->fence);; \
} while(0)
void glFinishFenceNV(glFinishFenceNV_ARG_EXPAND);
packed_call_t *pack_glFinishFenceNV(glFinishFenceNV_PACKED *_dst glFinishFenceNV_ARG_EXPAND_TAIL);
typedef void (*glFinishFenceNV_PTR)(glFinishFenceNV_ARG_EXPAND);
#endif
#ifndef glFinishObjectAPPLE_RETURN
#define glFinishObjectAPPLE_RETURN void
#define glFinishObjectAPPLE_ARG_NAMES object, name
#define glFinishObjectAPPLE_ARG_EXPAND GLenum object, GLint name
#define glFinishObjectAPPLE_ARG_NAMES_TAIL , object, name
#define glFinishObjectAPPLE_ARG_EXPAND_TAIL , GLenum object, GLint name
#define forward_glFinishObjectAPPLE(_object, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glFinishObjectAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFinishObjectAPPLE(dst, _object, _name), NULL); \
    });
#define call_glFinishObjectAPPLE(packed, ret_v) do { \
    glFinishObjectAPPLE_PACKED *unpacked = (glFinishObjectAPPLE_PACKED *)packed; \
    glFinishObjectAPPLE_ARGS *args = (glFinishObjectAPPLE_ARGS *)&unpacked->args; \
    glFinishObjectAPPLE(args->object, args->name);; \
} while(0)
void glFinishObjectAPPLE(glFinishObjectAPPLE_ARG_EXPAND);
packed_call_t *pack_glFinishObjectAPPLE(glFinishObjectAPPLE_PACKED *_dst glFinishObjectAPPLE_ARG_EXPAND_TAIL);
typedef void (*glFinishObjectAPPLE_PTR)(glFinishObjectAPPLE_ARG_EXPAND);
#endif
#ifndef glFinishTextureSUNX_RETURN
#define glFinishTextureSUNX_RETURN void
#define glFinishTextureSUNX_ARG_NAMES 
#define glFinishTextureSUNX_ARG_EXPAND 
#define glFinishTextureSUNX_ARG_NAMES_TAIL 
#define glFinishTextureSUNX_ARG_EXPAND_TAIL 
#define forward_glFinishTextureSUNX() \
    ({ \
        void *dst = remote_dma(sizeof(glFinishTextureSUNX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFinishTextureSUNX(dst), NULL); \
    });
#define call_glFinishTextureSUNX(packed, ret_v) do { \
    glFinishTextureSUNX();; \
} while(0)
void glFinishTextureSUNX(glFinishTextureSUNX_ARG_EXPAND);
packed_call_t *pack_glFinishTextureSUNX(glFinishTextureSUNX_PACKED *_dst glFinishTextureSUNX_ARG_EXPAND_TAIL);
typedef void (*glFinishTextureSUNX_PTR)(glFinishTextureSUNX_ARG_EXPAND);
#endif
#ifndef glFlush_RETURN
#define glFlush_RETURN void
#define glFlush_ARG_NAMES 
#define glFlush_ARG_EXPAND 
#define glFlush_ARG_NAMES_TAIL 
#define glFlush_ARG_EXPAND_TAIL 
#define forward_glFlush() \
    ({ \
        void *dst = remote_dma(sizeof(glFlush_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlush(dst), NULL); \
    });
#define call_glFlush(packed, ret_v) do { \
    glFlush();; \
} while(0)
void glFlush(glFlush_ARG_EXPAND);
packed_call_t *pack_glFlush(glFlush_PACKED *_dst glFlush_ARG_EXPAND_TAIL);
typedef void (*glFlush_PTR)(glFlush_ARG_EXPAND);
#endif
#ifndef glFlushMappedBufferRange_RETURN
#define glFlushMappedBufferRange_RETURN void
#define glFlushMappedBufferRange_ARG_NAMES target, offset, length
#define glFlushMappedBufferRange_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr length
#define glFlushMappedBufferRange_ARG_NAMES_TAIL , target, offset, length
#define glFlushMappedBufferRange_ARG_EXPAND_TAIL , GLenum target, GLintptr offset, GLsizeiptr length
#define forward_glFlushMappedBufferRange(_target, _offset, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glFlushMappedBufferRange_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushMappedBufferRange(dst, _target, _offset, _length), NULL); \
    });
#define call_glFlushMappedBufferRange(packed, ret_v) do { \
    glFlushMappedBufferRange_PACKED *unpacked = (glFlushMappedBufferRange_PACKED *)packed; \
    glFlushMappedBufferRange_ARGS *args = (glFlushMappedBufferRange_ARGS *)&unpacked->args; \
    glFlushMappedBufferRange(args->target, args->offset, args->length);; \
} while(0)
void glFlushMappedBufferRange(glFlushMappedBufferRange_ARG_EXPAND);
packed_call_t *pack_glFlushMappedBufferRange(glFlushMappedBufferRange_PACKED *_dst glFlushMappedBufferRange_ARG_EXPAND_TAIL);
typedef void (*glFlushMappedBufferRange_PTR)(glFlushMappedBufferRange_ARG_EXPAND);
#endif
#ifndef glFlushMappedBufferRangeAPPLE_RETURN
#define glFlushMappedBufferRangeAPPLE_RETURN void
#define glFlushMappedBufferRangeAPPLE_ARG_NAMES target, offset, size
#define glFlushMappedBufferRangeAPPLE_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr size
#define glFlushMappedBufferRangeAPPLE_ARG_NAMES_TAIL , target, offset, size
#define glFlushMappedBufferRangeAPPLE_ARG_EXPAND_TAIL , GLenum target, GLintptr offset, GLsizeiptr size
#define forward_glFlushMappedBufferRangeAPPLE(_target, _offset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glFlushMappedBufferRangeAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushMappedBufferRangeAPPLE(dst, _target, _offset, _size), NULL); \
    });
#define call_glFlushMappedBufferRangeAPPLE(packed, ret_v) do { \
    glFlushMappedBufferRangeAPPLE_PACKED *unpacked = (glFlushMappedBufferRangeAPPLE_PACKED *)packed; \
    glFlushMappedBufferRangeAPPLE_ARGS *args = (glFlushMappedBufferRangeAPPLE_ARGS *)&unpacked->args; \
    glFlushMappedBufferRangeAPPLE(args->target, args->offset, args->size);; \
} while(0)
void glFlushMappedBufferRangeAPPLE(glFlushMappedBufferRangeAPPLE_ARG_EXPAND);
packed_call_t *pack_glFlushMappedBufferRangeAPPLE(glFlushMappedBufferRangeAPPLE_PACKED *_dst glFlushMappedBufferRangeAPPLE_ARG_EXPAND_TAIL);
typedef void (*glFlushMappedBufferRangeAPPLE_PTR)(glFlushMappedBufferRangeAPPLE_ARG_EXPAND);
#endif
#ifndef glFlushMappedNamedBufferRangeEXT_RETURN
#define glFlushMappedNamedBufferRangeEXT_RETURN void
#define glFlushMappedNamedBufferRangeEXT_ARG_NAMES buffer, offset, length
#define glFlushMappedNamedBufferRangeEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr length
#define glFlushMappedNamedBufferRangeEXT_ARG_NAMES_TAIL , buffer, offset, length
#define glFlushMappedNamedBufferRangeEXT_ARG_EXPAND_TAIL , GLuint buffer, GLintptr offset, GLsizeiptr length
#define forward_glFlushMappedNamedBufferRangeEXT(_buffer, _offset, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glFlushMappedNamedBufferRangeEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushMappedNamedBufferRangeEXT(dst, _buffer, _offset, _length), NULL); \
    });
#define call_glFlushMappedNamedBufferRangeEXT(packed, ret_v) do { \
    glFlushMappedNamedBufferRangeEXT_PACKED *unpacked = (glFlushMappedNamedBufferRangeEXT_PACKED *)packed; \
    glFlushMappedNamedBufferRangeEXT_ARGS *args = (glFlushMappedNamedBufferRangeEXT_ARGS *)&unpacked->args; \
    glFlushMappedNamedBufferRangeEXT(args->buffer, args->offset, args->length);; \
} while(0)
void glFlushMappedNamedBufferRangeEXT(glFlushMappedNamedBufferRangeEXT_ARG_EXPAND);
packed_call_t *pack_glFlushMappedNamedBufferRangeEXT(glFlushMappedNamedBufferRangeEXT_PACKED *_dst glFlushMappedNamedBufferRangeEXT_ARG_EXPAND_TAIL);
typedef void (*glFlushMappedNamedBufferRangeEXT_PTR)(glFlushMappedNamedBufferRangeEXT_ARG_EXPAND);
#endif
#ifndef glFlushPixelDataRangeNV_RETURN
#define glFlushPixelDataRangeNV_RETURN void
#define glFlushPixelDataRangeNV_ARG_NAMES target
#define glFlushPixelDataRangeNV_ARG_EXPAND GLenum target
#define glFlushPixelDataRangeNV_ARG_NAMES_TAIL , target
#define glFlushPixelDataRangeNV_ARG_EXPAND_TAIL , GLenum target
#define forward_glFlushPixelDataRangeNV(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glFlushPixelDataRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushPixelDataRangeNV(dst, _target), NULL); \
    });
#define call_glFlushPixelDataRangeNV(packed, ret_v) do { \
    glFlushPixelDataRangeNV_PACKED *unpacked = (glFlushPixelDataRangeNV_PACKED *)packed; \
    glFlushPixelDataRangeNV_ARGS *args = (glFlushPixelDataRangeNV_ARGS *)&unpacked->args; \
    glFlushPixelDataRangeNV(args->target);; \
} while(0)
void glFlushPixelDataRangeNV(glFlushPixelDataRangeNV_ARG_EXPAND);
packed_call_t *pack_glFlushPixelDataRangeNV(glFlushPixelDataRangeNV_PACKED *_dst glFlushPixelDataRangeNV_ARG_EXPAND_TAIL);
typedef void (*glFlushPixelDataRangeNV_PTR)(glFlushPixelDataRangeNV_ARG_EXPAND);
#endif
#ifndef glFlushRasterSGIX_RETURN
#define glFlushRasterSGIX_RETURN void
#define glFlushRasterSGIX_ARG_NAMES 
#define glFlushRasterSGIX_ARG_EXPAND 
#define glFlushRasterSGIX_ARG_NAMES_TAIL 
#define glFlushRasterSGIX_ARG_EXPAND_TAIL 
#define forward_glFlushRasterSGIX() \
    ({ \
        void *dst = remote_dma(sizeof(glFlushRasterSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushRasterSGIX(dst), NULL); \
    });
#define call_glFlushRasterSGIX(packed, ret_v) do { \
    glFlushRasterSGIX();; \
} while(0)
void glFlushRasterSGIX(glFlushRasterSGIX_ARG_EXPAND);
packed_call_t *pack_glFlushRasterSGIX(glFlushRasterSGIX_PACKED *_dst glFlushRasterSGIX_ARG_EXPAND_TAIL);
typedef void (*glFlushRasterSGIX_PTR)(glFlushRasterSGIX_ARG_EXPAND);
#endif
#ifndef glFlushStaticDataIBM_RETURN
#define glFlushStaticDataIBM_RETURN void
#define glFlushStaticDataIBM_ARG_NAMES target
#define glFlushStaticDataIBM_ARG_EXPAND GLenum target
#define glFlushStaticDataIBM_ARG_NAMES_TAIL , target
#define glFlushStaticDataIBM_ARG_EXPAND_TAIL , GLenum target
#define forward_glFlushStaticDataIBM(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glFlushStaticDataIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushStaticDataIBM(dst, _target), NULL); \
    });
#define call_glFlushStaticDataIBM(packed, ret_v) do { \
    glFlushStaticDataIBM_PACKED *unpacked = (glFlushStaticDataIBM_PACKED *)packed; \
    glFlushStaticDataIBM_ARGS *args = (glFlushStaticDataIBM_ARGS *)&unpacked->args; \
    glFlushStaticDataIBM(args->target);; \
} while(0)
void glFlushStaticDataIBM(glFlushStaticDataIBM_ARG_EXPAND);
packed_call_t *pack_glFlushStaticDataIBM(glFlushStaticDataIBM_PACKED *_dst glFlushStaticDataIBM_ARG_EXPAND_TAIL);
typedef void (*glFlushStaticDataIBM_PTR)(glFlushStaticDataIBM_ARG_EXPAND);
#endif
#ifndef glFlushVertexArrayRangeAPPLE_RETURN
#define glFlushVertexArrayRangeAPPLE_RETURN void
#define glFlushVertexArrayRangeAPPLE_ARG_NAMES length, pointer
#define glFlushVertexArrayRangeAPPLE_ARG_EXPAND GLsizei length, GLvoid * pointer
#define glFlushVertexArrayRangeAPPLE_ARG_NAMES_TAIL , length, pointer
#define glFlushVertexArrayRangeAPPLE_ARG_EXPAND_TAIL , GLsizei length, GLvoid * pointer
#define forward_glFlushVertexArrayRangeAPPLE(_length, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glFlushVertexArrayRangeAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushVertexArrayRangeAPPLE(dst, _length, _pointer), NULL); \
    });
#define call_glFlushVertexArrayRangeAPPLE(packed, ret_v) do { \
    glFlushVertexArrayRangeAPPLE_PACKED *unpacked = (glFlushVertexArrayRangeAPPLE_PACKED *)packed; \
    glFlushVertexArrayRangeAPPLE_ARGS *args = (glFlushVertexArrayRangeAPPLE_ARGS *)&unpacked->args; \
    glFlushVertexArrayRangeAPPLE(args->length, args->pointer);; \
} while(0)
void glFlushVertexArrayRangeAPPLE(glFlushVertexArrayRangeAPPLE_ARG_EXPAND);
packed_call_t *pack_glFlushVertexArrayRangeAPPLE(glFlushVertexArrayRangeAPPLE_PACKED *_dst glFlushVertexArrayRangeAPPLE_ARG_EXPAND_TAIL);
typedef void (*glFlushVertexArrayRangeAPPLE_PTR)(glFlushVertexArrayRangeAPPLE_ARG_EXPAND);
#endif
#ifndef glFlushVertexArrayRangeNV_RETURN
#define glFlushVertexArrayRangeNV_RETURN void
#define glFlushVertexArrayRangeNV_ARG_NAMES 
#define glFlushVertexArrayRangeNV_ARG_EXPAND 
#define glFlushVertexArrayRangeNV_ARG_NAMES_TAIL 
#define glFlushVertexArrayRangeNV_ARG_EXPAND_TAIL 
#define forward_glFlushVertexArrayRangeNV() \
    ({ \
        void *dst = remote_dma(sizeof(glFlushVertexArrayRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFlushVertexArrayRangeNV(dst), NULL); \
    });
#define call_glFlushVertexArrayRangeNV(packed, ret_v) do { \
    glFlushVertexArrayRangeNV();; \
} while(0)
void glFlushVertexArrayRangeNV(glFlushVertexArrayRangeNV_ARG_EXPAND);
packed_call_t *pack_glFlushVertexArrayRangeNV(glFlushVertexArrayRangeNV_PACKED *_dst glFlushVertexArrayRangeNV_ARG_EXPAND_TAIL);
typedef void (*glFlushVertexArrayRangeNV_PTR)(glFlushVertexArrayRangeNV_ARG_EXPAND);
#endif
#ifndef glFogCoordFormatNV_RETURN
#define glFogCoordFormatNV_RETURN void
#define glFogCoordFormatNV_ARG_NAMES type, stride
#define glFogCoordFormatNV_ARG_EXPAND GLenum type, GLsizei stride
#define glFogCoordFormatNV_ARG_NAMES_TAIL , type, stride
#define glFogCoordFormatNV_ARG_EXPAND_TAIL , GLenum type, GLsizei stride
#define forward_glFogCoordFormatNV(_type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordFormatNV(dst, _type, _stride), NULL); \
    });
#define call_glFogCoordFormatNV(packed, ret_v) do { \
    glFogCoordFormatNV_PACKED *unpacked = (glFogCoordFormatNV_PACKED *)packed; \
    glFogCoordFormatNV_ARGS *args = (glFogCoordFormatNV_ARGS *)&unpacked->args; \
    glFogCoordFormatNV(args->type, args->stride);; \
} while(0)
void glFogCoordFormatNV(glFogCoordFormatNV_ARG_EXPAND);
packed_call_t *pack_glFogCoordFormatNV(glFogCoordFormatNV_PACKED *_dst glFogCoordFormatNV_ARG_EXPAND_TAIL);
typedef void (*glFogCoordFormatNV_PTR)(glFogCoordFormatNV_ARG_EXPAND);
#endif
#ifndef glFogCoordPointer_RETURN
#define glFogCoordPointer_RETURN void
#define glFogCoordPointer_ARG_NAMES type, stride, pointer
#define glFogCoordPointer_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glFogCoordPointer_ARG_NAMES_TAIL , type, stride, pointer
#define glFogCoordPointer_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glFogCoordPointer(_type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordPointer(dst, _type, _stride, _pointer), NULL); \
    });
#define call_glFogCoordPointer(packed, ret_v) do { \
    glFogCoordPointer_PACKED *unpacked = (glFogCoordPointer_PACKED *)packed; \
    glFogCoordPointer_ARGS *args = (glFogCoordPointer_ARGS *)&unpacked->args; \
    glFogCoordPointer(args->type, args->stride, args->pointer);; \
} while(0)
void glFogCoordPointer(glFogCoordPointer_ARG_EXPAND);
packed_call_t *pack_glFogCoordPointer(glFogCoordPointer_PACKED *_dst glFogCoordPointer_ARG_EXPAND_TAIL);
typedef void (*glFogCoordPointer_PTR)(glFogCoordPointer_ARG_EXPAND);
#endif
#ifndef glFogCoordPointerEXT_RETURN
#define glFogCoordPointerEXT_RETURN void
#define glFogCoordPointerEXT_ARG_NAMES type, stride, pointer
#define glFogCoordPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glFogCoordPointerEXT_ARG_NAMES_TAIL , type, stride, pointer
#define glFogCoordPointerEXT_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glFogCoordPointerEXT(_type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordPointerEXT(dst, _type, _stride, _pointer), NULL); \
    });
#define call_glFogCoordPointerEXT(packed, ret_v) do { \
    glFogCoordPointerEXT_PACKED *unpacked = (glFogCoordPointerEXT_PACKED *)packed; \
    glFogCoordPointerEXT_ARGS *args = (glFogCoordPointerEXT_ARGS *)&unpacked->args; \
    glFogCoordPointerEXT(args->type, args->stride, args->pointer);; \
} while(0)
void glFogCoordPointerEXT(glFogCoordPointerEXT_ARG_EXPAND);
packed_call_t *pack_glFogCoordPointerEXT(glFogCoordPointerEXT_PACKED *_dst glFogCoordPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glFogCoordPointerEXT_PTR)(glFogCoordPointerEXT_ARG_EXPAND);
#endif
#ifndef glFogCoordPointerListIBM_RETURN
#define glFogCoordPointerListIBM_RETURN void
#define glFogCoordPointerListIBM_ARG_NAMES type, stride, pointer, ptrstride
#define glFogCoordPointerListIBM_ARG_EXPAND GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glFogCoordPointerListIBM_ARG_NAMES_TAIL , type, stride, pointer, ptrstride
#define glFogCoordPointerListIBM_ARG_EXPAND_TAIL , GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define forward_glFogCoordPointerListIBM(_type, _stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordPointerListIBM(dst, _type, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glFogCoordPointerListIBM(packed, ret_v) do { \
    glFogCoordPointerListIBM_PACKED *unpacked = (glFogCoordPointerListIBM_PACKED *)packed; \
    glFogCoordPointerListIBM_ARGS *args = (glFogCoordPointerListIBM_ARGS *)&unpacked->args; \
    glFogCoordPointerListIBM(args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glFogCoordPointerListIBM(glFogCoordPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glFogCoordPointerListIBM(glFogCoordPointerListIBM_PACKED *_dst glFogCoordPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glFogCoordPointerListIBM_PTR)(glFogCoordPointerListIBM_ARG_EXPAND);
#endif
#ifndef glFogCoordd_RETURN
#define glFogCoordd_RETURN void
#define glFogCoordd_ARG_NAMES coord
#define glFogCoordd_ARG_EXPAND GLdouble coord
#define glFogCoordd_ARG_NAMES_TAIL , coord
#define glFogCoordd_ARG_EXPAND_TAIL , GLdouble coord
#define forward_glFogCoordd(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordd(dst, _coord), NULL); \
    });
#define call_glFogCoordd(packed, ret_v) do { \
    glFogCoordd_PACKED *unpacked = (glFogCoordd_PACKED *)packed; \
    glFogCoordd_ARGS *args = (glFogCoordd_ARGS *)&unpacked->args; \
    glFogCoordd(args->coord);; \
} while(0)
void glFogCoordd(glFogCoordd_ARG_EXPAND);
packed_call_t *pack_glFogCoordd(glFogCoordd_PACKED *_dst glFogCoordd_ARG_EXPAND_TAIL);
typedef void (*glFogCoordd_PTR)(glFogCoordd_ARG_EXPAND);
#endif
#ifndef glFogCoorddEXT_RETURN
#define glFogCoorddEXT_RETURN void
#define glFogCoorddEXT_ARG_NAMES coord
#define glFogCoorddEXT_ARG_EXPAND GLdouble coord
#define glFogCoorddEXT_ARG_NAMES_TAIL , coord
#define glFogCoorddEXT_ARG_EXPAND_TAIL , GLdouble coord
#define forward_glFogCoorddEXT(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoorddEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoorddEXT(dst, _coord), NULL); \
    });
#define call_glFogCoorddEXT(packed, ret_v) do { \
    glFogCoorddEXT_PACKED *unpacked = (glFogCoorddEXT_PACKED *)packed; \
    glFogCoorddEXT_ARGS *args = (glFogCoorddEXT_ARGS *)&unpacked->args; \
    glFogCoorddEXT(args->coord);; \
} while(0)
void glFogCoorddEXT(glFogCoorddEXT_ARG_EXPAND);
packed_call_t *pack_glFogCoorddEXT(glFogCoorddEXT_PACKED *_dst glFogCoorddEXT_ARG_EXPAND_TAIL);
typedef void (*glFogCoorddEXT_PTR)(glFogCoorddEXT_ARG_EXPAND);
#endif
#ifndef glFogCoorddv_RETURN
#define glFogCoorddv_RETURN void
#define glFogCoorddv_ARG_NAMES coord
#define glFogCoorddv_ARG_EXPAND const GLdouble * coord
#define glFogCoorddv_ARG_NAMES_TAIL , coord
#define glFogCoorddv_ARG_EXPAND_TAIL , const GLdouble * coord
#define forward_glFogCoorddv(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoorddv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoorddv(dst, _coord), NULL); \
    });
#define call_glFogCoorddv(packed, ret_v) do { \
    glFogCoorddv_PACKED *unpacked = (glFogCoorddv_PACKED *)packed; \
    glFogCoorddv_ARGS *args = (glFogCoorddv_ARGS *)&unpacked->args; \
    glFogCoorddv(args->coord);; \
} while(0)
void glFogCoorddv(glFogCoorddv_ARG_EXPAND);
packed_call_t *pack_glFogCoorddv(glFogCoorddv_PACKED *_dst glFogCoorddv_ARG_EXPAND_TAIL);
typedef void (*glFogCoorddv_PTR)(glFogCoorddv_ARG_EXPAND);
#endif
#ifndef glFogCoorddvEXT_RETURN
#define glFogCoorddvEXT_RETURN void
#define glFogCoorddvEXT_ARG_NAMES coord
#define glFogCoorddvEXT_ARG_EXPAND const GLdouble * coord
#define glFogCoorddvEXT_ARG_NAMES_TAIL , coord
#define glFogCoorddvEXT_ARG_EXPAND_TAIL , const GLdouble * coord
#define forward_glFogCoorddvEXT(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoorddvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoorddvEXT(dst, _coord), NULL); \
    });
#define call_glFogCoorddvEXT(packed, ret_v) do { \
    glFogCoorddvEXT_PACKED *unpacked = (glFogCoorddvEXT_PACKED *)packed; \
    glFogCoorddvEXT_ARGS *args = (glFogCoorddvEXT_ARGS *)&unpacked->args; \
    glFogCoorddvEXT(args->coord);; \
} while(0)
void glFogCoorddvEXT(glFogCoorddvEXT_ARG_EXPAND);
packed_call_t *pack_glFogCoorddvEXT(glFogCoorddvEXT_PACKED *_dst glFogCoorddvEXT_ARG_EXPAND_TAIL);
typedef void (*glFogCoorddvEXT_PTR)(glFogCoorddvEXT_ARG_EXPAND);
#endif
#ifndef glFogCoordf_RETURN
#define glFogCoordf_RETURN void
#define glFogCoordf_ARG_NAMES coord
#define glFogCoordf_ARG_EXPAND GLfloat coord
#define glFogCoordf_ARG_NAMES_TAIL , coord
#define glFogCoordf_ARG_EXPAND_TAIL , GLfloat coord
#define forward_glFogCoordf(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordf(dst, _coord), NULL); \
    });
#define call_glFogCoordf(packed, ret_v) do { \
    glFogCoordf_PACKED *unpacked = (glFogCoordf_PACKED *)packed; \
    glFogCoordf_ARGS *args = (glFogCoordf_ARGS *)&unpacked->args; \
    glFogCoordf(args->coord);; \
} while(0)
void glFogCoordf(glFogCoordf_ARG_EXPAND);
packed_call_t *pack_glFogCoordf(glFogCoordf_PACKED *_dst glFogCoordf_ARG_EXPAND_TAIL);
typedef void (*glFogCoordf_PTR)(glFogCoordf_ARG_EXPAND);
#endif
#ifndef glFogCoordfEXT_RETURN
#define glFogCoordfEXT_RETURN void
#define glFogCoordfEXT_ARG_NAMES coord
#define glFogCoordfEXT_ARG_EXPAND GLfloat coord
#define glFogCoordfEXT_ARG_NAMES_TAIL , coord
#define glFogCoordfEXT_ARG_EXPAND_TAIL , GLfloat coord
#define forward_glFogCoordfEXT(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordfEXT(dst, _coord), NULL); \
    });
#define call_glFogCoordfEXT(packed, ret_v) do { \
    glFogCoordfEXT_PACKED *unpacked = (glFogCoordfEXT_PACKED *)packed; \
    glFogCoordfEXT_ARGS *args = (glFogCoordfEXT_ARGS *)&unpacked->args; \
    glFogCoordfEXT(args->coord);; \
} while(0)
void glFogCoordfEXT(glFogCoordfEXT_ARG_EXPAND);
packed_call_t *pack_glFogCoordfEXT(glFogCoordfEXT_PACKED *_dst glFogCoordfEXT_ARG_EXPAND_TAIL);
typedef void (*glFogCoordfEXT_PTR)(glFogCoordfEXT_ARG_EXPAND);
#endif
#ifndef glFogCoordfv_RETURN
#define glFogCoordfv_RETURN void
#define glFogCoordfv_ARG_NAMES coord
#define glFogCoordfv_ARG_EXPAND const GLfloat * coord
#define glFogCoordfv_ARG_NAMES_TAIL , coord
#define glFogCoordfv_ARG_EXPAND_TAIL , const GLfloat * coord
#define forward_glFogCoordfv(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordfv(dst, _coord), NULL); \
    });
#define call_glFogCoordfv(packed, ret_v) do { \
    glFogCoordfv_PACKED *unpacked = (glFogCoordfv_PACKED *)packed; \
    glFogCoordfv_ARGS *args = (glFogCoordfv_ARGS *)&unpacked->args; \
    glFogCoordfv(args->coord);; \
} while(0)
void glFogCoordfv(glFogCoordfv_ARG_EXPAND);
packed_call_t *pack_glFogCoordfv(glFogCoordfv_PACKED *_dst glFogCoordfv_ARG_EXPAND_TAIL);
typedef void (*glFogCoordfv_PTR)(glFogCoordfv_ARG_EXPAND);
#endif
#ifndef glFogCoordfvEXT_RETURN
#define glFogCoordfvEXT_RETURN void
#define glFogCoordfvEXT_ARG_NAMES coord
#define glFogCoordfvEXT_ARG_EXPAND const GLfloat * coord
#define glFogCoordfvEXT_ARG_NAMES_TAIL , coord
#define glFogCoordfvEXT_ARG_EXPAND_TAIL , const GLfloat * coord
#define forward_glFogCoordfvEXT(_coord) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordfvEXT(dst, _coord), NULL); \
    });
#define call_glFogCoordfvEXT(packed, ret_v) do { \
    glFogCoordfvEXT_PACKED *unpacked = (glFogCoordfvEXT_PACKED *)packed; \
    glFogCoordfvEXT_ARGS *args = (glFogCoordfvEXT_ARGS *)&unpacked->args; \
    glFogCoordfvEXT(args->coord);; \
} while(0)
void glFogCoordfvEXT(glFogCoordfvEXT_ARG_EXPAND);
packed_call_t *pack_glFogCoordfvEXT(glFogCoordfvEXT_PACKED *_dst glFogCoordfvEXT_ARG_EXPAND_TAIL);
typedef void (*glFogCoordfvEXT_PTR)(glFogCoordfvEXT_ARG_EXPAND);
#endif
#ifndef glFogCoordhNV_RETURN
#define glFogCoordhNV_RETURN void
#define glFogCoordhNV_ARG_NAMES fog
#define glFogCoordhNV_ARG_EXPAND GLhalfNV fog
#define glFogCoordhNV_ARG_NAMES_TAIL , fog
#define glFogCoordhNV_ARG_EXPAND_TAIL , GLhalfNV fog
#define forward_glFogCoordhNV(_fog) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordhNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordhNV(dst, _fog), NULL); \
    });
#define call_glFogCoordhNV(packed, ret_v) do { \
    glFogCoordhNV_PACKED *unpacked = (glFogCoordhNV_PACKED *)packed; \
    glFogCoordhNV_ARGS *args = (glFogCoordhNV_ARGS *)&unpacked->args; \
    glFogCoordhNV(args->fog);; \
} while(0)
void glFogCoordhNV(glFogCoordhNV_ARG_EXPAND);
packed_call_t *pack_glFogCoordhNV(glFogCoordhNV_PACKED *_dst glFogCoordhNV_ARG_EXPAND_TAIL);
typedef void (*glFogCoordhNV_PTR)(glFogCoordhNV_ARG_EXPAND);
#endif
#ifndef glFogCoordhvNV_RETURN
#define glFogCoordhvNV_RETURN void
#define glFogCoordhvNV_ARG_NAMES fog
#define glFogCoordhvNV_ARG_EXPAND const GLhalfNV * fog
#define glFogCoordhvNV_ARG_NAMES_TAIL , fog
#define glFogCoordhvNV_ARG_EXPAND_TAIL , const GLhalfNV * fog
#define forward_glFogCoordhvNV(_fog) \
    ({ \
        void *dst = remote_dma(sizeof(glFogCoordhvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogCoordhvNV(dst, _fog), NULL); \
    });
#define call_glFogCoordhvNV(packed, ret_v) do { \
    glFogCoordhvNV_PACKED *unpacked = (glFogCoordhvNV_PACKED *)packed; \
    glFogCoordhvNV_ARGS *args = (glFogCoordhvNV_ARGS *)&unpacked->args; \
    glFogCoordhvNV(args->fog);; \
} while(0)
void glFogCoordhvNV(glFogCoordhvNV_ARG_EXPAND);
packed_call_t *pack_glFogCoordhvNV(glFogCoordhvNV_PACKED *_dst glFogCoordhvNV_ARG_EXPAND_TAIL);
typedef void (*glFogCoordhvNV_PTR)(glFogCoordhvNV_ARG_EXPAND);
#endif
#ifndef glFogFuncSGIS_RETURN
#define glFogFuncSGIS_RETURN void
#define glFogFuncSGIS_ARG_NAMES n, points
#define glFogFuncSGIS_ARG_EXPAND GLsizei n, const GLfloat * points
#define glFogFuncSGIS_ARG_NAMES_TAIL , n, points
#define glFogFuncSGIS_ARG_EXPAND_TAIL , GLsizei n, const GLfloat * points
#define forward_glFogFuncSGIS(_n, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glFogFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogFuncSGIS(dst, _n, _points), NULL); \
    });
#define call_glFogFuncSGIS(packed, ret_v) do { \
    glFogFuncSGIS_PACKED *unpacked = (glFogFuncSGIS_PACKED *)packed; \
    glFogFuncSGIS_ARGS *args = (glFogFuncSGIS_ARGS *)&unpacked->args; \
    glFogFuncSGIS(args->n, args->points);; \
} while(0)
void glFogFuncSGIS(glFogFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glFogFuncSGIS(glFogFuncSGIS_PACKED *_dst glFogFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glFogFuncSGIS_PTR)(glFogFuncSGIS_ARG_EXPAND);
#endif
#ifndef glFogf_RETURN
#define glFogf_RETURN void
#define glFogf_ARG_NAMES pname, param
#define glFogf_ARG_EXPAND GLenum pname, GLfloat param
#define glFogf_ARG_NAMES_TAIL , pname, param
#define glFogf_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glFogf(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFogf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogf(dst, _pname, _param), NULL); \
    });
#define call_glFogf(packed, ret_v) do { \
    glFogf_PACKED *unpacked = (glFogf_PACKED *)packed; \
    glFogf_ARGS *args = (glFogf_ARGS *)&unpacked->args; \
    glFogf(args->pname, args->param);; \
} while(0)
void glFogf(glFogf_ARG_EXPAND);
packed_call_t *pack_glFogf(glFogf_PACKED *_dst glFogf_ARG_EXPAND_TAIL);
typedef void (*glFogf_PTR)(glFogf_ARG_EXPAND);
#endif
#ifndef glFogfv_RETURN
#define glFogfv_RETURN void
#define glFogfv_ARG_NAMES pname, params
#define glFogfv_ARG_EXPAND GLenum pname, const GLfloat * params
#define glFogfv_ARG_NAMES_TAIL , pname, params
#define glFogfv_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glFogfv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFogfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogfv(dst, _pname, _params), NULL); \
    });
#define call_glFogfv(packed, ret_v) do { \
    glFogfv_PACKED *unpacked = (glFogfv_PACKED *)packed; \
    glFogfv_ARGS *args = (glFogfv_ARGS *)&unpacked->args; \
    glFogfv(args->pname, args->params);; \
} while(0)
void glFogfv(glFogfv_ARG_EXPAND);
packed_call_t *pack_glFogfv(glFogfv_PACKED *_dst glFogfv_ARG_EXPAND_TAIL);
typedef void (*glFogfv_PTR)(glFogfv_ARG_EXPAND);
#endif
#ifndef glFogi_RETURN
#define glFogi_RETURN void
#define glFogi_ARG_NAMES pname, param
#define glFogi_ARG_EXPAND GLenum pname, GLint param
#define glFogi_ARG_NAMES_TAIL , pname, param
#define glFogi_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glFogi(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFogi_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogi(dst, _pname, _param), NULL); \
    });
#define call_glFogi(packed, ret_v) do { \
    glFogi_PACKED *unpacked = (glFogi_PACKED *)packed; \
    glFogi_ARGS *args = (glFogi_ARGS *)&unpacked->args; \
    glFogi(args->pname, args->param);; \
} while(0)
void glFogi(glFogi_ARG_EXPAND);
packed_call_t *pack_glFogi(glFogi_PACKED *_dst glFogi_ARG_EXPAND_TAIL);
typedef void (*glFogi_PTR)(glFogi_ARG_EXPAND);
#endif
#ifndef glFogiv_RETURN
#define glFogiv_RETURN void
#define glFogiv_ARG_NAMES pname, params
#define glFogiv_ARG_EXPAND GLenum pname, const GLint * params
#define glFogiv_ARG_NAMES_TAIL , pname, params
#define glFogiv_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glFogiv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFogiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogiv(dst, _pname, _params), NULL); \
    });
#define call_glFogiv(packed, ret_v) do { \
    glFogiv_PACKED *unpacked = (glFogiv_PACKED *)packed; \
    glFogiv_ARGS *args = (glFogiv_ARGS *)&unpacked->args; \
    glFogiv(args->pname, args->params);; \
} while(0)
void glFogiv(glFogiv_ARG_EXPAND);
packed_call_t *pack_glFogiv(glFogiv_PACKED *_dst glFogiv_ARG_EXPAND_TAIL);
typedef void (*glFogiv_PTR)(glFogiv_ARG_EXPAND);
#endif
#ifndef glFogxOES_RETURN
#define glFogxOES_RETURN void
#define glFogxOES_ARG_NAMES pname, param
#define glFogxOES_ARG_EXPAND GLenum pname, GLfixed param
#define glFogxOES_ARG_NAMES_TAIL , pname, param
#define glFogxOES_ARG_EXPAND_TAIL , GLenum pname, GLfixed param
#define forward_glFogxOES(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFogxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogxOES(dst, _pname, _param), NULL); \
    });
#define call_glFogxOES(packed, ret_v) do { \
    glFogxOES_PACKED *unpacked = (glFogxOES_PACKED *)packed; \
    glFogxOES_ARGS *args = (glFogxOES_ARGS *)&unpacked->args; \
    glFogxOES(args->pname, args->param);; \
} while(0)
void glFogxOES(glFogxOES_ARG_EXPAND);
packed_call_t *pack_glFogxOES(glFogxOES_PACKED *_dst glFogxOES_ARG_EXPAND_TAIL);
typedef void (*glFogxOES_PTR)(glFogxOES_ARG_EXPAND);
#endif
#ifndef glFogxvOES_RETURN
#define glFogxvOES_RETURN void
#define glFogxvOES_ARG_NAMES pname, param
#define glFogxvOES_ARG_EXPAND GLenum pname, const GLfixed * param
#define glFogxvOES_ARG_NAMES_TAIL , pname, param
#define glFogxvOES_ARG_EXPAND_TAIL , GLenum pname, const GLfixed * param
#define forward_glFogxvOES(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFogxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFogxvOES(dst, _pname, _param), NULL); \
    });
#define call_glFogxvOES(packed, ret_v) do { \
    glFogxvOES_PACKED *unpacked = (glFogxvOES_PACKED *)packed; \
    glFogxvOES_ARGS *args = (glFogxvOES_ARGS *)&unpacked->args; \
    glFogxvOES(args->pname, args->param);; \
} while(0)
void glFogxvOES(glFogxvOES_ARG_EXPAND);
packed_call_t *pack_glFogxvOES(glFogxvOES_PACKED *_dst glFogxvOES_ARG_EXPAND_TAIL);
typedef void (*glFogxvOES_PTR)(glFogxvOES_ARG_EXPAND);
#endif
#ifndef glFragmentColorMaterialSGIX_RETURN
#define glFragmentColorMaterialSGIX_RETURN void
#define glFragmentColorMaterialSGIX_ARG_NAMES face, mode
#define glFragmentColorMaterialSGIX_ARG_EXPAND GLenum face, GLenum mode
#define glFragmentColorMaterialSGIX_ARG_NAMES_TAIL , face, mode
#define glFragmentColorMaterialSGIX_ARG_EXPAND_TAIL , GLenum face, GLenum mode
#define forward_glFragmentColorMaterialSGIX(_face, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentColorMaterialSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentColorMaterialSGIX(dst, _face, _mode), NULL); \
    });
#define call_glFragmentColorMaterialSGIX(packed, ret_v) do { \
    glFragmentColorMaterialSGIX_PACKED *unpacked = (glFragmentColorMaterialSGIX_PACKED *)packed; \
    glFragmentColorMaterialSGIX_ARGS *args = (glFragmentColorMaterialSGIX_ARGS *)&unpacked->args; \
    glFragmentColorMaterialSGIX(args->face, args->mode);; \
} while(0)
void glFragmentColorMaterialSGIX(glFragmentColorMaterialSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentColorMaterialSGIX(glFragmentColorMaterialSGIX_PACKED *_dst glFragmentColorMaterialSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentColorMaterialSGIX_PTR)(glFragmentColorMaterialSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightModelfSGIX_RETURN
#define glFragmentLightModelfSGIX_RETURN void
#define glFragmentLightModelfSGIX_ARG_NAMES pname, param
#define glFragmentLightModelfSGIX_ARG_EXPAND GLenum pname, GLfloat param
#define glFragmentLightModelfSGIX_ARG_NAMES_TAIL , pname, param
#define glFragmentLightModelfSGIX_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glFragmentLightModelfSGIX(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightModelfSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightModelfSGIX(dst, _pname, _param), NULL); \
    });
#define call_glFragmentLightModelfSGIX(packed, ret_v) do { \
    glFragmentLightModelfSGIX_PACKED *unpacked = (glFragmentLightModelfSGIX_PACKED *)packed; \
    glFragmentLightModelfSGIX_ARGS *args = (glFragmentLightModelfSGIX_ARGS *)&unpacked->args; \
    glFragmentLightModelfSGIX(args->pname, args->param);; \
} while(0)
void glFragmentLightModelfSGIX(glFragmentLightModelfSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightModelfSGIX(glFragmentLightModelfSGIX_PACKED *_dst glFragmentLightModelfSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightModelfSGIX_PTR)(glFragmentLightModelfSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightModelfvSGIX_RETURN
#define glFragmentLightModelfvSGIX_RETURN void
#define glFragmentLightModelfvSGIX_ARG_NAMES pname, params
#define glFragmentLightModelfvSGIX_ARG_EXPAND GLenum pname, const GLfloat * params
#define glFragmentLightModelfvSGIX_ARG_NAMES_TAIL , pname, params
#define glFragmentLightModelfvSGIX_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glFragmentLightModelfvSGIX(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightModelfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightModelfvSGIX(dst, _pname, _params), NULL); \
    });
#define call_glFragmentLightModelfvSGIX(packed, ret_v) do { \
    glFragmentLightModelfvSGIX_PACKED *unpacked = (glFragmentLightModelfvSGIX_PACKED *)packed; \
    glFragmentLightModelfvSGIX_ARGS *args = (glFragmentLightModelfvSGIX_ARGS *)&unpacked->args; \
    glFragmentLightModelfvSGIX(args->pname, args->params);; \
} while(0)
void glFragmentLightModelfvSGIX(glFragmentLightModelfvSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightModelfvSGIX(glFragmentLightModelfvSGIX_PACKED *_dst glFragmentLightModelfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightModelfvSGIX_PTR)(glFragmentLightModelfvSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightModeliSGIX_RETURN
#define glFragmentLightModeliSGIX_RETURN void
#define glFragmentLightModeliSGIX_ARG_NAMES pname, param
#define glFragmentLightModeliSGIX_ARG_EXPAND GLenum pname, GLint param
#define glFragmentLightModeliSGIX_ARG_NAMES_TAIL , pname, param
#define glFragmentLightModeliSGIX_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glFragmentLightModeliSGIX(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightModeliSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightModeliSGIX(dst, _pname, _param), NULL); \
    });
#define call_glFragmentLightModeliSGIX(packed, ret_v) do { \
    glFragmentLightModeliSGIX_PACKED *unpacked = (glFragmentLightModeliSGIX_PACKED *)packed; \
    glFragmentLightModeliSGIX_ARGS *args = (glFragmentLightModeliSGIX_ARGS *)&unpacked->args; \
    glFragmentLightModeliSGIX(args->pname, args->param);; \
} while(0)
void glFragmentLightModeliSGIX(glFragmentLightModeliSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightModeliSGIX(glFragmentLightModeliSGIX_PACKED *_dst glFragmentLightModeliSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightModeliSGIX_PTR)(glFragmentLightModeliSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightModelivSGIX_RETURN
#define glFragmentLightModelivSGIX_RETURN void
#define glFragmentLightModelivSGIX_ARG_NAMES pname, params
#define glFragmentLightModelivSGIX_ARG_EXPAND GLenum pname, const GLint * params
#define glFragmentLightModelivSGIX_ARG_NAMES_TAIL , pname, params
#define glFragmentLightModelivSGIX_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glFragmentLightModelivSGIX(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightModelivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightModelivSGIX(dst, _pname, _params), NULL); \
    });
#define call_glFragmentLightModelivSGIX(packed, ret_v) do { \
    glFragmentLightModelivSGIX_PACKED *unpacked = (glFragmentLightModelivSGIX_PACKED *)packed; \
    glFragmentLightModelivSGIX_ARGS *args = (glFragmentLightModelivSGIX_ARGS *)&unpacked->args; \
    glFragmentLightModelivSGIX(args->pname, args->params);; \
} while(0)
void glFragmentLightModelivSGIX(glFragmentLightModelivSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightModelivSGIX(glFragmentLightModelivSGIX_PACKED *_dst glFragmentLightModelivSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightModelivSGIX_PTR)(glFragmentLightModelivSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightfSGIX_RETURN
#define glFragmentLightfSGIX_RETURN void
#define glFragmentLightfSGIX_ARG_NAMES light, pname, param
#define glFragmentLightfSGIX_ARG_EXPAND GLenum light, GLenum pname, GLfloat param
#define glFragmentLightfSGIX_ARG_NAMES_TAIL , light, pname, param
#define glFragmentLightfSGIX_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLfloat param
#define forward_glFragmentLightfSGIX(_light, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightfSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightfSGIX(dst, _light, _pname, _param), NULL); \
    });
#define call_glFragmentLightfSGIX(packed, ret_v) do { \
    glFragmentLightfSGIX_PACKED *unpacked = (glFragmentLightfSGIX_PACKED *)packed; \
    glFragmentLightfSGIX_ARGS *args = (glFragmentLightfSGIX_ARGS *)&unpacked->args; \
    glFragmentLightfSGIX(args->light, args->pname, args->param);; \
} while(0)
void glFragmentLightfSGIX(glFragmentLightfSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightfSGIX(glFragmentLightfSGIX_PACKED *_dst glFragmentLightfSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightfSGIX_PTR)(glFragmentLightfSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightfvSGIX_RETURN
#define glFragmentLightfvSGIX_RETURN void
#define glFragmentLightfvSGIX_ARG_NAMES light, pname, params
#define glFragmentLightfvSGIX_ARG_EXPAND GLenum light, GLenum pname, const GLfloat * params
#define glFragmentLightfvSGIX_ARG_NAMES_TAIL , light, pname, params
#define glFragmentLightfvSGIX_ARG_EXPAND_TAIL , GLenum light, GLenum pname, const GLfloat * params
#define forward_glFragmentLightfvSGIX(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightfvSGIX(dst, _light, _pname, _params), NULL); \
    });
#define call_glFragmentLightfvSGIX(packed, ret_v) do { \
    glFragmentLightfvSGIX_PACKED *unpacked = (glFragmentLightfvSGIX_PACKED *)packed; \
    glFragmentLightfvSGIX_ARGS *args = (glFragmentLightfvSGIX_ARGS *)&unpacked->args; \
    glFragmentLightfvSGIX(args->light, args->pname, args->params);; \
} while(0)
void glFragmentLightfvSGIX(glFragmentLightfvSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightfvSGIX(glFragmentLightfvSGIX_PACKED *_dst glFragmentLightfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightfvSGIX_PTR)(glFragmentLightfvSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightiSGIX_RETURN
#define glFragmentLightiSGIX_RETURN void
#define glFragmentLightiSGIX_ARG_NAMES light, pname, param
#define glFragmentLightiSGIX_ARG_EXPAND GLenum light, GLenum pname, GLint param
#define glFragmentLightiSGIX_ARG_NAMES_TAIL , light, pname, param
#define glFragmentLightiSGIX_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLint param
#define forward_glFragmentLightiSGIX(_light, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightiSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightiSGIX(dst, _light, _pname, _param), NULL); \
    });
#define call_glFragmentLightiSGIX(packed, ret_v) do { \
    glFragmentLightiSGIX_PACKED *unpacked = (glFragmentLightiSGIX_PACKED *)packed; \
    glFragmentLightiSGIX_ARGS *args = (glFragmentLightiSGIX_ARGS *)&unpacked->args; \
    glFragmentLightiSGIX(args->light, args->pname, args->param);; \
} while(0)
void glFragmentLightiSGIX(glFragmentLightiSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightiSGIX(glFragmentLightiSGIX_PACKED *_dst glFragmentLightiSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightiSGIX_PTR)(glFragmentLightiSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentLightivSGIX_RETURN
#define glFragmentLightivSGIX_RETURN void
#define glFragmentLightivSGIX_ARG_NAMES light, pname, params
#define glFragmentLightivSGIX_ARG_EXPAND GLenum light, GLenum pname, const GLint * params
#define glFragmentLightivSGIX_ARG_NAMES_TAIL , light, pname, params
#define glFragmentLightivSGIX_ARG_EXPAND_TAIL , GLenum light, GLenum pname, const GLint * params
#define forward_glFragmentLightivSGIX(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentLightivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentLightivSGIX(dst, _light, _pname, _params), NULL); \
    });
#define call_glFragmentLightivSGIX(packed, ret_v) do { \
    glFragmentLightivSGIX_PACKED *unpacked = (glFragmentLightivSGIX_PACKED *)packed; \
    glFragmentLightivSGIX_ARGS *args = (glFragmentLightivSGIX_ARGS *)&unpacked->args; \
    glFragmentLightivSGIX(args->light, args->pname, args->params);; \
} while(0)
void glFragmentLightivSGIX(glFragmentLightivSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentLightivSGIX(glFragmentLightivSGIX_PACKED *_dst glFragmentLightivSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentLightivSGIX_PTR)(glFragmentLightivSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentMaterialfSGIX_RETURN
#define glFragmentMaterialfSGIX_RETURN void
#define glFragmentMaterialfSGIX_ARG_NAMES face, pname, param
#define glFragmentMaterialfSGIX_ARG_EXPAND GLenum face, GLenum pname, GLfloat param
#define glFragmentMaterialfSGIX_ARG_NAMES_TAIL , face, pname, param
#define glFragmentMaterialfSGIX_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLfloat param
#define forward_glFragmentMaterialfSGIX(_face, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentMaterialfSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentMaterialfSGIX(dst, _face, _pname, _param), NULL); \
    });
#define call_glFragmentMaterialfSGIX(packed, ret_v) do { \
    glFragmentMaterialfSGIX_PACKED *unpacked = (glFragmentMaterialfSGIX_PACKED *)packed; \
    glFragmentMaterialfSGIX_ARGS *args = (glFragmentMaterialfSGIX_ARGS *)&unpacked->args; \
    glFragmentMaterialfSGIX(args->face, args->pname, args->param);; \
} while(0)
void glFragmentMaterialfSGIX(glFragmentMaterialfSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentMaterialfSGIX(glFragmentMaterialfSGIX_PACKED *_dst glFragmentMaterialfSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentMaterialfSGIX_PTR)(glFragmentMaterialfSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentMaterialfvSGIX_RETURN
#define glFragmentMaterialfvSGIX_RETURN void
#define glFragmentMaterialfvSGIX_ARG_NAMES face, pname, params
#define glFragmentMaterialfvSGIX_ARG_EXPAND GLenum face, GLenum pname, const GLfloat * params
#define glFragmentMaterialfvSGIX_ARG_NAMES_TAIL , face, pname, params
#define glFragmentMaterialfvSGIX_ARG_EXPAND_TAIL , GLenum face, GLenum pname, const GLfloat * params
#define forward_glFragmentMaterialfvSGIX(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentMaterialfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentMaterialfvSGIX(dst, _face, _pname, _params), NULL); \
    });
#define call_glFragmentMaterialfvSGIX(packed, ret_v) do { \
    glFragmentMaterialfvSGIX_PACKED *unpacked = (glFragmentMaterialfvSGIX_PACKED *)packed; \
    glFragmentMaterialfvSGIX_ARGS *args = (glFragmentMaterialfvSGIX_ARGS *)&unpacked->args; \
    glFragmentMaterialfvSGIX(args->face, args->pname, args->params);; \
} while(0)
void glFragmentMaterialfvSGIX(glFragmentMaterialfvSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentMaterialfvSGIX(glFragmentMaterialfvSGIX_PACKED *_dst glFragmentMaterialfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentMaterialfvSGIX_PTR)(glFragmentMaterialfvSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentMaterialiSGIX_RETURN
#define glFragmentMaterialiSGIX_RETURN void
#define glFragmentMaterialiSGIX_ARG_NAMES face, pname, param
#define glFragmentMaterialiSGIX_ARG_EXPAND GLenum face, GLenum pname, GLint param
#define glFragmentMaterialiSGIX_ARG_NAMES_TAIL , face, pname, param
#define glFragmentMaterialiSGIX_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLint param
#define forward_glFragmentMaterialiSGIX(_face, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentMaterialiSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentMaterialiSGIX(dst, _face, _pname, _param), NULL); \
    });
#define call_glFragmentMaterialiSGIX(packed, ret_v) do { \
    glFragmentMaterialiSGIX_PACKED *unpacked = (glFragmentMaterialiSGIX_PACKED *)packed; \
    glFragmentMaterialiSGIX_ARGS *args = (glFragmentMaterialiSGIX_ARGS *)&unpacked->args; \
    glFragmentMaterialiSGIX(args->face, args->pname, args->param);; \
} while(0)
void glFragmentMaterialiSGIX(glFragmentMaterialiSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentMaterialiSGIX(glFragmentMaterialiSGIX_PACKED *_dst glFragmentMaterialiSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentMaterialiSGIX_PTR)(glFragmentMaterialiSGIX_ARG_EXPAND);
#endif
#ifndef glFragmentMaterialivSGIX_RETURN
#define glFragmentMaterialivSGIX_RETURN void
#define glFragmentMaterialivSGIX_ARG_NAMES face, pname, params
#define glFragmentMaterialivSGIX_ARG_EXPAND GLenum face, GLenum pname, const GLint * params
#define glFragmentMaterialivSGIX_ARG_NAMES_TAIL , face, pname, params
#define glFragmentMaterialivSGIX_ARG_EXPAND_TAIL , GLenum face, GLenum pname, const GLint * params
#define forward_glFragmentMaterialivSGIX(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glFragmentMaterialivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFragmentMaterialivSGIX(dst, _face, _pname, _params), NULL); \
    });
#define call_glFragmentMaterialivSGIX(packed, ret_v) do { \
    glFragmentMaterialivSGIX_PACKED *unpacked = (glFragmentMaterialivSGIX_PACKED *)packed; \
    glFragmentMaterialivSGIX_ARGS *args = (glFragmentMaterialivSGIX_ARGS *)&unpacked->args; \
    glFragmentMaterialivSGIX(args->face, args->pname, args->params);; \
} while(0)
void glFragmentMaterialivSGIX(glFragmentMaterialivSGIX_ARG_EXPAND);
packed_call_t *pack_glFragmentMaterialivSGIX(glFragmentMaterialivSGIX_PACKED *_dst glFragmentMaterialivSGIX_ARG_EXPAND_TAIL);
typedef void (*glFragmentMaterialivSGIX_PTR)(glFragmentMaterialivSGIX_ARG_EXPAND);
#endif
#ifndef glFrameTerminatorGREMEDY_RETURN
#define glFrameTerminatorGREMEDY_RETURN void
#define glFrameTerminatorGREMEDY_ARG_NAMES 
#define glFrameTerminatorGREMEDY_ARG_EXPAND 
#define glFrameTerminatorGREMEDY_ARG_NAMES_TAIL 
#define glFrameTerminatorGREMEDY_ARG_EXPAND_TAIL 
#define forward_glFrameTerminatorGREMEDY() \
    ({ \
        void *dst = remote_dma(sizeof(glFrameTerminatorGREMEDY_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFrameTerminatorGREMEDY(dst), NULL); \
    });
#define call_glFrameTerminatorGREMEDY(packed, ret_v) do { \
    glFrameTerminatorGREMEDY();; \
} while(0)
void glFrameTerminatorGREMEDY(glFrameTerminatorGREMEDY_ARG_EXPAND);
packed_call_t *pack_glFrameTerminatorGREMEDY(glFrameTerminatorGREMEDY_PACKED *_dst glFrameTerminatorGREMEDY_ARG_EXPAND_TAIL);
typedef void (*glFrameTerminatorGREMEDY_PTR)(glFrameTerminatorGREMEDY_ARG_EXPAND);
#endif
#ifndef glFrameZoomSGIX_RETURN
#define glFrameZoomSGIX_RETURN void
#define glFrameZoomSGIX_ARG_NAMES factor
#define glFrameZoomSGIX_ARG_EXPAND GLint factor
#define glFrameZoomSGIX_ARG_NAMES_TAIL , factor
#define glFrameZoomSGIX_ARG_EXPAND_TAIL , GLint factor
#define forward_glFrameZoomSGIX(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glFrameZoomSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFrameZoomSGIX(dst, _factor), NULL); \
    });
#define call_glFrameZoomSGIX(packed, ret_v) do { \
    glFrameZoomSGIX_PACKED *unpacked = (glFrameZoomSGIX_PACKED *)packed; \
    glFrameZoomSGIX_ARGS *args = (glFrameZoomSGIX_ARGS *)&unpacked->args; \
    glFrameZoomSGIX(args->factor);; \
} while(0)
void glFrameZoomSGIX(glFrameZoomSGIX_ARG_EXPAND);
packed_call_t *pack_glFrameZoomSGIX(glFrameZoomSGIX_PACKED *_dst glFrameZoomSGIX_ARG_EXPAND_TAIL);
typedef void (*glFrameZoomSGIX_PTR)(glFrameZoomSGIX_ARG_EXPAND);
#endif
#ifndef glFramebufferDrawBufferEXT_RETURN
#define glFramebufferDrawBufferEXT_RETURN void
#define glFramebufferDrawBufferEXT_ARG_NAMES framebuffer, mode
#define glFramebufferDrawBufferEXT_ARG_EXPAND GLuint framebuffer, GLenum mode
#define glFramebufferDrawBufferEXT_ARG_NAMES_TAIL , framebuffer, mode
#define glFramebufferDrawBufferEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum mode
#define forward_glFramebufferDrawBufferEXT(_framebuffer, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferDrawBufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferDrawBufferEXT(dst, _framebuffer, _mode), NULL); \
    });
#define call_glFramebufferDrawBufferEXT(packed, ret_v) do { \
    glFramebufferDrawBufferEXT_PACKED *unpacked = (glFramebufferDrawBufferEXT_PACKED *)packed; \
    glFramebufferDrawBufferEXT_ARGS *args = (glFramebufferDrawBufferEXT_ARGS *)&unpacked->args; \
    glFramebufferDrawBufferEXT(args->framebuffer, args->mode);; \
} while(0)
void glFramebufferDrawBufferEXT(glFramebufferDrawBufferEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferDrawBufferEXT(glFramebufferDrawBufferEXT_PACKED *_dst glFramebufferDrawBufferEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferDrawBufferEXT_PTR)(glFramebufferDrawBufferEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferDrawBuffersEXT_RETURN
#define glFramebufferDrawBuffersEXT_RETURN void
#define glFramebufferDrawBuffersEXT_ARG_NAMES framebuffer, n, bufs
#define glFramebufferDrawBuffersEXT_ARG_EXPAND GLuint framebuffer, GLsizei n, const GLenum * bufs
#define glFramebufferDrawBuffersEXT_ARG_NAMES_TAIL , framebuffer, n, bufs
#define glFramebufferDrawBuffersEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLsizei n, const GLenum * bufs
#define forward_glFramebufferDrawBuffersEXT(_framebuffer, _n, _bufs) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferDrawBuffersEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferDrawBuffersEXT(dst, _framebuffer, _n, _bufs), NULL); \
    });
#define call_glFramebufferDrawBuffersEXT(packed, ret_v) do { \
    glFramebufferDrawBuffersEXT_PACKED *unpacked = (glFramebufferDrawBuffersEXT_PACKED *)packed; \
    glFramebufferDrawBuffersEXT_ARGS *args = (glFramebufferDrawBuffersEXT_ARGS *)&unpacked->args; \
    glFramebufferDrawBuffersEXT(args->framebuffer, args->n, args->bufs);; \
} while(0)
void glFramebufferDrawBuffersEXT(glFramebufferDrawBuffersEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferDrawBuffersEXT(glFramebufferDrawBuffersEXT_PACKED *_dst glFramebufferDrawBuffersEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferDrawBuffersEXT_PTR)(glFramebufferDrawBuffersEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferParameteri_RETURN
#define glFramebufferParameteri_RETURN void
#define glFramebufferParameteri_ARG_NAMES target, pname, param
#define glFramebufferParameteri_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glFramebufferParameteri_ARG_NAMES_TAIL , target, pname, param
#define glFramebufferParameteri_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint param
#define forward_glFramebufferParameteri(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferParameteri_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferParameteri(dst, _target, _pname, _param), NULL); \
    });
#define call_glFramebufferParameteri(packed, ret_v) do { \
    glFramebufferParameteri_PACKED *unpacked = (glFramebufferParameteri_PACKED *)packed; \
    glFramebufferParameteri_ARGS *args = (glFramebufferParameteri_ARGS *)&unpacked->args; \
    glFramebufferParameteri(args->target, args->pname, args->param);; \
} while(0)
void glFramebufferParameteri(glFramebufferParameteri_ARG_EXPAND);
packed_call_t *pack_glFramebufferParameteri(glFramebufferParameteri_PACKED *_dst glFramebufferParameteri_ARG_EXPAND_TAIL);
typedef void (*glFramebufferParameteri_PTR)(glFramebufferParameteri_ARG_EXPAND);
#endif
#ifndef glFramebufferReadBufferEXT_RETURN
#define glFramebufferReadBufferEXT_RETURN void
#define glFramebufferReadBufferEXT_ARG_NAMES framebuffer, mode
#define glFramebufferReadBufferEXT_ARG_EXPAND GLuint framebuffer, GLenum mode
#define glFramebufferReadBufferEXT_ARG_NAMES_TAIL , framebuffer, mode
#define glFramebufferReadBufferEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum mode
#define forward_glFramebufferReadBufferEXT(_framebuffer, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferReadBufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferReadBufferEXT(dst, _framebuffer, _mode), NULL); \
    });
#define call_glFramebufferReadBufferEXT(packed, ret_v) do { \
    glFramebufferReadBufferEXT_PACKED *unpacked = (glFramebufferReadBufferEXT_PACKED *)packed; \
    glFramebufferReadBufferEXT_ARGS *args = (glFramebufferReadBufferEXT_ARGS *)&unpacked->args; \
    glFramebufferReadBufferEXT(args->framebuffer, args->mode);; \
} while(0)
void glFramebufferReadBufferEXT(glFramebufferReadBufferEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferReadBufferEXT(glFramebufferReadBufferEXT_PACKED *_dst glFramebufferReadBufferEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferReadBufferEXT_PTR)(glFramebufferReadBufferEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferRenderbuffer_RETURN
#define glFramebufferRenderbuffer_RETURN void
#define glFramebufferRenderbuffer_ARG_NAMES target, attachment, renderbuffertarget, renderbuffer
#define glFramebufferRenderbuffer_ARG_EXPAND GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define glFramebufferRenderbuffer_ARG_NAMES_TAIL , target, attachment, renderbuffertarget, renderbuffer
#define glFramebufferRenderbuffer_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define forward_glFramebufferRenderbuffer(_target, _attachment, _renderbuffertarget, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferRenderbuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferRenderbuffer(dst, _target, _attachment, _renderbuffertarget, _renderbuffer), NULL); \
    });
#define call_glFramebufferRenderbuffer(packed, ret_v) do { \
    glFramebufferRenderbuffer_PACKED *unpacked = (glFramebufferRenderbuffer_PACKED *)packed; \
    glFramebufferRenderbuffer_ARGS *args = (glFramebufferRenderbuffer_ARGS *)&unpacked->args; \
    glFramebufferRenderbuffer(args->target, args->attachment, args->renderbuffertarget, args->renderbuffer);; \
} while(0)
void glFramebufferRenderbuffer(glFramebufferRenderbuffer_ARG_EXPAND);
packed_call_t *pack_glFramebufferRenderbuffer(glFramebufferRenderbuffer_PACKED *_dst glFramebufferRenderbuffer_ARG_EXPAND_TAIL);
typedef void (*glFramebufferRenderbuffer_PTR)(glFramebufferRenderbuffer_ARG_EXPAND);
#endif
#ifndef glFramebufferRenderbufferEXT_RETURN
#define glFramebufferRenderbufferEXT_RETURN void
#define glFramebufferRenderbufferEXT_ARG_NAMES target, attachment, renderbuffertarget, renderbuffer
#define glFramebufferRenderbufferEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define glFramebufferRenderbufferEXT_ARG_NAMES_TAIL , target, attachment, renderbuffertarget, renderbuffer
#define glFramebufferRenderbufferEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define forward_glFramebufferRenderbufferEXT(_target, _attachment, _renderbuffertarget, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferRenderbufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferRenderbufferEXT(dst, _target, _attachment, _renderbuffertarget, _renderbuffer), NULL); \
    });
#define call_glFramebufferRenderbufferEXT(packed, ret_v) do { \
    glFramebufferRenderbufferEXT_PACKED *unpacked = (glFramebufferRenderbufferEXT_PACKED *)packed; \
    glFramebufferRenderbufferEXT_ARGS *args = (glFramebufferRenderbufferEXT_ARGS *)&unpacked->args; \
    glFramebufferRenderbufferEXT(args->target, args->attachment, args->renderbuffertarget, args->renderbuffer);; \
} while(0)
void glFramebufferRenderbufferEXT(glFramebufferRenderbufferEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferRenderbufferEXT(glFramebufferRenderbufferEXT_PACKED *_dst glFramebufferRenderbufferEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferRenderbufferEXT_PTR)(glFramebufferRenderbufferEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferTexture_RETURN
#define glFramebufferTexture_RETURN void
#define glFramebufferTexture_ARG_NAMES target, attachment, texture, level
#define glFramebufferTexture_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level
#define glFramebufferTexture_ARG_NAMES_TAIL , target, attachment, texture, level
#define glFramebufferTexture_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level
#define forward_glFramebufferTexture(_target, _attachment, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTexture_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTexture(dst, _target, _attachment, _texture, _level), NULL); \
    });
#define call_glFramebufferTexture(packed, ret_v) do { \
    glFramebufferTexture_PACKED *unpacked = (glFramebufferTexture_PACKED *)packed; \
    glFramebufferTexture_ARGS *args = (glFramebufferTexture_ARGS *)&unpacked->args; \
    glFramebufferTexture(args->target, args->attachment, args->texture, args->level);; \
} while(0)
void glFramebufferTexture(glFramebufferTexture_ARG_EXPAND);
packed_call_t *pack_glFramebufferTexture(glFramebufferTexture_PACKED *_dst glFramebufferTexture_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTexture_PTR)(glFramebufferTexture_ARG_EXPAND);
#endif
#ifndef glFramebufferTexture1D_RETURN
#define glFramebufferTexture1D_RETURN void
#define glFramebufferTexture1D_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture1D_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture1D_ARG_NAMES_TAIL , target, attachment, textarget, texture, level
#define glFramebufferTexture1D_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define forward_glFramebufferTexture1D(_target, _attachment, _textarget, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTexture1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTexture1D(dst, _target, _attachment, _textarget, _texture, _level), NULL); \
    });
#define call_glFramebufferTexture1D(packed, ret_v) do { \
    glFramebufferTexture1D_PACKED *unpacked = (glFramebufferTexture1D_PACKED *)packed; \
    glFramebufferTexture1D_ARGS *args = (glFramebufferTexture1D_ARGS *)&unpacked->args; \
    glFramebufferTexture1D(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture1D(glFramebufferTexture1D_ARG_EXPAND);
packed_call_t *pack_glFramebufferTexture1D(glFramebufferTexture1D_PACKED *_dst glFramebufferTexture1D_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTexture1D_PTR)(glFramebufferTexture1D_ARG_EXPAND);
#endif
#ifndef glFramebufferTexture1DEXT_RETURN
#define glFramebufferTexture1DEXT_RETURN void
#define glFramebufferTexture1DEXT_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture1DEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture1DEXT_ARG_NAMES_TAIL , target, attachment, textarget, texture, level
#define glFramebufferTexture1DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define forward_glFramebufferTexture1DEXT(_target, _attachment, _textarget, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTexture1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTexture1DEXT(dst, _target, _attachment, _textarget, _texture, _level), NULL); \
    });
#define call_glFramebufferTexture1DEXT(packed, ret_v) do { \
    glFramebufferTexture1DEXT_PACKED *unpacked = (glFramebufferTexture1DEXT_PACKED *)packed; \
    glFramebufferTexture1DEXT_ARGS *args = (glFramebufferTexture1DEXT_ARGS *)&unpacked->args; \
    glFramebufferTexture1DEXT(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture1DEXT(glFramebufferTexture1DEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferTexture1DEXT(glFramebufferTexture1DEXT_PACKED *_dst glFramebufferTexture1DEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTexture1DEXT_PTR)(glFramebufferTexture1DEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferTexture2D_RETURN
#define glFramebufferTexture2D_RETURN void
#define glFramebufferTexture2D_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture2D_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture2D_ARG_NAMES_TAIL , target, attachment, textarget, texture, level
#define glFramebufferTexture2D_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define forward_glFramebufferTexture2D(_target, _attachment, _textarget, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTexture2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTexture2D(dst, _target, _attachment, _textarget, _texture, _level), NULL); \
    });
#define call_glFramebufferTexture2D(packed, ret_v) do { \
    glFramebufferTexture2D_PACKED *unpacked = (glFramebufferTexture2D_PACKED *)packed; \
    glFramebufferTexture2D_ARGS *args = (glFramebufferTexture2D_ARGS *)&unpacked->args; \
    glFramebufferTexture2D(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture2D(glFramebufferTexture2D_ARG_EXPAND);
packed_call_t *pack_glFramebufferTexture2D(glFramebufferTexture2D_PACKED *_dst glFramebufferTexture2D_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTexture2D_PTR)(glFramebufferTexture2D_ARG_EXPAND);
#endif
#ifndef glFramebufferTexture2DEXT_RETURN
#define glFramebufferTexture2DEXT_RETURN void
#define glFramebufferTexture2DEXT_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture2DEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture2DEXT_ARG_NAMES_TAIL , target, attachment, textarget, texture, level
#define glFramebufferTexture2DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define forward_glFramebufferTexture2DEXT(_target, _attachment, _textarget, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTexture2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTexture2DEXT(dst, _target, _attachment, _textarget, _texture, _level), NULL); \
    });
#define call_glFramebufferTexture2DEXT(packed, ret_v) do { \
    glFramebufferTexture2DEXT_PACKED *unpacked = (glFramebufferTexture2DEXT_PACKED *)packed; \
    glFramebufferTexture2DEXT_ARGS *args = (glFramebufferTexture2DEXT_ARGS *)&unpacked->args; \
    glFramebufferTexture2DEXT(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture2DEXT(glFramebufferTexture2DEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferTexture2DEXT(glFramebufferTexture2DEXT_PACKED *_dst glFramebufferTexture2DEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTexture2DEXT_PTR)(glFramebufferTexture2DEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferTexture3D_RETURN
#define glFramebufferTexture3D_RETURN void
#define glFramebufferTexture3D_ARG_NAMES target, attachment, textarget, texture, level, zoffset
#define glFramebufferTexture3D_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define glFramebufferTexture3D_ARG_NAMES_TAIL , target, attachment, textarget, texture, level, zoffset
#define glFramebufferTexture3D_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define forward_glFramebufferTexture3D(_target, _attachment, _textarget, _texture, _level, _zoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTexture3D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTexture3D(dst, _target, _attachment, _textarget, _texture, _level, _zoffset), NULL); \
    });
#define call_glFramebufferTexture3D(packed, ret_v) do { \
    glFramebufferTexture3D_PACKED *unpacked = (glFramebufferTexture3D_PACKED *)packed; \
    glFramebufferTexture3D_ARGS *args = (glFramebufferTexture3D_ARGS *)&unpacked->args; \
    glFramebufferTexture3D(args->target, args->attachment, args->textarget, args->texture, args->level, args->zoffset);; \
} while(0)
void glFramebufferTexture3D(glFramebufferTexture3D_ARG_EXPAND);
packed_call_t *pack_glFramebufferTexture3D(glFramebufferTexture3D_PACKED *_dst glFramebufferTexture3D_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTexture3D_PTR)(glFramebufferTexture3D_ARG_EXPAND);
#endif
#ifndef glFramebufferTexture3DEXT_RETURN
#define glFramebufferTexture3DEXT_RETURN void
#define glFramebufferTexture3DEXT_ARG_NAMES target, attachment, textarget, texture, level, zoffset
#define glFramebufferTexture3DEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define glFramebufferTexture3DEXT_ARG_NAMES_TAIL , target, attachment, textarget, texture, level, zoffset
#define glFramebufferTexture3DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define forward_glFramebufferTexture3DEXT(_target, _attachment, _textarget, _texture, _level, _zoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTexture3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTexture3DEXT(dst, _target, _attachment, _textarget, _texture, _level, _zoffset), NULL); \
    });
#define call_glFramebufferTexture3DEXT(packed, ret_v) do { \
    glFramebufferTexture3DEXT_PACKED *unpacked = (glFramebufferTexture3DEXT_PACKED *)packed; \
    glFramebufferTexture3DEXT_ARGS *args = (glFramebufferTexture3DEXT_ARGS *)&unpacked->args; \
    glFramebufferTexture3DEXT(args->target, args->attachment, args->textarget, args->texture, args->level, args->zoffset);; \
} while(0)
void glFramebufferTexture3DEXT(glFramebufferTexture3DEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferTexture3DEXT(glFramebufferTexture3DEXT_PACKED *_dst glFramebufferTexture3DEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTexture3DEXT_PTR)(glFramebufferTexture3DEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferTextureARB_RETURN
#define glFramebufferTextureARB_RETURN void
#define glFramebufferTextureARB_ARG_NAMES target, attachment, texture, level
#define glFramebufferTextureARB_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level
#define glFramebufferTextureARB_ARG_NAMES_TAIL , target, attachment, texture, level
#define glFramebufferTextureARB_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level
#define forward_glFramebufferTextureARB(_target, _attachment, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTextureARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTextureARB(dst, _target, _attachment, _texture, _level), NULL); \
    });
#define call_glFramebufferTextureARB(packed, ret_v) do { \
    glFramebufferTextureARB_PACKED *unpacked = (glFramebufferTextureARB_PACKED *)packed; \
    glFramebufferTextureARB_ARGS *args = (glFramebufferTextureARB_ARGS *)&unpacked->args; \
    glFramebufferTextureARB(args->target, args->attachment, args->texture, args->level);; \
} while(0)
void glFramebufferTextureARB(glFramebufferTextureARB_ARG_EXPAND);
packed_call_t *pack_glFramebufferTextureARB(glFramebufferTextureARB_PACKED *_dst glFramebufferTextureARB_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTextureARB_PTR)(glFramebufferTextureARB_ARG_EXPAND);
#endif
#ifndef glFramebufferTextureEXT_RETURN
#define glFramebufferTextureEXT_RETURN void
#define glFramebufferTextureEXT_ARG_NAMES target, attachment, texture, level
#define glFramebufferTextureEXT_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level
#define glFramebufferTextureEXT_ARG_NAMES_TAIL , target, attachment, texture, level
#define glFramebufferTextureEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level
#define forward_glFramebufferTextureEXT(_target, _attachment, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTextureEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTextureEXT(dst, _target, _attachment, _texture, _level), NULL); \
    });
#define call_glFramebufferTextureEXT(packed, ret_v) do { \
    glFramebufferTextureEXT_PACKED *unpacked = (glFramebufferTextureEXT_PACKED *)packed; \
    glFramebufferTextureEXT_ARGS *args = (glFramebufferTextureEXT_ARGS *)&unpacked->args; \
    glFramebufferTextureEXT(args->target, args->attachment, args->texture, args->level);; \
} while(0)
void glFramebufferTextureEXT(glFramebufferTextureEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferTextureEXT(glFramebufferTextureEXT_PACKED *_dst glFramebufferTextureEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTextureEXT_PTR)(glFramebufferTextureEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferTextureFaceARB_RETURN
#define glFramebufferTextureFaceARB_RETURN void
#define glFramebufferTextureFaceARB_ARG_NAMES target, attachment, texture, level, face
#define glFramebufferTextureFaceARB_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face
#define glFramebufferTextureFaceARB_ARG_NAMES_TAIL , target, attachment, texture, level, face
#define glFramebufferTextureFaceARB_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face
#define forward_glFramebufferTextureFaceARB(_target, _attachment, _texture, _level, _face) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTextureFaceARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTextureFaceARB(dst, _target, _attachment, _texture, _level, _face), NULL); \
    });
#define call_glFramebufferTextureFaceARB(packed, ret_v) do { \
    glFramebufferTextureFaceARB_PACKED *unpacked = (glFramebufferTextureFaceARB_PACKED *)packed; \
    glFramebufferTextureFaceARB_ARGS *args = (glFramebufferTextureFaceARB_ARGS *)&unpacked->args; \
    glFramebufferTextureFaceARB(args->target, args->attachment, args->texture, args->level, args->face);; \
} while(0)
void glFramebufferTextureFaceARB(glFramebufferTextureFaceARB_ARG_EXPAND);
packed_call_t *pack_glFramebufferTextureFaceARB(glFramebufferTextureFaceARB_PACKED *_dst glFramebufferTextureFaceARB_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTextureFaceARB_PTR)(glFramebufferTextureFaceARB_ARG_EXPAND);
#endif
#ifndef glFramebufferTextureFaceEXT_RETURN
#define glFramebufferTextureFaceEXT_RETURN void
#define glFramebufferTextureFaceEXT_ARG_NAMES target, attachment, texture, level, face
#define glFramebufferTextureFaceEXT_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face
#define glFramebufferTextureFaceEXT_ARG_NAMES_TAIL , target, attachment, texture, level, face
#define glFramebufferTextureFaceEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face
#define forward_glFramebufferTextureFaceEXT(_target, _attachment, _texture, _level, _face) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTextureFaceEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTextureFaceEXT(dst, _target, _attachment, _texture, _level, _face), NULL); \
    });
#define call_glFramebufferTextureFaceEXT(packed, ret_v) do { \
    glFramebufferTextureFaceEXT_PACKED *unpacked = (glFramebufferTextureFaceEXT_PACKED *)packed; \
    glFramebufferTextureFaceEXT_ARGS *args = (glFramebufferTextureFaceEXT_ARGS *)&unpacked->args; \
    glFramebufferTextureFaceEXT(args->target, args->attachment, args->texture, args->level, args->face);; \
} while(0)
void glFramebufferTextureFaceEXT(glFramebufferTextureFaceEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferTextureFaceEXT(glFramebufferTextureFaceEXT_PACKED *_dst glFramebufferTextureFaceEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTextureFaceEXT_PTR)(glFramebufferTextureFaceEXT_ARG_EXPAND);
#endif
#ifndef glFramebufferTextureLayer_RETURN
#define glFramebufferTextureLayer_RETURN void
#define glFramebufferTextureLayer_ARG_NAMES target, attachment, texture, level, layer
#define glFramebufferTextureLayer_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glFramebufferTextureLayer_ARG_NAMES_TAIL , target, attachment, texture, level, layer
#define glFramebufferTextureLayer_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define forward_glFramebufferTextureLayer(_target, _attachment, _texture, _level, _layer) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTextureLayer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTextureLayer(dst, _target, _attachment, _texture, _level, _layer), NULL); \
    });
#define call_glFramebufferTextureLayer(packed, ret_v) do { \
    glFramebufferTextureLayer_PACKED *unpacked = (glFramebufferTextureLayer_PACKED *)packed; \
    glFramebufferTextureLayer_ARGS *args = (glFramebufferTextureLayer_ARGS *)&unpacked->args; \
    glFramebufferTextureLayer(args->target, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glFramebufferTextureLayer(glFramebufferTextureLayer_ARG_EXPAND);
packed_call_t *pack_glFramebufferTextureLayer(glFramebufferTextureLayer_PACKED *_dst glFramebufferTextureLayer_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTextureLayer_PTR)(glFramebufferTextureLayer_ARG_EXPAND);
#endif
#ifndef glFramebufferTextureLayerARB_RETURN
#define glFramebufferTextureLayerARB_RETURN void
#define glFramebufferTextureLayerARB_ARG_NAMES target, attachment, texture, level, layer
#define glFramebufferTextureLayerARB_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glFramebufferTextureLayerARB_ARG_NAMES_TAIL , target, attachment, texture, level, layer
#define glFramebufferTextureLayerARB_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define forward_glFramebufferTextureLayerARB(_target, _attachment, _texture, _level, _layer) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTextureLayerARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTextureLayerARB(dst, _target, _attachment, _texture, _level, _layer), NULL); \
    });
#define call_glFramebufferTextureLayerARB(packed, ret_v) do { \
    glFramebufferTextureLayerARB_PACKED *unpacked = (glFramebufferTextureLayerARB_PACKED *)packed; \
    glFramebufferTextureLayerARB_ARGS *args = (glFramebufferTextureLayerARB_ARGS *)&unpacked->args; \
    glFramebufferTextureLayerARB(args->target, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glFramebufferTextureLayerARB(glFramebufferTextureLayerARB_ARG_EXPAND);
packed_call_t *pack_glFramebufferTextureLayerARB(glFramebufferTextureLayerARB_PACKED *_dst glFramebufferTextureLayerARB_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTextureLayerARB_PTR)(glFramebufferTextureLayerARB_ARG_EXPAND);
#endif
#ifndef glFramebufferTextureLayerEXT_RETURN
#define glFramebufferTextureLayerEXT_RETURN void
#define glFramebufferTextureLayerEXT_ARG_NAMES target, attachment, texture, level, layer
#define glFramebufferTextureLayerEXT_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glFramebufferTextureLayerEXT_ARG_NAMES_TAIL , target, attachment, texture, level, layer
#define glFramebufferTextureLayerEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define forward_glFramebufferTextureLayerEXT(_target, _attachment, _texture, _level, _layer) \
    ({ \
        void *dst = remote_dma(sizeof(glFramebufferTextureLayerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFramebufferTextureLayerEXT(dst, _target, _attachment, _texture, _level, _layer), NULL); \
    });
#define call_glFramebufferTextureLayerEXT(packed, ret_v) do { \
    glFramebufferTextureLayerEXT_PACKED *unpacked = (glFramebufferTextureLayerEXT_PACKED *)packed; \
    glFramebufferTextureLayerEXT_ARGS *args = (glFramebufferTextureLayerEXT_ARGS *)&unpacked->args; \
    glFramebufferTextureLayerEXT(args->target, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glFramebufferTextureLayerEXT(glFramebufferTextureLayerEXT_ARG_EXPAND);
packed_call_t *pack_glFramebufferTextureLayerEXT(glFramebufferTextureLayerEXT_PACKED *_dst glFramebufferTextureLayerEXT_ARG_EXPAND_TAIL);
typedef void (*glFramebufferTextureLayerEXT_PTR)(glFramebufferTextureLayerEXT_ARG_EXPAND);
#endif
#ifndef glFreeObjectBufferATI_RETURN
#define glFreeObjectBufferATI_RETURN void
#define glFreeObjectBufferATI_ARG_NAMES buffer
#define glFreeObjectBufferATI_ARG_EXPAND GLuint buffer
#define glFreeObjectBufferATI_ARG_NAMES_TAIL , buffer
#define glFreeObjectBufferATI_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glFreeObjectBufferATI(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glFreeObjectBufferATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFreeObjectBufferATI(dst, _buffer), NULL); \
    });
#define call_glFreeObjectBufferATI(packed, ret_v) do { \
    glFreeObjectBufferATI_PACKED *unpacked = (glFreeObjectBufferATI_PACKED *)packed; \
    glFreeObjectBufferATI_ARGS *args = (glFreeObjectBufferATI_ARGS *)&unpacked->args; \
    glFreeObjectBufferATI(args->buffer);; \
} while(0)
void glFreeObjectBufferATI(glFreeObjectBufferATI_ARG_EXPAND);
packed_call_t *pack_glFreeObjectBufferATI(glFreeObjectBufferATI_PACKED *_dst glFreeObjectBufferATI_ARG_EXPAND_TAIL);
typedef void (*glFreeObjectBufferATI_PTR)(glFreeObjectBufferATI_ARG_EXPAND);
#endif
#ifndef glFrontFace_RETURN
#define glFrontFace_RETURN void
#define glFrontFace_ARG_NAMES mode
#define glFrontFace_ARG_EXPAND GLenum mode
#define glFrontFace_ARG_NAMES_TAIL , mode
#define glFrontFace_ARG_EXPAND_TAIL , GLenum mode
#define forward_glFrontFace(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glFrontFace_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFrontFace(dst, _mode), NULL); \
    });
#define call_glFrontFace(packed, ret_v) do { \
    glFrontFace_PACKED *unpacked = (glFrontFace_PACKED *)packed; \
    glFrontFace_ARGS *args = (glFrontFace_ARGS *)&unpacked->args; \
    glFrontFace(args->mode);; \
} while(0)
void glFrontFace(glFrontFace_ARG_EXPAND);
packed_call_t *pack_glFrontFace(glFrontFace_PACKED *_dst glFrontFace_ARG_EXPAND_TAIL);
typedef void (*glFrontFace_PTR)(glFrontFace_ARG_EXPAND);
#endif
#ifndef glFrustum_RETURN
#define glFrustum_RETURN void
#define glFrustum_ARG_NAMES left, right, bottom, top, zNear, zFar
#define glFrustum_ARG_EXPAND GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glFrustum_ARG_NAMES_TAIL , left, right, bottom, top, zNear, zFar
#define glFrustum_ARG_EXPAND_TAIL , GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define forward_glFrustum(_left, _right, _bottom, _top, _zNear, _zFar) \
    ({ \
        void *dst = remote_dma(sizeof(glFrustum_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFrustum(dst, _left, _right, _bottom, _top, _zNear, _zFar), NULL); \
    });
#define call_glFrustum(packed, ret_v) do { \
    glFrustum_PACKED *unpacked = (glFrustum_PACKED *)packed; \
    glFrustum_ARGS *args = (glFrustum_ARGS *)&unpacked->args; \
    glFrustum(args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glFrustum(glFrustum_ARG_EXPAND);
packed_call_t *pack_glFrustum(glFrustum_PACKED *_dst glFrustum_ARG_EXPAND_TAIL);
typedef void (*glFrustum_PTR)(glFrustum_ARG_EXPAND);
#endif
#ifndef glFrustumfOES_RETURN
#define glFrustumfOES_RETURN void
#define glFrustumfOES_ARG_NAMES l, r, b, t, n, f
#define glFrustumfOES_ARG_EXPAND GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f
#define glFrustumfOES_ARG_NAMES_TAIL , l, r, b, t, n, f
#define glFrustumfOES_ARG_EXPAND_TAIL , GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f
#define forward_glFrustumfOES(_l, _r, _b, _t, _n, _f) \
    ({ \
        void *dst = remote_dma(sizeof(glFrustumfOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFrustumfOES(dst, _l, _r, _b, _t, _n, _f), NULL); \
    });
#define call_glFrustumfOES(packed, ret_v) do { \
    glFrustumfOES_PACKED *unpacked = (glFrustumfOES_PACKED *)packed; \
    glFrustumfOES_ARGS *args = (glFrustumfOES_ARGS *)&unpacked->args; \
    glFrustumfOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glFrustumfOES(glFrustumfOES_ARG_EXPAND);
packed_call_t *pack_glFrustumfOES(glFrustumfOES_PACKED *_dst glFrustumfOES_ARG_EXPAND_TAIL);
typedef void (*glFrustumfOES_PTR)(glFrustumfOES_ARG_EXPAND);
#endif
#ifndef glFrustumxOES_RETURN
#define glFrustumxOES_RETURN void
#define glFrustumxOES_ARG_NAMES l, r, b, t, n, f
#define glFrustumxOES_ARG_EXPAND GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f
#define glFrustumxOES_ARG_NAMES_TAIL , l, r, b, t, n, f
#define glFrustumxOES_ARG_EXPAND_TAIL , GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f
#define forward_glFrustumxOES(_l, _r, _b, _t, _n, _f) \
    ({ \
        void *dst = remote_dma(sizeof(glFrustumxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glFrustumxOES(dst, _l, _r, _b, _t, _n, _f), NULL); \
    });
#define call_glFrustumxOES(packed, ret_v) do { \
    glFrustumxOES_PACKED *unpacked = (glFrustumxOES_PACKED *)packed; \
    glFrustumxOES_ARGS *args = (glFrustumxOES_ARGS *)&unpacked->args; \
    glFrustumxOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glFrustumxOES(glFrustumxOES_ARG_EXPAND);
packed_call_t *pack_glFrustumxOES(glFrustumxOES_PACKED *_dst glFrustumxOES_ARG_EXPAND_TAIL);
typedef void (*glFrustumxOES_PTR)(glFrustumxOES_ARG_EXPAND);
#endif
#ifndef glGenAsyncMarkersSGIX_RETURN
#define glGenAsyncMarkersSGIX_RETURN GLuint
#define glGenAsyncMarkersSGIX_ARG_NAMES range
#define glGenAsyncMarkersSGIX_ARG_EXPAND GLsizei range
#define glGenAsyncMarkersSGIX_ARG_NAMES_TAIL , range
#define glGenAsyncMarkersSGIX_ARG_EXPAND_TAIL , GLsizei range
#define forward_glGenAsyncMarkersSGIX(_range) \
    ({ \
        void *dst = remote_dma(sizeof(glGenAsyncMarkersSGIX_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGenAsyncMarkersSGIX(dst, _range), &ret); \
        ret; \
    });
#define call_glGenAsyncMarkersSGIX(packed, ret_v) do { \
    glGenAsyncMarkersSGIX_PACKED *unpacked = (glGenAsyncMarkersSGIX_PACKED *)packed; \
    glGenAsyncMarkersSGIX_ARGS *args = (glGenAsyncMarkersSGIX_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenAsyncMarkersSGIX(args->range);; \
    } else { \
        glGenAsyncMarkersSGIX(args->range);; \
    } \
} while(0)
GLuint glGenAsyncMarkersSGIX(glGenAsyncMarkersSGIX_ARG_EXPAND);
packed_call_t *pack_glGenAsyncMarkersSGIX(glGenAsyncMarkersSGIX_PACKED *_dst glGenAsyncMarkersSGIX_ARG_EXPAND_TAIL);
typedef GLuint (*glGenAsyncMarkersSGIX_PTR)(glGenAsyncMarkersSGIX_ARG_EXPAND);
#endif
#ifndef glGenBuffers_RETURN
#define glGenBuffers_RETURN void
#define glGenBuffers_ARG_NAMES n, buffers
#define glGenBuffers_ARG_EXPAND GLsizei n, GLuint * buffers
#define glGenBuffers_ARG_NAMES_TAIL , n, buffers
#define glGenBuffers_ARG_EXPAND_TAIL , GLsizei n, GLuint * buffers
#define forward_glGenBuffers(_n, _buffers) \
    ({ \
        void *dst = remote_dma(sizeof(glGenBuffers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenBuffers(dst, _n, _buffers), NULL); \
    });
#define call_glGenBuffers(packed, ret_v) do { \
    glGenBuffers_PACKED *unpacked = (glGenBuffers_PACKED *)packed; \
    glGenBuffers_ARGS *args = (glGenBuffers_ARGS *)&unpacked->args; \
    glGenBuffers(args->n, args->buffers);; \
} while(0)
void glGenBuffers(glGenBuffers_ARG_EXPAND);
packed_call_t *pack_glGenBuffers(glGenBuffers_PACKED *_dst glGenBuffers_ARG_EXPAND_TAIL);
typedef void (*glGenBuffers_PTR)(glGenBuffers_ARG_EXPAND);
#endif
#ifndef glGenBuffersARB_RETURN
#define glGenBuffersARB_RETURN void
#define glGenBuffersARB_ARG_NAMES n, buffers
#define glGenBuffersARB_ARG_EXPAND GLsizei n, GLuint * buffers
#define glGenBuffersARB_ARG_NAMES_TAIL , n, buffers
#define glGenBuffersARB_ARG_EXPAND_TAIL , GLsizei n, GLuint * buffers
#define forward_glGenBuffersARB(_n, _buffers) \
    ({ \
        void *dst = remote_dma(sizeof(glGenBuffersARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenBuffersARB(dst, _n, _buffers), NULL); \
    });
#define call_glGenBuffersARB(packed, ret_v) do { \
    glGenBuffersARB_PACKED *unpacked = (glGenBuffersARB_PACKED *)packed; \
    glGenBuffersARB_ARGS *args = (glGenBuffersARB_ARGS *)&unpacked->args; \
    glGenBuffersARB(args->n, args->buffers);; \
} while(0)
void glGenBuffersARB(glGenBuffersARB_ARG_EXPAND);
packed_call_t *pack_glGenBuffersARB(glGenBuffersARB_PACKED *_dst glGenBuffersARB_ARG_EXPAND_TAIL);
typedef void (*glGenBuffersARB_PTR)(glGenBuffersARB_ARG_EXPAND);
#endif
#ifndef glGenFencesAPPLE_RETURN
#define glGenFencesAPPLE_RETURN void
#define glGenFencesAPPLE_ARG_NAMES n, fences
#define glGenFencesAPPLE_ARG_EXPAND GLsizei n, GLuint * fences
#define glGenFencesAPPLE_ARG_NAMES_TAIL , n, fences
#define glGenFencesAPPLE_ARG_EXPAND_TAIL , GLsizei n, GLuint * fences
#define forward_glGenFencesAPPLE(_n, _fences) \
    ({ \
        void *dst = remote_dma(sizeof(glGenFencesAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenFencesAPPLE(dst, _n, _fences), NULL); \
    });
#define call_glGenFencesAPPLE(packed, ret_v) do { \
    glGenFencesAPPLE_PACKED *unpacked = (glGenFencesAPPLE_PACKED *)packed; \
    glGenFencesAPPLE_ARGS *args = (glGenFencesAPPLE_ARGS *)&unpacked->args; \
    glGenFencesAPPLE(args->n, args->fences);; \
} while(0)
void glGenFencesAPPLE(glGenFencesAPPLE_ARG_EXPAND);
packed_call_t *pack_glGenFencesAPPLE(glGenFencesAPPLE_PACKED *_dst glGenFencesAPPLE_ARG_EXPAND_TAIL);
typedef void (*glGenFencesAPPLE_PTR)(glGenFencesAPPLE_ARG_EXPAND);
#endif
#ifndef glGenFencesNV_RETURN
#define glGenFencesNV_RETURN void
#define glGenFencesNV_ARG_NAMES n, fences
#define glGenFencesNV_ARG_EXPAND GLsizei n, GLuint * fences
#define glGenFencesNV_ARG_NAMES_TAIL , n, fences
#define glGenFencesNV_ARG_EXPAND_TAIL , GLsizei n, GLuint * fences
#define forward_glGenFencesNV(_n, _fences) \
    ({ \
        void *dst = remote_dma(sizeof(glGenFencesNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenFencesNV(dst, _n, _fences), NULL); \
    });
#define call_glGenFencesNV(packed, ret_v) do { \
    glGenFencesNV_PACKED *unpacked = (glGenFencesNV_PACKED *)packed; \
    glGenFencesNV_ARGS *args = (glGenFencesNV_ARGS *)&unpacked->args; \
    glGenFencesNV(args->n, args->fences);; \
} while(0)
void glGenFencesNV(glGenFencesNV_ARG_EXPAND);
packed_call_t *pack_glGenFencesNV(glGenFencesNV_PACKED *_dst glGenFencesNV_ARG_EXPAND_TAIL);
typedef void (*glGenFencesNV_PTR)(glGenFencesNV_ARG_EXPAND);
#endif
#ifndef glGenFragmentShadersATI_RETURN
#define glGenFragmentShadersATI_RETURN GLuint
#define glGenFragmentShadersATI_ARG_NAMES range
#define glGenFragmentShadersATI_ARG_EXPAND GLuint range
#define glGenFragmentShadersATI_ARG_NAMES_TAIL , range
#define glGenFragmentShadersATI_ARG_EXPAND_TAIL , GLuint range
#define forward_glGenFragmentShadersATI(_range) \
    ({ \
        void *dst = remote_dma(sizeof(glGenFragmentShadersATI_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGenFragmentShadersATI(dst, _range), &ret); \
        ret; \
    });
#define call_glGenFragmentShadersATI(packed, ret_v) do { \
    glGenFragmentShadersATI_PACKED *unpacked = (glGenFragmentShadersATI_PACKED *)packed; \
    glGenFragmentShadersATI_ARGS *args = (glGenFragmentShadersATI_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenFragmentShadersATI(args->range);; \
    } else { \
        glGenFragmentShadersATI(args->range);; \
    } \
} while(0)
GLuint glGenFragmentShadersATI(glGenFragmentShadersATI_ARG_EXPAND);
packed_call_t *pack_glGenFragmentShadersATI(glGenFragmentShadersATI_PACKED *_dst glGenFragmentShadersATI_ARG_EXPAND_TAIL);
typedef GLuint (*glGenFragmentShadersATI_PTR)(glGenFragmentShadersATI_ARG_EXPAND);
#endif
#ifndef glGenFramebuffers_RETURN
#define glGenFramebuffers_RETURN void
#define glGenFramebuffers_ARG_NAMES n, framebuffers
#define glGenFramebuffers_ARG_EXPAND GLsizei n, GLuint * framebuffers
#define glGenFramebuffers_ARG_NAMES_TAIL , n, framebuffers
#define glGenFramebuffers_ARG_EXPAND_TAIL , GLsizei n, GLuint * framebuffers
#define forward_glGenFramebuffers(_n, _framebuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glGenFramebuffers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenFramebuffers(dst, _n, _framebuffers), NULL); \
    });
#define call_glGenFramebuffers(packed, ret_v) do { \
    glGenFramebuffers_PACKED *unpacked = (glGenFramebuffers_PACKED *)packed; \
    glGenFramebuffers_ARGS *args = (glGenFramebuffers_ARGS *)&unpacked->args; \
    glGenFramebuffers(args->n, args->framebuffers);; \
} while(0)
void glGenFramebuffers(glGenFramebuffers_ARG_EXPAND);
packed_call_t *pack_glGenFramebuffers(glGenFramebuffers_PACKED *_dst glGenFramebuffers_ARG_EXPAND_TAIL);
typedef void (*glGenFramebuffers_PTR)(glGenFramebuffers_ARG_EXPAND);
#endif
#ifndef glGenFramebuffersEXT_RETURN
#define glGenFramebuffersEXT_RETURN void
#define glGenFramebuffersEXT_ARG_NAMES n, framebuffers
#define glGenFramebuffersEXT_ARG_EXPAND GLsizei n, GLuint * framebuffers
#define glGenFramebuffersEXT_ARG_NAMES_TAIL , n, framebuffers
#define glGenFramebuffersEXT_ARG_EXPAND_TAIL , GLsizei n, GLuint * framebuffers
#define forward_glGenFramebuffersEXT(_n, _framebuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glGenFramebuffersEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenFramebuffersEXT(dst, _n, _framebuffers), NULL); \
    });
#define call_glGenFramebuffersEXT(packed, ret_v) do { \
    glGenFramebuffersEXT_PACKED *unpacked = (glGenFramebuffersEXT_PACKED *)packed; \
    glGenFramebuffersEXT_ARGS *args = (glGenFramebuffersEXT_ARGS *)&unpacked->args; \
    glGenFramebuffersEXT(args->n, args->framebuffers);; \
} while(0)
void glGenFramebuffersEXT(glGenFramebuffersEXT_ARG_EXPAND);
packed_call_t *pack_glGenFramebuffersEXT(glGenFramebuffersEXT_PACKED *_dst glGenFramebuffersEXT_ARG_EXPAND_TAIL);
typedef void (*glGenFramebuffersEXT_PTR)(glGenFramebuffersEXT_ARG_EXPAND);
#endif
#ifndef glGenLists_RETURN
#define glGenLists_RETURN GLuint
#define glGenLists_ARG_NAMES range
#define glGenLists_ARG_EXPAND GLsizei range
#define glGenLists_ARG_NAMES_TAIL , range
#define glGenLists_ARG_EXPAND_TAIL , GLsizei range
#define forward_glGenLists(_range) \
    ({ \
        void *dst = remote_dma(sizeof(glGenLists_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGenLists(dst, _range), &ret); \
        ret; \
    });
#define call_glGenLists(packed, ret_v) do { \
    glGenLists_PACKED *unpacked = (glGenLists_PACKED *)packed; \
    glGenLists_ARGS *args = (glGenLists_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenLists(args->range);; \
    } else { \
        glGenLists(args->range);; \
    } \
} while(0)
GLuint glGenLists(glGenLists_ARG_EXPAND);
packed_call_t *pack_glGenLists(glGenLists_PACKED *_dst glGenLists_ARG_EXPAND_TAIL);
typedef GLuint (*glGenLists_PTR)(glGenLists_ARG_EXPAND);
#endif
#ifndef glGenNamesAMD_RETURN
#define glGenNamesAMD_RETURN void
#define glGenNamesAMD_ARG_NAMES identifier, num, names
#define glGenNamesAMD_ARG_EXPAND GLenum identifier, GLuint num, GLuint * names
#define glGenNamesAMD_ARG_NAMES_TAIL , identifier, num, names
#define glGenNamesAMD_ARG_EXPAND_TAIL , GLenum identifier, GLuint num, GLuint * names
#define forward_glGenNamesAMD(_identifier, _num, _names) \
    ({ \
        void *dst = remote_dma(sizeof(glGenNamesAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenNamesAMD(dst, _identifier, _num, _names), NULL); \
    });
#define call_glGenNamesAMD(packed, ret_v) do { \
    glGenNamesAMD_PACKED *unpacked = (glGenNamesAMD_PACKED *)packed; \
    glGenNamesAMD_ARGS *args = (glGenNamesAMD_ARGS *)&unpacked->args; \
    glGenNamesAMD(args->identifier, args->num, args->names);; \
} while(0)
void glGenNamesAMD(glGenNamesAMD_ARG_EXPAND);
packed_call_t *pack_glGenNamesAMD(glGenNamesAMD_PACKED *_dst glGenNamesAMD_ARG_EXPAND_TAIL);
typedef void (*glGenNamesAMD_PTR)(glGenNamesAMD_ARG_EXPAND);
#endif
#ifndef glGenOcclusionQueriesNV_RETURN
#define glGenOcclusionQueriesNV_RETURN void
#define glGenOcclusionQueriesNV_ARG_NAMES n, ids
#define glGenOcclusionQueriesNV_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenOcclusionQueriesNV_ARG_NAMES_TAIL , n, ids
#define glGenOcclusionQueriesNV_ARG_EXPAND_TAIL , GLsizei n, GLuint * ids
#define forward_glGenOcclusionQueriesNV(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glGenOcclusionQueriesNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenOcclusionQueriesNV(dst, _n, _ids), NULL); \
    });
#define call_glGenOcclusionQueriesNV(packed, ret_v) do { \
    glGenOcclusionQueriesNV_PACKED *unpacked = (glGenOcclusionQueriesNV_PACKED *)packed; \
    glGenOcclusionQueriesNV_ARGS *args = (glGenOcclusionQueriesNV_ARGS *)&unpacked->args; \
    glGenOcclusionQueriesNV(args->n, args->ids);; \
} while(0)
void glGenOcclusionQueriesNV(glGenOcclusionQueriesNV_ARG_EXPAND);
packed_call_t *pack_glGenOcclusionQueriesNV(glGenOcclusionQueriesNV_PACKED *_dst glGenOcclusionQueriesNV_ARG_EXPAND_TAIL);
typedef void (*glGenOcclusionQueriesNV_PTR)(glGenOcclusionQueriesNV_ARG_EXPAND);
#endif
#ifndef glGenPathsNV_RETURN
#define glGenPathsNV_RETURN GLuint
#define glGenPathsNV_ARG_NAMES range
#define glGenPathsNV_ARG_EXPAND GLsizei range
#define glGenPathsNV_ARG_NAMES_TAIL , range
#define glGenPathsNV_ARG_EXPAND_TAIL , GLsizei range
#define forward_glGenPathsNV(_range) \
    ({ \
        void *dst = remote_dma(sizeof(glGenPathsNV_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGenPathsNV(dst, _range), &ret); \
        ret; \
    });
#define call_glGenPathsNV(packed, ret_v) do { \
    glGenPathsNV_PACKED *unpacked = (glGenPathsNV_PACKED *)packed; \
    glGenPathsNV_ARGS *args = (glGenPathsNV_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenPathsNV(args->range);; \
    } else { \
        glGenPathsNV(args->range);; \
    } \
} while(0)
GLuint glGenPathsNV(glGenPathsNV_ARG_EXPAND);
packed_call_t *pack_glGenPathsNV(glGenPathsNV_PACKED *_dst glGenPathsNV_ARG_EXPAND_TAIL);
typedef GLuint (*glGenPathsNV_PTR)(glGenPathsNV_ARG_EXPAND);
#endif
#ifndef glGenPerfMonitorsAMD_RETURN
#define glGenPerfMonitorsAMD_RETURN void
#define glGenPerfMonitorsAMD_ARG_NAMES n, monitors
#define glGenPerfMonitorsAMD_ARG_EXPAND GLsizei n, GLuint * monitors
#define glGenPerfMonitorsAMD_ARG_NAMES_TAIL , n, monitors
#define glGenPerfMonitorsAMD_ARG_EXPAND_TAIL , GLsizei n, GLuint * monitors
#define forward_glGenPerfMonitorsAMD(_n, _monitors) \
    ({ \
        void *dst = remote_dma(sizeof(glGenPerfMonitorsAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenPerfMonitorsAMD(dst, _n, _monitors), NULL); \
    });
#define call_glGenPerfMonitorsAMD(packed, ret_v) do { \
    glGenPerfMonitorsAMD_PACKED *unpacked = (glGenPerfMonitorsAMD_PACKED *)packed; \
    glGenPerfMonitorsAMD_ARGS *args = (glGenPerfMonitorsAMD_ARGS *)&unpacked->args; \
    glGenPerfMonitorsAMD(args->n, args->monitors);; \
} while(0)
void glGenPerfMonitorsAMD(glGenPerfMonitorsAMD_ARG_EXPAND);
packed_call_t *pack_glGenPerfMonitorsAMD(glGenPerfMonitorsAMD_PACKED *_dst glGenPerfMonitorsAMD_ARG_EXPAND_TAIL);
typedef void (*glGenPerfMonitorsAMD_PTR)(glGenPerfMonitorsAMD_ARG_EXPAND);
#endif
#ifndef glGenProgramPipelines_RETURN
#define glGenProgramPipelines_RETURN void
#define glGenProgramPipelines_ARG_NAMES n, pipelines
#define glGenProgramPipelines_ARG_EXPAND GLsizei n, GLuint * pipelines
#define glGenProgramPipelines_ARG_NAMES_TAIL , n, pipelines
#define glGenProgramPipelines_ARG_EXPAND_TAIL , GLsizei n, GLuint * pipelines
#define forward_glGenProgramPipelines(_n, _pipelines) \
    ({ \
        void *dst = remote_dma(sizeof(glGenProgramPipelines_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenProgramPipelines(dst, _n, _pipelines), NULL); \
    });
#define call_glGenProgramPipelines(packed, ret_v) do { \
    glGenProgramPipelines_PACKED *unpacked = (glGenProgramPipelines_PACKED *)packed; \
    glGenProgramPipelines_ARGS *args = (glGenProgramPipelines_ARGS *)&unpacked->args; \
    glGenProgramPipelines(args->n, args->pipelines);; \
} while(0)
void glGenProgramPipelines(glGenProgramPipelines_ARG_EXPAND);
packed_call_t *pack_glGenProgramPipelines(glGenProgramPipelines_PACKED *_dst glGenProgramPipelines_ARG_EXPAND_TAIL);
typedef void (*glGenProgramPipelines_PTR)(glGenProgramPipelines_ARG_EXPAND);
#endif
#ifndef glGenProgramsARB_RETURN
#define glGenProgramsARB_RETURN void
#define glGenProgramsARB_ARG_NAMES n, programs
#define glGenProgramsARB_ARG_EXPAND GLsizei n, GLuint * programs
#define glGenProgramsARB_ARG_NAMES_TAIL , n, programs
#define glGenProgramsARB_ARG_EXPAND_TAIL , GLsizei n, GLuint * programs
#define forward_glGenProgramsARB(_n, _programs) \
    ({ \
        void *dst = remote_dma(sizeof(glGenProgramsARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenProgramsARB(dst, _n, _programs), NULL); \
    });
#define call_glGenProgramsARB(packed, ret_v) do { \
    glGenProgramsARB_PACKED *unpacked = (glGenProgramsARB_PACKED *)packed; \
    glGenProgramsARB_ARGS *args = (glGenProgramsARB_ARGS *)&unpacked->args; \
    glGenProgramsARB(args->n, args->programs);; \
} while(0)
void glGenProgramsARB(glGenProgramsARB_ARG_EXPAND);
packed_call_t *pack_glGenProgramsARB(glGenProgramsARB_PACKED *_dst glGenProgramsARB_ARG_EXPAND_TAIL);
typedef void (*glGenProgramsARB_PTR)(glGenProgramsARB_ARG_EXPAND);
#endif
#ifndef glGenProgramsNV_RETURN
#define glGenProgramsNV_RETURN void
#define glGenProgramsNV_ARG_NAMES n, programs
#define glGenProgramsNV_ARG_EXPAND GLsizei n, GLuint * programs
#define glGenProgramsNV_ARG_NAMES_TAIL , n, programs
#define glGenProgramsNV_ARG_EXPAND_TAIL , GLsizei n, GLuint * programs
#define forward_glGenProgramsNV(_n, _programs) \
    ({ \
        void *dst = remote_dma(sizeof(glGenProgramsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenProgramsNV(dst, _n, _programs), NULL); \
    });
#define call_glGenProgramsNV(packed, ret_v) do { \
    glGenProgramsNV_PACKED *unpacked = (glGenProgramsNV_PACKED *)packed; \
    glGenProgramsNV_ARGS *args = (glGenProgramsNV_ARGS *)&unpacked->args; \
    glGenProgramsNV(args->n, args->programs);; \
} while(0)
void glGenProgramsNV(glGenProgramsNV_ARG_EXPAND);
packed_call_t *pack_glGenProgramsNV(glGenProgramsNV_PACKED *_dst glGenProgramsNV_ARG_EXPAND_TAIL);
typedef void (*glGenProgramsNV_PTR)(glGenProgramsNV_ARG_EXPAND);
#endif
#ifndef glGenQueries_RETURN
#define glGenQueries_RETURN void
#define glGenQueries_ARG_NAMES n, ids
#define glGenQueries_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenQueries_ARG_NAMES_TAIL , n, ids
#define glGenQueries_ARG_EXPAND_TAIL , GLsizei n, GLuint * ids
#define forward_glGenQueries(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glGenQueries_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenQueries(dst, _n, _ids), NULL); \
    });
#define call_glGenQueries(packed, ret_v) do { \
    glGenQueries_PACKED *unpacked = (glGenQueries_PACKED *)packed; \
    glGenQueries_ARGS *args = (glGenQueries_ARGS *)&unpacked->args; \
    glGenQueries(args->n, args->ids);; \
} while(0)
void glGenQueries(glGenQueries_ARG_EXPAND);
packed_call_t *pack_glGenQueries(glGenQueries_PACKED *_dst glGenQueries_ARG_EXPAND_TAIL);
typedef void (*glGenQueries_PTR)(glGenQueries_ARG_EXPAND);
#endif
#ifndef glGenQueriesARB_RETURN
#define glGenQueriesARB_RETURN void
#define glGenQueriesARB_ARG_NAMES n, ids
#define glGenQueriesARB_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenQueriesARB_ARG_NAMES_TAIL , n, ids
#define glGenQueriesARB_ARG_EXPAND_TAIL , GLsizei n, GLuint * ids
#define forward_glGenQueriesARB(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glGenQueriesARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenQueriesARB(dst, _n, _ids), NULL); \
    });
#define call_glGenQueriesARB(packed, ret_v) do { \
    glGenQueriesARB_PACKED *unpacked = (glGenQueriesARB_PACKED *)packed; \
    glGenQueriesARB_ARGS *args = (glGenQueriesARB_ARGS *)&unpacked->args; \
    glGenQueriesARB(args->n, args->ids);; \
} while(0)
void glGenQueriesARB(glGenQueriesARB_ARG_EXPAND);
packed_call_t *pack_glGenQueriesARB(glGenQueriesARB_PACKED *_dst glGenQueriesARB_ARG_EXPAND_TAIL);
typedef void (*glGenQueriesARB_PTR)(glGenQueriesARB_ARG_EXPAND);
#endif
#ifndef glGenRenderbuffers_RETURN
#define glGenRenderbuffers_RETURN void
#define glGenRenderbuffers_ARG_NAMES n, renderbuffers
#define glGenRenderbuffers_ARG_EXPAND GLsizei n, GLuint * renderbuffers
#define glGenRenderbuffers_ARG_NAMES_TAIL , n, renderbuffers
#define glGenRenderbuffers_ARG_EXPAND_TAIL , GLsizei n, GLuint * renderbuffers
#define forward_glGenRenderbuffers(_n, _renderbuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glGenRenderbuffers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenRenderbuffers(dst, _n, _renderbuffers), NULL); \
    });
#define call_glGenRenderbuffers(packed, ret_v) do { \
    glGenRenderbuffers_PACKED *unpacked = (glGenRenderbuffers_PACKED *)packed; \
    glGenRenderbuffers_ARGS *args = (glGenRenderbuffers_ARGS *)&unpacked->args; \
    glGenRenderbuffers(args->n, args->renderbuffers);; \
} while(0)
void glGenRenderbuffers(glGenRenderbuffers_ARG_EXPAND);
packed_call_t *pack_glGenRenderbuffers(glGenRenderbuffers_PACKED *_dst glGenRenderbuffers_ARG_EXPAND_TAIL);
typedef void (*glGenRenderbuffers_PTR)(glGenRenderbuffers_ARG_EXPAND);
#endif
#ifndef glGenRenderbuffersEXT_RETURN
#define glGenRenderbuffersEXT_RETURN void
#define glGenRenderbuffersEXT_ARG_NAMES n, renderbuffers
#define glGenRenderbuffersEXT_ARG_EXPAND GLsizei n, GLuint * renderbuffers
#define glGenRenderbuffersEXT_ARG_NAMES_TAIL , n, renderbuffers
#define glGenRenderbuffersEXT_ARG_EXPAND_TAIL , GLsizei n, GLuint * renderbuffers
#define forward_glGenRenderbuffersEXT(_n, _renderbuffers) \
    ({ \
        void *dst = remote_dma(sizeof(glGenRenderbuffersEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenRenderbuffersEXT(dst, _n, _renderbuffers), NULL); \
    });
#define call_glGenRenderbuffersEXT(packed, ret_v) do { \
    glGenRenderbuffersEXT_PACKED *unpacked = (glGenRenderbuffersEXT_PACKED *)packed; \
    glGenRenderbuffersEXT_ARGS *args = (glGenRenderbuffersEXT_ARGS *)&unpacked->args; \
    glGenRenderbuffersEXT(args->n, args->renderbuffers);; \
} while(0)
void glGenRenderbuffersEXT(glGenRenderbuffersEXT_ARG_EXPAND);
packed_call_t *pack_glGenRenderbuffersEXT(glGenRenderbuffersEXT_PACKED *_dst glGenRenderbuffersEXT_ARG_EXPAND_TAIL);
typedef void (*glGenRenderbuffersEXT_PTR)(glGenRenderbuffersEXT_ARG_EXPAND);
#endif
#ifndef glGenSamplers_RETURN
#define glGenSamplers_RETURN void
#define glGenSamplers_ARG_NAMES count, samplers
#define glGenSamplers_ARG_EXPAND GLsizei count, GLuint * samplers
#define glGenSamplers_ARG_NAMES_TAIL , count, samplers
#define glGenSamplers_ARG_EXPAND_TAIL , GLsizei count, GLuint * samplers
#define forward_glGenSamplers(_count, _samplers) \
    ({ \
        void *dst = remote_dma(sizeof(glGenSamplers_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenSamplers(dst, _count, _samplers), NULL); \
    });
#define call_glGenSamplers(packed, ret_v) do { \
    glGenSamplers_PACKED *unpacked = (glGenSamplers_PACKED *)packed; \
    glGenSamplers_ARGS *args = (glGenSamplers_ARGS *)&unpacked->args; \
    glGenSamplers(args->count, args->samplers);; \
} while(0)
void glGenSamplers(glGenSamplers_ARG_EXPAND);
packed_call_t *pack_glGenSamplers(glGenSamplers_PACKED *_dst glGenSamplers_ARG_EXPAND_TAIL);
typedef void (*glGenSamplers_PTR)(glGenSamplers_ARG_EXPAND);
#endif
#ifndef glGenSymbolsEXT_RETURN
#define glGenSymbolsEXT_RETURN GLuint
#define glGenSymbolsEXT_ARG_NAMES datatype, storagetype, range, components
#define glGenSymbolsEXT_ARG_EXPAND GLenum datatype, GLenum storagetype, GLenum range, GLuint components
#define glGenSymbolsEXT_ARG_NAMES_TAIL , datatype, storagetype, range, components
#define glGenSymbolsEXT_ARG_EXPAND_TAIL , GLenum datatype, GLenum storagetype, GLenum range, GLuint components
#define forward_glGenSymbolsEXT(_datatype, _storagetype, _range, _components) \
    ({ \
        void *dst = remote_dma(sizeof(glGenSymbolsEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGenSymbolsEXT(dst, _datatype, _storagetype, _range, _components), &ret); \
        ret; \
    });
#define call_glGenSymbolsEXT(packed, ret_v) do { \
    glGenSymbolsEXT_PACKED *unpacked = (glGenSymbolsEXT_PACKED *)packed; \
    glGenSymbolsEXT_ARGS *args = (glGenSymbolsEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenSymbolsEXT(args->datatype, args->storagetype, args->range, args->components);; \
    } else { \
        glGenSymbolsEXT(args->datatype, args->storagetype, args->range, args->components);; \
    } \
} while(0)
GLuint glGenSymbolsEXT(glGenSymbolsEXT_ARG_EXPAND);
packed_call_t *pack_glGenSymbolsEXT(glGenSymbolsEXT_PACKED *_dst glGenSymbolsEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glGenSymbolsEXT_PTR)(glGenSymbolsEXT_ARG_EXPAND);
#endif
#ifndef glGenTextures_RETURN
#define glGenTextures_RETURN void
#define glGenTextures_ARG_NAMES n, textures
#define glGenTextures_ARG_EXPAND GLsizei n, GLuint * textures
#define glGenTextures_ARG_NAMES_TAIL , n, textures
#define glGenTextures_ARG_EXPAND_TAIL , GLsizei n, GLuint * textures
#define forward_glGenTextures(_n, _textures) \
    ({ \
        void *dst = remote_dma(sizeof(glGenTextures_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenTextures(dst, _n, _textures), NULL); \
    });
#define call_glGenTextures(packed, ret_v) do { \
    glGenTextures_PACKED *unpacked = (glGenTextures_PACKED *)packed; \
    glGenTextures_ARGS *args = (glGenTextures_ARGS *)&unpacked->args; \
    glGenTextures(args->n, args->textures);; \
} while(0)
void glGenTextures(glGenTextures_ARG_EXPAND);
packed_call_t *pack_glGenTextures(glGenTextures_PACKED *_dst glGenTextures_ARG_EXPAND_TAIL);
typedef void (*glGenTextures_PTR)(glGenTextures_ARG_EXPAND);
#endif
#ifndef glGenTexturesEXT_RETURN
#define glGenTexturesEXT_RETURN void
#define glGenTexturesEXT_ARG_NAMES n, textures
#define glGenTexturesEXT_ARG_EXPAND GLsizei n, GLuint * textures
#define glGenTexturesEXT_ARG_NAMES_TAIL , n, textures
#define glGenTexturesEXT_ARG_EXPAND_TAIL , GLsizei n, GLuint * textures
#define forward_glGenTexturesEXT(_n, _textures) \
    ({ \
        void *dst = remote_dma(sizeof(glGenTexturesEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenTexturesEXT(dst, _n, _textures), NULL); \
    });
#define call_glGenTexturesEXT(packed, ret_v) do { \
    glGenTexturesEXT_PACKED *unpacked = (glGenTexturesEXT_PACKED *)packed; \
    glGenTexturesEXT_ARGS *args = (glGenTexturesEXT_ARGS *)&unpacked->args; \
    glGenTexturesEXT(args->n, args->textures);; \
} while(0)
void glGenTexturesEXT(glGenTexturesEXT_ARG_EXPAND);
packed_call_t *pack_glGenTexturesEXT(glGenTexturesEXT_PACKED *_dst glGenTexturesEXT_ARG_EXPAND_TAIL);
typedef void (*glGenTexturesEXT_PTR)(glGenTexturesEXT_ARG_EXPAND);
#endif
#ifndef glGenTransformFeedbacks_RETURN
#define glGenTransformFeedbacks_RETURN void
#define glGenTransformFeedbacks_ARG_NAMES n, ids
#define glGenTransformFeedbacks_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenTransformFeedbacks_ARG_NAMES_TAIL , n, ids
#define glGenTransformFeedbacks_ARG_EXPAND_TAIL , GLsizei n, GLuint * ids
#define forward_glGenTransformFeedbacks(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glGenTransformFeedbacks_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenTransformFeedbacks(dst, _n, _ids), NULL); \
    });
#define call_glGenTransformFeedbacks(packed, ret_v) do { \
    glGenTransformFeedbacks_PACKED *unpacked = (glGenTransformFeedbacks_PACKED *)packed; \
    glGenTransformFeedbacks_ARGS *args = (glGenTransformFeedbacks_ARGS *)&unpacked->args; \
    glGenTransformFeedbacks(args->n, args->ids);; \
} while(0)
void glGenTransformFeedbacks(glGenTransformFeedbacks_ARG_EXPAND);
packed_call_t *pack_glGenTransformFeedbacks(glGenTransformFeedbacks_PACKED *_dst glGenTransformFeedbacks_ARG_EXPAND_TAIL);
typedef void (*glGenTransformFeedbacks_PTR)(glGenTransformFeedbacks_ARG_EXPAND);
#endif
#ifndef glGenTransformFeedbacksNV_RETURN
#define glGenTransformFeedbacksNV_RETURN void
#define glGenTransformFeedbacksNV_ARG_NAMES n, ids
#define glGenTransformFeedbacksNV_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenTransformFeedbacksNV_ARG_NAMES_TAIL , n, ids
#define glGenTransformFeedbacksNV_ARG_EXPAND_TAIL , GLsizei n, GLuint * ids
#define forward_glGenTransformFeedbacksNV(_n, _ids) \
    ({ \
        void *dst = remote_dma(sizeof(glGenTransformFeedbacksNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenTransformFeedbacksNV(dst, _n, _ids), NULL); \
    });
#define call_glGenTransformFeedbacksNV(packed, ret_v) do { \
    glGenTransformFeedbacksNV_PACKED *unpacked = (glGenTransformFeedbacksNV_PACKED *)packed; \
    glGenTransformFeedbacksNV_ARGS *args = (glGenTransformFeedbacksNV_ARGS *)&unpacked->args; \
    glGenTransformFeedbacksNV(args->n, args->ids);; \
} while(0)
void glGenTransformFeedbacksNV(glGenTransformFeedbacksNV_ARG_EXPAND);
packed_call_t *pack_glGenTransformFeedbacksNV(glGenTransformFeedbacksNV_PACKED *_dst glGenTransformFeedbacksNV_ARG_EXPAND_TAIL);
typedef void (*glGenTransformFeedbacksNV_PTR)(glGenTransformFeedbacksNV_ARG_EXPAND);
#endif
#ifndef glGenVertexArrays_RETURN
#define glGenVertexArrays_RETURN void
#define glGenVertexArrays_ARG_NAMES n, arrays
#define glGenVertexArrays_ARG_EXPAND GLsizei n, GLuint * arrays
#define glGenVertexArrays_ARG_NAMES_TAIL , n, arrays
#define glGenVertexArrays_ARG_EXPAND_TAIL , GLsizei n, GLuint * arrays
#define forward_glGenVertexArrays(_n, _arrays) \
    ({ \
        void *dst = remote_dma(sizeof(glGenVertexArrays_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenVertexArrays(dst, _n, _arrays), NULL); \
    });
#define call_glGenVertexArrays(packed, ret_v) do { \
    glGenVertexArrays_PACKED *unpacked = (glGenVertexArrays_PACKED *)packed; \
    glGenVertexArrays_ARGS *args = (glGenVertexArrays_ARGS *)&unpacked->args; \
    glGenVertexArrays(args->n, args->arrays);; \
} while(0)
void glGenVertexArrays(glGenVertexArrays_ARG_EXPAND);
packed_call_t *pack_glGenVertexArrays(glGenVertexArrays_PACKED *_dst glGenVertexArrays_ARG_EXPAND_TAIL);
typedef void (*glGenVertexArrays_PTR)(glGenVertexArrays_ARG_EXPAND);
#endif
#ifndef glGenVertexArraysAPPLE_RETURN
#define glGenVertexArraysAPPLE_RETURN void
#define glGenVertexArraysAPPLE_ARG_NAMES n, arrays
#define glGenVertexArraysAPPLE_ARG_EXPAND GLsizei n, GLuint * arrays
#define glGenVertexArraysAPPLE_ARG_NAMES_TAIL , n, arrays
#define glGenVertexArraysAPPLE_ARG_EXPAND_TAIL , GLsizei n, GLuint * arrays
#define forward_glGenVertexArraysAPPLE(_n, _arrays) \
    ({ \
        void *dst = remote_dma(sizeof(glGenVertexArraysAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenVertexArraysAPPLE(dst, _n, _arrays), NULL); \
    });
#define call_glGenVertexArraysAPPLE(packed, ret_v) do { \
    glGenVertexArraysAPPLE_PACKED *unpacked = (glGenVertexArraysAPPLE_PACKED *)packed; \
    glGenVertexArraysAPPLE_ARGS *args = (glGenVertexArraysAPPLE_ARGS *)&unpacked->args; \
    glGenVertexArraysAPPLE(args->n, args->arrays);; \
} while(0)
void glGenVertexArraysAPPLE(glGenVertexArraysAPPLE_ARG_EXPAND);
packed_call_t *pack_glGenVertexArraysAPPLE(glGenVertexArraysAPPLE_PACKED *_dst glGenVertexArraysAPPLE_ARG_EXPAND_TAIL);
typedef void (*glGenVertexArraysAPPLE_PTR)(glGenVertexArraysAPPLE_ARG_EXPAND);
#endif
#ifndef glGenVertexShadersEXT_RETURN
#define glGenVertexShadersEXT_RETURN GLuint
#define glGenVertexShadersEXT_ARG_NAMES range
#define glGenVertexShadersEXT_ARG_EXPAND GLuint range
#define glGenVertexShadersEXT_ARG_NAMES_TAIL , range
#define glGenVertexShadersEXT_ARG_EXPAND_TAIL , GLuint range
#define forward_glGenVertexShadersEXT(_range) \
    ({ \
        void *dst = remote_dma(sizeof(glGenVertexShadersEXT_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGenVertexShadersEXT(dst, _range), &ret); \
        ret; \
    });
#define call_glGenVertexShadersEXT(packed, ret_v) do { \
    glGenVertexShadersEXT_PACKED *unpacked = (glGenVertexShadersEXT_PACKED *)packed; \
    glGenVertexShadersEXT_ARGS *args = (glGenVertexShadersEXT_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenVertexShadersEXT(args->range);; \
    } else { \
        glGenVertexShadersEXT(args->range);; \
    } \
} while(0)
GLuint glGenVertexShadersEXT(glGenVertexShadersEXT_ARG_EXPAND);
packed_call_t *pack_glGenVertexShadersEXT(glGenVertexShadersEXT_PACKED *_dst glGenVertexShadersEXT_ARG_EXPAND_TAIL);
typedef GLuint (*glGenVertexShadersEXT_PTR)(glGenVertexShadersEXT_ARG_EXPAND);
#endif
#ifndef glGenerateMipmap_RETURN
#define glGenerateMipmap_RETURN void
#define glGenerateMipmap_ARG_NAMES target
#define glGenerateMipmap_ARG_EXPAND GLenum target
#define glGenerateMipmap_ARG_NAMES_TAIL , target
#define glGenerateMipmap_ARG_EXPAND_TAIL , GLenum target
#define forward_glGenerateMipmap(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glGenerateMipmap_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenerateMipmap(dst, _target), NULL); \
    });
#define call_glGenerateMipmap(packed, ret_v) do { \
    glGenerateMipmap_PACKED *unpacked = (glGenerateMipmap_PACKED *)packed; \
    glGenerateMipmap_ARGS *args = (glGenerateMipmap_ARGS *)&unpacked->args; \
    glGenerateMipmap(args->target);; \
} while(0)
void glGenerateMipmap(glGenerateMipmap_ARG_EXPAND);
packed_call_t *pack_glGenerateMipmap(glGenerateMipmap_PACKED *_dst glGenerateMipmap_ARG_EXPAND_TAIL);
typedef void (*glGenerateMipmap_PTR)(glGenerateMipmap_ARG_EXPAND);
#endif
#ifndef glGenerateMipmapEXT_RETURN
#define glGenerateMipmapEXT_RETURN void
#define glGenerateMipmapEXT_ARG_NAMES target
#define glGenerateMipmapEXT_ARG_EXPAND GLenum target
#define glGenerateMipmapEXT_ARG_NAMES_TAIL , target
#define glGenerateMipmapEXT_ARG_EXPAND_TAIL , GLenum target
#define forward_glGenerateMipmapEXT(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glGenerateMipmapEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenerateMipmapEXT(dst, _target), NULL); \
    });
#define call_glGenerateMipmapEXT(packed, ret_v) do { \
    glGenerateMipmapEXT_PACKED *unpacked = (glGenerateMipmapEXT_PACKED *)packed; \
    glGenerateMipmapEXT_ARGS *args = (glGenerateMipmapEXT_ARGS *)&unpacked->args; \
    glGenerateMipmapEXT(args->target);; \
} while(0)
void glGenerateMipmapEXT(glGenerateMipmapEXT_ARG_EXPAND);
packed_call_t *pack_glGenerateMipmapEXT(glGenerateMipmapEXT_PACKED *_dst glGenerateMipmapEXT_ARG_EXPAND_TAIL);
typedef void (*glGenerateMipmapEXT_PTR)(glGenerateMipmapEXT_ARG_EXPAND);
#endif
#ifndef glGenerateMultiTexMipmapEXT_RETURN
#define glGenerateMultiTexMipmapEXT_RETURN void
#define glGenerateMultiTexMipmapEXT_ARG_NAMES texunit, target
#define glGenerateMultiTexMipmapEXT_ARG_EXPAND GLenum texunit, GLenum target
#define glGenerateMultiTexMipmapEXT_ARG_NAMES_TAIL , texunit, target
#define glGenerateMultiTexMipmapEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target
#define forward_glGenerateMultiTexMipmapEXT(_texunit, _target) \
    ({ \
        void *dst = remote_dma(sizeof(glGenerateMultiTexMipmapEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenerateMultiTexMipmapEXT(dst, _texunit, _target), NULL); \
    });
#define call_glGenerateMultiTexMipmapEXT(packed, ret_v) do { \
    glGenerateMultiTexMipmapEXT_PACKED *unpacked = (glGenerateMultiTexMipmapEXT_PACKED *)packed; \
    glGenerateMultiTexMipmapEXT_ARGS *args = (glGenerateMultiTexMipmapEXT_ARGS *)&unpacked->args; \
    glGenerateMultiTexMipmapEXT(args->texunit, args->target);; \
} while(0)
void glGenerateMultiTexMipmapEXT(glGenerateMultiTexMipmapEXT_ARG_EXPAND);
packed_call_t *pack_glGenerateMultiTexMipmapEXT(glGenerateMultiTexMipmapEXT_PACKED *_dst glGenerateMultiTexMipmapEXT_ARG_EXPAND_TAIL);
typedef void (*glGenerateMultiTexMipmapEXT_PTR)(glGenerateMultiTexMipmapEXT_ARG_EXPAND);
#endif
#ifndef glGenerateTextureMipmapEXT_RETURN
#define glGenerateTextureMipmapEXT_RETURN void
#define glGenerateTextureMipmapEXT_ARG_NAMES texture, target
#define glGenerateTextureMipmapEXT_ARG_EXPAND GLuint texture, GLenum target
#define glGenerateTextureMipmapEXT_ARG_NAMES_TAIL , texture, target
#define glGenerateTextureMipmapEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target
#define forward_glGenerateTextureMipmapEXT(_texture, _target) \
    ({ \
        void *dst = remote_dma(sizeof(glGenerateTextureMipmapEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGenerateTextureMipmapEXT(dst, _texture, _target), NULL); \
    });
#define call_glGenerateTextureMipmapEXT(packed, ret_v) do { \
    glGenerateTextureMipmapEXT_PACKED *unpacked = (glGenerateTextureMipmapEXT_PACKED *)packed; \
    glGenerateTextureMipmapEXT_ARGS *args = (glGenerateTextureMipmapEXT_ARGS *)&unpacked->args; \
    glGenerateTextureMipmapEXT(args->texture, args->target);; \
} while(0)
void glGenerateTextureMipmapEXT(glGenerateTextureMipmapEXT_ARG_EXPAND);
packed_call_t *pack_glGenerateTextureMipmapEXT(glGenerateTextureMipmapEXT_PACKED *_dst glGenerateTextureMipmapEXT_ARG_EXPAND_TAIL);
typedef void (*glGenerateTextureMipmapEXT_PTR)(glGenerateTextureMipmapEXT_ARG_EXPAND);
#endif
#ifndef glGetActiveAtomicCounterBufferiv_RETURN
#define glGetActiveAtomicCounterBufferiv_RETURN void
#define glGetActiveAtomicCounterBufferiv_ARG_NAMES program, bufferIndex, pname, params
#define glGetActiveAtomicCounterBufferiv_ARG_EXPAND GLuint program, GLuint bufferIndex, GLenum pname, GLint * params
#define glGetActiveAtomicCounterBufferiv_ARG_NAMES_TAIL , program, bufferIndex, pname, params
#define glGetActiveAtomicCounterBufferiv_ARG_EXPAND_TAIL , GLuint program, GLuint bufferIndex, GLenum pname, GLint * params
#define forward_glGetActiveAtomicCounterBufferiv(_program, _bufferIndex, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveAtomicCounterBufferiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveAtomicCounterBufferiv(dst, _program, _bufferIndex, _pname, _params), NULL); \
    });
#define call_glGetActiveAtomicCounterBufferiv(packed, ret_v) do { \
    glGetActiveAtomicCounterBufferiv_PACKED *unpacked = (glGetActiveAtomicCounterBufferiv_PACKED *)packed; \
    glGetActiveAtomicCounterBufferiv_ARGS *args = (glGetActiveAtomicCounterBufferiv_ARGS *)&unpacked->args; \
    glGetActiveAtomicCounterBufferiv(args->program, args->bufferIndex, args->pname, args->params);; \
} while(0)
void glGetActiveAtomicCounterBufferiv(glGetActiveAtomicCounterBufferiv_ARG_EXPAND);
packed_call_t *pack_glGetActiveAtomicCounterBufferiv(glGetActiveAtomicCounterBufferiv_PACKED *_dst glGetActiveAtomicCounterBufferiv_ARG_EXPAND_TAIL);
typedef void (*glGetActiveAtomicCounterBufferiv_PTR)(glGetActiveAtomicCounterBufferiv_ARG_EXPAND);
#endif
#ifndef glGetActiveAttrib_RETURN
#define glGetActiveAttrib_RETURN void
#define glGetActiveAttrib_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetActiveAttrib_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name
#define glGetActiveAttrib_ARG_NAMES_TAIL , program, index, bufSize, length, size, type, name
#define glGetActiveAttrib_ARG_EXPAND_TAIL , GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name
#define forward_glGetActiveAttrib(_program, _index, _bufSize, _length, _size, _type, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveAttrib_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveAttrib(dst, _program, _index, _bufSize, _length, _size, _type, _name), NULL); \
    });
#define call_glGetActiveAttrib(packed, ret_v) do { \
    glGetActiveAttrib_PACKED *unpacked = (glGetActiveAttrib_PACKED *)packed; \
    glGetActiveAttrib_ARGS *args = (glGetActiveAttrib_ARGS *)&unpacked->args; \
    glGetActiveAttrib(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveAttrib(glGetActiveAttrib_ARG_EXPAND);
packed_call_t *pack_glGetActiveAttrib(glGetActiveAttrib_PACKED *_dst glGetActiveAttrib_ARG_EXPAND_TAIL);
typedef void (*glGetActiveAttrib_PTR)(glGetActiveAttrib_ARG_EXPAND);
#endif
#ifndef glGetActiveAttribARB_RETURN
#define glGetActiveAttribARB_RETURN void
#define glGetActiveAttribARB_ARG_NAMES programObj, index, maxLength, length, size, type, name
#define glGetActiveAttribARB_ARG_EXPAND GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name
#define glGetActiveAttribARB_ARG_NAMES_TAIL , programObj, index, maxLength, length, size, type, name
#define glGetActiveAttribARB_ARG_EXPAND_TAIL , GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name
#define forward_glGetActiveAttribARB(_programObj, _index, _maxLength, _length, _size, _type, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveAttribARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveAttribARB(dst, _programObj, _index, _maxLength, _length, _size, _type, _name), NULL); \
    });
#define call_glGetActiveAttribARB(packed, ret_v) do { \
    glGetActiveAttribARB_PACKED *unpacked = (glGetActiveAttribARB_PACKED *)packed; \
    glGetActiveAttribARB_ARGS *args = (glGetActiveAttribARB_ARGS *)&unpacked->args; \
    glGetActiveAttribARB(args->programObj, args->index, args->maxLength, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveAttribARB(glGetActiveAttribARB_ARG_EXPAND);
packed_call_t *pack_glGetActiveAttribARB(glGetActiveAttribARB_PACKED *_dst glGetActiveAttribARB_ARG_EXPAND_TAIL);
typedef void (*glGetActiveAttribARB_PTR)(glGetActiveAttribARB_ARG_EXPAND);
#endif
#ifndef glGetActiveSubroutineName_RETURN
#define glGetActiveSubroutineName_RETURN void
#define glGetActiveSubroutineName_ARG_NAMES program, shadertype, index, bufsize, length, name
#define glGetActiveSubroutineName_ARG_EXPAND GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name
#define glGetActiveSubroutineName_ARG_NAMES_TAIL , program, shadertype, index, bufsize, length, name
#define glGetActiveSubroutineName_ARG_EXPAND_TAIL , GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name
#define forward_glGetActiveSubroutineName(_program, _shadertype, _index, _bufsize, _length, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveSubroutineName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveSubroutineName(dst, _program, _shadertype, _index, _bufsize, _length, _name), NULL); \
    });
#define call_glGetActiveSubroutineName(packed, ret_v) do { \
    glGetActiveSubroutineName_PACKED *unpacked = (glGetActiveSubroutineName_PACKED *)packed; \
    glGetActiveSubroutineName_ARGS *args = (glGetActiveSubroutineName_ARGS *)&unpacked->args; \
    glGetActiveSubroutineName(args->program, args->shadertype, args->index, args->bufsize, args->length, args->name);; \
} while(0)
void glGetActiveSubroutineName(glGetActiveSubroutineName_ARG_EXPAND);
packed_call_t *pack_glGetActiveSubroutineName(glGetActiveSubroutineName_PACKED *_dst glGetActiveSubroutineName_ARG_EXPAND_TAIL);
typedef void (*glGetActiveSubroutineName_PTR)(glGetActiveSubroutineName_ARG_EXPAND);
#endif
#ifndef glGetActiveSubroutineUniformName_RETURN
#define glGetActiveSubroutineUniformName_RETURN void
#define glGetActiveSubroutineUniformName_ARG_NAMES program, shadertype, index, bufsize, length, name
#define glGetActiveSubroutineUniformName_ARG_EXPAND GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name
#define glGetActiveSubroutineUniformName_ARG_NAMES_TAIL , program, shadertype, index, bufsize, length, name
#define glGetActiveSubroutineUniformName_ARG_EXPAND_TAIL , GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name
#define forward_glGetActiveSubroutineUniformName(_program, _shadertype, _index, _bufsize, _length, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveSubroutineUniformName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveSubroutineUniformName(dst, _program, _shadertype, _index, _bufsize, _length, _name), NULL); \
    });
#define call_glGetActiveSubroutineUniformName(packed, ret_v) do { \
    glGetActiveSubroutineUniformName_PACKED *unpacked = (glGetActiveSubroutineUniformName_PACKED *)packed; \
    glGetActiveSubroutineUniformName_ARGS *args = (glGetActiveSubroutineUniformName_ARGS *)&unpacked->args; \
    glGetActiveSubroutineUniformName(args->program, args->shadertype, args->index, args->bufsize, args->length, args->name);; \
} while(0)
void glGetActiveSubroutineUniformName(glGetActiveSubroutineUniformName_ARG_EXPAND);
packed_call_t *pack_glGetActiveSubroutineUniformName(glGetActiveSubroutineUniformName_PACKED *_dst glGetActiveSubroutineUniformName_ARG_EXPAND_TAIL);
typedef void (*glGetActiveSubroutineUniformName_PTR)(glGetActiveSubroutineUniformName_ARG_EXPAND);
#endif
#ifndef glGetActiveSubroutineUniformiv_RETURN
#define glGetActiveSubroutineUniformiv_RETURN void
#define glGetActiveSubroutineUniformiv_ARG_NAMES program, shadertype, index, pname, values
#define glGetActiveSubroutineUniformiv_ARG_EXPAND GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values
#define glGetActiveSubroutineUniformiv_ARG_NAMES_TAIL , program, shadertype, index, pname, values
#define glGetActiveSubroutineUniformiv_ARG_EXPAND_TAIL , GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values
#define forward_glGetActiveSubroutineUniformiv(_program, _shadertype, _index, _pname, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveSubroutineUniformiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveSubroutineUniformiv(dst, _program, _shadertype, _index, _pname, _values), NULL); \
    });
#define call_glGetActiveSubroutineUniformiv(packed, ret_v) do { \
    glGetActiveSubroutineUniformiv_PACKED *unpacked = (glGetActiveSubroutineUniformiv_PACKED *)packed; \
    glGetActiveSubroutineUniformiv_ARGS *args = (glGetActiveSubroutineUniformiv_ARGS *)&unpacked->args; \
    glGetActiveSubroutineUniformiv(args->program, args->shadertype, args->index, args->pname, args->values);; \
} while(0)
void glGetActiveSubroutineUniformiv(glGetActiveSubroutineUniformiv_ARG_EXPAND);
packed_call_t *pack_glGetActiveSubroutineUniformiv(glGetActiveSubroutineUniformiv_PACKED *_dst glGetActiveSubroutineUniformiv_ARG_EXPAND_TAIL);
typedef void (*glGetActiveSubroutineUniformiv_PTR)(glGetActiveSubroutineUniformiv_ARG_EXPAND);
#endif
#ifndef glGetActiveUniform_RETURN
#define glGetActiveUniform_RETURN void
#define glGetActiveUniform_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetActiveUniform_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name
#define glGetActiveUniform_ARG_NAMES_TAIL , program, index, bufSize, length, size, type, name
#define glGetActiveUniform_ARG_EXPAND_TAIL , GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name
#define forward_glGetActiveUniform(_program, _index, _bufSize, _length, _size, _type, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveUniform_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveUniform(dst, _program, _index, _bufSize, _length, _size, _type, _name), NULL); \
    });
#define call_glGetActiveUniform(packed, ret_v) do { \
    glGetActiveUniform_PACKED *unpacked = (glGetActiveUniform_PACKED *)packed; \
    glGetActiveUniform_ARGS *args = (glGetActiveUniform_ARGS *)&unpacked->args; \
    glGetActiveUniform(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveUniform(glGetActiveUniform_ARG_EXPAND);
packed_call_t *pack_glGetActiveUniform(glGetActiveUniform_PACKED *_dst glGetActiveUniform_ARG_EXPAND_TAIL);
typedef void (*glGetActiveUniform_PTR)(glGetActiveUniform_ARG_EXPAND);
#endif
#ifndef glGetActiveUniformARB_RETURN
#define glGetActiveUniformARB_RETURN void
#define glGetActiveUniformARB_ARG_NAMES programObj, index, maxLength, length, size, type, name
#define glGetActiveUniformARB_ARG_EXPAND GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name
#define glGetActiveUniformARB_ARG_NAMES_TAIL , programObj, index, maxLength, length, size, type, name
#define glGetActiveUniformARB_ARG_EXPAND_TAIL , GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name
#define forward_glGetActiveUniformARB(_programObj, _index, _maxLength, _length, _size, _type, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveUniformARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveUniformARB(dst, _programObj, _index, _maxLength, _length, _size, _type, _name), NULL); \
    });
#define call_glGetActiveUniformARB(packed, ret_v) do { \
    glGetActiveUniformARB_PACKED *unpacked = (glGetActiveUniformARB_PACKED *)packed; \
    glGetActiveUniformARB_ARGS *args = (glGetActiveUniformARB_ARGS *)&unpacked->args; \
    glGetActiveUniformARB(args->programObj, args->index, args->maxLength, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveUniformARB(glGetActiveUniformARB_ARG_EXPAND);
packed_call_t *pack_glGetActiveUniformARB(glGetActiveUniformARB_PACKED *_dst glGetActiveUniformARB_ARG_EXPAND_TAIL);
typedef void (*glGetActiveUniformARB_PTR)(glGetActiveUniformARB_ARG_EXPAND);
#endif
#ifndef glGetActiveUniformBlockName_RETURN
#define glGetActiveUniformBlockName_RETURN void
#define glGetActiveUniformBlockName_ARG_NAMES program, uniformBlockIndex, bufSize, length, uniformBlockName
#define glGetActiveUniformBlockName_ARG_EXPAND GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName
#define glGetActiveUniformBlockName_ARG_NAMES_TAIL , program, uniformBlockIndex, bufSize, length, uniformBlockName
#define glGetActiveUniformBlockName_ARG_EXPAND_TAIL , GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName
#define forward_glGetActiveUniformBlockName(_program, _uniformBlockIndex, _bufSize, _length, _uniformBlockName) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveUniformBlockName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveUniformBlockName(dst, _program, _uniformBlockIndex, _bufSize, _length, _uniformBlockName), NULL); \
    });
#define call_glGetActiveUniformBlockName(packed, ret_v) do { \
    glGetActiveUniformBlockName_PACKED *unpacked = (glGetActiveUniformBlockName_PACKED *)packed; \
    glGetActiveUniformBlockName_ARGS *args = (glGetActiveUniformBlockName_ARGS *)&unpacked->args; \
    glGetActiveUniformBlockName(args->program, args->uniformBlockIndex, args->bufSize, args->length, args->uniformBlockName);; \
} while(0)
void glGetActiveUniformBlockName(glGetActiveUniformBlockName_ARG_EXPAND);
packed_call_t *pack_glGetActiveUniformBlockName(glGetActiveUniformBlockName_PACKED *_dst glGetActiveUniformBlockName_ARG_EXPAND_TAIL);
typedef void (*glGetActiveUniformBlockName_PTR)(glGetActiveUniformBlockName_ARG_EXPAND);
#endif
#ifndef glGetActiveUniformBlockiv_RETURN
#define glGetActiveUniformBlockiv_RETURN void
#define glGetActiveUniformBlockiv_ARG_NAMES program, uniformBlockIndex, pname, params
#define glGetActiveUniformBlockiv_ARG_EXPAND GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params
#define glGetActiveUniformBlockiv_ARG_NAMES_TAIL , program, uniformBlockIndex, pname, params
#define glGetActiveUniformBlockiv_ARG_EXPAND_TAIL , GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params
#define forward_glGetActiveUniformBlockiv(_program, _uniformBlockIndex, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveUniformBlockiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveUniformBlockiv(dst, _program, _uniformBlockIndex, _pname, _params), NULL); \
    });
#define call_glGetActiveUniformBlockiv(packed, ret_v) do { \
    glGetActiveUniformBlockiv_PACKED *unpacked = (glGetActiveUniformBlockiv_PACKED *)packed; \
    glGetActiveUniformBlockiv_ARGS *args = (glGetActiveUniformBlockiv_ARGS *)&unpacked->args; \
    glGetActiveUniformBlockiv(args->program, args->uniformBlockIndex, args->pname, args->params);; \
} while(0)
void glGetActiveUniformBlockiv(glGetActiveUniformBlockiv_ARG_EXPAND);
packed_call_t *pack_glGetActiveUniformBlockiv(glGetActiveUniformBlockiv_PACKED *_dst glGetActiveUniformBlockiv_ARG_EXPAND_TAIL);
typedef void (*glGetActiveUniformBlockiv_PTR)(glGetActiveUniformBlockiv_ARG_EXPAND);
#endif
#ifndef glGetActiveUniformName_RETURN
#define glGetActiveUniformName_RETURN void
#define glGetActiveUniformName_ARG_NAMES program, uniformIndex, bufSize, length, uniformName
#define glGetActiveUniformName_ARG_EXPAND GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName
#define glGetActiveUniformName_ARG_NAMES_TAIL , program, uniformIndex, bufSize, length, uniformName
#define glGetActiveUniformName_ARG_EXPAND_TAIL , GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName
#define forward_glGetActiveUniformName(_program, _uniformIndex, _bufSize, _length, _uniformName) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveUniformName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveUniformName(dst, _program, _uniformIndex, _bufSize, _length, _uniformName), NULL); \
    });
#define call_glGetActiveUniformName(packed, ret_v) do { \
    glGetActiveUniformName_PACKED *unpacked = (glGetActiveUniformName_PACKED *)packed; \
    glGetActiveUniformName_ARGS *args = (glGetActiveUniformName_ARGS *)&unpacked->args; \
    glGetActiveUniformName(args->program, args->uniformIndex, args->bufSize, args->length, args->uniformName);; \
} while(0)
void glGetActiveUniformName(glGetActiveUniformName_ARG_EXPAND);
packed_call_t *pack_glGetActiveUniformName(glGetActiveUniformName_PACKED *_dst glGetActiveUniformName_ARG_EXPAND_TAIL);
typedef void (*glGetActiveUniformName_PTR)(glGetActiveUniformName_ARG_EXPAND);
#endif
#ifndef glGetActiveUniformsiv_RETURN
#define glGetActiveUniformsiv_RETURN void
#define glGetActiveUniformsiv_ARG_NAMES program, uniformCount, uniformIndices, pname, params
#define glGetActiveUniformsiv_ARG_EXPAND GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params
#define glGetActiveUniformsiv_ARG_NAMES_TAIL , program, uniformCount, uniformIndices, pname, params
#define glGetActiveUniformsiv_ARG_EXPAND_TAIL , GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params
#define forward_glGetActiveUniformsiv(_program, _uniformCount, _uniformIndices, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveUniformsiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveUniformsiv(dst, _program, _uniformCount, _uniformIndices, _pname, _params), NULL); \
    });
#define call_glGetActiveUniformsiv(packed, ret_v) do { \
    glGetActiveUniformsiv_PACKED *unpacked = (glGetActiveUniformsiv_PACKED *)packed; \
    glGetActiveUniformsiv_ARGS *args = (glGetActiveUniformsiv_ARGS *)&unpacked->args; \
    glGetActiveUniformsiv(args->program, args->uniformCount, args->uniformIndices, args->pname, args->params);; \
} while(0)
void glGetActiveUniformsiv(glGetActiveUniformsiv_ARG_EXPAND);
packed_call_t *pack_glGetActiveUniformsiv(glGetActiveUniformsiv_PACKED *_dst glGetActiveUniformsiv_ARG_EXPAND_TAIL);
typedef void (*glGetActiveUniformsiv_PTR)(glGetActiveUniformsiv_ARG_EXPAND);
#endif
#ifndef glGetActiveVaryingNV_RETURN
#define glGetActiveVaryingNV_RETURN void
#define glGetActiveVaryingNV_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetActiveVaryingNV_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define glGetActiveVaryingNV_ARG_NAMES_TAIL , program, index, bufSize, length, size, type, name
#define glGetActiveVaryingNV_ARG_EXPAND_TAIL , GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define forward_glGetActiveVaryingNV(_program, _index, _bufSize, _length, _size, _type, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetActiveVaryingNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetActiveVaryingNV(dst, _program, _index, _bufSize, _length, _size, _type, _name), NULL); \
    });
#define call_glGetActiveVaryingNV(packed, ret_v) do { \
    glGetActiveVaryingNV_PACKED *unpacked = (glGetActiveVaryingNV_PACKED *)packed; \
    glGetActiveVaryingNV_ARGS *args = (glGetActiveVaryingNV_ARGS *)&unpacked->args; \
    glGetActiveVaryingNV(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveVaryingNV(glGetActiveVaryingNV_ARG_EXPAND);
packed_call_t *pack_glGetActiveVaryingNV(glGetActiveVaryingNV_PACKED *_dst glGetActiveVaryingNV_ARG_EXPAND_TAIL);
typedef void (*glGetActiveVaryingNV_PTR)(glGetActiveVaryingNV_ARG_EXPAND);
#endif
#ifndef glGetArrayObjectfvATI_RETURN
#define glGetArrayObjectfvATI_RETURN void
#define glGetArrayObjectfvATI_ARG_NAMES array, pname, params
#define glGetArrayObjectfvATI_ARG_EXPAND GLenum array, GLenum pname, GLfloat * params
#define glGetArrayObjectfvATI_ARG_NAMES_TAIL , array, pname, params
#define glGetArrayObjectfvATI_ARG_EXPAND_TAIL , GLenum array, GLenum pname, GLfloat * params
#define forward_glGetArrayObjectfvATI(_array, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetArrayObjectfvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetArrayObjectfvATI(dst, _array, _pname, _params), NULL); \
    });
#define call_glGetArrayObjectfvATI(packed, ret_v) do { \
    glGetArrayObjectfvATI_PACKED *unpacked = (glGetArrayObjectfvATI_PACKED *)packed; \
    glGetArrayObjectfvATI_ARGS *args = (glGetArrayObjectfvATI_ARGS *)&unpacked->args; \
    glGetArrayObjectfvATI(args->array, args->pname, args->params);; \
} while(0)
void glGetArrayObjectfvATI(glGetArrayObjectfvATI_ARG_EXPAND);
packed_call_t *pack_glGetArrayObjectfvATI(glGetArrayObjectfvATI_PACKED *_dst glGetArrayObjectfvATI_ARG_EXPAND_TAIL);
typedef void (*glGetArrayObjectfvATI_PTR)(glGetArrayObjectfvATI_ARG_EXPAND);
#endif
#ifndef glGetArrayObjectivATI_RETURN
#define glGetArrayObjectivATI_RETURN void
#define glGetArrayObjectivATI_ARG_NAMES array, pname, params
#define glGetArrayObjectivATI_ARG_EXPAND GLenum array, GLenum pname, GLint * params
#define glGetArrayObjectivATI_ARG_NAMES_TAIL , array, pname, params
#define glGetArrayObjectivATI_ARG_EXPAND_TAIL , GLenum array, GLenum pname, GLint * params
#define forward_glGetArrayObjectivATI(_array, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetArrayObjectivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetArrayObjectivATI(dst, _array, _pname, _params), NULL); \
    });
#define call_glGetArrayObjectivATI(packed, ret_v) do { \
    glGetArrayObjectivATI_PACKED *unpacked = (glGetArrayObjectivATI_PACKED *)packed; \
    glGetArrayObjectivATI_ARGS *args = (glGetArrayObjectivATI_ARGS *)&unpacked->args; \
    glGetArrayObjectivATI(args->array, args->pname, args->params);; \
} while(0)
void glGetArrayObjectivATI(glGetArrayObjectivATI_ARG_EXPAND);
packed_call_t *pack_glGetArrayObjectivATI(glGetArrayObjectivATI_PACKED *_dst glGetArrayObjectivATI_ARG_EXPAND_TAIL);
typedef void (*glGetArrayObjectivATI_PTR)(glGetArrayObjectivATI_ARG_EXPAND);
#endif
#ifndef glGetAttachedObjectsARB_RETURN
#define glGetAttachedObjectsARB_RETURN void
#define glGetAttachedObjectsARB_ARG_NAMES containerObj, maxCount, count, obj
#define glGetAttachedObjectsARB_ARG_EXPAND GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj
#define glGetAttachedObjectsARB_ARG_NAMES_TAIL , containerObj, maxCount, count, obj
#define glGetAttachedObjectsARB_ARG_EXPAND_TAIL , GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj
#define forward_glGetAttachedObjectsARB(_containerObj, _maxCount, _count, _obj) \
    ({ \
        void *dst = remote_dma(sizeof(glGetAttachedObjectsARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetAttachedObjectsARB(dst, _containerObj, _maxCount, _count, _obj), NULL); \
    });
#define call_glGetAttachedObjectsARB(packed, ret_v) do { \
    glGetAttachedObjectsARB_PACKED *unpacked = (glGetAttachedObjectsARB_PACKED *)packed; \
    glGetAttachedObjectsARB_ARGS *args = (glGetAttachedObjectsARB_ARGS *)&unpacked->args; \
    glGetAttachedObjectsARB(args->containerObj, args->maxCount, args->count, args->obj);; \
} while(0)
void glGetAttachedObjectsARB(glGetAttachedObjectsARB_ARG_EXPAND);
packed_call_t *pack_glGetAttachedObjectsARB(glGetAttachedObjectsARB_PACKED *_dst glGetAttachedObjectsARB_ARG_EXPAND_TAIL);
typedef void (*glGetAttachedObjectsARB_PTR)(glGetAttachedObjectsARB_ARG_EXPAND);
#endif
#ifndef glGetAttachedShaders_RETURN
#define glGetAttachedShaders_RETURN void
#define glGetAttachedShaders_ARG_NAMES program, maxCount, count, obj
#define glGetAttachedShaders_ARG_EXPAND GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj
#define glGetAttachedShaders_ARG_NAMES_TAIL , program, maxCount, count, obj
#define glGetAttachedShaders_ARG_EXPAND_TAIL , GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj
#define forward_glGetAttachedShaders(_program, _maxCount, _count, _obj) \
    ({ \
        void *dst = remote_dma(sizeof(glGetAttachedShaders_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetAttachedShaders(dst, _program, _maxCount, _count, _obj), NULL); \
    });
#define call_glGetAttachedShaders(packed, ret_v) do { \
    glGetAttachedShaders_PACKED *unpacked = (glGetAttachedShaders_PACKED *)packed; \
    glGetAttachedShaders_ARGS *args = (glGetAttachedShaders_ARGS *)&unpacked->args; \
    glGetAttachedShaders(args->program, args->maxCount, args->count, args->obj);; \
} while(0)
void glGetAttachedShaders(glGetAttachedShaders_ARG_EXPAND);
packed_call_t *pack_glGetAttachedShaders(glGetAttachedShaders_PACKED *_dst glGetAttachedShaders_ARG_EXPAND_TAIL);
typedef void (*glGetAttachedShaders_PTR)(glGetAttachedShaders_ARG_EXPAND);
#endif
#ifndef glGetAttribLocation_RETURN
#define glGetAttribLocation_RETURN GLint
#define glGetAttribLocation_ARG_NAMES program, name
#define glGetAttribLocation_ARG_EXPAND GLuint program, const GLchar * name
#define glGetAttribLocation_ARG_NAMES_TAIL , program, name
#define glGetAttribLocation_ARG_EXPAND_TAIL , GLuint program, const GLchar * name
#define forward_glGetAttribLocation(_program, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetAttribLocation_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetAttribLocation(dst, _program, _name), &ret); \
        ret; \
    });
#define call_glGetAttribLocation(packed, ret_v) do { \
    glGetAttribLocation_PACKED *unpacked = (glGetAttribLocation_PACKED *)packed; \
    glGetAttribLocation_ARGS *args = (glGetAttribLocation_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetAttribLocation(args->program, args->name);; \
    } else { \
        glGetAttribLocation(args->program, args->name);; \
    } \
} while(0)
GLint glGetAttribLocation(glGetAttribLocation_ARG_EXPAND);
packed_call_t *pack_glGetAttribLocation(glGetAttribLocation_PACKED *_dst glGetAttribLocation_ARG_EXPAND_TAIL);
typedef GLint (*glGetAttribLocation_PTR)(glGetAttribLocation_ARG_EXPAND);
#endif
#ifndef glGetAttribLocationARB_RETURN
#define glGetAttribLocationARB_RETURN GLint
#define glGetAttribLocationARB_ARG_NAMES programObj, name
#define glGetAttribLocationARB_ARG_EXPAND GLhandleARB programObj, const GLcharARB * name
#define glGetAttribLocationARB_ARG_NAMES_TAIL , programObj, name
#define glGetAttribLocationARB_ARG_EXPAND_TAIL , GLhandleARB programObj, const GLcharARB * name
#define forward_glGetAttribLocationARB(_programObj, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetAttribLocationARB_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetAttribLocationARB(dst, _programObj, _name), &ret); \
        ret; \
    });
#define call_glGetAttribLocationARB(packed, ret_v) do { \
    glGetAttribLocationARB_PACKED *unpacked = (glGetAttribLocationARB_PACKED *)packed; \
    glGetAttribLocationARB_ARGS *args = (glGetAttribLocationARB_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetAttribLocationARB(args->programObj, args->name);; \
    } else { \
        glGetAttribLocationARB(args->programObj, args->name);; \
    } \
} while(0)
GLint glGetAttribLocationARB(glGetAttribLocationARB_ARG_EXPAND);
packed_call_t *pack_glGetAttribLocationARB(glGetAttribLocationARB_PACKED *_dst glGetAttribLocationARB_ARG_EXPAND_TAIL);
typedef GLint (*glGetAttribLocationARB_PTR)(glGetAttribLocationARB_ARG_EXPAND);
#endif
#ifndef glGetBooleanIndexedvEXT_RETURN
#define glGetBooleanIndexedvEXT_RETURN void
#define glGetBooleanIndexedvEXT_ARG_NAMES target, index, data
#define glGetBooleanIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLboolean * data
#define glGetBooleanIndexedvEXT_ARG_NAMES_TAIL , target, index, data
#define glGetBooleanIndexedvEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLboolean * data
#define forward_glGetBooleanIndexedvEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBooleanIndexedvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBooleanIndexedvEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetBooleanIndexedvEXT(packed, ret_v) do { \
    glGetBooleanIndexedvEXT_PACKED *unpacked = (glGetBooleanIndexedvEXT_PACKED *)packed; \
    glGetBooleanIndexedvEXT_ARGS *args = (glGetBooleanIndexedvEXT_ARGS *)&unpacked->args; \
    glGetBooleanIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetBooleanIndexedvEXT(glGetBooleanIndexedvEXT_ARG_EXPAND);
packed_call_t *pack_glGetBooleanIndexedvEXT(glGetBooleanIndexedvEXT_PACKED *_dst glGetBooleanIndexedvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetBooleanIndexedvEXT_PTR)(glGetBooleanIndexedvEXT_ARG_EXPAND);
#endif
#ifndef glGetBooleani_v_RETURN
#define glGetBooleani_v_RETURN void
#define glGetBooleani_v_ARG_NAMES target, index, data
#define glGetBooleani_v_ARG_EXPAND GLenum target, GLuint index, GLboolean * data
#define glGetBooleani_v_ARG_NAMES_TAIL , target, index, data
#define glGetBooleani_v_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLboolean * data
#define forward_glGetBooleani_v(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBooleani_v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBooleani_v(dst, _target, _index, _data), NULL); \
    });
#define call_glGetBooleani_v(packed, ret_v) do { \
    glGetBooleani_v_PACKED *unpacked = (glGetBooleani_v_PACKED *)packed; \
    glGetBooleani_v_ARGS *args = (glGetBooleani_v_ARGS *)&unpacked->args; \
    glGetBooleani_v(args->target, args->index, args->data);; \
} while(0)
void glGetBooleani_v(glGetBooleani_v_ARG_EXPAND);
packed_call_t *pack_glGetBooleani_v(glGetBooleani_v_PACKED *_dst glGetBooleani_v_ARG_EXPAND_TAIL);
typedef void (*glGetBooleani_v_PTR)(glGetBooleani_v_ARG_EXPAND);
#endif
#ifndef glGetBooleanv_RETURN
#define glGetBooleanv_RETURN void
#define glGetBooleanv_ARG_NAMES pname, params
#define glGetBooleanv_ARG_EXPAND GLenum pname, GLboolean * params
#define glGetBooleanv_ARG_NAMES_TAIL , pname, params
#define glGetBooleanv_ARG_EXPAND_TAIL , GLenum pname, GLboolean * params
#define forward_glGetBooleanv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBooleanv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBooleanv(dst, _pname, _params), NULL); \
    });
#define call_glGetBooleanv(packed, ret_v) do { \
    glGetBooleanv_PACKED *unpacked = (glGetBooleanv_PACKED *)packed; \
    glGetBooleanv_ARGS *args = (glGetBooleanv_ARGS *)&unpacked->args; \
    glGetBooleanv(args->pname, args->params);; \
} while(0)
void glGetBooleanv(glGetBooleanv_ARG_EXPAND);
packed_call_t *pack_glGetBooleanv(glGetBooleanv_PACKED *_dst glGetBooleanv_ARG_EXPAND_TAIL);
typedef void (*glGetBooleanv_PTR)(glGetBooleanv_ARG_EXPAND);
#endif
#ifndef glGetBufferParameteri64v_RETURN
#define glGetBufferParameteri64v_RETURN void
#define glGetBufferParameteri64v_ARG_NAMES target, pname, params
#define glGetBufferParameteri64v_ARG_EXPAND GLenum target, GLenum pname, GLint64 * params
#define glGetBufferParameteri64v_ARG_NAMES_TAIL , target, pname, params
#define glGetBufferParameteri64v_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint64 * params
#define forward_glGetBufferParameteri64v(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferParameteri64v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferParameteri64v(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetBufferParameteri64v(packed, ret_v) do { \
    glGetBufferParameteri64v_PACKED *unpacked = (glGetBufferParameteri64v_PACKED *)packed; \
    glGetBufferParameteri64v_ARGS *args = (glGetBufferParameteri64v_ARGS *)&unpacked->args; \
    glGetBufferParameteri64v(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameteri64v(glGetBufferParameteri64v_ARG_EXPAND);
packed_call_t *pack_glGetBufferParameteri64v(glGetBufferParameteri64v_PACKED *_dst glGetBufferParameteri64v_ARG_EXPAND_TAIL);
typedef void (*glGetBufferParameteri64v_PTR)(glGetBufferParameteri64v_ARG_EXPAND);
#endif
#ifndef glGetBufferParameteriv_RETURN
#define glGetBufferParameteriv_RETURN void
#define glGetBufferParameteriv_ARG_NAMES target, pname, params
#define glGetBufferParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetBufferParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetBufferParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetBufferParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetBufferParameteriv(packed, ret_v) do { \
    glGetBufferParameteriv_PACKED *unpacked = (glGetBufferParameteriv_PACKED *)packed; \
    glGetBufferParameteriv_ARGS *args = (glGetBufferParameteriv_ARGS *)&unpacked->args; \
    glGetBufferParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameteriv(glGetBufferParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetBufferParameteriv(glGetBufferParameteriv_PACKED *_dst glGetBufferParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetBufferParameteriv_PTR)(glGetBufferParameteriv_ARG_EXPAND);
#endif
#ifndef glGetBufferParameterivARB_RETURN
#define glGetBufferParameterivARB_RETURN void
#define glGetBufferParameterivARB_ARG_NAMES target, pname, params
#define glGetBufferParameterivARB_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetBufferParameterivARB_ARG_NAMES_TAIL , target, pname, params
#define glGetBufferParameterivARB_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetBufferParameterivARB(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferParameterivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferParameterivARB(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetBufferParameterivARB(packed, ret_v) do { \
    glGetBufferParameterivARB_PACKED *unpacked = (glGetBufferParameterivARB_PACKED *)packed; \
    glGetBufferParameterivARB_ARGS *args = (glGetBufferParameterivARB_ARGS *)&unpacked->args; \
    glGetBufferParameterivARB(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameterivARB(glGetBufferParameterivARB_ARG_EXPAND);
packed_call_t *pack_glGetBufferParameterivARB(glGetBufferParameterivARB_PACKED *_dst glGetBufferParameterivARB_ARG_EXPAND_TAIL);
typedef void (*glGetBufferParameterivARB_PTR)(glGetBufferParameterivARB_ARG_EXPAND);
#endif
#ifndef glGetBufferParameterui64vNV_RETURN
#define glGetBufferParameterui64vNV_RETURN void
#define glGetBufferParameterui64vNV_ARG_NAMES target, pname, params
#define glGetBufferParameterui64vNV_ARG_EXPAND GLenum target, GLenum pname, GLuint64EXT * params
#define glGetBufferParameterui64vNV_ARG_NAMES_TAIL , target, pname, params
#define glGetBufferParameterui64vNV_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLuint64EXT * params
#define forward_glGetBufferParameterui64vNV(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferParameterui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferParameterui64vNV(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetBufferParameterui64vNV(packed, ret_v) do { \
    glGetBufferParameterui64vNV_PACKED *unpacked = (glGetBufferParameterui64vNV_PACKED *)packed; \
    glGetBufferParameterui64vNV_ARGS *args = (glGetBufferParameterui64vNV_ARGS *)&unpacked->args; \
    glGetBufferParameterui64vNV(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameterui64vNV(glGetBufferParameterui64vNV_ARG_EXPAND);
packed_call_t *pack_glGetBufferParameterui64vNV(glGetBufferParameterui64vNV_PACKED *_dst glGetBufferParameterui64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetBufferParameterui64vNV_PTR)(glGetBufferParameterui64vNV_ARG_EXPAND);
#endif
#ifndef glGetBufferPointerv_RETURN
#define glGetBufferPointerv_RETURN void
#define glGetBufferPointerv_ARG_NAMES target, pname, params
#define glGetBufferPointerv_ARG_EXPAND GLenum target, GLenum pname, GLvoid * params
#define glGetBufferPointerv_ARG_NAMES_TAIL , target, pname, params
#define glGetBufferPointerv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLvoid * params
#define forward_glGetBufferPointerv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferPointerv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferPointerv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetBufferPointerv(packed, ret_v) do { \
    glGetBufferPointerv_PACKED *unpacked = (glGetBufferPointerv_PACKED *)packed; \
    glGetBufferPointerv_ARGS *args = (glGetBufferPointerv_ARGS *)&unpacked->args; \
    glGetBufferPointerv(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferPointerv(glGetBufferPointerv_ARG_EXPAND);
packed_call_t *pack_glGetBufferPointerv(glGetBufferPointerv_PACKED *_dst glGetBufferPointerv_ARG_EXPAND_TAIL);
typedef void (*glGetBufferPointerv_PTR)(glGetBufferPointerv_ARG_EXPAND);
#endif
#ifndef glGetBufferPointervARB_RETURN
#define glGetBufferPointervARB_RETURN void
#define glGetBufferPointervARB_ARG_NAMES target, pname, params
#define glGetBufferPointervARB_ARG_EXPAND GLenum target, GLenum pname, GLvoid * params
#define glGetBufferPointervARB_ARG_NAMES_TAIL , target, pname, params
#define glGetBufferPointervARB_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLvoid * params
#define forward_glGetBufferPointervARB(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferPointervARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferPointervARB(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetBufferPointervARB(packed, ret_v) do { \
    glGetBufferPointervARB_PACKED *unpacked = (glGetBufferPointervARB_PACKED *)packed; \
    glGetBufferPointervARB_ARGS *args = (glGetBufferPointervARB_ARGS *)&unpacked->args; \
    glGetBufferPointervARB(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferPointervARB(glGetBufferPointervARB_ARG_EXPAND);
packed_call_t *pack_glGetBufferPointervARB(glGetBufferPointervARB_PACKED *_dst glGetBufferPointervARB_ARG_EXPAND_TAIL);
typedef void (*glGetBufferPointervARB_PTR)(glGetBufferPointervARB_ARG_EXPAND);
#endif
#ifndef glGetBufferSubData_RETURN
#define glGetBufferSubData_RETURN void
#define glGetBufferSubData_ARG_NAMES target, offset, size, data
#define glGetBufferSubData_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data
#define glGetBufferSubData_ARG_NAMES_TAIL , target, offset, size, data
#define glGetBufferSubData_ARG_EXPAND_TAIL , GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data
#define forward_glGetBufferSubData(_target, _offset, _size, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferSubData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferSubData(dst, _target, _offset, _size, _data), NULL); \
    });
#define call_glGetBufferSubData(packed, ret_v) do { \
    glGetBufferSubData_PACKED *unpacked = (glGetBufferSubData_PACKED *)packed; \
    glGetBufferSubData_ARGS *args = (glGetBufferSubData_ARGS *)&unpacked->args; \
    glGetBufferSubData(args->target, args->offset, args->size, args->data);; \
} while(0)
void glGetBufferSubData(glGetBufferSubData_ARG_EXPAND);
packed_call_t *pack_glGetBufferSubData(glGetBufferSubData_PACKED *_dst glGetBufferSubData_ARG_EXPAND_TAIL);
typedef void (*glGetBufferSubData_PTR)(glGetBufferSubData_ARG_EXPAND);
#endif
#ifndef glGetBufferSubDataARB_RETURN
#define glGetBufferSubDataARB_RETURN void
#define glGetBufferSubDataARB_ARG_NAMES target, offset, size, data
#define glGetBufferSubDataARB_ARG_EXPAND GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data
#define glGetBufferSubDataARB_ARG_NAMES_TAIL , target, offset, size, data
#define glGetBufferSubDataARB_ARG_EXPAND_TAIL , GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data
#define forward_glGetBufferSubDataARB(_target, _offset, _size, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetBufferSubDataARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetBufferSubDataARB(dst, _target, _offset, _size, _data), NULL); \
    });
#define call_glGetBufferSubDataARB(packed, ret_v) do { \
    glGetBufferSubDataARB_PACKED *unpacked = (glGetBufferSubDataARB_PACKED *)packed; \
    glGetBufferSubDataARB_ARGS *args = (glGetBufferSubDataARB_ARGS *)&unpacked->args; \
    glGetBufferSubDataARB(args->target, args->offset, args->size, args->data);; \
} while(0)
void glGetBufferSubDataARB(glGetBufferSubDataARB_ARG_EXPAND);
packed_call_t *pack_glGetBufferSubDataARB(glGetBufferSubDataARB_PACKED *_dst glGetBufferSubDataARB_ARG_EXPAND_TAIL);
typedef void (*glGetBufferSubDataARB_PTR)(glGetBufferSubDataARB_ARG_EXPAND);
#endif
#ifndef glGetClipPlane_RETURN
#define glGetClipPlane_RETURN void
#define glGetClipPlane_ARG_NAMES plane, equation
#define glGetClipPlane_ARG_EXPAND GLenum plane, GLdouble * equation
#define glGetClipPlane_ARG_NAMES_TAIL , plane, equation
#define glGetClipPlane_ARG_EXPAND_TAIL , GLenum plane, GLdouble * equation
#define forward_glGetClipPlane(_plane, _equation) \
    ({ \
        void *dst = remote_dma(sizeof(glGetClipPlane_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetClipPlane(dst, _plane, _equation), NULL); \
    });
#define call_glGetClipPlane(packed, ret_v) do { \
    glGetClipPlane_PACKED *unpacked = (glGetClipPlane_PACKED *)packed; \
    glGetClipPlane_ARGS *args = (glGetClipPlane_ARGS *)&unpacked->args; \
    glGetClipPlane(args->plane, args->equation);; \
} while(0)
void glGetClipPlane(glGetClipPlane_ARG_EXPAND);
packed_call_t *pack_glGetClipPlane(glGetClipPlane_PACKED *_dst glGetClipPlane_ARG_EXPAND_TAIL);
typedef void (*glGetClipPlane_PTR)(glGetClipPlane_ARG_EXPAND);
#endif
#ifndef glGetClipPlanefOES_RETURN
#define glGetClipPlanefOES_RETURN void
#define glGetClipPlanefOES_ARG_NAMES plane, equation
#define glGetClipPlanefOES_ARG_EXPAND GLenum plane, GLfloat * equation
#define glGetClipPlanefOES_ARG_NAMES_TAIL , plane, equation
#define glGetClipPlanefOES_ARG_EXPAND_TAIL , GLenum plane, GLfloat * equation
#define forward_glGetClipPlanefOES(_plane, _equation) \
    ({ \
        void *dst = remote_dma(sizeof(glGetClipPlanefOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetClipPlanefOES(dst, _plane, _equation), NULL); \
    });
#define call_glGetClipPlanefOES(packed, ret_v) do { \
    glGetClipPlanefOES_PACKED *unpacked = (glGetClipPlanefOES_PACKED *)packed; \
    glGetClipPlanefOES_ARGS *args = (glGetClipPlanefOES_ARGS *)&unpacked->args; \
    glGetClipPlanefOES(args->plane, args->equation);; \
} while(0)
void glGetClipPlanefOES(glGetClipPlanefOES_ARG_EXPAND);
packed_call_t *pack_glGetClipPlanefOES(glGetClipPlanefOES_PACKED *_dst glGetClipPlanefOES_ARG_EXPAND_TAIL);
typedef void (*glGetClipPlanefOES_PTR)(glGetClipPlanefOES_ARG_EXPAND);
#endif
#ifndef glGetClipPlanexOES_RETURN
#define glGetClipPlanexOES_RETURN void
#define glGetClipPlanexOES_ARG_NAMES plane, equation
#define glGetClipPlanexOES_ARG_EXPAND GLenum plane, GLfixed * equation
#define glGetClipPlanexOES_ARG_NAMES_TAIL , plane, equation
#define glGetClipPlanexOES_ARG_EXPAND_TAIL , GLenum plane, GLfixed * equation
#define forward_glGetClipPlanexOES(_plane, _equation) \
    ({ \
        void *dst = remote_dma(sizeof(glGetClipPlanexOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetClipPlanexOES(dst, _plane, _equation), NULL); \
    });
#define call_glGetClipPlanexOES(packed, ret_v) do { \
    glGetClipPlanexOES_PACKED *unpacked = (glGetClipPlanexOES_PACKED *)packed; \
    glGetClipPlanexOES_ARGS *args = (glGetClipPlanexOES_ARGS *)&unpacked->args; \
    glGetClipPlanexOES(args->plane, args->equation);; \
} while(0)
void glGetClipPlanexOES(glGetClipPlanexOES_ARG_EXPAND);
packed_call_t *pack_glGetClipPlanexOES(glGetClipPlanexOES_PACKED *_dst glGetClipPlanexOES_ARG_EXPAND_TAIL);
typedef void (*glGetClipPlanexOES_PTR)(glGetClipPlanexOES_ARG_EXPAND);
#endif
#ifndef glGetColorTable_RETURN
#define glGetColorTable_RETURN void
#define glGetColorTable_ARG_NAMES target, format, type, table
#define glGetColorTable_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * table
#define glGetColorTable_ARG_NAMES_TAIL , target, format, type, table
#define glGetColorTable_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLvoid * table
#define forward_glGetColorTable(_target, _format, _type, _table) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTable_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTable(dst, _target, _format, _type, _table), NULL); \
    });
#define call_glGetColorTable(packed, ret_v) do { \
    glGetColorTable_PACKED *unpacked = (glGetColorTable_PACKED *)packed; \
    glGetColorTable_ARGS *args = (glGetColorTable_ARGS *)&unpacked->args; \
    glGetColorTable(args->target, args->format, args->type, args->table);; \
} while(0)
void glGetColorTable(glGetColorTable_ARG_EXPAND);
packed_call_t *pack_glGetColorTable(glGetColorTable_PACKED *_dst glGetColorTable_ARG_EXPAND_TAIL);
typedef void (*glGetColorTable_PTR)(glGetColorTable_ARG_EXPAND);
#endif
#ifndef glGetColorTableEXT_RETURN
#define glGetColorTableEXT_RETURN void
#define glGetColorTableEXT_ARG_NAMES target, format, type, data
#define glGetColorTableEXT_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * data
#define glGetColorTableEXT_ARG_NAMES_TAIL , target, format, type, data
#define glGetColorTableEXT_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLvoid * data
#define forward_glGetColorTableEXT(_target, _format, _type, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableEXT(dst, _target, _format, _type, _data), NULL); \
    });
#define call_glGetColorTableEXT(packed, ret_v) do { \
    glGetColorTableEXT_PACKED *unpacked = (glGetColorTableEXT_PACKED *)packed; \
    glGetColorTableEXT_ARGS *args = (glGetColorTableEXT_ARGS *)&unpacked->args; \
    glGetColorTableEXT(args->target, args->format, args->type, args->data);; \
} while(0)
void glGetColorTableEXT(glGetColorTableEXT_ARG_EXPAND);
packed_call_t *pack_glGetColorTableEXT(glGetColorTableEXT_PACKED *_dst glGetColorTableEXT_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableEXT_PTR)(glGetColorTableEXT_ARG_EXPAND);
#endif
#ifndef glGetColorTableParameterfv_RETURN
#define glGetColorTableParameterfv_RETURN void
#define glGetColorTableParameterfv_ARG_NAMES target, pname, params
#define glGetColorTableParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetColorTableParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glGetColorTableParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetColorTableParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetColorTableParameterfv(packed, ret_v) do { \
    glGetColorTableParameterfv_PACKED *unpacked = (glGetColorTableParameterfv_PACKED *)packed; \
    glGetColorTableParameterfv_ARGS *args = (glGetColorTableParameterfv_ARGS *)&unpacked->args; \
    glGetColorTableParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterfv(glGetColorTableParameterfv_ARG_EXPAND);
packed_call_t *pack_glGetColorTableParameterfv(glGetColorTableParameterfv_PACKED *_dst glGetColorTableParameterfv_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableParameterfv_PTR)(glGetColorTableParameterfv_ARG_EXPAND);
#endif
#ifndef glGetColorTableParameterfvEXT_RETURN
#define glGetColorTableParameterfvEXT_RETURN void
#define glGetColorTableParameterfvEXT_ARG_NAMES target, pname, params
#define glGetColorTableParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetColorTableParameterfvEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetColorTableParameterfvEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetColorTableParameterfvEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableParameterfvEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetColorTableParameterfvEXT(packed, ret_v) do { \
    glGetColorTableParameterfvEXT_PACKED *unpacked = (glGetColorTableParameterfvEXT_PACKED *)packed; \
    glGetColorTableParameterfvEXT_ARGS *args = (glGetColorTableParameterfvEXT_ARGS *)&unpacked->args; \
    glGetColorTableParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterfvEXT(glGetColorTableParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetColorTableParameterfvEXT(glGetColorTableParameterfvEXT_PACKED *_dst glGetColorTableParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableParameterfvEXT_PTR)(glGetColorTableParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetColorTableParameterfvSGI_RETURN
#define glGetColorTableParameterfvSGI_RETURN void
#define glGetColorTableParameterfvSGI_ARG_NAMES target, pname, params
#define glGetColorTableParameterfvSGI_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetColorTableParameterfvSGI_ARG_NAMES_TAIL , target, pname, params
#define glGetColorTableParameterfvSGI_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetColorTableParameterfvSGI(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableParameterfvSGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableParameterfvSGI(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetColorTableParameterfvSGI(packed, ret_v) do { \
    glGetColorTableParameterfvSGI_PACKED *unpacked = (glGetColorTableParameterfvSGI_PACKED *)packed; \
    glGetColorTableParameterfvSGI_ARGS *args = (glGetColorTableParameterfvSGI_ARGS *)&unpacked->args; \
    glGetColorTableParameterfvSGI(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterfvSGI(glGetColorTableParameterfvSGI_ARG_EXPAND);
packed_call_t *pack_glGetColorTableParameterfvSGI(glGetColorTableParameterfvSGI_PACKED *_dst glGetColorTableParameterfvSGI_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableParameterfvSGI_PTR)(glGetColorTableParameterfvSGI_ARG_EXPAND);
#endif
#ifndef glGetColorTableParameteriv_RETURN
#define glGetColorTableParameteriv_RETURN void
#define glGetColorTableParameteriv_ARG_NAMES target, pname, params
#define glGetColorTableParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetColorTableParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetColorTableParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetColorTableParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetColorTableParameteriv(packed, ret_v) do { \
    glGetColorTableParameteriv_PACKED *unpacked = (glGetColorTableParameteriv_PACKED *)packed; \
    glGetColorTableParameteriv_ARGS *args = (glGetColorTableParameteriv_ARGS *)&unpacked->args; \
    glGetColorTableParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameteriv(glGetColorTableParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetColorTableParameteriv(glGetColorTableParameteriv_PACKED *_dst glGetColorTableParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableParameteriv_PTR)(glGetColorTableParameteriv_ARG_EXPAND);
#endif
#ifndef glGetColorTableParameterivEXT_RETURN
#define glGetColorTableParameterivEXT_RETURN void
#define glGetColorTableParameterivEXT_ARG_NAMES target, pname, params
#define glGetColorTableParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetColorTableParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetColorTableParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetColorTableParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetColorTableParameterivEXT(packed, ret_v) do { \
    glGetColorTableParameterivEXT_PACKED *unpacked = (glGetColorTableParameterivEXT_PACKED *)packed; \
    glGetColorTableParameterivEXT_ARGS *args = (glGetColorTableParameterivEXT_ARGS *)&unpacked->args; \
    glGetColorTableParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterivEXT(glGetColorTableParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetColorTableParameterivEXT(glGetColorTableParameterivEXT_PACKED *_dst glGetColorTableParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableParameterivEXT_PTR)(glGetColorTableParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetColorTableParameterivSGI_RETURN
#define glGetColorTableParameterivSGI_RETURN void
#define glGetColorTableParameterivSGI_ARG_NAMES target, pname, params
#define glGetColorTableParameterivSGI_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetColorTableParameterivSGI_ARG_NAMES_TAIL , target, pname, params
#define glGetColorTableParameterivSGI_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetColorTableParameterivSGI(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableParameterivSGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableParameterivSGI(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetColorTableParameterivSGI(packed, ret_v) do { \
    glGetColorTableParameterivSGI_PACKED *unpacked = (glGetColorTableParameterivSGI_PACKED *)packed; \
    glGetColorTableParameterivSGI_ARGS *args = (glGetColorTableParameterivSGI_ARGS *)&unpacked->args; \
    glGetColorTableParameterivSGI(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterivSGI(glGetColorTableParameterivSGI_ARG_EXPAND);
packed_call_t *pack_glGetColorTableParameterivSGI(glGetColorTableParameterivSGI_PACKED *_dst glGetColorTableParameterivSGI_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableParameterivSGI_PTR)(glGetColorTableParameterivSGI_ARG_EXPAND);
#endif
#ifndef glGetColorTableSGI_RETURN
#define glGetColorTableSGI_RETURN void
#define glGetColorTableSGI_ARG_NAMES target, format, type, table
#define glGetColorTableSGI_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * table
#define glGetColorTableSGI_ARG_NAMES_TAIL , target, format, type, table
#define glGetColorTableSGI_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLvoid * table
#define forward_glGetColorTableSGI(_target, _format, _type, _table) \
    ({ \
        void *dst = remote_dma(sizeof(glGetColorTableSGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetColorTableSGI(dst, _target, _format, _type, _table), NULL); \
    });
#define call_glGetColorTableSGI(packed, ret_v) do { \
    glGetColorTableSGI_PACKED *unpacked = (glGetColorTableSGI_PACKED *)packed; \
    glGetColorTableSGI_ARGS *args = (glGetColorTableSGI_ARGS *)&unpacked->args; \
    glGetColorTableSGI(args->target, args->format, args->type, args->table);; \
} while(0)
void glGetColorTableSGI(glGetColorTableSGI_ARG_EXPAND);
packed_call_t *pack_glGetColorTableSGI(glGetColorTableSGI_PACKED *_dst glGetColorTableSGI_ARG_EXPAND_TAIL);
typedef void (*glGetColorTableSGI_PTR)(glGetColorTableSGI_ARG_EXPAND);
#endif
#ifndef glGetCombinerInputParameterfvNV_RETURN
#define glGetCombinerInputParameterfvNV_RETURN void
#define glGetCombinerInputParameterfvNV_ARG_NAMES stage, portion, variable, pname, params
#define glGetCombinerInputParameterfvNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params
#define glGetCombinerInputParameterfvNV_ARG_NAMES_TAIL , stage, portion, variable, pname, params
#define glGetCombinerInputParameterfvNV_ARG_EXPAND_TAIL , GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params
#define forward_glGetCombinerInputParameterfvNV(_stage, _portion, _variable, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCombinerInputParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCombinerInputParameterfvNV(dst, _stage, _portion, _variable, _pname, _params), NULL); \
    });
#define call_glGetCombinerInputParameterfvNV(packed, ret_v) do { \
    glGetCombinerInputParameterfvNV_PACKED *unpacked = (glGetCombinerInputParameterfvNV_PACKED *)packed; \
    glGetCombinerInputParameterfvNV_ARGS *args = (glGetCombinerInputParameterfvNV_ARGS *)&unpacked->args; \
    glGetCombinerInputParameterfvNV(args->stage, args->portion, args->variable, args->pname, args->params);; \
} while(0)
void glGetCombinerInputParameterfvNV(glGetCombinerInputParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetCombinerInputParameterfvNV(glGetCombinerInputParameterfvNV_PACKED *_dst glGetCombinerInputParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetCombinerInputParameterfvNV_PTR)(glGetCombinerInputParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetCombinerInputParameterivNV_RETURN
#define glGetCombinerInputParameterivNV_RETURN void
#define glGetCombinerInputParameterivNV_ARG_NAMES stage, portion, variable, pname, params
#define glGetCombinerInputParameterivNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params
#define glGetCombinerInputParameterivNV_ARG_NAMES_TAIL , stage, portion, variable, pname, params
#define glGetCombinerInputParameterivNV_ARG_EXPAND_TAIL , GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params
#define forward_glGetCombinerInputParameterivNV(_stage, _portion, _variable, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCombinerInputParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCombinerInputParameterivNV(dst, _stage, _portion, _variable, _pname, _params), NULL); \
    });
#define call_glGetCombinerInputParameterivNV(packed, ret_v) do { \
    glGetCombinerInputParameterivNV_PACKED *unpacked = (glGetCombinerInputParameterivNV_PACKED *)packed; \
    glGetCombinerInputParameterivNV_ARGS *args = (glGetCombinerInputParameterivNV_ARGS *)&unpacked->args; \
    glGetCombinerInputParameterivNV(args->stage, args->portion, args->variable, args->pname, args->params);; \
} while(0)
void glGetCombinerInputParameterivNV(glGetCombinerInputParameterivNV_ARG_EXPAND);
packed_call_t *pack_glGetCombinerInputParameterivNV(glGetCombinerInputParameterivNV_PACKED *_dst glGetCombinerInputParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glGetCombinerInputParameterivNV_PTR)(glGetCombinerInputParameterivNV_ARG_EXPAND);
#endif
#ifndef glGetCombinerOutputParameterfvNV_RETURN
#define glGetCombinerOutputParameterfvNV_RETURN void
#define glGetCombinerOutputParameterfvNV_ARG_NAMES stage, portion, pname, params
#define glGetCombinerOutputParameterfvNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum pname, GLfloat * params
#define glGetCombinerOutputParameterfvNV_ARG_NAMES_TAIL , stage, portion, pname, params
#define glGetCombinerOutputParameterfvNV_ARG_EXPAND_TAIL , GLenum stage, GLenum portion, GLenum pname, GLfloat * params
#define forward_glGetCombinerOutputParameterfvNV(_stage, _portion, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCombinerOutputParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCombinerOutputParameterfvNV(dst, _stage, _portion, _pname, _params), NULL); \
    });
#define call_glGetCombinerOutputParameterfvNV(packed, ret_v) do { \
    glGetCombinerOutputParameterfvNV_PACKED *unpacked = (glGetCombinerOutputParameterfvNV_PACKED *)packed; \
    glGetCombinerOutputParameterfvNV_ARGS *args = (glGetCombinerOutputParameterfvNV_ARGS *)&unpacked->args; \
    glGetCombinerOutputParameterfvNV(args->stage, args->portion, args->pname, args->params);; \
} while(0)
void glGetCombinerOutputParameterfvNV(glGetCombinerOutputParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetCombinerOutputParameterfvNV(glGetCombinerOutputParameterfvNV_PACKED *_dst glGetCombinerOutputParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetCombinerOutputParameterfvNV_PTR)(glGetCombinerOutputParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetCombinerOutputParameterivNV_RETURN
#define glGetCombinerOutputParameterivNV_RETURN void
#define glGetCombinerOutputParameterivNV_ARG_NAMES stage, portion, pname, params
#define glGetCombinerOutputParameterivNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum pname, GLint * params
#define glGetCombinerOutputParameterivNV_ARG_NAMES_TAIL , stage, portion, pname, params
#define glGetCombinerOutputParameterivNV_ARG_EXPAND_TAIL , GLenum stage, GLenum portion, GLenum pname, GLint * params
#define forward_glGetCombinerOutputParameterivNV(_stage, _portion, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCombinerOutputParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCombinerOutputParameterivNV(dst, _stage, _portion, _pname, _params), NULL); \
    });
#define call_glGetCombinerOutputParameterivNV(packed, ret_v) do { \
    glGetCombinerOutputParameterivNV_PACKED *unpacked = (glGetCombinerOutputParameterivNV_PACKED *)packed; \
    glGetCombinerOutputParameterivNV_ARGS *args = (glGetCombinerOutputParameterivNV_ARGS *)&unpacked->args; \
    glGetCombinerOutputParameterivNV(args->stage, args->portion, args->pname, args->params);; \
} while(0)
void glGetCombinerOutputParameterivNV(glGetCombinerOutputParameterivNV_ARG_EXPAND);
packed_call_t *pack_glGetCombinerOutputParameterivNV(glGetCombinerOutputParameterivNV_PACKED *_dst glGetCombinerOutputParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glGetCombinerOutputParameterivNV_PTR)(glGetCombinerOutputParameterivNV_ARG_EXPAND);
#endif
#ifndef glGetCombinerStageParameterfvNV_RETURN
#define glGetCombinerStageParameterfvNV_RETURN void
#define glGetCombinerStageParameterfvNV_ARG_NAMES stage, pname, params
#define glGetCombinerStageParameterfvNV_ARG_EXPAND GLenum stage, GLenum pname, GLfloat * params
#define glGetCombinerStageParameterfvNV_ARG_NAMES_TAIL , stage, pname, params
#define glGetCombinerStageParameterfvNV_ARG_EXPAND_TAIL , GLenum stage, GLenum pname, GLfloat * params
#define forward_glGetCombinerStageParameterfvNV(_stage, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCombinerStageParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCombinerStageParameterfvNV(dst, _stage, _pname, _params), NULL); \
    });
#define call_glGetCombinerStageParameterfvNV(packed, ret_v) do { \
    glGetCombinerStageParameterfvNV_PACKED *unpacked = (glGetCombinerStageParameterfvNV_PACKED *)packed; \
    glGetCombinerStageParameterfvNV_ARGS *args = (glGetCombinerStageParameterfvNV_ARGS *)&unpacked->args; \
    glGetCombinerStageParameterfvNV(args->stage, args->pname, args->params);; \
} while(0)
void glGetCombinerStageParameterfvNV(glGetCombinerStageParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetCombinerStageParameterfvNV(glGetCombinerStageParameterfvNV_PACKED *_dst glGetCombinerStageParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetCombinerStageParameterfvNV_PTR)(glGetCombinerStageParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetCompressedMultiTexImageEXT_RETURN
#define glGetCompressedMultiTexImageEXT_RETURN void
#define glGetCompressedMultiTexImageEXT_ARG_NAMES texunit, target, lod, img
#define glGetCompressedMultiTexImageEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint lod, GLvoid * img
#define glGetCompressedMultiTexImageEXT_ARG_NAMES_TAIL , texunit, target, lod, img
#define glGetCompressedMultiTexImageEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint lod, GLvoid * img
#define forward_glGetCompressedMultiTexImageEXT(_texunit, _target, _lod, _img) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCompressedMultiTexImageEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCompressedMultiTexImageEXT(dst, _texunit, _target, _lod, _img), NULL); \
    });
#define call_glGetCompressedMultiTexImageEXT(packed, ret_v) do { \
    glGetCompressedMultiTexImageEXT_PACKED *unpacked = (glGetCompressedMultiTexImageEXT_PACKED *)packed; \
    glGetCompressedMultiTexImageEXT_ARGS *args = (glGetCompressedMultiTexImageEXT_ARGS *)&unpacked->args; \
    glGetCompressedMultiTexImageEXT(args->texunit, args->target, args->lod, args->img);; \
} while(0)
void glGetCompressedMultiTexImageEXT(glGetCompressedMultiTexImageEXT_ARG_EXPAND);
packed_call_t *pack_glGetCompressedMultiTexImageEXT(glGetCompressedMultiTexImageEXT_PACKED *_dst glGetCompressedMultiTexImageEXT_ARG_EXPAND_TAIL);
typedef void (*glGetCompressedMultiTexImageEXT_PTR)(glGetCompressedMultiTexImageEXT_ARG_EXPAND);
#endif
#ifndef glGetCompressedTexImage_RETURN
#define glGetCompressedTexImage_RETURN void
#define glGetCompressedTexImage_ARG_NAMES target, level, img
#define glGetCompressedTexImage_ARG_EXPAND GLenum target, GLint level, GLvoid * img
#define glGetCompressedTexImage_ARG_NAMES_TAIL , target, level, img
#define glGetCompressedTexImage_ARG_EXPAND_TAIL , GLenum target, GLint level, GLvoid * img
#define forward_glGetCompressedTexImage(_target, _level, _img) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCompressedTexImage_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCompressedTexImage(dst, _target, _level, _img), NULL); \
    });
#define call_glGetCompressedTexImage(packed, ret_v) do { \
    glGetCompressedTexImage_PACKED *unpacked = (glGetCompressedTexImage_PACKED *)packed; \
    glGetCompressedTexImage_ARGS *args = (glGetCompressedTexImage_ARGS *)&unpacked->args; \
    glGetCompressedTexImage(args->target, args->level, args->img);; \
} while(0)
void glGetCompressedTexImage(glGetCompressedTexImage_ARG_EXPAND);
packed_call_t *pack_glGetCompressedTexImage(glGetCompressedTexImage_PACKED *_dst glGetCompressedTexImage_ARG_EXPAND_TAIL);
typedef void (*glGetCompressedTexImage_PTR)(glGetCompressedTexImage_ARG_EXPAND);
#endif
#ifndef glGetCompressedTexImageARB_RETURN
#define glGetCompressedTexImageARB_RETURN void
#define glGetCompressedTexImageARB_ARG_NAMES target, level, img
#define glGetCompressedTexImageARB_ARG_EXPAND GLenum target, GLint level, GLvoid * img
#define glGetCompressedTexImageARB_ARG_NAMES_TAIL , target, level, img
#define glGetCompressedTexImageARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLvoid * img
#define forward_glGetCompressedTexImageARB(_target, _level, _img) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCompressedTexImageARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCompressedTexImageARB(dst, _target, _level, _img), NULL); \
    });
#define call_glGetCompressedTexImageARB(packed, ret_v) do { \
    glGetCompressedTexImageARB_PACKED *unpacked = (glGetCompressedTexImageARB_PACKED *)packed; \
    glGetCompressedTexImageARB_ARGS *args = (glGetCompressedTexImageARB_ARGS *)&unpacked->args; \
    glGetCompressedTexImageARB(args->target, args->level, args->img);; \
} while(0)
void glGetCompressedTexImageARB(glGetCompressedTexImageARB_ARG_EXPAND);
packed_call_t *pack_glGetCompressedTexImageARB(glGetCompressedTexImageARB_PACKED *_dst glGetCompressedTexImageARB_ARG_EXPAND_TAIL);
typedef void (*glGetCompressedTexImageARB_PTR)(glGetCompressedTexImageARB_ARG_EXPAND);
#endif
#ifndef glGetCompressedTextureImageEXT_RETURN
#define glGetCompressedTextureImageEXT_RETURN void
#define glGetCompressedTextureImageEXT_ARG_NAMES texture, target, lod, img
#define glGetCompressedTextureImageEXT_ARG_EXPAND GLuint texture, GLenum target, GLint lod, GLvoid * img
#define glGetCompressedTextureImageEXT_ARG_NAMES_TAIL , texture, target, lod, img
#define glGetCompressedTextureImageEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint lod, GLvoid * img
#define forward_glGetCompressedTextureImageEXT(_texture, _target, _lod, _img) \
    ({ \
        void *dst = remote_dma(sizeof(glGetCompressedTextureImageEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetCompressedTextureImageEXT(dst, _texture, _target, _lod, _img), NULL); \
    });
#define call_glGetCompressedTextureImageEXT(packed, ret_v) do { \
    glGetCompressedTextureImageEXT_PACKED *unpacked = (glGetCompressedTextureImageEXT_PACKED *)packed; \
    glGetCompressedTextureImageEXT_ARGS *args = (glGetCompressedTextureImageEXT_ARGS *)&unpacked->args; \
    glGetCompressedTextureImageEXT(args->texture, args->target, args->lod, args->img);; \
} while(0)
void glGetCompressedTextureImageEXT(glGetCompressedTextureImageEXT_ARG_EXPAND);
packed_call_t *pack_glGetCompressedTextureImageEXT(glGetCompressedTextureImageEXT_PACKED *_dst glGetCompressedTextureImageEXT_ARG_EXPAND_TAIL);
typedef void (*glGetCompressedTextureImageEXT_PTR)(glGetCompressedTextureImageEXT_ARG_EXPAND);
#endif
#ifndef glGetConvolutionFilter_RETURN
#define glGetConvolutionFilter_RETURN void
#define glGetConvolutionFilter_ARG_NAMES target, format, type, image
#define glGetConvolutionFilter_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * image
#define glGetConvolutionFilter_ARG_NAMES_TAIL , target, format, type, image
#define glGetConvolutionFilter_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLvoid * image
#define forward_glGetConvolutionFilter(_target, _format, _type, _image) \
    ({ \
        void *dst = remote_dma(sizeof(glGetConvolutionFilter_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetConvolutionFilter(dst, _target, _format, _type, _image), NULL); \
    });
#define call_glGetConvolutionFilter(packed, ret_v) do { \
    glGetConvolutionFilter_PACKED *unpacked = (glGetConvolutionFilter_PACKED *)packed; \
    glGetConvolutionFilter_ARGS *args = (glGetConvolutionFilter_ARGS *)&unpacked->args; \
    glGetConvolutionFilter(args->target, args->format, args->type, args->image);; \
} while(0)
void glGetConvolutionFilter(glGetConvolutionFilter_ARG_EXPAND);
packed_call_t *pack_glGetConvolutionFilter(glGetConvolutionFilter_PACKED *_dst glGetConvolutionFilter_ARG_EXPAND_TAIL);
typedef void (*glGetConvolutionFilter_PTR)(glGetConvolutionFilter_ARG_EXPAND);
#endif
#ifndef glGetConvolutionFilterEXT_RETURN
#define glGetConvolutionFilterEXT_RETURN void
#define glGetConvolutionFilterEXT_ARG_NAMES target, format, type, image
#define glGetConvolutionFilterEXT_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * image
#define glGetConvolutionFilterEXT_ARG_NAMES_TAIL , target, format, type, image
#define glGetConvolutionFilterEXT_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLvoid * image
#define forward_glGetConvolutionFilterEXT(_target, _format, _type, _image) \
    ({ \
        void *dst = remote_dma(sizeof(glGetConvolutionFilterEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetConvolutionFilterEXT(dst, _target, _format, _type, _image), NULL); \
    });
#define call_glGetConvolutionFilterEXT(packed, ret_v) do { \
    glGetConvolutionFilterEXT_PACKED *unpacked = (glGetConvolutionFilterEXT_PACKED *)packed; \
    glGetConvolutionFilterEXT_ARGS *args = (glGetConvolutionFilterEXT_ARGS *)&unpacked->args; \
    glGetConvolutionFilterEXT(args->target, args->format, args->type, args->image);; \
} while(0)
void glGetConvolutionFilterEXT(glGetConvolutionFilterEXT_ARG_EXPAND);
packed_call_t *pack_glGetConvolutionFilterEXT(glGetConvolutionFilterEXT_PACKED *_dst glGetConvolutionFilterEXT_ARG_EXPAND_TAIL);
typedef void (*glGetConvolutionFilterEXT_PTR)(glGetConvolutionFilterEXT_ARG_EXPAND);
#endif
#ifndef glGetConvolutionParameterfv_RETURN
#define glGetConvolutionParameterfv_RETURN void
#define glGetConvolutionParameterfv_ARG_NAMES target, pname, params
#define glGetConvolutionParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetConvolutionParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glGetConvolutionParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetConvolutionParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetConvolutionParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetConvolutionParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetConvolutionParameterfv(packed, ret_v) do { \
    glGetConvolutionParameterfv_PACKED *unpacked = (glGetConvolutionParameterfv_PACKED *)packed; \
    glGetConvolutionParameterfv_ARGS *args = (glGetConvolutionParameterfv_ARGS *)&unpacked->args; \
    glGetConvolutionParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterfv(glGetConvolutionParameterfv_ARG_EXPAND);
packed_call_t *pack_glGetConvolutionParameterfv(glGetConvolutionParameterfv_PACKED *_dst glGetConvolutionParameterfv_ARG_EXPAND_TAIL);
typedef void (*glGetConvolutionParameterfv_PTR)(glGetConvolutionParameterfv_ARG_EXPAND);
#endif
#ifndef glGetConvolutionParameterfvEXT_RETURN
#define glGetConvolutionParameterfvEXT_RETURN void
#define glGetConvolutionParameterfvEXT_ARG_NAMES target, pname, params
#define glGetConvolutionParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetConvolutionParameterfvEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetConvolutionParameterfvEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetConvolutionParameterfvEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetConvolutionParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetConvolutionParameterfvEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetConvolutionParameterfvEXT(packed, ret_v) do { \
    glGetConvolutionParameterfvEXT_PACKED *unpacked = (glGetConvolutionParameterfvEXT_PACKED *)packed; \
    glGetConvolutionParameterfvEXT_ARGS *args = (glGetConvolutionParameterfvEXT_ARGS *)&unpacked->args; \
    glGetConvolutionParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterfvEXT(glGetConvolutionParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetConvolutionParameterfvEXT(glGetConvolutionParameterfvEXT_PACKED *_dst glGetConvolutionParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetConvolutionParameterfvEXT_PTR)(glGetConvolutionParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetConvolutionParameteriv_RETURN
#define glGetConvolutionParameteriv_RETURN void
#define glGetConvolutionParameteriv_ARG_NAMES target, pname, params
#define glGetConvolutionParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetConvolutionParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetConvolutionParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetConvolutionParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetConvolutionParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetConvolutionParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetConvolutionParameteriv(packed, ret_v) do { \
    glGetConvolutionParameteriv_PACKED *unpacked = (glGetConvolutionParameteriv_PACKED *)packed; \
    glGetConvolutionParameteriv_ARGS *args = (glGetConvolutionParameteriv_ARGS *)&unpacked->args; \
    glGetConvolutionParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameteriv(glGetConvolutionParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetConvolutionParameteriv(glGetConvolutionParameteriv_PACKED *_dst glGetConvolutionParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetConvolutionParameteriv_PTR)(glGetConvolutionParameteriv_ARG_EXPAND);
#endif
#ifndef glGetConvolutionParameterivEXT_RETURN
#define glGetConvolutionParameterivEXT_RETURN void
#define glGetConvolutionParameterivEXT_ARG_NAMES target, pname, params
#define glGetConvolutionParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetConvolutionParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetConvolutionParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetConvolutionParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetConvolutionParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetConvolutionParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetConvolutionParameterivEXT(packed, ret_v) do { \
    glGetConvolutionParameterivEXT_PACKED *unpacked = (glGetConvolutionParameterivEXT_PACKED *)packed; \
    glGetConvolutionParameterivEXT_ARGS *args = (glGetConvolutionParameterivEXT_ARGS *)&unpacked->args; \
    glGetConvolutionParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterivEXT(glGetConvolutionParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetConvolutionParameterivEXT(glGetConvolutionParameterivEXT_PACKED *_dst glGetConvolutionParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetConvolutionParameterivEXT_PTR)(glGetConvolutionParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetConvolutionParameterxvOES_RETURN
#define glGetConvolutionParameterxvOES_RETURN void
#define glGetConvolutionParameterxvOES_ARG_NAMES target, pname, params
#define glGetConvolutionParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetConvolutionParameterxvOES_ARG_NAMES_TAIL , target, pname, params
#define glGetConvolutionParameterxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfixed * params
#define forward_glGetConvolutionParameterxvOES(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetConvolutionParameterxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetConvolutionParameterxvOES(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetConvolutionParameterxvOES(packed, ret_v) do { \
    glGetConvolutionParameterxvOES_PACKED *unpacked = (glGetConvolutionParameterxvOES_PACKED *)packed; \
    glGetConvolutionParameterxvOES_ARGS *args = (glGetConvolutionParameterxvOES_ARGS *)&unpacked->args; \
    glGetConvolutionParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterxvOES(glGetConvolutionParameterxvOES_ARG_EXPAND);
packed_call_t *pack_glGetConvolutionParameterxvOES(glGetConvolutionParameterxvOES_PACKED *_dst glGetConvolutionParameterxvOES_ARG_EXPAND_TAIL);
typedef void (*glGetConvolutionParameterxvOES_PTR)(glGetConvolutionParameterxvOES_ARG_EXPAND);
#endif
#ifndef glGetDebugMessageLog_RETURN
#define glGetDebugMessageLog_RETURN GLuint
#define glGetDebugMessageLog_ARG_NAMES count, bufsize, sources, types, ids, severities, lengths, messageLog
#define glGetDebugMessageLog_ARG_EXPAND GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog
#define glGetDebugMessageLog_ARG_NAMES_TAIL , count, bufsize, sources, types, ids, severities, lengths, messageLog
#define glGetDebugMessageLog_ARG_EXPAND_TAIL , GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog
#define forward_glGetDebugMessageLog(_count, _bufsize, _sources, _types, _ids, _severities, _lengths, _messageLog) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDebugMessageLog_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGetDebugMessageLog(dst, _count, _bufsize, _sources, _types, _ids, _severities, _lengths, _messageLog), &ret); \
        ret; \
    });
#define call_glGetDebugMessageLog(packed, ret_v) do { \
    glGetDebugMessageLog_PACKED *unpacked = (glGetDebugMessageLog_PACKED *)packed; \
    glGetDebugMessageLog_ARGS *args = (glGetDebugMessageLog_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetDebugMessageLog(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } else { \
        glGetDebugMessageLog(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } \
} while(0)
GLuint glGetDebugMessageLog(glGetDebugMessageLog_ARG_EXPAND);
packed_call_t *pack_glGetDebugMessageLog(glGetDebugMessageLog_PACKED *_dst glGetDebugMessageLog_ARG_EXPAND_TAIL);
typedef GLuint (*glGetDebugMessageLog_PTR)(glGetDebugMessageLog_ARG_EXPAND);
#endif
#ifndef glGetDebugMessageLogAMD_RETURN
#define glGetDebugMessageLogAMD_RETURN GLuint
#define glGetDebugMessageLogAMD_ARG_NAMES count, bufsize, categories, severities, ids, lengths, message
#define glGetDebugMessageLogAMD_ARG_EXPAND GLuint count, GLsizei bufsize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message
#define glGetDebugMessageLogAMD_ARG_NAMES_TAIL , count, bufsize, categories, severities, ids, lengths, message
#define glGetDebugMessageLogAMD_ARG_EXPAND_TAIL , GLuint count, GLsizei bufsize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message
#define forward_glGetDebugMessageLogAMD(_count, _bufsize, _categories, _severities, _ids, _lengths, _message) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDebugMessageLogAMD_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGetDebugMessageLogAMD(dst, _count, _bufsize, _categories, _severities, _ids, _lengths, _message), &ret); \
        ret; \
    });
#define call_glGetDebugMessageLogAMD(packed, ret_v) do { \
    glGetDebugMessageLogAMD_PACKED *unpacked = (glGetDebugMessageLogAMD_PACKED *)packed; \
    glGetDebugMessageLogAMD_ARGS *args = (glGetDebugMessageLogAMD_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetDebugMessageLogAMD(args->count, args->bufsize, args->categories, args->severities, args->ids, args->lengths, args->message);; \
    } else { \
        glGetDebugMessageLogAMD(args->count, args->bufsize, args->categories, args->severities, args->ids, args->lengths, args->message);; \
    } \
} while(0)
GLuint glGetDebugMessageLogAMD(glGetDebugMessageLogAMD_ARG_EXPAND);
packed_call_t *pack_glGetDebugMessageLogAMD(glGetDebugMessageLogAMD_PACKED *_dst glGetDebugMessageLogAMD_ARG_EXPAND_TAIL);
typedef GLuint (*glGetDebugMessageLogAMD_PTR)(glGetDebugMessageLogAMD_ARG_EXPAND);
#endif
#ifndef glGetDebugMessageLogARB_RETURN
#define glGetDebugMessageLogARB_RETURN GLuint
#define glGetDebugMessageLogARB_ARG_NAMES count, bufsize, sources, types, ids, severities, lengths, messageLog
#define glGetDebugMessageLogARB_ARG_EXPAND GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog
#define glGetDebugMessageLogARB_ARG_NAMES_TAIL , count, bufsize, sources, types, ids, severities, lengths, messageLog
#define glGetDebugMessageLogARB_ARG_EXPAND_TAIL , GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog
#define forward_glGetDebugMessageLogARB(_count, _bufsize, _sources, _types, _ids, _severities, _lengths, _messageLog) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDebugMessageLogARB_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGetDebugMessageLogARB(dst, _count, _bufsize, _sources, _types, _ids, _severities, _lengths, _messageLog), &ret); \
        ret; \
    });
#define call_glGetDebugMessageLogARB(packed, ret_v) do { \
    glGetDebugMessageLogARB_PACKED *unpacked = (glGetDebugMessageLogARB_PACKED *)packed; \
    glGetDebugMessageLogARB_ARGS *args = (glGetDebugMessageLogARB_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetDebugMessageLogARB(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } else { \
        glGetDebugMessageLogARB(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } \
} while(0)
GLuint glGetDebugMessageLogARB(glGetDebugMessageLogARB_ARG_EXPAND);
packed_call_t *pack_glGetDebugMessageLogARB(glGetDebugMessageLogARB_PACKED *_dst glGetDebugMessageLogARB_ARG_EXPAND_TAIL);
typedef GLuint (*glGetDebugMessageLogARB_PTR)(glGetDebugMessageLogARB_ARG_EXPAND);
#endif
#ifndef glGetDetailTexFuncSGIS_RETURN
#define glGetDetailTexFuncSGIS_RETURN void
#define glGetDetailTexFuncSGIS_ARG_NAMES target, points
#define glGetDetailTexFuncSGIS_ARG_EXPAND GLenum target, GLfloat * points
#define glGetDetailTexFuncSGIS_ARG_NAMES_TAIL , target, points
#define glGetDetailTexFuncSGIS_ARG_EXPAND_TAIL , GLenum target, GLfloat * points
#define forward_glGetDetailTexFuncSGIS(_target, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDetailTexFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetDetailTexFuncSGIS(dst, _target, _points), NULL); \
    });
#define call_glGetDetailTexFuncSGIS(packed, ret_v) do { \
    glGetDetailTexFuncSGIS_PACKED *unpacked = (glGetDetailTexFuncSGIS_PACKED *)packed; \
    glGetDetailTexFuncSGIS_ARGS *args = (glGetDetailTexFuncSGIS_ARGS *)&unpacked->args; \
    glGetDetailTexFuncSGIS(args->target, args->points);; \
} while(0)
void glGetDetailTexFuncSGIS(glGetDetailTexFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glGetDetailTexFuncSGIS(glGetDetailTexFuncSGIS_PACKED *_dst glGetDetailTexFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glGetDetailTexFuncSGIS_PTR)(glGetDetailTexFuncSGIS_ARG_EXPAND);
#endif
#ifndef glGetDoubleIndexedvEXT_RETURN
#define glGetDoubleIndexedvEXT_RETURN void
#define glGetDoubleIndexedvEXT_ARG_NAMES target, index, data
#define glGetDoubleIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLdouble * data
#define glGetDoubleIndexedvEXT_ARG_NAMES_TAIL , target, index, data
#define glGetDoubleIndexedvEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble * data
#define forward_glGetDoubleIndexedvEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDoubleIndexedvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetDoubleIndexedvEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetDoubleIndexedvEXT(packed, ret_v) do { \
    glGetDoubleIndexedvEXT_PACKED *unpacked = (glGetDoubleIndexedvEXT_PACKED *)packed; \
    glGetDoubleIndexedvEXT_ARGS *args = (glGetDoubleIndexedvEXT_ARGS *)&unpacked->args; \
    glGetDoubleIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetDoubleIndexedvEXT(glGetDoubleIndexedvEXT_ARG_EXPAND);
packed_call_t *pack_glGetDoubleIndexedvEXT(glGetDoubleIndexedvEXT_PACKED *_dst glGetDoubleIndexedvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetDoubleIndexedvEXT_PTR)(glGetDoubleIndexedvEXT_ARG_EXPAND);
#endif
#ifndef glGetDoublei_v_RETURN
#define glGetDoublei_v_RETURN void
#define glGetDoublei_v_ARG_NAMES target, index, data
#define glGetDoublei_v_ARG_EXPAND GLenum target, GLuint index, GLdouble * data
#define glGetDoublei_v_ARG_NAMES_TAIL , target, index, data
#define glGetDoublei_v_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble * data
#define forward_glGetDoublei_v(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDoublei_v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetDoublei_v(dst, _target, _index, _data), NULL); \
    });
#define call_glGetDoublei_v(packed, ret_v) do { \
    glGetDoublei_v_PACKED *unpacked = (glGetDoublei_v_PACKED *)packed; \
    glGetDoublei_v_ARGS *args = (glGetDoublei_v_ARGS *)&unpacked->args; \
    glGetDoublei_v(args->target, args->index, args->data);; \
} while(0)
void glGetDoublei_v(glGetDoublei_v_ARG_EXPAND);
packed_call_t *pack_glGetDoublei_v(glGetDoublei_v_PACKED *_dst glGetDoublei_v_ARG_EXPAND_TAIL);
typedef void (*glGetDoublei_v_PTR)(glGetDoublei_v_ARG_EXPAND);
#endif
#ifndef glGetDoublei_vEXT_RETURN
#define glGetDoublei_vEXT_RETURN void
#define glGetDoublei_vEXT_ARG_NAMES target, index, data
#define glGetDoublei_vEXT_ARG_EXPAND GLenum target, GLuint index, GLdouble * data
#define glGetDoublei_vEXT_ARG_NAMES_TAIL , target, index, data
#define glGetDoublei_vEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble * data
#define forward_glGetDoublei_vEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDoublei_vEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetDoublei_vEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetDoublei_vEXT(packed, ret_v) do { \
    glGetDoublei_vEXT_PACKED *unpacked = (glGetDoublei_vEXT_PACKED *)packed; \
    glGetDoublei_vEXT_ARGS *args = (glGetDoublei_vEXT_ARGS *)&unpacked->args; \
    glGetDoublei_vEXT(args->target, args->index, args->data);; \
} while(0)
void glGetDoublei_vEXT(glGetDoublei_vEXT_ARG_EXPAND);
packed_call_t *pack_glGetDoublei_vEXT(glGetDoublei_vEXT_PACKED *_dst glGetDoublei_vEXT_ARG_EXPAND_TAIL);
typedef void (*glGetDoublei_vEXT_PTR)(glGetDoublei_vEXT_ARG_EXPAND);
#endif
#ifndef glGetDoublev_RETURN
#define glGetDoublev_RETURN void
#define glGetDoublev_ARG_NAMES pname, params
#define glGetDoublev_ARG_EXPAND GLenum pname, GLdouble * params
#define glGetDoublev_ARG_NAMES_TAIL , pname, params
#define glGetDoublev_ARG_EXPAND_TAIL , GLenum pname, GLdouble * params
#define forward_glGetDoublev(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetDoublev_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetDoublev(dst, _pname, _params), NULL); \
    });
#define call_glGetDoublev(packed, ret_v) do { \
    glGetDoublev_PACKED *unpacked = (glGetDoublev_PACKED *)packed; \
    glGetDoublev_ARGS *args = (glGetDoublev_ARGS *)&unpacked->args; \
    glGetDoublev(args->pname, args->params);; \
} while(0)
void glGetDoublev(glGetDoublev_ARG_EXPAND);
packed_call_t *pack_glGetDoublev(glGetDoublev_PACKED *_dst glGetDoublev_ARG_EXPAND_TAIL);
typedef void (*glGetDoublev_PTR)(glGetDoublev_ARG_EXPAND);
#endif
#ifndef glGetError_RETURN
#define glGetError_RETURN GLenum
#define glGetError_ARG_NAMES 
#define glGetError_ARG_EXPAND 
#define glGetError_ARG_NAMES_TAIL 
#define glGetError_ARG_EXPAND_TAIL 
#define forward_glGetError() \
    ({ \
        void *dst = remote_dma(sizeof(glGetError_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glGetError(dst), &ret); \
        ret; \
    });
#define call_glGetError(packed, ret_v) do { \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetError();; \
    } else { \
        glGetError();; \
    } \
} while(0)
GLenum glGetError(glGetError_ARG_EXPAND);
packed_call_t *pack_glGetError(glGetError_PACKED *_dst glGetError_ARG_EXPAND_TAIL);
typedef GLenum (*glGetError_PTR)(glGetError_ARG_EXPAND);
#endif
#ifndef glGetFenceivNV_RETURN
#define glGetFenceivNV_RETURN void
#define glGetFenceivNV_ARG_NAMES fence, pname, params
#define glGetFenceivNV_ARG_EXPAND GLuint fence, GLenum pname, GLint * params
#define glGetFenceivNV_ARG_NAMES_TAIL , fence, pname, params
#define glGetFenceivNV_ARG_EXPAND_TAIL , GLuint fence, GLenum pname, GLint * params
#define forward_glGetFenceivNV(_fence, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFenceivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFenceivNV(dst, _fence, _pname, _params), NULL); \
    });
#define call_glGetFenceivNV(packed, ret_v) do { \
    glGetFenceivNV_PACKED *unpacked = (glGetFenceivNV_PACKED *)packed; \
    glGetFenceivNV_ARGS *args = (glGetFenceivNV_ARGS *)&unpacked->args; \
    glGetFenceivNV(args->fence, args->pname, args->params);; \
} while(0)
void glGetFenceivNV(glGetFenceivNV_ARG_EXPAND);
packed_call_t *pack_glGetFenceivNV(glGetFenceivNV_PACKED *_dst glGetFenceivNV_ARG_EXPAND_TAIL);
typedef void (*glGetFenceivNV_PTR)(glGetFenceivNV_ARG_EXPAND);
#endif
#ifndef glGetFinalCombinerInputParameterfvNV_RETURN
#define glGetFinalCombinerInputParameterfvNV_RETURN void
#define glGetFinalCombinerInputParameterfvNV_ARG_NAMES variable, pname, params
#define glGetFinalCombinerInputParameterfvNV_ARG_EXPAND GLenum variable, GLenum pname, GLfloat * params
#define glGetFinalCombinerInputParameterfvNV_ARG_NAMES_TAIL , variable, pname, params
#define glGetFinalCombinerInputParameterfvNV_ARG_EXPAND_TAIL , GLenum variable, GLenum pname, GLfloat * params
#define forward_glGetFinalCombinerInputParameterfvNV(_variable, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFinalCombinerInputParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFinalCombinerInputParameterfvNV(dst, _variable, _pname, _params), NULL); \
    });
#define call_glGetFinalCombinerInputParameterfvNV(packed, ret_v) do { \
    glGetFinalCombinerInputParameterfvNV_PACKED *unpacked = (glGetFinalCombinerInputParameterfvNV_PACKED *)packed; \
    glGetFinalCombinerInputParameterfvNV_ARGS *args = (glGetFinalCombinerInputParameterfvNV_ARGS *)&unpacked->args; \
    glGetFinalCombinerInputParameterfvNV(args->variable, args->pname, args->params);; \
} while(0)
void glGetFinalCombinerInputParameterfvNV(glGetFinalCombinerInputParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetFinalCombinerInputParameterfvNV(glGetFinalCombinerInputParameterfvNV_PACKED *_dst glGetFinalCombinerInputParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetFinalCombinerInputParameterfvNV_PTR)(glGetFinalCombinerInputParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetFinalCombinerInputParameterivNV_RETURN
#define glGetFinalCombinerInputParameterivNV_RETURN void
#define glGetFinalCombinerInputParameterivNV_ARG_NAMES variable, pname, params
#define glGetFinalCombinerInputParameterivNV_ARG_EXPAND GLenum variable, GLenum pname, GLint * params
#define glGetFinalCombinerInputParameterivNV_ARG_NAMES_TAIL , variable, pname, params
#define glGetFinalCombinerInputParameterivNV_ARG_EXPAND_TAIL , GLenum variable, GLenum pname, GLint * params
#define forward_glGetFinalCombinerInputParameterivNV(_variable, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFinalCombinerInputParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFinalCombinerInputParameterivNV(dst, _variable, _pname, _params), NULL); \
    });
#define call_glGetFinalCombinerInputParameterivNV(packed, ret_v) do { \
    glGetFinalCombinerInputParameterivNV_PACKED *unpacked = (glGetFinalCombinerInputParameterivNV_PACKED *)packed; \
    glGetFinalCombinerInputParameterivNV_ARGS *args = (glGetFinalCombinerInputParameterivNV_ARGS *)&unpacked->args; \
    glGetFinalCombinerInputParameterivNV(args->variable, args->pname, args->params);; \
} while(0)
void glGetFinalCombinerInputParameterivNV(glGetFinalCombinerInputParameterivNV_ARG_EXPAND);
packed_call_t *pack_glGetFinalCombinerInputParameterivNV(glGetFinalCombinerInputParameterivNV_PACKED *_dst glGetFinalCombinerInputParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glGetFinalCombinerInputParameterivNV_PTR)(glGetFinalCombinerInputParameterivNV_ARG_EXPAND);
#endif
#ifndef glGetFixedvOES_RETURN
#define glGetFixedvOES_RETURN void
#define glGetFixedvOES_ARG_NAMES pname, params
#define glGetFixedvOES_ARG_EXPAND GLenum pname, GLfixed * params
#define glGetFixedvOES_ARG_NAMES_TAIL , pname, params
#define glGetFixedvOES_ARG_EXPAND_TAIL , GLenum pname, GLfixed * params
#define forward_glGetFixedvOES(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFixedvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFixedvOES(dst, _pname, _params), NULL); \
    });
#define call_glGetFixedvOES(packed, ret_v) do { \
    glGetFixedvOES_PACKED *unpacked = (glGetFixedvOES_PACKED *)packed; \
    glGetFixedvOES_ARGS *args = (glGetFixedvOES_ARGS *)&unpacked->args; \
    glGetFixedvOES(args->pname, args->params);; \
} while(0)
void glGetFixedvOES(glGetFixedvOES_ARG_EXPAND);
packed_call_t *pack_glGetFixedvOES(glGetFixedvOES_PACKED *_dst glGetFixedvOES_ARG_EXPAND_TAIL);
typedef void (*glGetFixedvOES_PTR)(glGetFixedvOES_ARG_EXPAND);
#endif
#ifndef glGetFloatIndexedvEXT_RETURN
#define glGetFloatIndexedvEXT_RETURN void
#define glGetFloatIndexedvEXT_ARG_NAMES target, index, data
#define glGetFloatIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLfloat * data
#define glGetFloatIndexedvEXT_ARG_NAMES_TAIL , target, index, data
#define glGetFloatIndexedvEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat * data
#define forward_glGetFloatIndexedvEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFloatIndexedvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFloatIndexedvEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetFloatIndexedvEXT(packed, ret_v) do { \
    glGetFloatIndexedvEXT_PACKED *unpacked = (glGetFloatIndexedvEXT_PACKED *)packed; \
    glGetFloatIndexedvEXT_ARGS *args = (glGetFloatIndexedvEXT_ARGS *)&unpacked->args; \
    glGetFloatIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetFloatIndexedvEXT(glGetFloatIndexedvEXT_ARG_EXPAND);
packed_call_t *pack_glGetFloatIndexedvEXT(glGetFloatIndexedvEXT_PACKED *_dst glGetFloatIndexedvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetFloatIndexedvEXT_PTR)(glGetFloatIndexedvEXT_ARG_EXPAND);
#endif
#ifndef glGetFloati_v_RETURN
#define glGetFloati_v_RETURN void
#define glGetFloati_v_ARG_NAMES target, index, data
#define glGetFloati_v_ARG_EXPAND GLenum target, GLuint index, GLfloat * data
#define glGetFloati_v_ARG_NAMES_TAIL , target, index, data
#define glGetFloati_v_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat * data
#define forward_glGetFloati_v(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFloati_v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFloati_v(dst, _target, _index, _data), NULL); \
    });
#define call_glGetFloati_v(packed, ret_v) do { \
    glGetFloati_v_PACKED *unpacked = (glGetFloati_v_PACKED *)packed; \
    glGetFloati_v_ARGS *args = (glGetFloati_v_ARGS *)&unpacked->args; \
    glGetFloati_v(args->target, args->index, args->data);; \
} while(0)
void glGetFloati_v(glGetFloati_v_ARG_EXPAND);
packed_call_t *pack_glGetFloati_v(glGetFloati_v_PACKED *_dst glGetFloati_v_ARG_EXPAND_TAIL);
typedef void (*glGetFloati_v_PTR)(glGetFloati_v_ARG_EXPAND);
#endif
#ifndef glGetFloati_vEXT_RETURN
#define glGetFloati_vEXT_RETURN void
#define glGetFloati_vEXT_ARG_NAMES target, index, data
#define glGetFloati_vEXT_ARG_EXPAND GLenum target, GLuint index, GLfloat * data
#define glGetFloati_vEXT_ARG_NAMES_TAIL , target, index, data
#define glGetFloati_vEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat * data
#define forward_glGetFloati_vEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFloati_vEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFloati_vEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetFloati_vEXT(packed, ret_v) do { \
    glGetFloati_vEXT_PACKED *unpacked = (glGetFloati_vEXT_PACKED *)packed; \
    glGetFloati_vEXT_ARGS *args = (glGetFloati_vEXT_ARGS *)&unpacked->args; \
    glGetFloati_vEXT(args->target, args->index, args->data);; \
} while(0)
void glGetFloati_vEXT(glGetFloati_vEXT_ARG_EXPAND);
packed_call_t *pack_glGetFloati_vEXT(glGetFloati_vEXT_PACKED *_dst glGetFloati_vEXT_ARG_EXPAND_TAIL);
typedef void (*glGetFloati_vEXT_PTR)(glGetFloati_vEXT_ARG_EXPAND);
#endif
#ifndef glGetFloatv_RETURN
#define glGetFloatv_RETURN void
#define glGetFloatv_ARG_NAMES pname, params
#define glGetFloatv_ARG_EXPAND GLenum pname, GLfloat * params
#define glGetFloatv_ARG_NAMES_TAIL , pname, params
#define glGetFloatv_ARG_EXPAND_TAIL , GLenum pname, GLfloat * params
#define forward_glGetFloatv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFloatv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFloatv(dst, _pname, _params), NULL); \
    });
#define call_glGetFloatv(packed, ret_v) do { \
    glGetFloatv_PACKED *unpacked = (glGetFloatv_PACKED *)packed; \
    glGetFloatv_ARGS *args = (glGetFloatv_ARGS *)&unpacked->args; \
    glGetFloatv(args->pname, args->params);; \
} while(0)
void glGetFloatv(glGetFloatv_ARG_EXPAND);
packed_call_t *pack_glGetFloatv(glGetFloatv_PACKED *_dst glGetFloatv_ARG_EXPAND_TAIL);
typedef void (*glGetFloatv_PTR)(glGetFloatv_ARG_EXPAND);
#endif
#ifndef glGetFogFuncSGIS_RETURN
#define glGetFogFuncSGIS_RETURN void
#define glGetFogFuncSGIS_ARG_NAMES points
#define glGetFogFuncSGIS_ARG_EXPAND GLfloat * points
#define glGetFogFuncSGIS_ARG_NAMES_TAIL , points
#define glGetFogFuncSGIS_ARG_EXPAND_TAIL , GLfloat * points
#define forward_glGetFogFuncSGIS(_points) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFogFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFogFuncSGIS(dst, _points), NULL); \
    });
#define call_glGetFogFuncSGIS(packed, ret_v) do { \
    glGetFogFuncSGIS_PACKED *unpacked = (glGetFogFuncSGIS_PACKED *)packed; \
    glGetFogFuncSGIS_ARGS *args = (glGetFogFuncSGIS_ARGS *)&unpacked->args; \
    glGetFogFuncSGIS(args->points);; \
} while(0)
void glGetFogFuncSGIS(glGetFogFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glGetFogFuncSGIS(glGetFogFuncSGIS_PACKED *_dst glGetFogFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glGetFogFuncSGIS_PTR)(glGetFogFuncSGIS_ARG_EXPAND);
#endif
#ifndef glGetFragDataIndex_RETURN
#define glGetFragDataIndex_RETURN GLint
#define glGetFragDataIndex_ARG_NAMES program, name
#define glGetFragDataIndex_ARG_EXPAND GLuint program, const GLchar * name
#define glGetFragDataIndex_ARG_NAMES_TAIL , program, name
#define glGetFragDataIndex_ARG_EXPAND_TAIL , GLuint program, const GLchar * name
#define forward_glGetFragDataIndex(_program, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFragDataIndex_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetFragDataIndex(dst, _program, _name), &ret); \
        ret; \
    });
#define call_glGetFragDataIndex(packed, ret_v) do { \
    glGetFragDataIndex_PACKED *unpacked = (glGetFragDataIndex_PACKED *)packed; \
    glGetFragDataIndex_ARGS *args = (glGetFragDataIndex_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetFragDataIndex(args->program, args->name);; \
    } else { \
        glGetFragDataIndex(args->program, args->name);; \
    } \
} while(0)
GLint glGetFragDataIndex(glGetFragDataIndex_ARG_EXPAND);
packed_call_t *pack_glGetFragDataIndex(glGetFragDataIndex_PACKED *_dst glGetFragDataIndex_ARG_EXPAND_TAIL);
typedef GLint (*glGetFragDataIndex_PTR)(glGetFragDataIndex_ARG_EXPAND);
#endif
#ifndef glGetFragDataLocation_RETURN
#define glGetFragDataLocation_RETURN GLint
#define glGetFragDataLocation_ARG_NAMES program, name
#define glGetFragDataLocation_ARG_EXPAND GLuint program, const GLchar * name
#define glGetFragDataLocation_ARG_NAMES_TAIL , program, name
#define glGetFragDataLocation_ARG_EXPAND_TAIL , GLuint program, const GLchar * name
#define forward_glGetFragDataLocation(_program, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFragDataLocation_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetFragDataLocation(dst, _program, _name), &ret); \
        ret; \
    });
#define call_glGetFragDataLocation(packed, ret_v) do { \
    glGetFragDataLocation_PACKED *unpacked = (glGetFragDataLocation_PACKED *)packed; \
    glGetFragDataLocation_ARGS *args = (glGetFragDataLocation_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetFragDataLocation(args->program, args->name);; \
    } else { \
        glGetFragDataLocation(args->program, args->name);; \
    } \
} while(0)
GLint glGetFragDataLocation(glGetFragDataLocation_ARG_EXPAND);
packed_call_t *pack_glGetFragDataLocation(glGetFragDataLocation_PACKED *_dst glGetFragDataLocation_ARG_EXPAND_TAIL);
typedef GLint (*glGetFragDataLocation_PTR)(glGetFragDataLocation_ARG_EXPAND);
#endif
#ifndef glGetFragDataLocationEXT_RETURN
#define glGetFragDataLocationEXT_RETURN GLint
#define glGetFragDataLocationEXT_ARG_NAMES program, name
#define glGetFragDataLocationEXT_ARG_EXPAND GLuint program, const GLchar * name
#define glGetFragDataLocationEXT_ARG_NAMES_TAIL , program, name
#define glGetFragDataLocationEXT_ARG_EXPAND_TAIL , GLuint program, const GLchar * name
#define forward_glGetFragDataLocationEXT(_program, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFragDataLocationEXT_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetFragDataLocationEXT(dst, _program, _name), &ret); \
        ret; \
    });
#define call_glGetFragDataLocationEXT(packed, ret_v) do { \
    glGetFragDataLocationEXT_PACKED *unpacked = (glGetFragDataLocationEXT_PACKED *)packed; \
    glGetFragDataLocationEXT_ARGS *args = (glGetFragDataLocationEXT_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetFragDataLocationEXT(args->program, args->name);; \
    } else { \
        glGetFragDataLocationEXT(args->program, args->name);; \
    } \
} while(0)
GLint glGetFragDataLocationEXT(glGetFragDataLocationEXT_ARG_EXPAND);
packed_call_t *pack_glGetFragDataLocationEXT(glGetFragDataLocationEXT_PACKED *_dst glGetFragDataLocationEXT_ARG_EXPAND_TAIL);
typedef GLint (*glGetFragDataLocationEXT_PTR)(glGetFragDataLocationEXT_ARG_EXPAND);
#endif
#ifndef glGetFragmentLightfvSGIX_RETURN
#define glGetFragmentLightfvSGIX_RETURN void
#define glGetFragmentLightfvSGIX_ARG_NAMES light, pname, params
#define glGetFragmentLightfvSGIX_ARG_EXPAND GLenum light, GLenum pname, GLfloat * params
#define glGetFragmentLightfvSGIX_ARG_NAMES_TAIL , light, pname, params
#define glGetFragmentLightfvSGIX_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLfloat * params
#define forward_glGetFragmentLightfvSGIX(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFragmentLightfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFragmentLightfvSGIX(dst, _light, _pname, _params), NULL); \
    });
#define call_glGetFragmentLightfvSGIX(packed, ret_v) do { \
    glGetFragmentLightfvSGIX_PACKED *unpacked = (glGetFragmentLightfvSGIX_PACKED *)packed; \
    glGetFragmentLightfvSGIX_ARGS *args = (glGetFragmentLightfvSGIX_ARGS *)&unpacked->args; \
    glGetFragmentLightfvSGIX(args->light, args->pname, args->params);; \
} while(0)
void glGetFragmentLightfvSGIX(glGetFragmentLightfvSGIX_ARG_EXPAND);
packed_call_t *pack_glGetFragmentLightfvSGIX(glGetFragmentLightfvSGIX_PACKED *_dst glGetFragmentLightfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glGetFragmentLightfvSGIX_PTR)(glGetFragmentLightfvSGIX_ARG_EXPAND);
#endif
#ifndef glGetFragmentLightivSGIX_RETURN
#define glGetFragmentLightivSGIX_RETURN void
#define glGetFragmentLightivSGIX_ARG_NAMES light, pname, params
#define glGetFragmentLightivSGIX_ARG_EXPAND GLenum light, GLenum pname, GLint * params
#define glGetFragmentLightivSGIX_ARG_NAMES_TAIL , light, pname, params
#define glGetFragmentLightivSGIX_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLint * params
#define forward_glGetFragmentLightivSGIX(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFragmentLightivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFragmentLightivSGIX(dst, _light, _pname, _params), NULL); \
    });
#define call_glGetFragmentLightivSGIX(packed, ret_v) do { \
    glGetFragmentLightivSGIX_PACKED *unpacked = (glGetFragmentLightivSGIX_PACKED *)packed; \
    glGetFragmentLightivSGIX_ARGS *args = (glGetFragmentLightivSGIX_ARGS *)&unpacked->args; \
    glGetFragmentLightivSGIX(args->light, args->pname, args->params);; \
} while(0)
void glGetFragmentLightivSGIX(glGetFragmentLightivSGIX_ARG_EXPAND);
packed_call_t *pack_glGetFragmentLightivSGIX(glGetFragmentLightivSGIX_PACKED *_dst glGetFragmentLightivSGIX_ARG_EXPAND_TAIL);
typedef void (*glGetFragmentLightivSGIX_PTR)(glGetFragmentLightivSGIX_ARG_EXPAND);
#endif
#ifndef glGetFragmentMaterialfvSGIX_RETURN
#define glGetFragmentMaterialfvSGIX_RETURN void
#define glGetFragmentMaterialfvSGIX_ARG_NAMES face, pname, params
#define glGetFragmentMaterialfvSGIX_ARG_EXPAND GLenum face, GLenum pname, GLfloat * params
#define glGetFragmentMaterialfvSGIX_ARG_NAMES_TAIL , face, pname, params
#define glGetFragmentMaterialfvSGIX_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLfloat * params
#define forward_glGetFragmentMaterialfvSGIX(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFragmentMaterialfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFragmentMaterialfvSGIX(dst, _face, _pname, _params), NULL); \
    });
#define call_glGetFragmentMaterialfvSGIX(packed, ret_v) do { \
    glGetFragmentMaterialfvSGIX_PACKED *unpacked = (glGetFragmentMaterialfvSGIX_PACKED *)packed; \
    glGetFragmentMaterialfvSGIX_ARGS *args = (glGetFragmentMaterialfvSGIX_ARGS *)&unpacked->args; \
    glGetFragmentMaterialfvSGIX(args->face, args->pname, args->params);; \
} while(0)
void glGetFragmentMaterialfvSGIX(glGetFragmentMaterialfvSGIX_ARG_EXPAND);
packed_call_t *pack_glGetFragmentMaterialfvSGIX(glGetFragmentMaterialfvSGIX_PACKED *_dst glGetFragmentMaterialfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glGetFragmentMaterialfvSGIX_PTR)(glGetFragmentMaterialfvSGIX_ARG_EXPAND);
#endif
#ifndef glGetFragmentMaterialivSGIX_RETURN
#define glGetFragmentMaterialivSGIX_RETURN void
#define glGetFragmentMaterialivSGIX_ARG_NAMES face, pname, params
#define glGetFragmentMaterialivSGIX_ARG_EXPAND GLenum face, GLenum pname, GLint * params
#define glGetFragmentMaterialivSGIX_ARG_NAMES_TAIL , face, pname, params
#define glGetFragmentMaterialivSGIX_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLint * params
#define forward_glGetFragmentMaterialivSGIX(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFragmentMaterialivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFragmentMaterialivSGIX(dst, _face, _pname, _params), NULL); \
    });
#define call_glGetFragmentMaterialivSGIX(packed, ret_v) do { \
    glGetFragmentMaterialivSGIX_PACKED *unpacked = (glGetFragmentMaterialivSGIX_PACKED *)packed; \
    glGetFragmentMaterialivSGIX_ARGS *args = (glGetFragmentMaterialivSGIX_ARGS *)&unpacked->args; \
    glGetFragmentMaterialivSGIX(args->face, args->pname, args->params);; \
} while(0)
void glGetFragmentMaterialivSGIX(glGetFragmentMaterialivSGIX_ARG_EXPAND);
packed_call_t *pack_glGetFragmentMaterialivSGIX(glGetFragmentMaterialivSGIX_PACKED *_dst glGetFragmentMaterialivSGIX_ARG_EXPAND_TAIL);
typedef void (*glGetFragmentMaterialivSGIX_PTR)(glGetFragmentMaterialivSGIX_ARG_EXPAND);
#endif
#ifndef glGetFramebufferAttachmentParameteriv_RETURN
#define glGetFramebufferAttachmentParameteriv_RETURN void
#define glGetFramebufferAttachmentParameteriv_ARG_NAMES target, attachment, pname, params
#define glGetFramebufferAttachmentParameteriv_ARG_EXPAND GLenum target, GLenum attachment, GLenum pname, GLint * params
#define glGetFramebufferAttachmentParameteriv_ARG_NAMES_TAIL , target, attachment, pname, params
#define glGetFramebufferAttachmentParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum pname, GLint * params
#define forward_glGetFramebufferAttachmentParameteriv(_target, _attachment, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFramebufferAttachmentParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFramebufferAttachmentParameteriv(dst, _target, _attachment, _pname, _params), NULL); \
    });
#define call_glGetFramebufferAttachmentParameteriv(packed, ret_v) do { \
    glGetFramebufferAttachmentParameteriv_PACKED *unpacked = (glGetFramebufferAttachmentParameteriv_PACKED *)packed; \
    glGetFramebufferAttachmentParameteriv_ARGS *args = (glGetFramebufferAttachmentParameteriv_ARGS *)&unpacked->args; \
    glGetFramebufferAttachmentParameteriv(args->target, args->attachment, args->pname, args->params);; \
} while(0)
void glGetFramebufferAttachmentParameteriv(glGetFramebufferAttachmentParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetFramebufferAttachmentParameteriv(glGetFramebufferAttachmentParameteriv_PACKED *_dst glGetFramebufferAttachmentParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetFramebufferAttachmentParameteriv_PTR)(glGetFramebufferAttachmentParameteriv_ARG_EXPAND);
#endif
#ifndef glGetFramebufferAttachmentParameterivEXT_RETURN
#define glGetFramebufferAttachmentParameterivEXT_RETURN void
#define glGetFramebufferAttachmentParameterivEXT_ARG_NAMES target, attachment, pname, params
#define glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum pname, GLint * params
#define glGetFramebufferAttachmentParameterivEXT_ARG_NAMES_TAIL , target, attachment, pname, params
#define glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum attachment, GLenum pname, GLint * params
#define forward_glGetFramebufferAttachmentParameterivEXT(_target, _attachment, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFramebufferAttachmentParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFramebufferAttachmentParameterivEXT(dst, _target, _attachment, _pname, _params), NULL); \
    });
#define call_glGetFramebufferAttachmentParameterivEXT(packed, ret_v) do { \
    glGetFramebufferAttachmentParameterivEXT_PACKED *unpacked = (glGetFramebufferAttachmentParameterivEXT_PACKED *)packed; \
    glGetFramebufferAttachmentParameterivEXT_ARGS *args = (glGetFramebufferAttachmentParameterivEXT_ARGS *)&unpacked->args; \
    glGetFramebufferAttachmentParameterivEXT(args->target, args->attachment, args->pname, args->params);; \
} while(0)
void glGetFramebufferAttachmentParameterivEXT(glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetFramebufferAttachmentParameterivEXT(glGetFramebufferAttachmentParameterivEXT_PACKED *_dst glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetFramebufferAttachmentParameterivEXT_PTR)(glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetFramebufferParameteriv_RETURN
#define glGetFramebufferParameteriv_RETURN void
#define glGetFramebufferParameteriv_ARG_NAMES target, pname, params
#define glGetFramebufferParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetFramebufferParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetFramebufferParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetFramebufferParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFramebufferParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFramebufferParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetFramebufferParameteriv(packed, ret_v) do { \
    glGetFramebufferParameteriv_PACKED *unpacked = (glGetFramebufferParameteriv_PACKED *)packed; \
    glGetFramebufferParameteriv_ARGS *args = (glGetFramebufferParameteriv_ARGS *)&unpacked->args; \
    glGetFramebufferParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetFramebufferParameteriv(glGetFramebufferParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetFramebufferParameteriv(glGetFramebufferParameteriv_PACKED *_dst glGetFramebufferParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetFramebufferParameteriv_PTR)(glGetFramebufferParameteriv_ARG_EXPAND);
#endif
#ifndef glGetFramebufferParameterivEXT_RETURN
#define glGetFramebufferParameterivEXT_RETURN void
#define glGetFramebufferParameterivEXT_ARG_NAMES framebuffer, pname, params
#define glGetFramebufferParameterivEXT_ARG_EXPAND GLuint framebuffer, GLenum pname, GLint * params
#define glGetFramebufferParameterivEXT_ARG_NAMES_TAIL , framebuffer, pname, params
#define glGetFramebufferParameterivEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum pname, GLint * params
#define forward_glGetFramebufferParameterivEXT(_framebuffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetFramebufferParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetFramebufferParameterivEXT(dst, _framebuffer, _pname, _params), NULL); \
    });
#define call_glGetFramebufferParameterivEXT(packed, ret_v) do { \
    glGetFramebufferParameterivEXT_PACKED *unpacked = (glGetFramebufferParameterivEXT_PACKED *)packed; \
    glGetFramebufferParameterivEXT_ARGS *args = (glGetFramebufferParameterivEXT_ARGS *)&unpacked->args; \
    glGetFramebufferParameterivEXT(args->framebuffer, args->pname, args->params);; \
} while(0)
void glGetFramebufferParameterivEXT(glGetFramebufferParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetFramebufferParameterivEXT(glGetFramebufferParameterivEXT_PACKED *_dst glGetFramebufferParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetFramebufferParameterivEXT_PTR)(glGetFramebufferParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetGraphicsResetStatusARB_RETURN
#define glGetGraphicsResetStatusARB_RETURN GLenum
#define glGetGraphicsResetStatusARB_ARG_NAMES 
#define glGetGraphicsResetStatusARB_ARG_EXPAND 
#define glGetGraphicsResetStatusARB_ARG_NAMES_TAIL 
#define glGetGraphicsResetStatusARB_ARG_EXPAND_TAIL 
#define forward_glGetGraphicsResetStatusARB() \
    ({ \
        void *dst = remote_dma(sizeof(glGetGraphicsResetStatusARB_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glGetGraphicsResetStatusARB(dst), &ret); \
        ret; \
    });
#define call_glGetGraphicsResetStatusARB(packed, ret_v) do { \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetGraphicsResetStatusARB();; \
    } else { \
        glGetGraphicsResetStatusARB();; \
    } \
} while(0)
GLenum glGetGraphicsResetStatusARB(glGetGraphicsResetStatusARB_ARG_EXPAND);
packed_call_t *pack_glGetGraphicsResetStatusARB(glGetGraphicsResetStatusARB_PACKED *_dst glGetGraphicsResetStatusARB_ARG_EXPAND_TAIL);
typedef GLenum (*glGetGraphicsResetStatusARB_PTR)(glGetGraphicsResetStatusARB_ARG_EXPAND);
#endif
#ifndef glGetHandleARB_RETURN
#define glGetHandleARB_RETURN GLhandleARB
#define glGetHandleARB_ARG_NAMES pname
#define glGetHandleARB_ARG_EXPAND GLenum pname
#define glGetHandleARB_ARG_NAMES_TAIL , pname
#define glGetHandleARB_ARG_EXPAND_TAIL , GLenum pname
#define forward_glGetHandleARB(_pname) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHandleARB_PACKED)); \
        GLhandleARB ret = (GLhandleARB)0; \
        remote_dma_send((packed_call_t *)pack_glGetHandleARB(dst, _pname), &ret); \
        ret; \
    });
#define call_glGetHandleARB(packed, ret_v) do { \
    glGetHandleARB_PACKED *unpacked = (glGetHandleARB_PACKED *)packed; \
    glGetHandleARB_ARGS *args = (glGetHandleARB_ARGS *)&unpacked->args; \
    GLhandleARB *ret = (GLhandleARB *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetHandleARB(args->pname);; \
    } else { \
        glGetHandleARB(args->pname);; \
    } \
} while(0)
GLhandleARB glGetHandleARB(glGetHandleARB_ARG_EXPAND);
packed_call_t *pack_glGetHandleARB(glGetHandleARB_PACKED *_dst glGetHandleARB_ARG_EXPAND_TAIL);
typedef GLhandleARB (*glGetHandleARB_PTR)(glGetHandleARB_ARG_EXPAND);
#endif
#ifndef glGetHistogram_RETURN
#define glGetHistogram_RETURN void
#define glGetHistogram_ARG_NAMES target, reset, format, type, values
#define glGetHistogram_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetHistogram_ARG_NAMES_TAIL , target, reset, format, type, values
#define glGetHistogram_ARG_EXPAND_TAIL , GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define forward_glGetHistogram(_target, _reset, _format, _type, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHistogram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetHistogram(dst, _target, _reset, _format, _type, _values), NULL); \
    });
#define call_glGetHistogram(packed, ret_v) do { \
    glGetHistogram_PACKED *unpacked = (glGetHistogram_PACKED *)packed; \
    glGetHistogram_ARGS *args = (glGetHistogram_ARGS *)&unpacked->args; \
    glGetHistogram(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetHistogram(glGetHistogram_ARG_EXPAND);
packed_call_t *pack_glGetHistogram(glGetHistogram_PACKED *_dst glGetHistogram_ARG_EXPAND_TAIL);
typedef void (*glGetHistogram_PTR)(glGetHistogram_ARG_EXPAND);
#endif
#ifndef glGetHistogramEXT_RETURN
#define glGetHistogramEXT_RETURN void
#define glGetHistogramEXT_ARG_NAMES target, reset, format, type, values
#define glGetHistogramEXT_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetHistogramEXT_ARG_NAMES_TAIL , target, reset, format, type, values
#define glGetHistogramEXT_ARG_EXPAND_TAIL , GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define forward_glGetHistogramEXT(_target, _reset, _format, _type, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHistogramEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetHistogramEXT(dst, _target, _reset, _format, _type, _values), NULL); \
    });
#define call_glGetHistogramEXT(packed, ret_v) do { \
    glGetHistogramEXT_PACKED *unpacked = (glGetHistogramEXT_PACKED *)packed; \
    glGetHistogramEXT_ARGS *args = (glGetHistogramEXT_ARGS *)&unpacked->args; \
    glGetHistogramEXT(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetHistogramEXT(glGetHistogramEXT_ARG_EXPAND);
packed_call_t *pack_glGetHistogramEXT(glGetHistogramEXT_PACKED *_dst glGetHistogramEXT_ARG_EXPAND_TAIL);
typedef void (*glGetHistogramEXT_PTR)(glGetHistogramEXT_ARG_EXPAND);
#endif
#ifndef glGetHistogramParameterfv_RETURN
#define glGetHistogramParameterfv_RETURN void
#define glGetHistogramParameterfv_ARG_NAMES target, pname, params
#define glGetHistogramParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetHistogramParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glGetHistogramParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetHistogramParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHistogramParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetHistogramParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetHistogramParameterfv(packed, ret_v) do { \
    glGetHistogramParameterfv_PACKED *unpacked = (glGetHistogramParameterfv_PACKED *)packed; \
    glGetHistogramParameterfv_ARGS *args = (glGetHistogramParameterfv_ARGS *)&unpacked->args; \
    glGetHistogramParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterfv(glGetHistogramParameterfv_ARG_EXPAND);
packed_call_t *pack_glGetHistogramParameterfv(glGetHistogramParameterfv_PACKED *_dst glGetHistogramParameterfv_ARG_EXPAND_TAIL);
typedef void (*glGetHistogramParameterfv_PTR)(glGetHistogramParameterfv_ARG_EXPAND);
#endif
#ifndef glGetHistogramParameterfvEXT_RETURN
#define glGetHistogramParameterfvEXT_RETURN void
#define glGetHistogramParameterfvEXT_ARG_NAMES target, pname, params
#define glGetHistogramParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetHistogramParameterfvEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetHistogramParameterfvEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetHistogramParameterfvEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHistogramParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetHistogramParameterfvEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetHistogramParameterfvEXT(packed, ret_v) do { \
    glGetHistogramParameterfvEXT_PACKED *unpacked = (glGetHistogramParameterfvEXT_PACKED *)packed; \
    glGetHistogramParameterfvEXT_ARGS *args = (glGetHistogramParameterfvEXT_ARGS *)&unpacked->args; \
    glGetHistogramParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterfvEXT(glGetHistogramParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetHistogramParameterfvEXT(glGetHistogramParameterfvEXT_PACKED *_dst glGetHistogramParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetHistogramParameterfvEXT_PTR)(glGetHistogramParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetHistogramParameteriv_RETURN
#define glGetHistogramParameteriv_RETURN void
#define glGetHistogramParameteriv_ARG_NAMES target, pname, params
#define glGetHistogramParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetHistogramParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetHistogramParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetHistogramParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHistogramParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetHistogramParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetHistogramParameteriv(packed, ret_v) do { \
    glGetHistogramParameteriv_PACKED *unpacked = (glGetHistogramParameteriv_PACKED *)packed; \
    glGetHistogramParameteriv_ARGS *args = (glGetHistogramParameteriv_ARGS *)&unpacked->args; \
    glGetHistogramParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameteriv(glGetHistogramParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetHistogramParameteriv(glGetHistogramParameteriv_PACKED *_dst glGetHistogramParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetHistogramParameteriv_PTR)(glGetHistogramParameteriv_ARG_EXPAND);
#endif
#ifndef glGetHistogramParameterivEXT_RETURN
#define glGetHistogramParameterivEXT_RETURN void
#define glGetHistogramParameterivEXT_ARG_NAMES target, pname, params
#define glGetHistogramParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetHistogramParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetHistogramParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetHistogramParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHistogramParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetHistogramParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetHistogramParameterivEXT(packed, ret_v) do { \
    glGetHistogramParameterivEXT_PACKED *unpacked = (glGetHistogramParameterivEXT_PACKED *)packed; \
    glGetHistogramParameterivEXT_ARGS *args = (glGetHistogramParameterivEXT_ARGS *)&unpacked->args; \
    glGetHistogramParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterivEXT(glGetHistogramParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetHistogramParameterivEXT(glGetHistogramParameterivEXT_PACKED *_dst glGetHistogramParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetHistogramParameterivEXT_PTR)(glGetHistogramParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetHistogramParameterxvOES_RETURN
#define glGetHistogramParameterxvOES_RETURN void
#define glGetHistogramParameterxvOES_ARG_NAMES target, pname, params
#define glGetHistogramParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetHistogramParameterxvOES_ARG_NAMES_TAIL , target, pname, params
#define glGetHistogramParameterxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfixed * params
#define forward_glGetHistogramParameterxvOES(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetHistogramParameterxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetHistogramParameterxvOES(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetHistogramParameterxvOES(packed, ret_v) do { \
    glGetHistogramParameterxvOES_PACKED *unpacked = (glGetHistogramParameterxvOES_PACKED *)packed; \
    glGetHistogramParameterxvOES_ARGS *args = (glGetHistogramParameterxvOES_ARGS *)&unpacked->args; \
    glGetHistogramParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterxvOES(glGetHistogramParameterxvOES_ARG_EXPAND);
packed_call_t *pack_glGetHistogramParameterxvOES(glGetHistogramParameterxvOES_PACKED *_dst glGetHistogramParameterxvOES_ARG_EXPAND_TAIL);
typedef void (*glGetHistogramParameterxvOES_PTR)(glGetHistogramParameterxvOES_ARG_EXPAND);
#endif
#ifndef glGetImageHandleNV_RETURN
#define glGetImageHandleNV_RETURN GLuint64
#define glGetImageHandleNV_ARG_NAMES texture, level, layered, layer, format
#define glGetImageHandleNV_ARG_EXPAND GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format
#define glGetImageHandleNV_ARG_NAMES_TAIL , texture, level, layered, layer, format
#define glGetImageHandleNV_ARG_EXPAND_TAIL , GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format
#define forward_glGetImageHandleNV(_texture, _level, _layered, _layer, _format) \
    ({ \
        void *dst = remote_dma(sizeof(glGetImageHandleNV_PACKED)); \
        GLuint64 ret = (GLuint64)0; \
        remote_dma_send((packed_call_t *)pack_glGetImageHandleNV(dst, _texture, _level, _layered, _layer, _format), &ret); \
        ret; \
    });
#define call_glGetImageHandleNV(packed, ret_v) do { \
    glGetImageHandleNV_PACKED *unpacked = (glGetImageHandleNV_PACKED *)packed; \
    glGetImageHandleNV_ARGS *args = (glGetImageHandleNV_ARGS *)&unpacked->args; \
    GLuint64 *ret = (GLuint64 *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetImageHandleNV(args->texture, args->level, args->layered, args->layer, args->format);; \
    } else { \
        glGetImageHandleNV(args->texture, args->level, args->layered, args->layer, args->format);; \
    } \
} while(0)
GLuint64 glGetImageHandleNV(glGetImageHandleNV_ARG_EXPAND);
packed_call_t *pack_glGetImageHandleNV(glGetImageHandleNV_PACKED *_dst glGetImageHandleNV_ARG_EXPAND_TAIL);
typedef GLuint64 (*glGetImageHandleNV_PTR)(glGetImageHandleNV_ARG_EXPAND);
#endif
#ifndef glGetImageTransformParameterfvHP_RETURN
#define glGetImageTransformParameterfvHP_RETURN void
#define glGetImageTransformParameterfvHP_ARG_NAMES target, pname, params
#define glGetImageTransformParameterfvHP_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetImageTransformParameterfvHP_ARG_NAMES_TAIL , target, pname, params
#define glGetImageTransformParameterfvHP_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetImageTransformParameterfvHP(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetImageTransformParameterfvHP_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetImageTransformParameterfvHP(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetImageTransformParameterfvHP(packed, ret_v) do { \
    glGetImageTransformParameterfvHP_PACKED *unpacked = (glGetImageTransformParameterfvHP_PACKED *)packed; \
    glGetImageTransformParameterfvHP_ARGS *args = (glGetImageTransformParameterfvHP_ARGS *)&unpacked->args; \
    glGetImageTransformParameterfvHP(args->target, args->pname, args->params);; \
} while(0)
void glGetImageTransformParameterfvHP(glGetImageTransformParameterfvHP_ARG_EXPAND);
packed_call_t *pack_glGetImageTransformParameterfvHP(glGetImageTransformParameterfvHP_PACKED *_dst glGetImageTransformParameterfvHP_ARG_EXPAND_TAIL);
typedef void (*glGetImageTransformParameterfvHP_PTR)(glGetImageTransformParameterfvHP_ARG_EXPAND);
#endif
#ifndef glGetImageTransformParameterivHP_RETURN
#define glGetImageTransformParameterivHP_RETURN void
#define glGetImageTransformParameterivHP_ARG_NAMES target, pname, params
#define glGetImageTransformParameterivHP_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetImageTransformParameterivHP_ARG_NAMES_TAIL , target, pname, params
#define glGetImageTransformParameterivHP_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetImageTransformParameterivHP(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetImageTransformParameterivHP_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetImageTransformParameterivHP(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetImageTransformParameterivHP(packed, ret_v) do { \
    glGetImageTransformParameterivHP_PACKED *unpacked = (glGetImageTransformParameterivHP_PACKED *)packed; \
    glGetImageTransformParameterivHP_ARGS *args = (glGetImageTransformParameterivHP_ARGS *)&unpacked->args; \
    glGetImageTransformParameterivHP(args->target, args->pname, args->params);; \
} while(0)
void glGetImageTransformParameterivHP(glGetImageTransformParameterivHP_ARG_EXPAND);
packed_call_t *pack_glGetImageTransformParameterivHP(glGetImageTransformParameterivHP_PACKED *_dst glGetImageTransformParameterivHP_ARG_EXPAND_TAIL);
typedef void (*glGetImageTransformParameterivHP_PTR)(glGetImageTransformParameterivHP_ARG_EXPAND);
#endif
#ifndef glGetInfoLogARB_RETURN
#define glGetInfoLogARB_RETURN void
#define glGetInfoLogARB_ARG_NAMES obj, maxLength, length, infoLog
#define glGetInfoLogARB_ARG_EXPAND GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog
#define glGetInfoLogARB_ARG_NAMES_TAIL , obj, maxLength, length, infoLog
#define glGetInfoLogARB_ARG_EXPAND_TAIL , GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog
#define forward_glGetInfoLogARB(_obj, _maxLength, _length, _infoLog) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInfoLogARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInfoLogARB(dst, _obj, _maxLength, _length, _infoLog), NULL); \
    });
#define call_glGetInfoLogARB(packed, ret_v) do { \
    glGetInfoLogARB_PACKED *unpacked = (glGetInfoLogARB_PACKED *)packed; \
    glGetInfoLogARB_ARGS *args = (glGetInfoLogARB_ARGS *)&unpacked->args; \
    glGetInfoLogARB(args->obj, args->maxLength, args->length, args->infoLog);; \
} while(0)
void glGetInfoLogARB(glGetInfoLogARB_ARG_EXPAND);
packed_call_t *pack_glGetInfoLogARB(glGetInfoLogARB_PACKED *_dst glGetInfoLogARB_ARG_EXPAND_TAIL);
typedef void (*glGetInfoLogARB_PTR)(glGetInfoLogARB_ARG_EXPAND);
#endif
#ifndef glGetInstrumentsSGIX_RETURN
#define glGetInstrumentsSGIX_RETURN GLint
#define glGetInstrumentsSGIX_ARG_NAMES 
#define glGetInstrumentsSGIX_ARG_EXPAND 
#define glGetInstrumentsSGIX_ARG_NAMES_TAIL 
#define glGetInstrumentsSGIX_ARG_EXPAND_TAIL 
#define forward_glGetInstrumentsSGIX() \
    ({ \
        void *dst = remote_dma(sizeof(glGetInstrumentsSGIX_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetInstrumentsSGIX(dst), &ret); \
        ret; \
    });
#define call_glGetInstrumentsSGIX(packed, ret_v) do { \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetInstrumentsSGIX();; \
    } else { \
        glGetInstrumentsSGIX();; \
    } \
} while(0)
GLint glGetInstrumentsSGIX(glGetInstrumentsSGIX_ARG_EXPAND);
packed_call_t *pack_glGetInstrumentsSGIX(glGetInstrumentsSGIX_PACKED *_dst glGetInstrumentsSGIX_ARG_EXPAND_TAIL);
typedef GLint (*glGetInstrumentsSGIX_PTR)(glGetInstrumentsSGIX_ARG_EXPAND);
#endif
#ifndef glGetInteger64i_v_RETURN
#define glGetInteger64i_v_RETURN void
#define glGetInteger64i_v_ARG_NAMES target, index, data
#define glGetInteger64i_v_ARG_EXPAND GLenum target, GLuint index, GLint64 * data
#define glGetInteger64i_v_ARG_NAMES_TAIL , target, index, data
#define glGetInteger64i_v_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLint64 * data
#define forward_glGetInteger64i_v(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInteger64i_v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInteger64i_v(dst, _target, _index, _data), NULL); \
    });
#define call_glGetInteger64i_v(packed, ret_v) do { \
    glGetInteger64i_v_PACKED *unpacked = (glGetInteger64i_v_PACKED *)packed; \
    glGetInteger64i_v_ARGS *args = (glGetInteger64i_v_ARGS *)&unpacked->args; \
    glGetInteger64i_v(args->target, args->index, args->data);; \
} while(0)
void glGetInteger64i_v(glGetInteger64i_v_ARG_EXPAND);
packed_call_t *pack_glGetInteger64i_v(glGetInteger64i_v_PACKED *_dst glGetInteger64i_v_ARG_EXPAND_TAIL);
typedef void (*glGetInteger64i_v_PTR)(glGetInteger64i_v_ARG_EXPAND);
#endif
#ifndef glGetInteger64v_RETURN
#define glGetInteger64v_RETURN void
#define glGetInteger64v_ARG_NAMES pname, params
#define glGetInteger64v_ARG_EXPAND GLenum pname, GLint64 * params
#define glGetInteger64v_ARG_NAMES_TAIL , pname, params
#define glGetInteger64v_ARG_EXPAND_TAIL , GLenum pname, GLint64 * params
#define forward_glGetInteger64v(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInteger64v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInteger64v(dst, _pname, _params), NULL); \
    });
#define call_glGetInteger64v(packed, ret_v) do { \
    glGetInteger64v_PACKED *unpacked = (glGetInteger64v_PACKED *)packed; \
    glGetInteger64v_ARGS *args = (glGetInteger64v_ARGS *)&unpacked->args; \
    glGetInteger64v(args->pname, args->params);; \
} while(0)
void glGetInteger64v(glGetInteger64v_ARG_EXPAND);
packed_call_t *pack_glGetInteger64v(glGetInteger64v_PACKED *_dst glGetInteger64v_ARG_EXPAND_TAIL);
typedef void (*glGetInteger64v_PTR)(glGetInteger64v_ARG_EXPAND);
#endif
#ifndef glGetIntegerIndexedvEXT_RETURN
#define glGetIntegerIndexedvEXT_RETURN void
#define glGetIntegerIndexedvEXT_ARG_NAMES target, index, data
#define glGetIntegerIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLint * data
#define glGetIntegerIndexedvEXT_ARG_NAMES_TAIL , target, index, data
#define glGetIntegerIndexedvEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLint * data
#define forward_glGetIntegerIndexedvEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetIntegerIndexedvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetIntegerIndexedvEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetIntegerIndexedvEXT(packed, ret_v) do { \
    glGetIntegerIndexedvEXT_PACKED *unpacked = (glGetIntegerIndexedvEXT_PACKED *)packed; \
    glGetIntegerIndexedvEXT_ARGS *args = (glGetIntegerIndexedvEXT_ARGS *)&unpacked->args; \
    glGetIntegerIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetIntegerIndexedvEXT(glGetIntegerIndexedvEXT_ARG_EXPAND);
packed_call_t *pack_glGetIntegerIndexedvEXT(glGetIntegerIndexedvEXT_PACKED *_dst glGetIntegerIndexedvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetIntegerIndexedvEXT_PTR)(glGetIntegerIndexedvEXT_ARG_EXPAND);
#endif
#ifndef glGetIntegeri_v_RETURN
#define glGetIntegeri_v_RETURN void
#define glGetIntegeri_v_ARG_NAMES target, index, data
#define glGetIntegeri_v_ARG_EXPAND GLenum target, GLuint index, GLint * data
#define glGetIntegeri_v_ARG_NAMES_TAIL , target, index, data
#define glGetIntegeri_v_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLint * data
#define forward_glGetIntegeri_v(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetIntegeri_v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetIntegeri_v(dst, _target, _index, _data), NULL); \
    });
#define call_glGetIntegeri_v(packed, ret_v) do { \
    glGetIntegeri_v_PACKED *unpacked = (glGetIntegeri_v_PACKED *)packed; \
    glGetIntegeri_v_ARGS *args = (glGetIntegeri_v_ARGS *)&unpacked->args; \
    glGetIntegeri_v(args->target, args->index, args->data);; \
} while(0)
void glGetIntegeri_v(glGetIntegeri_v_ARG_EXPAND);
packed_call_t *pack_glGetIntegeri_v(glGetIntegeri_v_PACKED *_dst glGetIntegeri_v_ARG_EXPAND_TAIL);
typedef void (*glGetIntegeri_v_PTR)(glGetIntegeri_v_ARG_EXPAND);
#endif
#ifndef glGetIntegerui64i_vNV_RETURN
#define glGetIntegerui64i_vNV_RETURN void
#define glGetIntegerui64i_vNV_ARG_NAMES value, index, result
#define glGetIntegerui64i_vNV_ARG_EXPAND GLenum value, GLuint index, GLuint64EXT * result
#define glGetIntegerui64i_vNV_ARG_NAMES_TAIL , value, index, result
#define glGetIntegerui64i_vNV_ARG_EXPAND_TAIL , GLenum value, GLuint index, GLuint64EXT * result
#define forward_glGetIntegerui64i_vNV(_value, _index, _result) \
    ({ \
        void *dst = remote_dma(sizeof(glGetIntegerui64i_vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetIntegerui64i_vNV(dst, _value, _index, _result), NULL); \
    });
#define call_glGetIntegerui64i_vNV(packed, ret_v) do { \
    glGetIntegerui64i_vNV_PACKED *unpacked = (glGetIntegerui64i_vNV_PACKED *)packed; \
    glGetIntegerui64i_vNV_ARGS *args = (glGetIntegerui64i_vNV_ARGS *)&unpacked->args; \
    glGetIntegerui64i_vNV(args->value, args->index, args->result);; \
} while(0)
void glGetIntegerui64i_vNV(glGetIntegerui64i_vNV_ARG_EXPAND);
packed_call_t *pack_glGetIntegerui64i_vNV(glGetIntegerui64i_vNV_PACKED *_dst glGetIntegerui64i_vNV_ARG_EXPAND_TAIL);
typedef void (*glGetIntegerui64i_vNV_PTR)(glGetIntegerui64i_vNV_ARG_EXPAND);
#endif
#ifndef glGetIntegerui64vNV_RETURN
#define glGetIntegerui64vNV_RETURN void
#define glGetIntegerui64vNV_ARG_NAMES value, result
#define glGetIntegerui64vNV_ARG_EXPAND GLenum value, GLuint64EXT * result
#define glGetIntegerui64vNV_ARG_NAMES_TAIL , value, result
#define glGetIntegerui64vNV_ARG_EXPAND_TAIL , GLenum value, GLuint64EXT * result
#define forward_glGetIntegerui64vNV(_value, _result) \
    ({ \
        void *dst = remote_dma(sizeof(glGetIntegerui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetIntegerui64vNV(dst, _value, _result), NULL); \
    });
#define call_glGetIntegerui64vNV(packed, ret_v) do { \
    glGetIntegerui64vNV_PACKED *unpacked = (glGetIntegerui64vNV_PACKED *)packed; \
    glGetIntegerui64vNV_ARGS *args = (glGetIntegerui64vNV_ARGS *)&unpacked->args; \
    glGetIntegerui64vNV(args->value, args->result);; \
} while(0)
void glGetIntegerui64vNV(glGetIntegerui64vNV_ARG_EXPAND);
packed_call_t *pack_glGetIntegerui64vNV(glGetIntegerui64vNV_PACKED *_dst glGetIntegerui64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetIntegerui64vNV_PTR)(glGetIntegerui64vNV_ARG_EXPAND);
#endif
#ifndef glGetIntegerv_RETURN
#define glGetIntegerv_RETURN void
#define glGetIntegerv_ARG_NAMES pname, params
#define glGetIntegerv_ARG_EXPAND GLenum pname, GLint * params
#define glGetIntegerv_ARG_NAMES_TAIL , pname, params
#define glGetIntegerv_ARG_EXPAND_TAIL , GLenum pname, GLint * params
#define forward_glGetIntegerv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetIntegerv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetIntegerv(dst, _pname, _params), NULL); \
    });
#define call_glGetIntegerv(packed, ret_v) do { \
    glGetIntegerv_PACKED *unpacked = (glGetIntegerv_PACKED *)packed; \
    glGetIntegerv_ARGS *args = (glGetIntegerv_ARGS *)&unpacked->args; \
    glGetIntegerv(args->pname, args->params);; \
} while(0)
void glGetIntegerv(glGetIntegerv_ARG_EXPAND);
packed_call_t *pack_glGetIntegerv(glGetIntegerv_PACKED *_dst glGetIntegerv_ARG_EXPAND_TAIL);
typedef void (*glGetIntegerv_PTR)(glGetIntegerv_ARG_EXPAND);
#endif
#ifndef glGetInternalformati64v_RETURN
#define glGetInternalformati64v_RETURN void
#define glGetInternalformati64v_ARG_NAMES target, internalformat, pname, bufSize, params
#define glGetInternalformati64v_ARG_EXPAND GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params
#define glGetInternalformati64v_ARG_NAMES_TAIL , target, internalformat, pname, bufSize, params
#define glGetInternalformati64v_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params
#define forward_glGetInternalformati64v(_target, _internalformat, _pname, _bufSize, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInternalformati64v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInternalformati64v(dst, _target, _internalformat, _pname, _bufSize, _params), NULL); \
    });
#define call_glGetInternalformati64v(packed, ret_v) do { \
    glGetInternalformati64v_PACKED *unpacked = (glGetInternalformati64v_PACKED *)packed; \
    glGetInternalformati64v_ARGS *args = (glGetInternalformati64v_ARGS *)&unpacked->args; \
    glGetInternalformati64v(args->target, args->internalformat, args->pname, args->bufSize, args->params);; \
} while(0)
void glGetInternalformati64v(glGetInternalformati64v_ARG_EXPAND);
packed_call_t *pack_glGetInternalformati64v(glGetInternalformati64v_PACKED *_dst glGetInternalformati64v_ARG_EXPAND_TAIL);
typedef void (*glGetInternalformati64v_PTR)(glGetInternalformati64v_ARG_EXPAND);
#endif
#ifndef glGetInternalformativ_RETURN
#define glGetInternalformativ_RETURN void
#define glGetInternalformativ_ARG_NAMES target, internalformat, pname, bufSize, params
#define glGetInternalformativ_ARG_EXPAND GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params
#define glGetInternalformativ_ARG_NAMES_TAIL , target, internalformat, pname, bufSize, params
#define glGetInternalformativ_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params
#define forward_glGetInternalformativ(_target, _internalformat, _pname, _bufSize, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInternalformativ_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInternalformativ(dst, _target, _internalformat, _pname, _bufSize, _params), NULL); \
    });
#define call_glGetInternalformativ(packed, ret_v) do { \
    glGetInternalformativ_PACKED *unpacked = (glGetInternalformativ_PACKED *)packed; \
    glGetInternalformativ_ARGS *args = (glGetInternalformativ_ARGS *)&unpacked->args; \
    glGetInternalformativ(args->target, args->internalformat, args->pname, args->bufSize, args->params);; \
} while(0)
void glGetInternalformativ(glGetInternalformativ_ARG_EXPAND);
packed_call_t *pack_glGetInternalformativ(glGetInternalformativ_PACKED *_dst glGetInternalformativ_ARG_EXPAND_TAIL);
typedef void (*glGetInternalformativ_PTR)(glGetInternalformativ_ARG_EXPAND);
#endif
#ifndef glGetInvariantBooleanvEXT_RETURN
#define glGetInvariantBooleanvEXT_RETURN void
#define glGetInvariantBooleanvEXT_ARG_NAMES id, value, data
#define glGetInvariantBooleanvEXT_ARG_EXPAND GLuint id, GLenum value, GLboolean * data
#define glGetInvariantBooleanvEXT_ARG_NAMES_TAIL , id, value, data
#define glGetInvariantBooleanvEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLboolean * data
#define forward_glGetInvariantBooleanvEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInvariantBooleanvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInvariantBooleanvEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetInvariantBooleanvEXT(packed, ret_v) do { \
    glGetInvariantBooleanvEXT_PACKED *unpacked = (glGetInvariantBooleanvEXT_PACKED *)packed; \
    glGetInvariantBooleanvEXT_ARGS *args = (glGetInvariantBooleanvEXT_ARGS *)&unpacked->args; \
    glGetInvariantBooleanvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetInvariantBooleanvEXT(glGetInvariantBooleanvEXT_ARG_EXPAND);
packed_call_t *pack_glGetInvariantBooleanvEXT(glGetInvariantBooleanvEXT_PACKED *_dst glGetInvariantBooleanvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetInvariantBooleanvEXT_PTR)(glGetInvariantBooleanvEXT_ARG_EXPAND);
#endif
#ifndef glGetInvariantFloatvEXT_RETURN
#define glGetInvariantFloatvEXT_RETURN void
#define glGetInvariantFloatvEXT_ARG_NAMES id, value, data
#define glGetInvariantFloatvEXT_ARG_EXPAND GLuint id, GLenum value, GLfloat * data
#define glGetInvariantFloatvEXT_ARG_NAMES_TAIL , id, value, data
#define glGetInvariantFloatvEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLfloat * data
#define forward_glGetInvariantFloatvEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInvariantFloatvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInvariantFloatvEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetInvariantFloatvEXT(packed, ret_v) do { \
    glGetInvariantFloatvEXT_PACKED *unpacked = (glGetInvariantFloatvEXT_PACKED *)packed; \
    glGetInvariantFloatvEXT_ARGS *args = (glGetInvariantFloatvEXT_ARGS *)&unpacked->args; \
    glGetInvariantFloatvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetInvariantFloatvEXT(glGetInvariantFloatvEXT_ARG_EXPAND);
packed_call_t *pack_glGetInvariantFloatvEXT(glGetInvariantFloatvEXT_PACKED *_dst glGetInvariantFloatvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetInvariantFloatvEXT_PTR)(glGetInvariantFloatvEXT_ARG_EXPAND);
#endif
#ifndef glGetInvariantIntegervEXT_RETURN
#define glGetInvariantIntegervEXT_RETURN void
#define glGetInvariantIntegervEXT_ARG_NAMES id, value, data
#define glGetInvariantIntegervEXT_ARG_EXPAND GLuint id, GLenum value, GLint * data
#define glGetInvariantIntegervEXT_ARG_NAMES_TAIL , id, value, data
#define glGetInvariantIntegervEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLint * data
#define forward_glGetInvariantIntegervEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetInvariantIntegervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetInvariantIntegervEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetInvariantIntegervEXT(packed, ret_v) do { \
    glGetInvariantIntegervEXT_PACKED *unpacked = (glGetInvariantIntegervEXT_PACKED *)packed; \
    glGetInvariantIntegervEXT_ARGS *args = (glGetInvariantIntegervEXT_ARGS *)&unpacked->args; \
    glGetInvariantIntegervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetInvariantIntegervEXT(glGetInvariantIntegervEXT_ARG_EXPAND);
packed_call_t *pack_glGetInvariantIntegervEXT(glGetInvariantIntegervEXT_PACKED *_dst glGetInvariantIntegervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetInvariantIntegervEXT_PTR)(glGetInvariantIntegervEXT_ARG_EXPAND);
#endif
#ifndef glGetLightfv_RETURN
#define glGetLightfv_RETURN void
#define glGetLightfv_ARG_NAMES light, pname, params
#define glGetLightfv_ARG_EXPAND GLenum light, GLenum pname, GLfloat * params
#define glGetLightfv_ARG_NAMES_TAIL , light, pname, params
#define glGetLightfv_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLfloat * params
#define forward_glGetLightfv(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetLightfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetLightfv(dst, _light, _pname, _params), NULL); \
    });
#define call_glGetLightfv(packed, ret_v) do { \
    glGetLightfv_PACKED *unpacked = (glGetLightfv_PACKED *)packed; \
    glGetLightfv_ARGS *args = (glGetLightfv_ARGS *)&unpacked->args; \
    glGetLightfv(args->light, args->pname, args->params);; \
} while(0)
void glGetLightfv(glGetLightfv_ARG_EXPAND);
packed_call_t *pack_glGetLightfv(glGetLightfv_PACKED *_dst glGetLightfv_ARG_EXPAND_TAIL);
typedef void (*glGetLightfv_PTR)(glGetLightfv_ARG_EXPAND);
#endif
#ifndef glGetLightiv_RETURN
#define glGetLightiv_RETURN void
#define glGetLightiv_ARG_NAMES light, pname, params
#define glGetLightiv_ARG_EXPAND GLenum light, GLenum pname, GLint * params
#define glGetLightiv_ARG_NAMES_TAIL , light, pname, params
#define glGetLightiv_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLint * params
#define forward_glGetLightiv(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetLightiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetLightiv(dst, _light, _pname, _params), NULL); \
    });
#define call_glGetLightiv(packed, ret_v) do { \
    glGetLightiv_PACKED *unpacked = (glGetLightiv_PACKED *)packed; \
    glGetLightiv_ARGS *args = (glGetLightiv_ARGS *)&unpacked->args; \
    glGetLightiv(args->light, args->pname, args->params);; \
} while(0)
void glGetLightiv(glGetLightiv_ARG_EXPAND);
packed_call_t *pack_glGetLightiv(glGetLightiv_PACKED *_dst glGetLightiv_ARG_EXPAND_TAIL);
typedef void (*glGetLightiv_PTR)(glGetLightiv_ARG_EXPAND);
#endif
#ifndef glGetLightxOES_RETURN
#define glGetLightxOES_RETURN void
#define glGetLightxOES_ARG_NAMES light, pname, params
#define glGetLightxOES_ARG_EXPAND GLenum light, GLenum pname, GLfixed * params
#define glGetLightxOES_ARG_NAMES_TAIL , light, pname, params
#define glGetLightxOES_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLfixed * params
#define forward_glGetLightxOES(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetLightxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetLightxOES(dst, _light, _pname, _params), NULL); \
    });
#define call_glGetLightxOES(packed, ret_v) do { \
    glGetLightxOES_PACKED *unpacked = (glGetLightxOES_PACKED *)packed; \
    glGetLightxOES_ARGS *args = (glGetLightxOES_ARGS *)&unpacked->args; \
    glGetLightxOES(args->light, args->pname, args->params);; \
} while(0)
void glGetLightxOES(glGetLightxOES_ARG_EXPAND);
packed_call_t *pack_glGetLightxOES(glGetLightxOES_PACKED *_dst glGetLightxOES_ARG_EXPAND_TAIL);
typedef void (*glGetLightxOES_PTR)(glGetLightxOES_ARG_EXPAND);
#endif
#ifndef glGetListParameterfvSGIX_RETURN
#define glGetListParameterfvSGIX_RETURN void
#define glGetListParameterfvSGIX_ARG_NAMES list, pname, params
#define glGetListParameterfvSGIX_ARG_EXPAND GLuint list, GLenum pname, GLfloat * params
#define glGetListParameterfvSGIX_ARG_NAMES_TAIL , list, pname, params
#define glGetListParameterfvSGIX_ARG_EXPAND_TAIL , GLuint list, GLenum pname, GLfloat * params
#define forward_glGetListParameterfvSGIX(_list, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetListParameterfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetListParameterfvSGIX(dst, _list, _pname, _params), NULL); \
    });
#define call_glGetListParameterfvSGIX(packed, ret_v) do { \
    glGetListParameterfvSGIX_PACKED *unpacked = (glGetListParameterfvSGIX_PACKED *)packed; \
    glGetListParameterfvSGIX_ARGS *args = (glGetListParameterfvSGIX_ARGS *)&unpacked->args; \
    glGetListParameterfvSGIX(args->list, args->pname, args->params);; \
} while(0)
void glGetListParameterfvSGIX(glGetListParameterfvSGIX_ARG_EXPAND);
packed_call_t *pack_glGetListParameterfvSGIX(glGetListParameterfvSGIX_PACKED *_dst glGetListParameterfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glGetListParameterfvSGIX_PTR)(glGetListParameterfvSGIX_ARG_EXPAND);
#endif
#ifndef glGetListParameterivSGIX_RETURN
#define glGetListParameterivSGIX_RETURN void
#define glGetListParameterivSGIX_ARG_NAMES list, pname, params
#define glGetListParameterivSGIX_ARG_EXPAND GLuint list, GLenum pname, GLint * params
#define glGetListParameterivSGIX_ARG_NAMES_TAIL , list, pname, params
#define glGetListParameterivSGIX_ARG_EXPAND_TAIL , GLuint list, GLenum pname, GLint * params
#define forward_glGetListParameterivSGIX(_list, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetListParameterivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetListParameterivSGIX(dst, _list, _pname, _params), NULL); \
    });
#define call_glGetListParameterivSGIX(packed, ret_v) do { \
    glGetListParameterivSGIX_PACKED *unpacked = (glGetListParameterivSGIX_PACKED *)packed; \
    glGetListParameterivSGIX_ARGS *args = (glGetListParameterivSGIX_ARGS *)&unpacked->args; \
    glGetListParameterivSGIX(args->list, args->pname, args->params);; \
} while(0)
void glGetListParameterivSGIX(glGetListParameterivSGIX_ARG_EXPAND);
packed_call_t *pack_glGetListParameterivSGIX(glGetListParameterivSGIX_PACKED *_dst glGetListParameterivSGIX_ARG_EXPAND_TAIL);
typedef void (*glGetListParameterivSGIX_PTR)(glGetListParameterivSGIX_ARG_EXPAND);
#endif
#ifndef glGetLocalConstantBooleanvEXT_RETURN
#define glGetLocalConstantBooleanvEXT_RETURN void
#define glGetLocalConstantBooleanvEXT_ARG_NAMES id, value, data
#define glGetLocalConstantBooleanvEXT_ARG_EXPAND GLuint id, GLenum value, GLboolean * data
#define glGetLocalConstantBooleanvEXT_ARG_NAMES_TAIL , id, value, data
#define glGetLocalConstantBooleanvEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLboolean * data
#define forward_glGetLocalConstantBooleanvEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetLocalConstantBooleanvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetLocalConstantBooleanvEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetLocalConstantBooleanvEXT(packed, ret_v) do { \
    glGetLocalConstantBooleanvEXT_PACKED *unpacked = (glGetLocalConstantBooleanvEXT_PACKED *)packed; \
    glGetLocalConstantBooleanvEXT_ARGS *args = (glGetLocalConstantBooleanvEXT_ARGS *)&unpacked->args; \
    glGetLocalConstantBooleanvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetLocalConstantBooleanvEXT(glGetLocalConstantBooleanvEXT_ARG_EXPAND);
packed_call_t *pack_glGetLocalConstantBooleanvEXT(glGetLocalConstantBooleanvEXT_PACKED *_dst glGetLocalConstantBooleanvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetLocalConstantBooleanvEXT_PTR)(glGetLocalConstantBooleanvEXT_ARG_EXPAND);
#endif
#ifndef glGetLocalConstantFloatvEXT_RETURN
#define glGetLocalConstantFloatvEXT_RETURN void
#define glGetLocalConstantFloatvEXT_ARG_NAMES id, value, data
#define glGetLocalConstantFloatvEXT_ARG_EXPAND GLuint id, GLenum value, GLfloat * data
#define glGetLocalConstantFloatvEXT_ARG_NAMES_TAIL , id, value, data
#define glGetLocalConstantFloatvEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLfloat * data
#define forward_glGetLocalConstantFloatvEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetLocalConstantFloatvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetLocalConstantFloatvEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetLocalConstantFloatvEXT(packed, ret_v) do { \
    glGetLocalConstantFloatvEXT_PACKED *unpacked = (glGetLocalConstantFloatvEXT_PACKED *)packed; \
    glGetLocalConstantFloatvEXT_ARGS *args = (glGetLocalConstantFloatvEXT_ARGS *)&unpacked->args; \
    glGetLocalConstantFloatvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetLocalConstantFloatvEXT(glGetLocalConstantFloatvEXT_ARG_EXPAND);
packed_call_t *pack_glGetLocalConstantFloatvEXT(glGetLocalConstantFloatvEXT_PACKED *_dst glGetLocalConstantFloatvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetLocalConstantFloatvEXT_PTR)(glGetLocalConstantFloatvEXT_ARG_EXPAND);
#endif
#ifndef glGetLocalConstantIntegervEXT_RETURN
#define glGetLocalConstantIntegervEXT_RETURN void
#define glGetLocalConstantIntegervEXT_ARG_NAMES id, value, data
#define glGetLocalConstantIntegervEXT_ARG_EXPAND GLuint id, GLenum value, GLint * data
#define glGetLocalConstantIntegervEXT_ARG_NAMES_TAIL , id, value, data
#define glGetLocalConstantIntegervEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLint * data
#define forward_glGetLocalConstantIntegervEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetLocalConstantIntegervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetLocalConstantIntegervEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetLocalConstantIntegervEXT(packed, ret_v) do { \
    glGetLocalConstantIntegervEXT_PACKED *unpacked = (glGetLocalConstantIntegervEXT_PACKED *)packed; \
    glGetLocalConstantIntegervEXT_ARGS *args = (glGetLocalConstantIntegervEXT_ARGS *)&unpacked->args; \
    glGetLocalConstantIntegervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetLocalConstantIntegervEXT(glGetLocalConstantIntegervEXT_ARG_EXPAND);
packed_call_t *pack_glGetLocalConstantIntegervEXT(glGetLocalConstantIntegervEXT_PACKED *_dst glGetLocalConstantIntegervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetLocalConstantIntegervEXT_PTR)(glGetLocalConstantIntegervEXT_ARG_EXPAND);
#endif
#ifndef glGetMapAttribParameterfvNV_RETURN
#define glGetMapAttribParameterfvNV_RETURN void
#define glGetMapAttribParameterfvNV_ARG_NAMES target, index, pname, params
#define glGetMapAttribParameterfvNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLfloat * params
#define glGetMapAttribParameterfvNV_ARG_NAMES_TAIL , target, index, pname, params
#define glGetMapAttribParameterfvNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLenum pname, GLfloat * params
#define forward_glGetMapAttribParameterfvNV(_target, _index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapAttribParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapAttribParameterfvNV(dst, _target, _index, _pname, _params), NULL); \
    });
#define call_glGetMapAttribParameterfvNV(packed, ret_v) do { \
    glGetMapAttribParameterfvNV_PACKED *unpacked = (glGetMapAttribParameterfvNV_PACKED *)packed; \
    glGetMapAttribParameterfvNV_ARGS *args = (glGetMapAttribParameterfvNV_ARGS *)&unpacked->args; \
    glGetMapAttribParameterfvNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetMapAttribParameterfvNV(glGetMapAttribParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetMapAttribParameterfvNV(glGetMapAttribParameterfvNV_PACKED *_dst glGetMapAttribParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetMapAttribParameterfvNV_PTR)(glGetMapAttribParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetMapAttribParameterivNV_RETURN
#define glGetMapAttribParameterivNV_RETURN void
#define glGetMapAttribParameterivNV_ARG_NAMES target, index, pname, params
#define glGetMapAttribParameterivNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLint * params
#define glGetMapAttribParameterivNV_ARG_NAMES_TAIL , target, index, pname, params
#define glGetMapAttribParameterivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLenum pname, GLint * params
#define forward_glGetMapAttribParameterivNV(_target, _index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapAttribParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapAttribParameterivNV(dst, _target, _index, _pname, _params), NULL); \
    });
#define call_glGetMapAttribParameterivNV(packed, ret_v) do { \
    glGetMapAttribParameterivNV_PACKED *unpacked = (glGetMapAttribParameterivNV_PACKED *)packed; \
    glGetMapAttribParameterivNV_ARGS *args = (glGetMapAttribParameterivNV_ARGS *)&unpacked->args; \
    glGetMapAttribParameterivNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetMapAttribParameterivNV(glGetMapAttribParameterivNV_ARG_EXPAND);
packed_call_t *pack_glGetMapAttribParameterivNV(glGetMapAttribParameterivNV_PACKED *_dst glGetMapAttribParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glGetMapAttribParameterivNV_PTR)(glGetMapAttribParameterivNV_ARG_EXPAND);
#endif
#ifndef glGetMapControlPointsNV_RETURN
#define glGetMapControlPointsNV_RETURN void
#define glGetMapControlPointsNV_ARG_NAMES target, index, type, ustride, vstride, packed, points
#define glGetMapControlPointsNV_ARG_EXPAND GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid * points
#define glGetMapControlPointsNV_ARG_NAMES_TAIL , target, index, type, ustride, vstride, packed, points
#define glGetMapControlPointsNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid * points
#define forward_glGetMapControlPointsNV(_target, _index, _type, _ustride, _vstride, _packed, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapControlPointsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapControlPointsNV(dst, _target, _index, _type, _ustride, _vstride, _packed, _points), NULL); \
    });
#define call_glGetMapControlPointsNV(packed, ret_v) do { \
    glGetMapControlPointsNV_PACKED *unpacked = (glGetMapControlPointsNV_PACKED *)packed; \
    glGetMapControlPointsNV_ARGS *args = (glGetMapControlPointsNV_ARGS *)&unpacked->args; \
    glGetMapControlPointsNV(args->target, args->index, args->type, args->ustride, args->vstride, args->packed, args->points);; \
} while(0)
void glGetMapControlPointsNV(glGetMapControlPointsNV_ARG_EXPAND);
packed_call_t *pack_glGetMapControlPointsNV(glGetMapControlPointsNV_PACKED *_dst glGetMapControlPointsNV_ARG_EXPAND_TAIL);
typedef void (*glGetMapControlPointsNV_PTR)(glGetMapControlPointsNV_ARG_EXPAND);
#endif
#ifndef glGetMapParameterfvNV_RETURN
#define glGetMapParameterfvNV_RETURN void
#define glGetMapParameterfvNV_ARG_NAMES target, pname, params
#define glGetMapParameterfvNV_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetMapParameterfvNV_ARG_NAMES_TAIL , target, pname, params
#define glGetMapParameterfvNV_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetMapParameterfvNV(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapParameterfvNV(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetMapParameterfvNV(packed, ret_v) do { \
    glGetMapParameterfvNV_PACKED *unpacked = (glGetMapParameterfvNV_PACKED *)packed; \
    glGetMapParameterfvNV_ARGS *args = (glGetMapParameterfvNV_ARGS *)&unpacked->args; \
    glGetMapParameterfvNV(args->target, args->pname, args->params);; \
} while(0)
void glGetMapParameterfvNV(glGetMapParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetMapParameterfvNV(glGetMapParameterfvNV_PACKED *_dst glGetMapParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetMapParameterfvNV_PTR)(glGetMapParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetMapParameterivNV_RETURN
#define glGetMapParameterivNV_RETURN void
#define glGetMapParameterivNV_ARG_NAMES target, pname, params
#define glGetMapParameterivNV_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetMapParameterivNV_ARG_NAMES_TAIL , target, pname, params
#define glGetMapParameterivNV_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetMapParameterivNV(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapParameterivNV(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetMapParameterivNV(packed, ret_v) do { \
    glGetMapParameterivNV_PACKED *unpacked = (glGetMapParameterivNV_PACKED *)packed; \
    glGetMapParameterivNV_ARGS *args = (glGetMapParameterivNV_ARGS *)&unpacked->args; \
    glGetMapParameterivNV(args->target, args->pname, args->params);; \
} while(0)
void glGetMapParameterivNV(glGetMapParameterivNV_ARG_EXPAND);
packed_call_t *pack_glGetMapParameterivNV(glGetMapParameterivNV_PACKED *_dst glGetMapParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glGetMapParameterivNV_PTR)(glGetMapParameterivNV_ARG_EXPAND);
#endif
#ifndef glGetMapdv_RETURN
#define glGetMapdv_RETURN void
#define glGetMapdv_ARG_NAMES target, query, v
#define glGetMapdv_ARG_EXPAND GLenum target, GLenum query, GLdouble * v
#define glGetMapdv_ARG_NAMES_TAIL , target, query, v
#define glGetMapdv_ARG_EXPAND_TAIL , GLenum target, GLenum query, GLdouble * v
#define forward_glGetMapdv(_target, _query, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapdv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapdv(dst, _target, _query, _v), NULL); \
    });
#define call_glGetMapdv(packed, ret_v) do { \
    glGetMapdv_PACKED *unpacked = (glGetMapdv_PACKED *)packed; \
    glGetMapdv_ARGS *args = (glGetMapdv_ARGS *)&unpacked->args; \
    glGetMapdv(args->target, args->query, args->v);; \
} while(0)
void glGetMapdv(glGetMapdv_ARG_EXPAND);
packed_call_t *pack_glGetMapdv(glGetMapdv_PACKED *_dst glGetMapdv_ARG_EXPAND_TAIL);
typedef void (*glGetMapdv_PTR)(glGetMapdv_ARG_EXPAND);
#endif
#ifndef glGetMapfv_RETURN
#define glGetMapfv_RETURN void
#define glGetMapfv_ARG_NAMES target, query, v
#define glGetMapfv_ARG_EXPAND GLenum target, GLenum query, GLfloat * v
#define glGetMapfv_ARG_NAMES_TAIL , target, query, v
#define glGetMapfv_ARG_EXPAND_TAIL , GLenum target, GLenum query, GLfloat * v
#define forward_glGetMapfv(_target, _query, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapfv(dst, _target, _query, _v), NULL); \
    });
#define call_glGetMapfv(packed, ret_v) do { \
    glGetMapfv_PACKED *unpacked = (glGetMapfv_PACKED *)packed; \
    glGetMapfv_ARGS *args = (glGetMapfv_ARGS *)&unpacked->args; \
    glGetMapfv(args->target, args->query, args->v);; \
} while(0)
void glGetMapfv(glGetMapfv_ARG_EXPAND);
packed_call_t *pack_glGetMapfv(glGetMapfv_PACKED *_dst glGetMapfv_ARG_EXPAND_TAIL);
typedef void (*glGetMapfv_PTR)(glGetMapfv_ARG_EXPAND);
#endif
#ifndef glGetMapiv_RETURN
#define glGetMapiv_RETURN void
#define glGetMapiv_ARG_NAMES target, query, v
#define glGetMapiv_ARG_EXPAND GLenum target, GLenum query, GLint * v
#define glGetMapiv_ARG_NAMES_TAIL , target, query, v
#define glGetMapiv_ARG_EXPAND_TAIL , GLenum target, GLenum query, GLint * v
#define forward_glGetMapiv(_target, _query, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapiv(dst, _target, _query, _v), NULL); \
    });
#define call_glGetMapiv(packed, ret_v) do { \
    glGetMapiv_PACKED *unpacked = (glGetMapiv_PACKED *)packed; \
    glGetMapiv_ARGS *args = (glGetMapiv_ARGS *)&unpacked->args; \
    glGetMapiv(args->target, args->query, args->v);; \
} while(0)
void glGetMapiv(glGetMapiv_ARG_EXPAND);
packed_call_t *pack_glGetMapiv(glGetMapiv_PACKED *_dst glGetMapiv_ARG_EXPAND_TAIL);
typedef void (*glGetMapiv_PTR)(glGetMapiv_ARG_EXPAND);
#endif
#ifndef glGetMapxvOES_RETURN
#define glGetMapxvOES_RETURN void
#define glGetMapxvOES_ARG_NAMES target, query, v
#define glGetMapxvOES_ARG_EXPAND GLenum target, GLenum query, GLfixed * v
#define glGetMapxvOES_ARG_NAMES_TAIL , target, query, v
#define glGetMapxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum query, GLfixed * v
#define forward_glGetMapxvOES(_target, _query, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMapxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMapxvOES(dst, _target, _query, _v), NULL); \
    });
#define call_glGetMapxvOES(packed, ret_v) do { \
    glGetMapxvOES_PACKED *unpacked = (glGetMapxvOES_PACKED *)packed; \
    glGetMapxvOES_ARGS *args = (glGetMapxvOES_ARGS *)&unpacked->args; \
    glGetMapxvOES(args->target, args->query, args->v);; \
} while(0)
void glGetMapxvOES(glGetMapxvOES_ARG_EXPAND);
packed_call_t *pack_glGetMapxvOES(glGetMapxvOES_PACKED *_dst glGetMapxvOES_ARG_EXPAND_TAIL);
typedef void (*glGetMapxvOES_PTR)(glGetMapxvOES_ARG_EXPAND);
#endif
#ifndef glGetMaterialfv_RETURN
#define glGetMaterialfv_RETURN void
#define glGetMaterialfv_ARG_NAMES face, pname, params
#define glGetMaterialfv_ARG_EXPAND GLenum face, GLenum pname, GLfloat * params
#define glGetMaterialfv_ARG_NAMES_TAIL , face, pname, params
#define glGetMaterialfv_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLfloat * params
#define forward_glGetMaterialfv(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMaterialfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMaterialfv(dst, _face, _pname, _params), NULL); \
    });
#define call_glGetMaterialfv(packed, ret_v) do { \
    glGetMaterialfv_PACKED *unpacked = (glGetMaterialfv_PACKED *)packed; \
    glGetMaterialfv_ARGS *args = (glGetMaterialfv_ARGS *)&unpacked->args; \
    glGetMaterialfv(args->face, args->pname, args->params);; \
} while(0)
void glGetMaterialfv(glGetMaterialfv_ARG_EXPAND);
packed_call_t *pack_glGetMaterialfv(glGetMaterialfv_PACKED *_dst glGetMaterialfv_ARG_EXPAND_TAIL);
typedef void (*glGetMaterialfv_PTR)(glGetMaterialfv_ARG_EXPAND);
#endif
#ifndef glGetMaterialiv_RETURN
#define glGetMaterialiv_RETURN void
#define glGetMaterialiv_ARG_NAMES face, pname, params
#define glGetMaterialiv_ARG_EXPAND GLenum face, GLenum pname, GLint * params
#define glGetMaterialiv_ARG_NAMES_TAIL , face, pname, params
#define glGetMaterialiv_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLint * params
#define forward_glGetMaterialiv(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMaterialiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMaterialiv(dst, _face, _pname, _params), NULL); \
    });
#define call_glGetMaterialiv(packed, ret_v) do { \
    glGetMaterialiv_PACKED *unpacked = (glGetMaterialiv_PACKED *)packed; \
    glGetMaterialiv_ARGS *args = (glGetMaterialiv_ARGS *)&unpacked->args; \
    glGetMaterialiv(args->face, args->pname, args->params);; \
} while(0)
void glGetMaterialiv(glGetMaterialiv_ARG_EXPAND);
packed_call_t *pack_glGetMaterialiv(glGetMaterialiv_PACKED *_dst glGetMaterialiv_ARG_EXPAND_TAIL);
typedef void (*glGetMaterialiv_PTR)(glGetMaterialiv_ARG_EXPAND);
#endif
#ifndef glGetMaterialxOES_RETURN
#define glGetMaterialxOES_RETURN void
#define glGetMaterialxOES_ARG_NAMES face, pname, param
#define glGetMaterialxOES_ARG_EXPAND GLenum face, GLenum pname, GLfixed param
#define glGetMaterialxOES_ARG_NAMES_TAIL , face, pname, param
#define glGetMaterialxOES_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLfixed param
#define forward_glGetMaterialxOES(_face, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMaterialxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMaterialxOES(dst, _face, _pname, _param), NULL); \
    });
#define call_glGetMaterialxOES(packed, ret_v) do { \
    glGetMaterialxOES_PACKED *unpacked = (glGetMaterialxOES_PACKED *)packed; \
    glGetMaterialxOES_ARGS *args = (glGetMaterialxOES_ARGS *)&unpacked->args; \
    glGetMaterialxOES(args->face, args->pname, args->param);; \
} while(0)
void glGetMaterialxOES(glGetMaterialxOES_ARG_EXPAND);
packed_call_t *pack_glGetMaterialxOES(glGetMaterialxOES_PACKED *_dst glGetMaterialxOES_ARG_EXPAND_TAIL);
typedef void (*glGetMaterialxOES_PTR)(glGetMaterialxOES_ARG_EXPAND);
#endif
#ifndef glGetMinmax_RETURN
#define glGetMinmax_RETURN void
#define glGetMinmax_ARG_NAMES target, reset, format, type, values
#define glGetMinmax_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetMinmax_ARG_NAMES_TAIL , target, reset, format, type, values
#define glGetMinmax_ARG_EXPAND_TAIL , GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define forward_glGetMinmax(_target, _reset, _format, _type, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMinmax_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMinmax(dst, _target, _reset, _format, _type, _values), NULL); \
    });
#define call_glGetMinmax(packed, ret_v) do { \
    glGetMinmax_PACKED *unpacked = (glGetMinmax_PACKED *)packed; \
    glGetMinmax_ARGS *args = (glGetMinmax_ARGS *)&unpacked->args; \
    glGetMinmax(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetMinmax(glGetMinmax_ARG_EXPAND);
packed_call_t *pack_glGetMinmax(glGetMinmax_PACKED *_dst glGetMinmax_ARG_EXPAND_TAIL);
typedef void (*glGetMinmax_PTR)(glGetMinmax_ARG_EXPAND);
#endif
#ifndef glGetMinmaxEXT_RETURN
#define glGetMinmaxEXT_RETURN void
#define glGetMinmaxEXT_ARG_NAMES target, reset, format, type, values
#define glGetMinmaxEXT_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetMinmaxEXT_ARG_NAMES_TAIL , target, reset, format, type, values
#define glGetMinmaxEXT_ARG_EXPAND_TAIL , GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define forward_glGetMinmaxEXT(_target, _reset, _format, _type, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMinmaxEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMinmaxEXT(dst, _target, _reset, _format, _type, _values), NULL); \
    });
#define call_glGetMinmaxEXT(packed, ret_v) do { \
    glGetMinmaxEXT_PACKED *unpacked = (glGetMinmaxEXT_PACKED *)packed; \
    glGetMinmaxEXT_ARGS *args = (glGetMinmaxEXT_ARGS *)&unpacked->args; \
    glGetMinmaxEXT(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetMinmaxEXT(glGetMinmaxEXT_ARG_EXPAND);
packed_call_t *pack_glGetMinmaxEXT(glGetMinmaxEXT_PACKED *_dst glGetMinmaxEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMinmaxEXT_PTR)(glGetMinmaxEXT_ARG_EXPAND);
#endif
#ifndef glGetMinmaxParameterfv_RETURN
#define glGetMinmaxParameterfv_RETURN void
#define glGetMinmaxParameterfv_ARG_NAMES target, pname, params
#define glGetMinmaxParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetMinmaxParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glGetMinmaxParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetMinmaxParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMinmaxParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMinmaxParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetMinmaxParameterfv(packed, ret_v) do { \
    glGetMinmaxParameterfv_PACKED *unpacked = (glGetMinmaxParameterfv_PACKED *)packed; \
    glGetMinmaxParameterfv_ARGS *args = (glGetMinmaxParameterfv_ARGS *)&unpacked->args; \
    glGetMinmaxParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameterfv(glGetMinmaxParameterfv_ARG_EXPAND);
packed_call_t *pack_glGetMinmaxParameterfv(glGetMinmaxParameterfv_PACKED *_dst glGetMinmaxParameterfv_ARG_EXPAND_TAIL);
typedef void (*glGetMinmaxParameterfv_PTR)(glGetMinmaxParameterfv_ARG_EXPAND);
#endif
#ifndef glGetMinmaxParameterfvEXT_RETURN
#define glGetMinmaxParameterfvEXT_RETURN void
#define glGetMinmaxParameterfvEXT_ARG_NAMES target, pname, params
#define glGetMinmaxParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetMinmaxParameterfvEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetMinmaxParameterfvEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetMinmaxParameterfvEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMinmaxParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMinmaxParameterfvEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetMinmaxParameterfvEXT(packed, ret_v) do { \
    glGetMinmaxParameterfvEXT_PACKED *unpacked = (glGetMinmaxParameterfvEXT_PACKED *)packed; \
    glGetMinmaxParameterfvEXT_ARGS *args = (glGetMinmaxParameterfvEXT_ARGS *)&unpacked->args; \
    glGetMinmaxParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameterfvEXT(glGetMinmaxParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetMinmaxParameterfvEXT(glGetMinmaxParameterfvEXT_PACKED *_dst glGetMinmaxParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMinmaxParameterfvEXT_PTR)(glGetMinmaxParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetMinmaxParameteriv_RETURN
#define glGetMinmaxParameteriv_RETURN void
#define glGetMinmaxParameteriv_ARG_NAMES target, pname, params
#define glGetMinmaxParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetMinmaxParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetMinmaxParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetMinmaxParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMinmaxParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMinmaxParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetMinmaxParameteriv(packed, ret_v) do { \
    glGetMinmaxParameteriv_PACKED *unpacked = (glGetMinmaxParameteriv_PACKED *)packed; \
    glGetMinmaxParameteriv_ARGS *args = (glGetMinmaxParameteriv_ARGS *)&unpacked->args; \
    glGetMinmaxParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameteriv(glGetMinmaxParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetMinmaxParameteriv(glGetMinmaxParameteriv_PACKED *_dst glGetMinmaxParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetMinmaxParameteriv_PTR)(glGetMinmaxParameteriv_ARG_EXPAND);
#endif
#ifndef glGetMinmaxParameterivEXT_RETURN
#define glGetMinmaxParameterivEXT_RETURN void
#define glGetMinmaxParameterivEXT_ARG_NAMES target, pname, params
#define glGetMinmaxParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetMinmaxParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetMinmaxParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetMinmaxParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMinmaxParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMinmaxParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetMinmaxParameterivEXT(packed, ret_v) do { \
    glGetMinmaxParameterivEXT_PACKED *unpacked = (glGetMinmaxParameterivEXT_PACKED *)packed; \
    glGetMinmaxParameterivEXT_ARGS *args = (glGetMinmaxParameterivEXT_ARGS *)&unpacked->args; \
    glGetMinmaxParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameterivEXT(glGetMinmaxParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetMinmaxParameterivEXT(glGetMinmaxParameterivEXT_PACKED *_dst glGetMinmaxParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMinmaxParameterivEXT_PTR)(glGetMinmaxParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexEnvfvEXT_RETURN
#define glGetMultiTexEnvfvEXT_RETURN void
#define glGetMultiTexEnvfvEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexEnvfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat * params
#define glGetMultiTexEnvfvEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glGetMultiTexEnvfvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLfloat * params
#define forward_glGetMultiTexEnvfvEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexEnvfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexEnvfvEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glGetMultiTexEnvfvEXT(packed, ret_v) do { \
    glGetMultiTexEnvfvEXT_PACKED *unpacked = (glGetMultiTexEnvfvEXT_PACKED *)packed; \
    glGetMultiTexEnvfvEXT_ARGS *args = (glGetMultiTexEnvfvEXT_ARGS *)&unpacked->args; \
    glGetMultiTexEnvfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexEnvfvEXT(glGetMultiTexEnvfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexEnvfvEXT(glGetMultiTexEnvfvEXT_PACKED *_dst glGetMultiTexEnvfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexEnvfvEXT_PTR)(glGetMultiTexEnvfvEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexEnvivEXT_RETURN
#define glGetMultiTexEnvivEXT_RETURN void
#define glGetMultiTexEnvivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexEnvivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint * params
#define glGetMultiTexEnvivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glGetMultiTexEnvivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLint * params
#define forward_glGetMultiTexEnvivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexEnvivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexEnvivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glGetMultiTexEnvivEXT(packed, ret_v) do { \
    glGetMultiTexEnvivEXT_PACKED *unpacked = (glGetMultiTexEnvivEXT_PACKED *)packed; \
    glGetMultiTexEnvivEXT_ARGS *args = (glGetMultiTexEnvivEXT_ARGS *)&unpacked->args; \
    glGetMultiTexEnvivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexEnvivEXT(glGetMultiTexEnvivEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexEnvivEXT(glGetMultiTexEnvivEXT_PACKED *_dst glGetMultiTexEnvivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexEnvivEXT_PTR)(glGetMultiTexEnvivEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexGendvEXT_RETURN
#define glGetMultiTexGendvEXT_RETURN void
#define glGetMultiTexGendvEXT_ARG_NAMES texunit, coord, pname, params
#define glGetMultiTexGendvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLdouble * params
#define glGetMultiTexGendvEXT_ARG_NAMES_TAIL , texunit, coord, pname, params
#define glGetMultiTexGendvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, GLdouble * params
#define forward_glGetMultiTexGendvEXT(_texunit, _coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexGendvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexGendvEXT(dst, _texunit, _coord, _pname, _params), NULL); \
    });
#define call_glGetMultiTexGendvEXT(packed, ret_v) do { \
    glGetMultiTexGendvEXT_PACKED *unpacked = (glGetMultiTexGendvEXT_PACKED *)packed; \
    glGetMultiTexGendvEXT_ARGS *args = (glGetMultiTexGendvEXT_ARGS *)&unpacked->args; \
    glGetMultiTexGendvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glGetMultiTexGendvEXT(glGetMultiTexGendvEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexGendvEXT(glGetMultiTexGendvEXT_PACKED *_dst glGetMultiTexGendvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexGendvEXT_PTR)(glGetMultiTexGendvEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexGenfvEXT_RETURN
#define glGetMultiTexGenfvEXT_RETURN void
#define glGetMultiTexGenfvEXT_ARG_NAMES texunit, coord, pname, params
#define glGetMultiTexGenfvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLfloat * params
#define glGetMultiTexGenfvEXT_ARG_NAMES_TAIL , texunit, coord, pname, params
#define glGetMultiTexGenfvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, GLfloat * params
#define forward_glGetMultiTexGenfvEXT(_texunit, _coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexGenfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexGenfvEXT(dst, _texunit, _coord, _pname, _params), NULL); \
    });
#define call_glGetMultiTexGenfvEXT(packed, ret_v) do { \
    glGetMultiTexGenfvEXT_PACKED *unpacked = (glGetMultiTexGenfvEXT_PACKED *)packed; \
    glGetMultiTexGenfvEXT_ARGS *args = (glGetMultiTexGenfvEXT_ARGS *)&unpacked->args; \
    glGetMultiTexGenfvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glGetMultiTexGenfvEXT(glGetMultiTexGenfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexGenfvEXT(glGetMultiTexGenfvEXT_PACKED *_dst glGetMultiTexGenfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexGenfvEXT_PTR)(glGetMultiTexGenfvEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexGenivEXT_RETURN
#define glGetMultiTexGenivEXT_RETURN void
#define glGetMultiTexGenivEXT_ARG_NAMES texunit, coord, pname, params
#define glGetMultiTexGenivEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLint * params
#define glGetMultiTexGenivEXT_ARG_NAMES_TAIL , texunit, coord, pname, params
#define glGetMultiTexGenivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, GLint * params
#define forward_glGetMultiTexGenivEXT(_texunit, _coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexGenivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexGenivEXT(dst, _texunit, _coord, _pname, _params), NULL); \
    });
#define call_glGetMultiTexGenivEXT(packed, ret_v) do { \
    glGetMultiTexGenivEXT_PACKED *unpacked = (glGetMultiTexGenivEXT_PACKED *)packed; \
    glGetMultiTexGenivEXT_ARGS *args = (glGetMultiTexGenivEXT_ARGS *)&unpacked->args; \
    glGetMultiTexGenivEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glGetMultiTexGenivEXT(glGetMultiTexGenivEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexGenivEXT(glGetMultiTexGenivEXT_PACKED *_dst glGetMultiTexGenivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexGenivEXT_PTR)(glGetMultiTexGenivEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexImageEXT_RETURN
#define glGetMultiTexImageEXT_RETURN void
#define glGetMultiTexImageEXT_ARG_NAMES texunit, target, level, format, type, pixels
#define glGetMultiTexImageEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define glGetMultiTexImageEXT_ARG_NAMES_TAIL , texunit, target, level, format, type, pixels
#define glGetMultiTexImageEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define forward_glGetMultiTexImageEXT(_texunit, _target, _level, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexImageEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexImageEXT(dst, _texunit, _target, _level, _format, _type, _pixels), NULL); \
    });
#define call_glGetMultiTexImageEXT(packed, ret_v) do { \
    glGetMultiTexImageEXT_PACKED *unpacked = (glGetMultiTexImageEXT_PACKED *)packed; \
    glGetMultiTexImageEXT_ARGS *args = (glGetMultiTexImageEXT_ARGS *)&unpacked->args; \
    glGetMultiTexImageEXT(args->texunit, args->target, args->level, args->format, args->type, args->pixels);; \
} while(0)
void glGetMultiTexImageEXT(glGetMultiTexImageEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexImageEXT(glGetMultiTexImageEXT_PACKED *_dst glGetMultiTexImageEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexImageEXT_PTR)(glGetMultiTexImageEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexLevelParameterfvEXT_RETURN
#define glGetMultiTexLevelParameterfvEXT_RETURN void
#define glGetMultiTexLevelParameterfvEXT_ARG_NAMES texunit, target, level, pname, params
#define glGetMultiTexLevelParameterfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params
#define glGetMultiTexLevelParameterfvEXT_ARG_NAMES_TAIL , texunit, target, level, pname, params
#define glGetMultiTexLevelParameterfvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params
#define forward_glGetMultiTexLevelParameterfvEXT(_texunit, _target, _level, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexLevelParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexLevelParameterfvEXT(dst, _texunit, _target, _level, _pname, _params), NULL); \
    });
#define call_glGetMultiTexLevelParameterfvEXT(packed, ret_v) do { \
    glGetMultiTexLevelParameterfvEXT_PACKED *unpacked = (glGetMultiTexLevelParameterfvEXT_PACKED *)packed; \
    glGetMultiTexLevelParameterfvEXT_ARGS *args = (glGetMultiTexLevelParameterfvEXT_ARGS *)&unpacked->args; \
    glGetMultiTexLevelParameterfvEXT(args->texunit, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetMultiTexLevelParameterfvEXT(glGetMultiTexLevelParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexLevelParameterfvEXT(glGetMultiTexLevelParameterfvEXT_PACKED *_dst glGetMultiTexLevelParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexLevelParameterfvEXT_PTR)(glGetMultiTexLevelParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexLevelParameterivEXT_RETURN
#define glGetMultiTexLevelParameterivEXT_RETURN void
#define glGetMultiTexLevelParameterivEXT_ARG_NAMES texunit, target, level, pname, params
#define glGetMultiTexLevelParameterivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params
#define glGetMultiTexLevelParameterivEXT_ARG_NAMES_TAIL , texunit, target, level, pname, params
#define glGetMultiTexLevelParameterivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params
#define forward_glGetMultiTexLevelParameterivEXT(_texunit, _target, _level, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexLevelParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexLevelParameterivEXT(dst, _texunit, _target, _level, _pname, _params), NULL); \
    });
#define call_glGetMultiTexLevelParameterivEXT(packed, ret_v) do { \
    glGetMultiTexLevelParameterivEXT_PACKED *unpacked = (glGetMultiTexLevelParameterivEXT_PACKED *)packed; \
    glGetMultiTexLevelParameterivEXT_ARGS *args = (glGetMultiTexLevelParameterivEXT_ARGS *)&unpacked->args; \
    glGetMultiTexLevelParameterivEXT(args->texunit, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetMultiTexLevelParameterivEXT(glGetMultiTexLevelParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexLevelParameterivEXT(glGetMultiTexLevelParameterivEXT_PACKED *_dst glGetMultiTexLevelParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexLevelParameterivEXT_PTR)(glGetMultiTexLevelParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexParameterIivEXT_RETURN
#define glGetMultiTexParameterIivEXT_RETURN void
#define glGetMultiTexParameterIivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterIivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint * params
#define glGetMultiTexParameterIivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glGetMultiTexParameterIivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLint * params
#define forward_glGetMultiTexParameterIivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexParameterIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexParameterIivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glGetMultiTexParameterIivEXT(packed, ret_v) do { \
    glGetMultiTexParameterIivEXT_PACKED *unpacked = (glGetMultiTexParameterIivEXT_PACKED *)packed; \
    glGetMultiTexParameterIivEXT_ARGS *args = (glGetMultiTexParameterIivEXT_ARGS *)&unpacked->args; \
    glGetMultiTexParameterIivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterIivEXT(glGetMultiTexParameterIivEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexParameterIivEXT(glGetMultiTexParameterIivEXT_PACKED *_dst glGetMultiTexParameterIivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexParameterIivEXT_PTR)(glGetMultiTexParameterIivEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexParameterIuivEXT_RETURN
#define glGetMultiTexParameterIuivEXT_RETURN void
#define glGetMultiTexParameterIuivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterIuivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLuint * params
#define glGetMultiTexParameterIuivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glGetMultiTexParameterIuivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLuint * params
#define forward_glGetMultiTexParameterIuivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexParameterIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexParameterIuivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glGetMultiTexParameterIuivEXT(packed, ret_v) do { \
    glGetMultiTexParameterIuivEXT_PACKED *unpacked = (glGetMultiTexParameterIuivEXT_PACKED *)packed; \
    glGetMultiTexParameterIuivEXT_ARGS *args = (glGetMultiTexParameterIuivEXT_ARGS *)&unpacked->args; \
    glGetMultiTexParameterIuivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterIuivEXT(glGetMultiTexParameterIuivEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexParameterIuivEXT(glGetMultiTexParameterIuivEXT_PACKED *_dst glGetMultiTexParameterIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexParameterIuivEXT_PTR)(glGetMultiTexParameterIuivEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexParameterfvEXT_RETURN
#define glGetMultiTexParameterfvEXT_RETURN void
#define glGetMultiTexParameterfvEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat * params
#define glGetMultiTexParameterfvEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glGetMultiTexParameterfvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLfloat * params
#define forward_glGetMultiTexParameterfvEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexParameterfvEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glGetMultiTexParameterfvEXT(packed, ret_v) do { \
    glGetMultiTexParameterfvEXT_PACKED *unpacked = (glGetMultiTexParameterfvEXT_PACKED *)packed; \
    glGetMultiTexParameterfvEXT_ARGS *args = (glGetMultiTexParameterfvEXT_ARGS *)&unpacked->args; \
    glGetMultiTexParameterfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterfvEXT(glGetMultiTexParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexParameterfvEXT(glGetMultiTexParameterfvEXT_PACKED *_dst glGetMultiTexParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexParameterfvEXT_PTR)(glGetMultiTexParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetMultiTexParameterivEXT_RETURN
#define glGetMultiTexParameterivEXT_RETURN void
#define glGetMultiTexParameterivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint * params
#define glGetMultiTexParameterivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glGetMultiTexParameterivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLint * params
#define forward_glGetMultiTexParameterivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultiTexParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultiTexParameterivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glGetMultiTexParameterivEXT(packed, ret_v) do { \
    glGetMultiTexParameterivEXT_PACKED *unpacked = (glGetMultiTexParameterivEXT_PACKED *)packed; \
    glGetMultiTexParameterivEXT_ARGS *args = (glGetMultiTexParameterivEXT_ARGS *)&unpacked->args; \
    glGetMultiTexParameterivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterivEXT(glGetMultiTexParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetMultiTexParameterivEXT(glGetMultiTexParameterivEXT_PACKED *_dst glGetMultiTexParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetMultiTexParameterivEXT_PTR)(glGetMultiTexParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetMultisamplefv_RETURN
#define glGetMultisamplefv_RETURN void
#define glGetMultisamplefv_ARG_NAMES pname, index, val
#define glGetMultisamplefv_ARG_EXPAND GLenum pname, GLuint index, GLfloat * val
#define glGetMultisamplefv_ARG_NAMES_TAIL , pname, index, val
#define glGetMultisamplefv_ARG_EXPAND_TAIL , GLenum pname, GLuint index, GLfloat * val
#define forward_glGetMultisamplefv(_pname, _index, _val) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultisamplefv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultisamplefv(dst, _pname, _index, _val), NULL); \
    });
#define call_glGetMultisamplefv(packed, ret_v) do { \
    glGetMultisamplefv_PACKED *unpacked = (glGetMultisamplefv_PACKED *)packed; \
    glGetMultisamplefv_ARGS *args = (glGetMultisamplefv_ARGS *)&unpacked->args; \
    glGetMultisamplefv(args->pname, args->index, args->val);; \
} while(0)
void glGetMultisamplefv(glGetMultisamplefv_ARG_EXPAND);
packed_call_t *pack_glGetMultisamplefv(glGetMultisamplefv_PACKED *_dst glGetMultisamplefv_ARG_EXPAND_TAIL);
typedef void (*glGetMultisamplefv_PTR)(glGetMultisamplefv_ARG_EXPAND);
#endif
#ifndef glGetMultisamplefvNV_RETURN
#define glGetMultisamplefvNV_RETURN void
#define glGetMultisamplefvNV_ARG_NAMES pname, index, val
#define glGetMultisamplefvNV_ARG_EXPAND GLenum pname, GLuint index, GLfloat * val
#define glGetMultisamplefvNV_ARG_NAMES_TAIL , pname, index, val
#define glGetMultisamplefvNV_ARG_EXPAND_TAIL , GLenum pname, GLuint index, GLfloat * val
#define forward_glGetMultisamplefvNV(_pname, _index, _val) \
    ({ \
        void *dst = remote_dma(sizeof(glGetMultisamplefvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetMultisamplefvNV(dst, _pname, _index, _val), NULL); \
    });
#define call_glGetMultisamplefvNV(packed, ret_v) do { \
    glGetMultisamplefvNV_PACKED *unpacked = (glGetMultisamplefvNV_PACKED *)packed; \
    glGetMultisamplefvNV_ARGS *args = (glGetMultisamplefvNV_ARGS *)&unpacked->args; \
    glGetMultisamplefvNV(args->pname, args->index, args->val);; \
} while(0)
void glGetMultisamplefvNV(glGetMultisamplefvNV_ARG_EXPAND);
packed_call_t *pack_glGetMultisamplefvNV(glGetMultisamplefvNV_PACKED *_dst glGetMultisamplefvNV_ARG_EXPAND_TAIL);
typedef void (*glGetMultisamplefvNV_PTR)(glGetMultisamplefvNV_ARG_EXPAND);
#endif
#ifndef glGetNamedBufferParameterivEXT_RETURN
#define glGetNamedBufferParameterivEXT_RETURN void
#define glGetNamedBufferParameterivEXT_ARG_NAMES buffer, pname, params
#define glGetNamedBufferParameterivEXT_ARG_EXPAND GLuint buffer, GLenum pname, GLint * params
#define glGetNamedBufferParameterivEXT_ARG_NAMES_TAIL , buffer, pname, params
#define glGetNamedBufferParameterivEXT_ARG_EXPAND_TAIL , GLuint buffer, GLenum pname, GLint * params
#define forward_glGetNamedBufferParameterivEXT(_buffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedBufferParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedBufferParameterivEXT(dst, _buffer, _pname, _params), NULL); \
    });
#define call_glGetNamedBufferParameterivEXT(packed, ret_v) do { \
    glGetNamedBufferParameterivEXT_PACKED *unpacked = (glGetNamedBufferParameterivEXT_PACKED *)packed; \
    glGetNamedBufferParameterivEXT_ARGS *args = (glGetNamedBufferParameterivEXT_ARGS *)&unpacked->args; \
    glGetNamedBufferParameterivEXT(args->buffer, args->pname, args->params);; \
} while(0)
void glGetNamedBufferParameterivEXT(glGetNamedBufferParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedBufferParameterivEXT(glGetNamedBufferParameterivEXT_PACKED *_dst glGetNamedBufferParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedBufferParameterivEXT_PTR)(glGetNamedBufferParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedBufferParameterui64vNV_RETURN
#define glGetNamedBufferParameterui64vNV_RETURN void
#define glGetNamedBufferParameterui64vNV_ARG_NAMES buffer, pname, params
#define glGetNamedBufferParameterui64vNV_ARG_EXPAND GLuint buffer, GLenum pname, GLuint64EXT * params
#define glGetNamedBufferParameterui64vNV_ARG_NAMES_TAIL , buffer, pname, params
#define glGetNamedBufferParameterui64vNV_ARG_EXPAND_TAIL , GLuint buffer, GLenum pname, GLuint64EXT * params
#define forward_glGetNamedBufferParameterui64vNV(_buffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedBufferParameterui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedBufferParameterui64vNV(dst, _buffer, _pname, _params), NULL); \
    });
#define call_glGetNamedBufferParameterui64vNV(packed, ret_v) do { \
    glGetNamedBufferParameterui64vNV_PACKED *unpacked = (glGetNamedBufferParameterui64vNV_PACKED *)packed; \
    glGetNamedBufferParameterui64vNV_ARGS *args = (glGetNamedBufferParameterui64vNV_ARGS *)&unpacked->args; \
    glGetNamedBufferParameterui64vNV(args->buffer, args->pname, args->params);; \
} while(0)
void glGetNamedBufferParameterui64vNV(glGetNamedBufferParameterui64vNV_ARG_EXPAND);
packed_call_t *pack_glGetNamedBufferParameterui64vNV(glGetNamedBufferParameterui64vNV_PACKED *_dst glGetNamedBufferParameterui64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetNamedBufferParameterui64vNV_PTR)(glGetNamedBufferParameterui64vNV_ARG_EXPAND);
#endif
#ifndef glGetNamedBufferPointervEXT_RETURN
#define glGetNamedBufferPointervEXT_RETURN void
#define glGetNamedBufferPointervEXT_ARG_NAMES buffer, pname, params
#define glGetNamedBufferPointervEXT_ARG_EXPAND GLuint buffer, GLenum pname, GLvoid * params
#define glGetNamedBufferPointervEXT_ARG_NAMES_TAIL , buffer, pname, params
#define glGetNamedBufferPointervEXT_ARG_EXPAND_TAIL , GLuint buffer, GLenum pname, GLvoid * params
#define forward_glGetNamedBufferPointervEXT(_buffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedBufferPointervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedBufferPointervEXT(dst, _buffer, _pname, _params), NULL); \
    });
#define call_glGetNamedBufferPointervEXT(packed, ret_v) do { \
    glGetNamedBufferPointervEXT_PACKED *unpacked = (glGetNamedBufferPointervEXT_PACKED *)packed; \
    glGetNamedBufferPointervEXT_ARGS *args = (glGetNamedBufferPointervEXT_ARGS *)&unpacked->args; \
    glGetNamedBufferPointervEXT(args->buffer, args->pname, args->params);; \
} while(0)
void glGetNamedBufferPointervEXT(glGetNamedBufferPointervEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedBufferPointervEXT(glGetNamedBufferPointervEXT_PACKED *_dst glGetNamedBufferPointervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedBufferPointervEXT_PTR)(glGetNamedBufferPointervEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedBufferSubDataEXT_RETURN
#define glGetNamedBufferSubDataEXT_RETURN void
#define glGetNamedBufferSubDataEXT_ARG_NAMES buffer, offset, size, data
#define glGetNamedBufferSubDataEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid * data
#define glGetNamedBufferSubDataEXT_ARG_NAMES_TAIL , buffer, offset, size, data
#define glGetNamedBufferSubDataEXT_ARG_EXPAND_TAIL , GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid * data
#define forward_glGetNamedBufferSubDataEXT(_buffer, _offset, _size, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedBufferSubDataEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedBufferSubDataEXT(dst, _buffer, _offset, _size, _data), NULL); \
    });
#define call_glGetNamedBufferSubDataEXT(packed, ret_v) do { \
    glGetNamedBufferSubDataEXT_PACKED *unpacked = (glGetNamedBufferSubDataEXT_PACKED *)packed; \
    glGetNamedBufferSubDataEXT_ARGS *args = (glGetNamedBufferSubDataEXT_ARGS *)&unpacked->args; \
    glGetNamedBufferSubDataEXT(args->buffer, args->offset, args->size, args->data);; \
} while(0)
void glGetNamedBufferSubDataEXT(glGetNamedBufferSubDataEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedBufferSubDataEXT(glGetNamedBufferSubDataEXT_PACKED *_dst glGetNamedBufferSubDataEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedBufferSubDataEXT_PTR)(glGetNamedBufferSubDataEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedFramebufferAttachmentParameterivEXT_RETURN
#define glGetNamedFramebufferAttachmentParameterivEXT_RETURN void
#define glGetNamedFramebufferAttachmentParameterivEXT_ARG_NAMES framebuffer, attachment, pname, params
#define glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params
#define glGetNamedFramebufferAttachmentParameterivEXT_ARG_NAMES_TAIL , framebuffer, attachment, pname, params
#define glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params
#define forward_glGetNamedFramebufferAttachmentParameterivEXT(_framebuffer, _attachment, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedFramebufferAttachmentParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedFramebufferAttachmentParameterivEXT(dst, _framebuffer, _attachment, _pname, _params), NULL); \
    });
#define call_glGetNamedFramebufferAttachmentParameterivEXT(packed, ret_v) do { \
    glGetNamedFramebufferAttachmentParameterivEXT_PACKED *unpacked = (glGetNamedFramebufferAttachmentParameterivEXT_PACKED *)packed; \
    glGetNamedFramebufferAttachmentParameterivEXT_ARGS *args = (glGetNamedFramebufferAttachmentParameterivEXT_ARGS *)&unpacked->args; \
    glGetNamedFramebufferAttachmentParameterivEXT(args->framebuffer, args->attachment, args->pname, args->params);; \
} while(0)
void glGetNamedFramebufferAttachmentParameterivEXT(glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedFramebufferAttachmentParameterivEXT(glGetNamedFramebufferAttachmentParameterivEXT_PACKED *_dst glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedFramebufferAttachmentParameterivEXT_PTR)(glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedFramebufferParameterivEXT_RETURN
#define glGetNamedFramebufferParameterivEXT_RETURN void
#define glGetNamedFramebufferParameterivEXT_ARG_NAMES framebuffer, pname, params
#define glGetNamedFramebufferParameterivEXT_ARG_EXPAND GLuint framebuffer, GLenum pname, GLint * params
#define glGetNamedFramebufferParameterivEXT_ARG_NAMES_TAIL , framebuffer, pname, params
#define glGetNamedFramebufferParameterivEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum pname, GLint * params
#define forward_glGetNamedFramebufferParameterivEXT(_framebuffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedFramebufferParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedFramebufferParameterivEXT(dst, _framebuffer, _pname, _params), NULL); \
    });
#define call_glGetNamedFramebufferParameterivEXT(packed, ret_v) do { \
    glGetNamedFramebufferParameterivEXT_PACKED *unpacked = (glGetNamedFramebufferParameterivEXT_PACKED *)packed; \
    glGetNamedFramebufferParameterivEXT_ARGS *args = (glGetNamedFramebufferParameterivEXT_ARGS *)&unpacked->args; \
    glGetNamedFramebufferParameterivEXT(args->framebuffer, args->pname, args->params);; \
} while(0)
void glGetNamedFramebufferParameterivEXT(glGetNamedFramebufferParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedFramebufferParameterivEXT(glGetNamedFramebufferParameterivEXT_PACKED *_dst glGetNamedFramebufferParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedFramebufferParameterivEXT_PTR)(glGetNamedFramebufferParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedProgramLocalParameterIivEXT_RETURN
#define glGetNamedProgramLocalParameterIivEXT_RETURN void
#define glGetNamedProgramLocalParameterIivEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLint * params
#define glGetNamedProgramLocalParameterIivEXT_ARG_NAMES_TAIL , program, target, index, params
#define glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLint * params
#define forward_glGetNamedProgramLocalParameterIivEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedProgramLocalParameterIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedProgramLocalParameterIivEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glGetNamedProgramLocalParameterIivEXT(packed, ret_v) do { \
    glGetNamedProgramLocalParameterIivEXT_PACKED *unpacked = (glGetNamedProgramLocalParameterIivEXT_PACKED *)packed; \
    glGetNamedProgramLocalParameterIivEXT_ARGS *args = (glGetNamedProgramLocalParameterIivEXT_ARGS *)&unpacked->args; \
    glGetNamedProgramLocalParameterIivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterIivEXT(glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedProgramLocalParameterIivEXT(glGetNamedProgramLocalParameterIivEXT_PACKED *_dst glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedProgramLocalParameterIivEXT_PTR)(glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedProgramLocalParameterIuivEXT_RETURN
#define glGetNamedProgramLocalParameterIuivEXT_RETURN void
#define glGetNamedProgramLocalParameterIuivEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLuint * params
#define glGetNamedProgramLocalParameterIuivEXT_ARG_NAMES_TAIL , program, target, index, params
#define glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLuint * params
#define forward_glGetNamedProgramLocalParameterIuivEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedProgramLocalParameterIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedProgramLocalParameterIuivEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glGetNamedProgramLocalParameterIuivEXT(packed, ret_v) do { \
    glGetNamedProgramLocalParameterIuivEXT_PACKED *unpacked = (glGetNamedProgramLocalParameterIuivEXT_PACKED *)packed; \
    glGetNamedProgramLocalParameterIuivEXT_ARGS *args = (glGetNamedProgramLocalParameterIuivEXT_ARGS *)&unpacked->args; \
    glGetNamedProgramLocalParameterIuivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterIuivEXT(glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedProgramLocalParameterIuivEXT(glGetNamedProgramLocalParameterIuivEXT_PACKED *_dst glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedProgramLocalParameterIuivEXT_PTR)(glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedProgramLocalParameterdvEXT_RETURN
#define glGetNamedProgramLocalParameterdvEXT_RETURN void
#define glGetNamedProgramLocalParameterdvEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLdouble * params
#define glGetNamedProgramLocalParameterdvEXT_ARG_NAMES_TAIL , program, target, index, params
#define glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLdouble * params
#define forward_glGetNamedProgramLocalParameterdvEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedProgramLocalParameterdvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedProgramLocalParameterdvEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glGetNamedProgramLocalParameterdvEXT(packed, ret_v) do { \
    glGetNamedProgramLocalParameterdvEXT_PACKED *unpacked = (glGetNamedProgramLocalParameterdvEXT_PACKED *)packed; \
    glGetNamedProgramLocalParameterdvEXT_ARGS *args = (glGetNamedProgramLocalParameterdvEXT_ARGS *)&unpacked->args; \
    glGetNamedProgramLocalParameterdvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterdvEXT(glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedProgramLocalParameterdvEXT(glGetNamedProgramLocalParameterdvEXT_PACKED *_dst glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedProgramLocalParameterdvEXT_PTR)(glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedProgramLocalParameterfvEXT_RETURN
#define glGetNamedProgramLocalParameterfvEXT_RETURN void
#define glGetNamedProgramLocalParameterfvEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLfloat * params
#define glGetNamedProgramLocalParameterfvEXT_ARG_NAMES_TAIL , program, target, index, params
#define glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLfloat * params
#define forward_glGetNamedProgramLocalParameterfvEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedProgramLocalParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedProgramLocalParameterfvEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glGetNamedProgramLocalParameterfvEXT(packed, ret_v) do { \
    glGetNamedProgramLocalParameterfvEXT_PACKED *unpacked = (glGetNamedProgramLocalParameterfvEXT_PACKED *)packed; \
    glGetNamedProgramLocalParameterfvEXT_ARGS *args = (glGetNamedProgramLocalParameterfvEXT_ARGS *)&unpacked->args; \
    glGetNamedProgramLocalParameterfvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterfvEXT(glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedProgramLocalParameterfvEXT(glGetNamedProgramLocalParameterfvEXT_PACKED *_dst glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedProgramLocalParameterfvEXT_PTR)(glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedProgramStringEXT_RETURN
#define glGetNamedProgramStringEXT_RETURN void
#define glGetNamedProgramStringEXT_ARG_NAMES program, target, pname, string
#define glGetNamedProgramStringEXT_ARG_EXPAND GLuint program, GLenum target, GLenum pname, GLvoid * string
#define glGetNamedProgramStringEXT_ARG_NAMES_TAIL , program, target, pname, string
#define glGetNamedProgramStringEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLenum pname, GLvoid * string
#define forward_glGetNamedProgramStringEXT(_program, _target, _pname, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedProgramStringEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedProgramStringEXT(dst, _program, _target, _pname, _string), NULL); \
    });
#define call_glGetNamedProgramStringEXT(packed, ret_v) do { \
    glGetNamedProgramStringEXT_PACKED *unpacked = (glGetNamedProgramStringEXT_PACKED *)packed; \
    glGetNamedProgramStringEXT_ARGS *args = (glGetNamedProgramStringEXT_ARGS *)&unpacked->args; \
    glGetNamedProgramStringEXT(args->program, args->target, args->pname, args->string);; \
} while(0)
void glGetNamedProgramStringEXT(glGetNamedProgramStringEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedProgramStringEXT(glGetNamedProgramStringEXT_PACKED *_dst glGetNamedProgramStringEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedProgramStringEXT_PTR)(glGetNamedProgramStringEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedProgramivEXT_RETURN
#define glGetNamedProgramivEXT_RETURN void
#define glGetNamedProgramivEXT_ARG_NAMES program, target, pname, params
#define glGetNamedProgramivEXT_ARG_EXPAND GLuint program, GLenum target, GLenum pname, GLint * params
#define glGetNamedProgramivEXT_ARG_NAMES_TAIL , program, target, pname, params
#define glGetNamedProgramivEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLenum pname, GLint * params
#define forward_glGetNamedProgramivEXT(_program, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedProgramivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedProgramivEXT(dst, _program, _target, _pname, _params), NULL); \
    });
#define call_glGetNamedProgramivEXT(packed, ret_v) do { \
    glGetNamedProgramivEXT_PACKED *unpacked = (glGetNamedProgramivEXT_PACKED *)packed; \
    glGetNamedProgramivEXT_ARGS *args = (glGetNamedProgramivEXT_ARGS *)&unpacked->args; \
    glGetNamedProgramivEXT(args->program, args->target, args->pname, args->params);; \
} while(0)
void glGetNamedProgramivEXT(glGetNamedProgramivEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedProgramivEXT(glGetNamedProgramivEXT_PACKED *_dst glGetNamedProgramivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedProgramivEXT_PTR)(glGetNamedProgramivEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedRenderbufferParameterivEXT_RETURN
#define glGetNamedRenderbufferParameterivEXT_RETURN void
#define glGetNamedRenderbufferParameterivEXT_ARG_NAMES renderbuffer, pname, params
#define glGetNamedRenderbufferParameterivEXT_ARG_EXPAND GLuint renderbuffer, GLenum pname, GLint * params
#define glGetNamedRenderbufferParameterivEXT_ARG_NAMES_TAIL , renderbuffer, pname, params
#define glGetNamedRenderbufferParameterivEXT_ARG_EXPAND_TAIL , GLuint renderbuffer, GLenum pname, GLint * params
#define forward_glGetNamedRenderbufferParameterivEXT(_renderbuffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedRenderbufferParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedRenderbufferParameterivEXT(dst, _renderbuffer, _pname, _params), NULL); \
    });
#define call_glGetNamedRenderbufferParameterivEXT(packed, ret_v) do { \
    glGetNamedRenderbufferParameterivEXT_PACKED *unpacked = (glGetNamedRenderbufferParameterivEXT_PACKED *)packed; \
    glGetNamedRenderbufferParameterivEXT_ARGS *args = (glGetNamedRenderbufferParameterivEXT_ARGS *)&unpacked->args; \
    glGetNamedRenderbufferParameterivEXT(args->renderbuffer, args->pname, args->params);; \
} while(0)
void glGetNamedRenderbufferParameterivEXT(glGetNamedRenderbufferParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetNamedRenderbufferParameterivEXT(glGetNamedRenderbufferParameterivEXT_PACKED *_dst glGetNamedRenderbufferParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetNamedRenderbufferParameterivEXT_PTR)(glGetNamedRenderbufferParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetNamedStringARB_RETURN
#define glGetNamedStringARB_RETURN void
#define glGetNamedStringARB_ARG_NAMES namelen, name, bufSize, stringlen, string
#define glGetNamedStringARB_ARG_EXPAND GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string
#define glGetNamedStringARB_ARG_NAMES_TAIL , namelen, name, bufSize, stringlen, string
#define glGetNamedStringARB_ARG_EXPAND_TAIL , GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string
#define forward_glGetNamedStringARB(_namelen, _name, _bufSize, _stringlen, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedStringARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedStringARB(dst, _namelen, _name, _bufSize, _stringlen, _string), NULL); \
    });
#define call_glGetNamedStringARB(packed, ret_v) do { \
    glGetNamedStringARB_PACKED *unpacked = (glGetNamedStringARB_PACKED *)packed; \
    glGetNamedStringARB_ARGS *args = (glGetNamedStringARB_ARGS *)&unpacked->args; \
    glGetNamedStringARB(args->namelen, args->name, args->bufSize, args->stringlen, args->string);; \
} while(0)
void glGetNamedStringARB(glGetNamedStringARB_ARG_EXPAND);
packed_call_t *pack_glGetNamedStringARB(glGetNamedStringARB_PACKED *_dst glGetNamedStringARB_ARG_EXPAND_TAIL);
typedef void (*glGetNamedStringARB_PTR)(glGetNamedStringARB_ARG_EXPAND);
#endif
#ifndef glGetNamedStringivARB_RETURN
#define glGetNamedStringivARB_RETURN void
#define glGetNamedStringivARB_ARG_NAMES namelen, name, pname, params
#define glGetNamedStringivARB_ARG_EXPAND GLint namelen, const GLchar * name, GLenum pname, GLint * params
#define glGetNamedStringivARB_ARG_NAMES_TAIL , namelen, name, pname, params
#define glGetNamedStringivARB_ARG_EXPAND_TAIL , GLint namelen, const GLchar * name, GLenum pname, GLint * params
#define forward_glGetNamedStringivARB(_namelen, _name, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetNamedStringivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetNamedStringivARB(dst, _namelen, _name, _pname, _params), NULL); \
    });
#define call_glGetNamedStringivARB(packed, ret_v) do { \
    glGetNamedStringivARB_PACKED *unpacked = (glGetNamedStringivARB_PACKED *)packed; \
    glGetNamedStringivARB_ARGS *args = (glGetNamedStringivARB_ARGS *)&unpacked->args; \
    glGetNamedStringivARB(args->namelen, args->name, args->pname, args->params);; \
} while(0)
void glGetNamedStringivARB(glGetNamedStringivARB_ARG_EXPAND);
packed_call_t *pack_glGetNamedStringivARB(glGetNamedStringivARB_PACKED *_dst glGetNamedStringivARB_ARG_EXPAND_TAIL);
typedef void (*glGetNamedStringivARB_PTR)(glGetNamedStringivARB_ARG_EXPAND);
#endif
#ifndef glGetObjectBufferfvATI_RETURN
#define glGetObjectBufferfvATI_RETURN void
#define glGetObjectBufferfvATI_ARG_NAMES buffer, pname, params
#define glGetObjectBufferfvATI_ARG_EXPAND GLuint buffer, GLenum pname, GLfloat * params
#define glGetObjectBufferfvATI_ARG_NAMES_TAIL , buffer, pname, params
#define glGetObjectBufferfvATI_ARG_EXPAND_TAIL , GLuint buffer, GLenum pname, GLfloat * params
#define forward_glGetObjectBufferfvATI(_buffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetObjectBufferfvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetObjectBufferfvATI(dst, _buffer, _pname, _params), NULL); \
    });
#define call_glGetObjectBufferfvATI(packed, ret_v) do { \
    glGetObjectBufferfvATI_PACKED *unpacked = (glGetObjectBufferfvATI_PACKED *)packed; \
    glGetObjectBufferfvATI_ARGS *args = (glGetObjectBufferfvATI_ARGS *)&unpacked->args; \
    glGetObjectBufferfvATI(args->buffer, args->pname, args->params);; \
} while(0)
void glGetObjectBufferfvATI(glGetObjectBufferfvATI_ARG_EXPAND);
packed_call_t *pack_glGetObjectBufferfvATI(glGetObjectBufferfvATI_PACKED *_dst glGetObjectBufferfvATI_ARG_EXPAND_TAIL);
typedef void (*glGetObjectBufferfvATI_PTR)(glGetObjectBufferfvATI_ARG_EXPAND);
#endif
#ifndef glGetObjectBufferivATI_RETURN
#define glGetObjectBufferivATI_RETURN void
#define glGetObjectBufferivATI_ARG_NAMES buffer, pname, params
#define glGetObjectBufferivATI_ARG_EXPAND GLuint buffer, GLenum pname, GLint * params
#define glGetObjectBufferivATI_ARG_NAMES_TAIL , buffer, pname, params
#define glGetObjectBufferivATI_ARG_EXPAND_TAIL , GLuint buffer, GLenum pname, GLint * params
#define forward_glGetObjectBufferivATI(_buffer, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetObjectBufferivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetObjectBufferivATI(dst, _buffer, _pname, _params), NULL); \
    });
#define call_glGetObjectBufferivATI(packed, ret_v) do { \
    glGetObjectBufferivATI_PACKED *unpacked = (glGetObjectBufferivATI_PACKED *)packed; \
    glGetObjectBufferivATI_ARGS *args = (glGetObjectBufferivATI_ARGS *)&unpacked->args; \
    glGetObjectBufferivATI(args->buffer, args->pname, args->params);; \
} while(0)
void glGetObjectBufferivATI(glGetObjectBufferivATI_ARG_EXPAND);
packed_call_t *pack_glGetObjectBufferivATI(glGetObjectBufferivATI_PACKED *_dst glGetObjectBufferivATI_ARG_EXPAND_TAIL);
typedef void (*glGetObjectBufferivATI_PTR)(glGetObjectBufferivATI_ARG_EXPAND);
#endif
#ifndef glGetObjectLabel_RETURN
#define glGetObjectLabel_RETURN void
#define glGetObjectLabel_ARG_NAMES identifier, name, bufSize, length, label
#define glGetObjectLabel_ARG_EXPAND GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label
#define glGetObjectLabel_ARG_NAMES_TAIL , identifier, name, bufSize, length, label
#define glGetObjectLabel_ARG_EXPAND_TAIL , GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label
#define forward_glGetObjectLabel(_identifier, _name, _bufSize, _length, _label) \
    ({ \
        void *dst = remote_dma(sizeof(glGetObjectLabel_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetObjectLabel(dst, _identifier, _name, _bufSize, _length, _label), NULL); \
    });
#define call_glGetObjectLabel(packed, ret_v) do { \
    glGetObjectLabel_PACKED *unpacked = (glGetObjectLabel_PACKED *)packed; \
    glGetObjectLabel_ARGS *args = (glGetObjectLabel_ARGS *)&unpacked->args; \
    glGetObjectLabel(args->identifier, args->name, args->bufSize, args->length, args->label);; \
} while(0)
void glGetObjectLabel(glGetObjectLabel_ARG_EXPAND);
packed_call_t *pack_glGetObjectLabel(glGetObjectLabel_PACKED *_dst glGetObjectLabel_ARG_EXPAND_TAIL);
typedef void (*glGetObjectLabel_PTR)(glGetObjectLabel_ARG_EXPAND);
#endif
#ifndef glGetObjectParameterfvARB_RETURN
#define glGetObjectParameterfvARB_RETURN void
#define glGetObjectParameterfvARB_ARG_NAMES obj, pname, params
#define glGetObjectParameterfvARB_ARG_EXPAND GLhandleARB obj, GLenum pname, GLfloat * params
#define glGetObjectParameterfvARB_ARG_NAMES_TAIL , obj, pname, params
#define glGetObjectParameterfvARB_ARG_EXPAND_TAIL , GLhandleARB obj, GLenum pname, GLfloat * params
#define forward_glGetObjectParameterfvARB(_obj, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetObjectParameterfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetObjectParameterfvARB(dst, _obj, _pname, _params), NULL); \
    });
#define call_glGetObjectParameterfvARB(packed, ret_v) do { \
    glGetObjectParameterfvARB_PACKED *unpacked = (glGetObjectParameterfvARB_PACKED *)packed; \
    glGetObjectParameterfvARB_ARGS *args = (glGetObjectParameterfvARB_ARGS *)&unpacked->args; \
    glGetObjectParameterfvARB(args->obj, args->pname, args->params);; \
} while(0)
void glGetObjectParameterfvARB(glGetObjectParameterfvARB_ARG_EXPAND);
packed_call_t *pack_glGetObjectParameterfvARB(glGetObjectParameterfvARB_PACKED *_dst glGetObjectParameterfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetObjectParameterfvARB_PTR)(glGetObjectParameterfvARB_ARG_EXPAND);
#endif
#ifndef glGetObjectParameterivAPPLE_RETURN
#define glGetObjectParameterivAPPLE_RETURN void
#define glGetObjectParameterivAPPLE_ARG_NAMES objectType, name, pname, params
#define glGetObjectParameterivAPPLE_ARG_EXPAND GLenum objectType, GLuint name, GLenum pname, GLint * params
#define glGetObjectParameterivAPPLE_ARG_NAMES_TAIL , objectType, name, pname, params
#define glGetObjectParameterivAPPLE_ARG_EXPAND_TAIL , GLenum objectType, GLuint name, GLenum pname, GLint * params
#define forward_glGetObjectParameterivAPPLE(_objectType, _name, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetObjectParameterivAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetObjectParameterivAPPLE(dst, _objectType, _name, _pname, _params), NULL); \
    });
#define call_glGetObjectParameterivAPPLE(packed, ret_v) do { \
    glGetObjectParameterivAPPLE_PACKED *unpacked = (glGetObjectParameterivAPPLE_PACKED *)packed; \
    glGetObjectParameterivAPPLE_ARGS *args = (glGetObjectParameterivAPPLE_ARGS *)&unpacked->args; \
    glGetObjectParameterivAPPLE(args->objectType, args->name, args->pname, args->params);; \
} while(0)
void glGetObjectParameterivAPPLE(glGetObjectParameterivAPPLE_ARG_EXPAND);
packed_call_t *pack_glGetObjectParameterivAPPLE(glGetObjectParameterivAPPLE_PACKED *_dst glGetObjectParameterivAPPLE_ARG_EXPAND_TAIL);
typedef void (*glGetObjectParameterivAPPLE_PTR)(glGetObjectParameterivAPPLE_ARG_EXPAND);
#endif
#ifndef glGetObjectParameterivARB_RETURN
#define glGetObjectParameterivARB_RETURN void
#define glGetObjectParameterivARB_ARG_NAMES obj, pname, params
#define glGetObjectParameterivARB_ARG_EXPAND GLhandleARB obj, GLenum pname, GLint * params
#define glGetObjectParameterivARB_ARG_NAMES_TAIL , obj, pname, params
#define glGetObjectParameterivARB_ARG_EXPAND_TAIL , GLhandleARB obj, GLenum pname, GLint * params
#define forward_glGetObjectParameterivARB(_obj, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetObjectParameterivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetObjectParameterivARB(dst, _obj, _pname, _params), NULL); \
    });
#define call_glGetObjectParameterivARB(packed, ret_v) do { \
    glGetObjectParameterivARB_PACKED *unpacked = (glGetObjectParameterivARB_PACKED *)packed; \
    glGetObjectParameterivARB_ARGS *args = (glGetObjectParameterivARB_ARGS *)&unpacked->args; \
    glGetObjectParameterivARB(args->obj, args->pname, args->params);; \
} while(0)
void glGetObjectParameterivARB(glGetObjectParameterivARB_ARG_EXPAND);
packed_call_t *pack_glGetObjectParameterivARB(glGetObjectParameterivARB_PACKED *_dst glGetObjectParameterivARB_ARG_EXPAND_TAIL);
typedef void (*glGetObjectParameterivARB_PTR)(glGetObjectParameterivARB_ARG_EXPAND);
#endif
#ifndef glGetObjectPtrLabel_RETURN
#define glGetObjectPtrLabel_RETURN void
#define glGetObjectPtrLabel_ARG_NAMES ptr, bufSize, length, label
#define glGetObjectPtrLabel_ARG_EXPAND const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label
#define glGetObjectPtrLabel_ARG_NAMES_TAIL , ptr, bufSize, length, label
#define glGetObjectPtrLabel_ARG_EXPAND_TAIL , const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label
#define forward_glGetObjectPtrLabel(_ptr, _bufSize, _length, _label) \
    ({ \
        void *dst = remote_dma(sizeof(glGetObjectPtrLabel_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetObjectPtrLabel(dst, _ptr, _bufSize, _length, _label), NULL); \
    });
#define call_glGetObjectPtrLabel(packed, ret_v) do { \
    glGetObjectPtrLabel_PACKED *unpacked = (glGetObjectPtrLabel_PACKED *)packed; \
    glGetObjectPtrLabel_ARGS *args = (glGetObjectPtrLabel_ARGS *)&unpacked->args; \
    glGetObjectPtrLabel(args->ptr, args->bufSize, args->length, args->label);; \
} while(0)
void glGetObjectPtrLabel(glGetObjectPtrLabel_ARG_EXPAND);
packed_call_t *pack_glGetObjectPtrLabel(glGetObjectPtrLabel_PACKED *_dst glGetObjectPtrLabel_ARG_EXPAND_TAIL);
typedef void (*glGetObjectPtrLabel_PTR)(glGetObjectPtrLabel_ARG_EXPAND);
#endif
#ifndef glGetOcclusionQueryivNV_RETURN
#define glGetOcclusionQueryivNV_RETURN void
#define glGetOcclusionQueryivNV_ARG_NAMES id, pname, params
#define glGetOcclusionQueryivNV_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetOcclusionQueryivNV_ARG_NAMES_TAIL , id, pname, params
#define glGetOcclusionQueryivNV_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLint * params
#define forward_glGetOcclusionQueryivNV(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetOcclusionQueryivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetOcclusionQueryivNV(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetOcclusionQueryivNV(packed, ret_v) do { \
    glGetOcclusionQueryivNV_PACKED *unpacked = (glGetOcclusionQueryivNV_PACKED *)packed; \
    glGetOcclusionQueryivNV_ARGS *args = (glGetOcclusionQueryivNV_ARGS *)&unpacked->args; \
    glGetOcclusionQueryivNV(args->id, args->pname, args->params);; \
} while(0)
void glGetOcclusionQueryivNV(glGetOcclusionQueryivNV_ARG_EXPAND);
packed_call_t *pack_glGetOcclusionQueryivNV(glGetOcclusionQueryivNV_PACKED *_dst glGetOcclusionQueryivNV_ARG_EXPAND_TAIL);
typedef void (*glGetOcclusionQueryivNV_PTR)(glGetOcclusionQueryivNV_ARG_EXPAND);
#endif
#ifndef glGetOcclusionQueryuivNV_RETURN
#define glGetOcclusionQueryuivNV_RETURN void
#define glGetOcclusionQueryuivNV_ARG_NAMES id, pname, params
#define glGetOcclusionQueryuivNV_ARG_EXPAND GLuint id, GLenum pname, GLuint * params
#define glGetOcclusionQueryuivNV_ARG_NAMES_TAIL , id, pname, params
#define glGetOcclusionQueryuivNV_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLuint * params
#define forward_glGetOcclusionQueryuivNV(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetOcclusionQueryuivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetOcclusionQueryuivNV(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetOcclusionQueryuivNV(packed, ret_v) do { \
    glGetOcclusionQueryuivNV_PACKED *unpacked = (glGetOcclusionQueryuivNV_PACKED *)packed; \
    glGetOcclusionQueryuivNV_ARGS *args = (glGetOcclusionQueryuivNV_ARGS *)&unpacked->args; \
    glGetOcclusionQueryuivNV(args->id, args->pname, args->params);; \
} while(0)
void glGetOcclusionQueryuivNV(glGetOcclusionQueryuivNV_ARG_EXPAND);
packed_call_t *pack_glGetOcclusionQueryuivNV(glGetOcclusionQueryuivNV_PACKED *_dst glGetOcclusionQueryuivNV_ARG_EXPAND_TAIL);
typedef void (*glGetOcclusionQueryuivNV_PTR)(glGetOcclusionQueryuivNV_ARG_EXPAND);
#endif
#ifndef glGetPathColorGenfvNV_RETURN
#define glGetPathColorGenfvNV_RETURN void
#define glGetPathColorGenfvNV_ARG_NAMES color, pname, value
#define glGetPathColorGenfvNV_ARG_EXPAND GLenum color, GLenum pname, GLfloat * value
#define glGetPathColorGenfvNV_ARG_NAMES_TAIL , color, pname, value
#define glGetPathColorGenfvNV_ARG_EXPAND_TAIL , GLenum color, GLenum pname, GLfloat * value
#define forward_glGetPathColorGenfvNV(_color, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathColorGenfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathColorGenfvNV(dst, _color, _pname, _value), NULL); \
    });
#define call_glGetPathColorGenfvNV(packed, ret_v) do { \
    glGetPathColorGenfvNV_PACKED *unpacked = (glGetPathColorGenfvNV_PACKED *)packed; \
    glGetPathColorGenfvNV_ARGS *args = (glGetPathColorGenfvNV_ARGS *)&unpacked->args; \
    glGetPathColorGenfvNV(args->color, args->pname, args->value);; \
} while(0)
void glGetPathColorGenfvNV(glGetPathColorGenfvNV_ARG_EXPAND);
packed_call_t *pack_glGetPathColorGenfvNV(glGetPathColorGenfvNV_PACKED *_dst glGetPathColorGenfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathColorGenfvNV_PTR)(glGetPathColorGenfvNV_ARG_EXPAND);
#endif
#ifndef glGetPathColorGenivNV_RETURN
#define glGetPathColorGenivNV_RETURN void
#define glGetPathColorGenivNV_ARG_NAMES color, pname, value
#define glGetPathColorGenivNV_ARG_EXPAND GLenum color, GLenum pname, GLint * value
#define glGetPathColorGenivNV_ARG_NAMES_TAIL , color, pname, value
#define glGetPathColorGenivNV_ARG_EXPAND_TAIL , GLenum color, GLenum pname, GLint * value
#define forward_glGetPathColorGenivNV(_color, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathColorGenivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathColorGenivNV(dst, _color, _pname, _value), NULL); \
    });
#define call_glGetPathColorGenivNV(packed, ret_v) do { \
    glGetPathColorGenivNV_PACKED *unpacked = (glGetPathColorGenivNV_PACKED *)packed; \
    glGetPathColorGenivNV_ARGS *args = (glGetPathColorGenivNV_ARGS *)&unpacked->args; \
    glGetPathColorGenivNV(args->color, args->pname, args->value);; \
} while(0)
void glGetPathColorGenivNV(glGetPathColorGenivNV_ARG_EXPAND);
packed_call_t *pack_glGetPathColorGenivNV(glGetPathColorGenivNV_PACKED *_dst glGetPathColorGenivNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathColorGenivNV_PTR)(glGetPathColorGenivNV_ARG_EXPAND);
#endif
#ifndef glGetPathCommandsNV_RETURN
#define glGetPathCommandsNV_RETURN void
#define glGetPathCommandsNV_ARG_NAMES path, commands
#define glGetPathCommandsNV_ARG_EXPAND GLuint path, GLubyte * commands
#define glGetPathCommandsNV_ARG_NAMES_TAIL , path, commands
#define glGetPathCommandsNV_ARG_EXPAND_TAIL , GLuint path, GLubyte * commands
#define forward_glGetPathCommandsNV(_path, _commands) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathCommandsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathCommandsNV(dst, _path, _commands), NULL); \
    });
#define call_glGetPathCommandsNV(packed, ret_v) do { \
    glGetPathCommandsNV_PACKED *unpacked = (glGetPathCommandsNV_PACKED *)packed; \
    glGetPathCommandsNV_ARGS *args = (glGetPathCommandsNV_ARGS *)&unpacked->args; \
    glGetPathCommandsNV(args->path, args->commands);; \
} while(0)
void glGetPathCommandsNV(glGetPathCommandsNV_ARG_EXPAND);
packed_call_t *pack_glGetPathCommandsNV(glGetPathCommandsNV_PACKED *_dst glGetPathCommandsNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathCommandsNV_PTR)(glGetPathCommandsNV_ARG_EXPAND);
#endif
#ifndef glGetPathCoordsNV_RETURN
#define glGetPathCoordsNV_RETURN void
#define glGetPathCoordsNV_ARG_NAMES path, coords
#define glGetPathCoordsNV_ARG_EXPAND GLuint path, GLfloat * coords
#define glGetPathCoordsNV_ARG_NAMES_TAIL , path, coords
#define glGetPathCoordsNV_ARG_EXPAND_TAIL , GLuint path, GLfloat * coords
#define forward_glGetPathCoordsNV(_path, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathCoordsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathCoordsNV(dst, _path, _coords), NULL); \
    });
#define call_glGetPathCoordsNV(packed, ret_v) do { \
    glGetPathCoordsNV_PACKED *unpacked = (glGetPathCoordsNV_PACKED *)packed; \
    glGetPathCoordsNV_ARGS *args = (glGetPathCoordsNV_ARGS *)&unpacked->args; \
    glGetPathCoordsNV(args->path, args->coords);; \
} while(0)
void glGetPathCoordsNV(glGetPathCoordsNV_ARG_EXPAND);
packed_call_t *pack_glGetPathCoordsNV(glGetPathCoordsNV_PACKED *_dst glGetPathCoordsNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathCoordsNV_PTR)(glGetPathCoordsNV_ARG_EXPAND);
#endif
#ifndef glGetPathDashArrayNV_RETURN
#define glGetPathDashArrayNV_RETURN void
#define glGetPathDashArrayNV_ARG_NAMES path, dashArray
#define glGetPathDashArrayNV_ARG_EXPAND GLuint path, GLfloat * dashArray
#define glGetPathDashArrayNV_ARG_NAMES_TAIL , path, dashArray
#define glGetPathDashArrayNV_ARG_EXPAND_TAIL , GLuint path, GLfloat * dashArray
#define forward_glGetPathDashArrayNV(_path, _dashArray) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathDashArrayNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathDashArrayNV(dst, _path, _dashArray), NULL); \
    });
#define call_glGetPathDashArrayNV(packed, ret_v) do { \
    glGetPathDashArrayNV_PACKED *unpacked = (glGetPathDashArrayNV_PACKED *)packed; \
    glGetPathDashArrayNV_ARGS *args = (glGetPathDashArrayNV_ARGS *)&unpacked->args; \
    glGetPathDashArrayNV(args->path, args->dashArray);; \
} while(0)
void glGetPathDashArrayNV(glGetPathDashArrayNV_ARG_EXPAND);
packed_call_t *pack_glGetPathDashArrayNV(glGetPathDashArrayNV_PACKED *_dst glGetPathDashArrayNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathDashArrayNV_PTR)(glGetPathDashArrayNV_ARG_EXPAND);
#endif
#ifndef glGetPathLengthNV_RETURN
#define glGetPathLengthNV_RETURN GLfloat
#define glGetPathLengthNV_ARG_NAMES path, startSegment, numSegments
#define glGetPathLengthNV_ARG_EXPAND GLuint path, GLsizei startSegment, GLsizei numSegments
#define glGetPathLengthNV_ARG_NAMES_TAIL , path, startSegment, numSegments
#define glGetPathLengthNV_ARG_EXPAND_TAIL , GLuint path, GLsizei startSegment, GLsizei numSegments
#define forward_glGetPathLengthNV(_path, _startSegment, _numSegments) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathLengthNV_PACKED)); \
        GLfloat ret = (GLfloat)0; \
        remote_dma_send((packed_call_t *)pack_glGetPathLengthNV(dst, _path, _startSegment, _numSegments), &ret); \
        ret; \
    });
#define call_glGetPathLengthNV(packed, ret_v) do { \
    glGetPathLengthNV_PACKED *unpacked = (glGetPathLengthNV_PACKED *)packed; \
    glGetPathLengthNV_ARGS *args = (glGetPathLengthNV_ARGS *)&unpacked->args; \
    GLfloat *ret = (GLfloat *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetPathLengthNV(args->path, args->startSegment, args->numSegments);; \
    } else { \
        glGetPathLengthNV(args->path, args->startSegment, args->numSegments);; \
    } \
} while(0)
GLfloat glGetPathLengthNV(glGetPathLengthNV_ARG_EXPAND);
packed_call_t *pack_glGetPathLengthNV(glGetPathLengthNV_PACKED *_dst glGetPathLengthNV_ARG_EXPAND_TAIL);
typedef GLfloat (*glGetPathLengthNV_PTR)(glGetPathLengthNV_ARG_EXPAND);
#endif
#ifndef glGetPathMetricRangeNV_RETURN
#define glGetPathMetricRangeNV_RETURN void
#define glGetPathMetricRangeNV_ARG_NAMES metricQueryMask, firstPathName, numPaths, stride, metrics
#define glGetPathMetricRangeNV_ARG_EXPAND GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics
#define glGetPathMetricRangeNV_ARG_NAMES_TAIL , metricQueryMask, firstPathName, numPaths, stride, metrics
#define glGetPathMetricRangeNV_ARG_EXPAND_TAIL , GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics
#define forward_glGetPathMetricRangeNV(_metricQueryMask, _firstPathName, _numPaths, _stride, _metrics) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathMetricRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathMetricRangeNV(dst, _metricQueryMask, _firstPathName, _numPaths, _stride, _metrics), NULL); \
    });
#define call_glGetPathMetricRangeNV(packed, ret_v) do { \
    glGetPathMetricRangeNV_PACKED *unpacked = (glGetPathMetricRangeNV_PACKED *)packed; \
    glGetPathMetricRangeNV_ARGS *args = (glGetPathMetricRangeNV_ARGS *)&unpacked->args; \
    glGetPathMetricRangeNV(args->metricQueryMask, args->firstPathName, args->numPaths, args->stride, args->metrics);; \
} while(0)
void glGetPathMetricRangeNV(glGetPathMetricRangeNV_ARG_EXPAND);
packed_call_t *pack_glGetPathMetricRangeNV(glGetPathMetricRangeNV_PACKED *_dst glGetPathMetricRangeNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathMetricRangeNV_PTR)(glGetPathMetricRangeNV_ARG_EXPAND);
#endif
#ifndef glGetPathMetricsNV_RETURN
#define glGetPathMetricsNV_RETURN void
#define glGetPathMetricsNV_ARG_NAMES metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics
#define glGetPathMetricsNV_ARG_EXPAND GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics
#define glGetPathMetricsNV_ARG_NAMES_TAIL , metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics
#define glGetPathMetricsNV_ARG_EXPAND_TAIL , GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics
#define forward_glGetPathMetricsNV(_metricQueryMask, _numPaths, _pathNameType, _paths, _pathBase, _stride, _metrics) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathMetricsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathMetricsNV(dst, _metricQueryMask, _numPaths, _pathNameType, _paths, _pathBase, _stride, _metrics), NULL); \
    });
#define call_glGetPathMetricsNV(packed, ret_v) do { \
    glGetPathMetricsNV_PACKED *unpacked = (glGetPathMetricsNV_PACKED *)packed; \
    glGetPathMetricsNV_ARGS *args = (glGetPathMetricsNV_ARGS *)&unpacked->args; \
    glGetPathMetricsNV(args->metricQueryMask, args->numPaths, args->pathNameType, args->paths, args->pathBase, args->stride, args->metrics);; \
} while(0)
void glGetPathMetricsNV(glGetPathMetricsNV_ARG_EXPAND);
packed_call_t *pack_glGetPathMetricsNV(glGetPathMetricsNV_PACKED *_dst glGetPathMetricsNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathMetricsNV_PTR)(glGetPathMetricsNV_ARG_EXPAND);
#endif
#ifndef glGetPathParameterfvNV_RETURN
#define glGetPathParameterfvNV_RETURN void
#define glGetPathParameterfvNV_ARG_NAMES path, pname, value
#define glGetPathParameterfvNV_ARG_EXPAND GLuint path, GLenum pname, GLfloat * value
#define glGetPathParameterfvNV_ARG_NAMES_TAIL , path, pname, value
#define glGetPathParameterfvNV_ARG_EXPAND_TAIL , GLuint path, GLenum pname, GLfloat * value
#define forward_glGetPathParameterfvNV(_path, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathParameterfvNV(dst, _path, _pname, _value), NULL); \
    });
#define call_glGetPathParameterfvNV(packed, ret_v) do { \
    glGetPathParameterfvNV_PACKED *unpacked = (glGetPathParameterfvNV_PACKED *)packed; \
    glGetPathParameterfvNV_ARGS *args = (glGetPathParameterfvNV_ARGS *)&unpacked->args; \
    glGetPathParameterfvNV(args->path, args->pname, args->value);; \
} while(0)
void glGetPathParameterfvNV(glGetPathParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetPathParameterfvNV(glGetPathParameterfvNV_PACKED *_dst glGetPathParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathParameterfvNV_PTR)(glGetPathParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetPathParameterivNV_RETURN
#define glGetPathParameterivNV_RETURN void
#define glGetPathParameterivNV_ARG_NAMES path, pname, value
#define glGetPathParameterivNV_ARG_EXPAND GLuint path, GLenum pname, GLint * value
#define glGetPathParameterivNV_ARG_NAMES_TAIL , path, pname, value
#define glGetPathParameterivNV_ARG_EXPAND_TAIL , GLuint path, GLenum pname, GLint * value
#define forward_glGetPathParameterivNV(_path, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathParameterivNV(dst, _path, _pname, _value), NULL); \
    });
#define call_glGetPathParameterivNV(packed, ret_v) do { \
    glGetPathParameterivNV_PACKED *unpacked = (glGetPathParameterivNV_PACKED *)packed; \
    glGetPathParameterivNV_ARGS *args = (glGetPathParameterivNV_ARGS *)&unpacked->args; \
    glGetPathParameterivNV(args->path, args->pname, args->value);; \
} while(0)
void glGetPathParameterivNV(glGetPathParameterivNV_ARG_EXPAND);
packed_call_t *pack_glGetPathParameterivNV(glGetPathParameterivNV_PACKED *_dst glGetPathParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathParameterivNV_PTR)(glGetPathParameterivNV_ARG_EXPAND);
#endif
#ifndef glGetPathSpacingNV_RETURN
#define glGetPathSpacingNV_RETURN void
#define glGetPathSpacingNV_ARG_NAMES pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing
#define glGetPathSpacingNV_ARG_EXPAND GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing
#define glGetPathSpacingNV_ARG_NAMES_TAIL , pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing
#define glGetPathSpacingNV_ARG_EXPAND_TAIL , GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing
#define forward_glGetPathSpacingNV(_pathListMode, _numPaths, _pathNameType, _paths, _pathBase, _advanceScale, _kerningScale, _transformType, _returnedSpacing) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathSpacingNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathSpacingNV(dst, _pathListMode, _numPaths, _pathNameType, _paths, _pathBase, _advanceScale, _kerningScale, _transformType, _returnedSpacing), NULL); \
    });
#define call_glGetPathSpacingNV(packed, ret_v) do { \
    glGetPathSpacingNV_PACKED *unpacked = (glGetPathSpacingNV_PACKED *)packed; \
    glGetPathSpacingNV_ARGS *args = (glGetPathSpacingNV_ARGS *)&unpacked->args; \
    glGetPathSpacingNV(args->pathListMode, args->numPaths, args->pathNameType, args->paths, args->pathBase, args->advanceScale, args->kerningScale, args->transformType, args->returnedSpacing);; \
} while(0)
void glGetPathSpacingNV(glGetPathSpacingNV_ARG_EXPAND);
packed_call_t *pack_glGetPathSpacingNV(glGetPathSpacingNV_PACKED *_dst glGetPathSpacingNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathSpacingNV_PTR)(glGetPathSpacingNV_ARG_EXPAND);
#endif
#ifndef glGetPathTexGenfvNV_RETURN
#define glGetPathTexGenfvNV_RETURN void
#define glGetPathTexGenfvNV_ARG_NAMES texCoordSet, pname, value
#define glGetPathTexGenfvNV_ARG_EXPAND GLenum texCoordSet, GLenum pname, GLfloat * value
#define glGetPathTexGenfvNV_ARG_NAMES_TAIL , texCoordSet, pname, value
#define glGetPathTexGenfvNV_ARG_EXPAND_TAIL , GLenum texCoordSet, GLenum pname, GLfloat * value
#define forward_glGetPathTexGenfvNV(_texCoordSet, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathTexGenfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathTexGenfvNV(dst, _texCoordSet, _pname, _value), NULL); \
    });
#define call_glGetPathTexGenfvNV(packed, ret_v) do { \
    glGetPathTexGenfvNV_PACKED *unpacked = (glGetPathTexGenfvNV_PACKED *)packed; \
    glGetPathTexGenfvNV_ARGS *args = (glGetPathTexGenfvNV_ARGS *)&unpacked->args; \
    glGetPathTexGenfvNV(args->texCoordSet, args->pname, args->value);; \
} while(0)
void glGetPathTexGenfvNV(glGetPathTexGenfvNV_ARG_EXPAND);
packed_call_t *pack_glGetPathTexGenfvNV(glGetPathTexGenfvNV_PACKED *_dst glGetPathTexGenfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathTexGenfvNV_PTR)(glGetPathTexGenfvNV_ARG_EXPAND);
#endif
#ifndef glGetPathTexGenivNV_RETURN
#define glGetPathTexGenivNV_RETURN void
#define glGetPathTexGenivNV_ARG_NAMES texCoordSet, pname, value
#define glGetPathTexGenivNV_ARG_EXPAND GLenum texCoordSet, GLenum pname, GLint * value
#define glGetPathTexGenivNV_ARG_NAMES_TAIL , texCoordSet, pname, value
#define glGetPathTexGenivNV_ARG_EXPAND_TAIL , GLenum texCoordSet, GLenum pname, GLint * value
#define forward_glGetPathTexGenivNV(_texCoordSet, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPathTexGenivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPathTexGenivNV(dst, _texCoordSet, _pname, _value), NULL); \
    });
#define call_glGetPathTexGenivNV(packed, ret_v) do { \
    glGetPathTexGenivNV_PACKED *unpacked = (glGetPathTexGenivNV_PACKED *)packed; \
    glGetPathTexGenivNV_ARGS *args = (glGetPathTexGenivNV_ARGS *)&unpacked->args; \
    glGetPathTexGenivNV(args->texCoordSet, args->pname, args->value);; \
} while(0)
void glGetPathTexGenivNV(glGetPathTexGenivNV_ARG_EXPAND);
packed_call_t *pack_glGetPathTexGenivNV(glGetPathTexGenivNV_PACKED *_dst glGetPathTexGenivNV_ARG_EXPAND_TAIL);
typedef void (*glGetPathTexGenivNV_PTR)(glGetPathTexGenivNV_ARG_EXPAND);
#endif
#ifndef glGetPerfMonitorCounterDataAMD_RETURN
#define glGetPerfMonitorCounterDataAMD_RETURN void
#define glGetPerfMonitorCounterDataAMD_ARG_NAMES monitor, pname, dataSize, data, bytesWritten
#define glGetPerfMonitorCounterDataAMD_ARG_EXPAND GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten
#define glGetPerfMonitorCounterDataAMD_ARG_NAMES_TAIL , monitor, pname, dataSize, data, bytesWritten
#define glGetPerfMonitorCounterDataAMD_ARG_EXPAND_TAIL , GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten
#define forward_glGetPerfMonitorCounterDataAMD(_monitor, _pname, _dataSize, _data, _bytesWritten) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPerfMonitorCounterDataAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPerfMonitorCounterDataAMD(dst, _monitor, _pname, _dataSize, _data, _bytesWritten), NULL); \
    });
#define call_glGetPerfMonitorCounterDataAMD(packed, ret_v) do { \
    glGetPerfMonitorCounterDataAMD_PACKED *unpacked = (glGetPerfMonitorCounterDataAMD_PACKED *)packed; \
    glGetPerfMonitorCounterDataAMD_ARGS *args = (glGetPerfMonitorCounterDataAMD_ARGS *)&unpacked->args; \
    glGetPerfMonitorCounterDataAMD(args->monitor, args->pname, args->dataSize, args->data, args->bytesWritten);; \
} while(0)
void glGetPerfMonitorCounterDataAMD(glGetPerfMonitorCounterDataAMD_ARG_EXPAND);
packed_call_t *pack_glGetPerfMonitorCounterDataAMD(glGetPerfMonitorCounterDataAMD_PACKED *_dst glGetPerfMonitorCounterDataAMD_ARG_EXPAND_TAIL);
typedef void (*glGetPerfMonitorCounterDataAMD_PTR)(glGetPerfMonitorCounterDataAMD_ARG_EXPAND);
#endif
#ifndef glGetPerfMonitorCounterInfoAMD_RETURN
#define glGetPerfMonitorCounterInfoAMD_RETURN void
#define glGetPerfMonitorCounterInfoAMD_ARG_NAMES group, counter, pname, data
#define glGetPerfMonitorCounterInfoAMD_ARG_EXPAND GLuint group, GLuint counter, GLenum pname, GLvoid * data
#define glGetPerfMonitorCounterInfoAMD_ARG_NAMES_TAIL , group, counter, pname, data
#define glGetPerfMonitorCounterInfoAMD_ARG_EXPAND_TAIL , GLuint group, GLuint counter, GLenum pname, GLvoid * data
#define forward_glGetPerfMonitorCounterInfoAMD(_group, _counter, _pname, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPerfMonitorCounterInfoAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPerfMonitorCounterInfoAMD(dst, _group, _counter, _pname, _data), NULL); \
    });
#define call_glGetPerfMonitorCounterInfoAMD(packed, ret_v) do { \
    glGetPerfMonitorCounterInfoAMD_PACKED *unpacked = (glGetPerfMonitorCounterInfoAMD_PACKED *)packed; \
    glGetPerfMonitorCounterInfoAMD_ARGS *args = (glGetPerfMonitorCounterInfoAMD_ARGS *)&unpacked->args; \
    glGetPerfMonitorCounterInfoAMD(args->group, args->counter, args->pname, args->data);; \
} while(0)
void glGetPerfMonitorCounterInfoAMD(glGetPerfMonitorCounterInfoAMD_ARG_EXPAND);
packed_call_t *pack_glGetPerfMonitorCounterInfoAMD(glGetPerfMonitorCounterInfoAMD_PACKED *_dst glGetPerfMonitorCounterInfoAMD_ARG_EXPAND_TAIL);
typedef void (*glGetPerfMonitorCounterInfoAMD_PTR)(glGetPerfMonitorCounterInfoAMD_ARG_EXPAND);
#endif
#ifndef glGetPerfMonitorCounterStringAMD_RETURN
#define glGetPerfMonitorCounterStringAMD_RETURN void
#define glGetPerfMonitorCounterStringAMD_ARG_NAMES group, counter, bufSize, length, counterString
#define glGetPerfMonitorCounterStringAMD_ARG_EXPAND GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString
#define glGetPerfMonitorCounterStringAMD_ARG_NAMES_TAIL , group, counter, bufSize, length, counterString
#define glGetPerfMonitorCounterStringAMD_ARG_EXPAND_TAIL , GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString
#define forward_glGetPerfMonitorCounterStringAMD(_group, _counter, _bufSize, _length, _counterString) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPerfMonitorCounterStringAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPerfMonitorCounterStringAMD(dst, _group, _counter, _bufSize, _length, _counterString), NULL); \
    });
#define call_glGetPerfMonitorCounterStringAMD(packed, ret_v) do { \
    glGetPerfMonitorCounterStringAMD_PACKED *unpacked = (glGetPerfMonitorCounterStringAMD_PACKED *)packed; \
    glGetPerfMonitorCounterStringAMD_ARGS *args = (glGetPerfMonitorCounterStringAMD_ARGS *)&unpacked->args; \
    glGetPerfMonitorCounterStringAMD(args->group, args->counter, args->bufSize, args->length, args->counterString);; \
} while(0)
void glGetPerfMonitorCounterStringAMD(glGetPerfMonitorCounterStringAMD_ARG_EXPAND);
packed_call_t *pack_glGetPerfMonitorCounterStringAMD(glGetPerfMonitorCounterStringAMD_PACKED *_dst glGetPerfMonitorCounterStringAMD_ARG_EXPAND_TAIL);
typedef void (*glGetPerfMonitorCounterStringAMD_PTR)(glGetPerfMonitorCounterStringAMD_ARG_EXPAND);
#endif
#ifndef glGetPerfMonitorCountersAMD_RETURN
#define glGetPerfMonitorCountersAMD_RETURN void
#define glGetPerfMonitorCountersAMD_ARG_NAMES group, numCounters, maxActiveCounters, counterSize, counters
#define glGetPerfMonitorCountersAMD_ARG_EXPAND GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters
#define glGetPerfMonitorCountersAMD_ARG_NAMES_TAIL , group, numCounters, maxActiveCounters, counterSize, counters
#define glGetPerfMonitorCountersAMD_ARG_EXPAND_TAIL , GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters
#define forward_glGetPerfMonitorCountersAMD(_group, _numCounters, _maxActiveCounters, _counterSize, _counters) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPerfMonitorCountersAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPerfMonitorCountersAMD(dst, _group, _numCounters, _maxActiveCounters, _counterSize, _counters), NULL); \
    });
#define call_glGetPerfMonitorCountersAMD(packed, ret_v) do { \
    glGetPerfMonitorCountersAMD_PACKED *unpacked = (glGetPerfMonitorCountersAMD_PACKED *)packed; \
    glGetPerfMonitorCountersAMD_ARGS *args = (glGetPerfMonitorCountersAMD_ARGS *)&unpacked->args; \
    glGetPerfMonitorCountersAMD(args->group, args->numCounters, args->maxActiveCounters, args->counterSize, args->counters);; \
} while(0)
void glGetPerfMonitorCountersAMD(glGetPerfMonitorCountersAMD_ARG_EXPAND);
packed_call_t *pack_glGetPerfMonitorCountersAMD(glGetPerfMonitorCountersAMD_PACKED *_dst glGetPerfMonitorCountersAMD_ARG_EXPAND_TAIL);
typedef void (*glGetPerfMonitorCountersAMD_PTR)(glGetPerfMonitorCountersAMD_ARG_EXPAND);
#endif
#ifndef glGetPerfMonitorGroupStringAMD_RETURN
#define glGetPerfMonitorGroupStringAMD_RETURN void
#define glGetPerfMonitorGroupStringAMD_ARG_NAMES group, bufSize, length, groupString
#define glGetPerfMonitorGroupStringAMD_ARG_EXPAND GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString
#define glGetPerfMonitorGroupStringAMD_ARG_NAMES_TAIL , group, bufSize, length, groupString
#define glGetPerfMonitorGroupStringAMD_ARG_EXPAND_TAIL , GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString
#define forward_glGetPerfMonitorGroupStringAMD(_group, _bufSize, _length, _groupString) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPerfMonitorGroupStringAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPerfMonitorGroupStringAMD(dst, _group, _bufSize, _length, _groupString), NULL); \
    });
#define call_glGetPerfMonitorGroupStringAMD(packed, ret_v) do { \
    glGetPerfMonitorGroupStringAMD_PACKED *unpacked = (glGetPerfMonitorGroupStringAMD_PACKED *)packed; \
    glGetPerfMonitorGroupStringAMD_ARGS *args = (glGetPerfMonitorGroupStringAMD_ARGS *)&unpacked->args; \
    glGetPerfMonitorGroupStringAMD(args->group, args->bufSize, args->length, args->groupString);; \
} while(0)
void glGetPerfMonitorGroupStringAMD(glGetPerfMonitorGroupStringAMD_ARG_EXPAND);
packed_call_t *pack_glGetPerfMonitorGroupStringAMD(glGetPerfMonitorGroupStringAMD_PACKED *_dst glGetPerfMonitorGroupStringAMD_ARG_EXPAND_TAIL);
typedef void (*glGetPerfMonitorGroupStringAMD_PTR)(glGetPerfMonitorGroupStringAMD_ARG_EXPAND);
#endif
#ifndef glGetPerfMonitorGroupsAMD_RETURN
#define glGetPerfMonitorGroupsAMD_RETURN void
#define glGetPerfMonitorGroupsAMD_ARG_NAMES numGroups, groupsSize, groups
#define glGetPerfMonitorGroupsAMD_ARG_EXPAND GLint * numGroups, GLsizei groupsSize, GLuint * groups
#define glGetPerfMonitorGroupsAMD_ARG_NAMES_TAIL , numGroups, groupsSize, groups
#define glGetPerfMonitorGroupsAMD_ARG_EXPAND_TAIL , GLint * numGroups, GLsizei groupsSize, GLuint * groups
#define forward_glGetPerfMonitorGroupsAMD(_numGroups, _groupsSize, _groups) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPerfMonitorGroupsAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPerfMonitorGroupsAMD(dst, _numGroups, _groupsSize, _groups), NULL); \
    });
#define call_glGetPerfMonitorGroupsAMD(packed, ret_v) do { \
    glGetPerfMonitorGroupsAMD_PACKED *unpacked = (glGetPerfMonitorGroupsAMD_PACKED *)packed; \
    glGetPerfMonitorGroupsAMD_ARGS *args = (glGetPerfMonitorGroupsAMD_ARGS *)&unpacked->args; \
    glGetPerfMonitorGroupsAMD(args->numGroups, args->groupsSize, args->groups);; \
} while(0)
void glGetPerfMonitorGroupsAMD(glGetPerfMonitorGroupsAMD_ARG_EXPAND);
packed_call_t *pack_glGetPerfMonitorGroupsAMD(glGetPerfMonitorGroupsAMD_PACKED *_dst glGetPerfMonitorGroupsAMD_ARG_EXPAND_TAIL);
typedef void (*glGetPerfMonitorGroupsAMD_PTR)(glGetPerfMonitorGroupsAMD_ARG_EXPAND);
#endif
#ifndef glGetPixelMapfv_RETURN
#define glGetPixelMapfv_RETURN void
#define glGetPixelMapfv_ARG_NAMES map, values
#define glGetPixelMapfv_ARG_EXPAND GLenum map, GLfloat * values
#define glGetPixelMapfv_ARG_NAMES_TAIL , map, values
#define glGetPixelMapfv_ARG_EXPAND_TAIL , GLenum map, GLfloat * values
#define forward_glGetPixelMapfv(_map, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelMapfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelMapfv(dst, _map, _values), NULL); \
    });
#define call_glGetPixelMapfv(packed, ret_v) do { \
    glGetPixelMapfv_PACKED *unpacked = (glGetPixelMapfv_PACKED *)packed; \
    glGetPixelMapfv_ARGS *args = (glGetPixelMapfv_ARGS *)&unpacked->args; \
    glGetPixelMapfv(args->map, args->values);; \
} while(0)
void glGetPixelMapfv(glGetPixelMapfv_ARG_EXPAND);
packed_call_t *pack_glGetPixelMapfv(glGetPixelMapfv_PACKED *_dst glGetPixelMapfv_ARG_EXPAND_TAIL);
typedef void (*glGetPixelMapfv_PTR)(glGetPixelMapfv_ARG_EXPAND);
#endif
#ifndef glGetPixelMapuiv_RETURN
#define glGetPixelMapuiv_RETURN void
#define glGetPixelMapuiv_ARG_NAMES map, values
#define glGetPixelMapuiv_ARG_EXPAND GLenum map, GLuint * values
#define glGetPixelMapuiv_ARG_NAMES_TAIL , map, values
#define glGetPixelMapuiv_ARG_EXPAND_TAIL , GLenum map, GLuint * values
#define forward_glGetPixelMapuiv(_map, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelMapuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelMapuiv(dst, _map, _values), NULL); \
    });
#define call_glGetPixelMapuiv(packed, ret_v) do { \
    glGetPixelMapuiv_PACKED *unpacked = (glGetPixelMapuiv_PACKED *)packed; \
    glGetPixelMapuiv_ARGS *args = (glGetPixelMapuiv_ARGS *)&unpacked->args; \
    glGetPixelMapuiv(args->map, args->values);; \
} while(0)
void glGetPixelMapuiv(glGetPixelMapuiv_ARG_EXPAND);
packed_call_t *pack_glGetPixelMapuiv(glGetPixelMapuiv_PACKED *_dst glGetPixelMapuiv_ARG_EXPAND_TAIL);
typedef void (*glGetPixelMapuiv_PTR)(glGetPixelMapuiv_ARG_EXPAND);
#endif
#ifndef glGetPixelMapusv_RETURN
#define glGetPixelMapusv_RETURN void
#define glGetPixelMapusv_ARG_NAMES map, values
#define glGetPixelMapusv_ARG_EXPAND GLenum map, GLushort * values
#define glGetPixelMapusv_ARG_NAMES_TAIL , map, values
#define glGetPixelMapusv_ARG_EXPAND_TAIL , GLenum map, GLushort * values
#define forward_glGetPixelMapusv(_map, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelMapusv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelMapusv(dst, _map, _values), NULL); \
    });
#define call_glGetPixelMapusv(packed, ret_v) do { \
    glGetPixelMapusv_PACKED *unpacked = (glGetPixelMapusv_PACKED *)packed; \
    glGetPixelMapusv_ARGS *args = (glGetPixelMapusv_ARGS *)&unpacked->args; \
    glGetPixelMapusv(args->map, args->values);; \
} while(0)
void glGetPixelMapusv(glGetPixelMapusv_ARG_EXPAND);
packed_call_t *pack_glGetPixelMapusv(glGetPixelMapusv_PACKED *_dst glGetPixelMapusv_ARG_EXPAND_TAIL);
typedef void (*glGetPixelMapusv_PTR)(glGetPixelMapusv_ARG_EXPAND);
#endif
#ifndef glGetPixelMapxv_RETURN
#define glGetPixelMapxv_RETURN void
#define glGetPixelMapxv_ARG_NAMES map, size, values
#define glGetPixelMapxv_ARG_EXPAND GLenum map, GLint size, GLfixed * values
#define glGetPixelMapxv_ARG_NAMES_TAIL , map, size, values
#define glGetPixelMapxv_ARG_EXPAND_TAIL , GLenum map, GLint size, GLfixed * values
#define forward_glGetPixelMapxv(_map, _size, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelMapxv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelMapxv(dst, _map, _size, _values), NULL); \
    });
#define call_glGetPixelMapxv(packed, ret_v) do { \
    glGetPixelMapxv_PACKED *unpacked = (glGetPixelMapxv_PACKED *)packed; \
    glGetPixelMapxv_ARGS *args = (glGetPixelMapxv_ARGS *)&unpacked->args; \
    glGetPixelMapxv(args->map, args->size, args->values);; \
} while(0)
void glGetPixelMapxv(glGetPixelMapxv_ARG_EXPAND);
packed_call_t *pack_glGetPixelMapxv(glGetPixelMapxv_PACKED *_dst glGetPixelMapxv_ARG_EXPAND_TAIL);
typedef void (*glGetPixelMapxv_PTR)(glGetPixelMapxv_ARG_EXPAND);
#endif
#ifndef glGetPixelTexGenParameterfvSGIS_RETURN
#define glGetPixelTexGenParameterfvSGIS_RETURN void
#define glGetPixelTexGenParameterfvSGIS_ARG_NAMES pname, params
#define glGetPixelTexGenParameterfvSGIS_ARG_EXPAND GLenum pname, GLfloat * params
#define glGetPixelTexGenParameterfvSGIS_ARG_NAMES_TAIL , pname, params
#define glGetPixelTexGenParameterfvSGIS_ARG_EXPAND_TAIL , GLenum pname, GLfloat * params
#define forward_glGetPixelTexGenParameterfvSGIS(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelTexGenParameterfvSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelTexGenParameterfvSGIS(dst, _pname, _params), NULL); \
    });
#define call_glGetPixelTexGenParameterfvSGIS(packed, ret_v) do { \
    glGetPixelTexGenParameterfvSGIS_PACKED *unpacked = (glGetPixelTexGenParameterfvSGIS_PACKED *)packed; \
    glGetPixelTexGenParameterfvSGIS_ARGS *args = (glGetPixelTexGenParameterfvSGIS_ARGS *)&unpacked->args; \
    glGetPixelTexGenParameterfvSGIS(args->pname, args->params);; \
} while(0)
void glGetPixelTexGenParameterfvSGIS(glGetPixelTexGenParameterfvSGIS_ARG_EXPAND);
packed_call_t *pack_glGetPixelTexGenParameterfvSGIS(glGetPixelTexGenParameterfvSGIS_PACKED *_dst glGetPixelTexGenParameterfvSGIS_ARG_EXPAND_TAIL);
typedef void (*glGetPixelTexGenParameterfvSGIS_PTR)(glGetPixelTexGenParameterfvSGIS_ARG_EXPAND);
#endif
#ifndef glGetPixelTexGenParameterivSGIS_RETURN
#define glGetPixelTexGenParameterivSGIS_RETURN void
#define glGetPixelTexGenParameterivSGIS_ARG_NAMES pname, params
#define glGetPixelTexGenParameterivSGIS_ARG_EXPAND GLenum pname, GLint * params
#define glGetPixelTexGenParameterivSGIS_ARG_NAMES_TAIL , pname, params
#define glGetPixelTexGenParameterivSGIS_ARG_EXPAND_TAIL , GLenum pname, GLint * params
#define forward_glGetPixelTexGenParameterivSGIS(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelTexGenParameterivSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelTexGenParameterivSGIS(dst, _pname, _params), NULL); \
    });
#define call_glGetPixelTexGenParameterivSGIS(packed, ret_v) do { \
    glGetPixelTexGenParameterivSGIS_PACKED *unpacked = (glGetPixelTexGenParameterivSGIS_PACKED *)packed; \
    glGetPixelTexGenParameterivSGIS_ARGS *args = (glGetPixelTexGenParameterivSGIS_ARGS *)&unpacked->args; \
    glGetPixelTexGenParameterivSGIS(args->pname, args->params);; \
} while(0)
void glGetPixelTexGenParameterivSGIS(glGetPixelTexGenParameterivSGIS_ARG_EXPAND);
packed_call_t *pack_glGetPixelTexGenParameterivSGIS(glGetPixelTexGenParameterivSGIS_PACKED *_dst glGetPixelTexGenParameterivSGIS_ARG_EXPAND_TAIL);
typedef void (*glGetPixelTexGenParameterivSGIS_PTR)(glGetPixelTexGenParameterivSGIS_ARG_EXPAND);
#endif
#ifndef glGetPixelTransformParameterfvEXT_RETURN
#define glGetPixelTransformParameterfvEXT_RETURN void
#define glGetPixelTransformParameterfvEXT_ARG_NAMES target, pname, params
#define glGetPixelTransformParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetPixelTransformParameterfvEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetPixelTransformParameterfvEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetPixelTransformParameterfvEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelTransformParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelTransformParameterfvEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetPixelTransformParameterfvEXT(packed, ret_v) do { \
    glGetPixelTransformParameterfvEXT_PACKED *unpacked = (glGetPixelTransformParameterfvEXT_PACKED *)packed; \
    glGetPixelTransformParameterfvEXT_ARGS *args = (glGetPixelTransformParameterfvEXT_ARGS *)&unpacked->args; \
    glGetPixelTransformParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetPixelTransformParameterfvEXT(glGetPixelTransformParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetPixelTransformParameterfvEXT(glGetPixelTransformParameterfvEXT_PACKED *_dst glGetPixelTransformParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetPixelTransformParameterfvEXT_PTR)(glGetPixelTransformParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetPixelTransformParameterivEXT_RETURN
#define glGetPixelTransformParameterivEXT_RETURN void
#define glGetPixelTransformParameterivEXT_ARG_NAMES target, pname, params
#define glGetPixelTransformParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetPixelTransformParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetPixelTransformParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetPixelTransformParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPixelTransformParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPixelTransformParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetPixelTransformParameterivEXT(packed, ret_v) do { \
    glGetPixelTransformParameterivEXT_PACKED *unpacked = (glGetPixelTransformParameterivEXT_PACKED *)packed; \
    glGetPixelTransformParameterivEXT_ARGS *args = (glGetPixelTransformParameterivEXT_ARGS *)&unpacked->args; \
    glGetPixelTransformParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetPixelTransformParameterivEXT(glGetPixelTransformParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetPixelTransformParameterivEXT(glGetPixelTransformParameterivEXT_PACKED *_dst glGetPixelTransformParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetPixelTransformParameterivEXT_PTR)(glGetPixelTransformParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetPointerIndexedvEXT_RETURN
#define glGetPointerIndexedvEXT_RETURN void
#define glGetPointerIndexedvEXT_ARG_NAMES target, index, data
#define glGetPointerIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLvoid * data
#define glGetPointerIndexedvEXT_ARG_NAMES_TAIL , target, index, data
#define glGetPointerIndexedvEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLvoid * data
#define forward_glGetPointerIndexedvEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPointerIndexedvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPointerIndexedvEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetPointerIndexedvEXT(packed, ret_v) do { \
    glGetPointerIndexedvEXT_PACKED *unpacked = (glGetPointerIndexedvEXT_PACKED *)packed; \
    glGetPointerIndexedvEXT_ARGS *args = (glGetPointerIndexedvEXT_ARGS *)&unpacked->args; \
    glGetPointerIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetPointerIndexedvEXT(glGetPointerIndexedvEXT_ARG_EXPAND);
packed_call_t *pack_glGetPointerIndexedvEXT(glGetPointerIndexedvEXT_PACKED *_dst glGetPointerIndexedvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetPointerIndexedvEXT_PTR)(glGetPointerIndexedvEXT_ARG_EXPAND);
#endif
#ifndef glGetPointeri_vEXT_RETURN
#define glGetPointeri_vEXT_RETURN void
#define glGetPointeri_vEXT_ARG_NAMES target, index, data
#define glGetPointeri_vEXT_ARG_EXPAND GLenum target, GLuint index, GLvoid * data
#define glGetPointeri_vEXT_ARG_NAMES_TAIL , target, index, data
#define glGetPointeri_vEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLvoid * data
#define forward_glGetPointeri_vEXT(_target, _index, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPointeri_vEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPointeri_vEXT(dst, _target, _index, _data), NULL); \
    });
#define call_glGetPointeri_vEXT(packed, ret_v) do { \
    glGetPointeri_vEXT_PACKED *unpacked = (glGetPointeri_vEXT_PACKED *)packed; \
    glGetPointeri_vEXT_ARGS *args = (glGetPointeri_vEXT_ARGS *)&unpacked->args; \
    glGetPointeri_vEXT(args->target, args->index, args->data);; \
} while(0)
void glGetPointeri_vEXT(glGetPointeri_vEXT_ARG_EXPAND);
packed_call_t *pack_glGetPointeri_vEXT(glGetPointeri_vEXT_PACKED *_dst glGetPointeri_vEXT_ARG_EXPAND_TAIL);
typedef void (*glGetPointeri_vEXT_PTR)(glGetPointeri_vEXT_ARG_EXPAND);
#endif
#ifndef glGetPointerv_RETURN
#define glGetPointerv_RETURN void
#define glGetPointerv_ARG_NAMES pname, params
#define glGetPointerv_ARG_EXPAND GLenum pname, GLvoid ** params
#define glGetPointerv_ARG_NAMES_TAIL , pname, params
#define glGetPointerv_ARG_EXPAND_TAIL , GLenum pname, GLvoid ** params
#define forward_glGetPointerv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPointerv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPointerv(dst, _pname, _params), NULL); \
    });
#define call_glGetPointerv(packed, ret_v) do { \
    glGetPointerv_PACKED *unpacked = (glGetPointerv_PACKED *)packed; \
    glGetPointerv_ARGS *args = (glGetPointerv_ARGS *)&unpacked->args; \
    glGetPointerv(args->pname, args->params);; \
} while(0)
void glGetPointerv(glGetPointerv_ARG_EXPAND);
packed_call_t *pack_glGetPointerv(glGetPointerv_PACKED *_dst glGetPointerv_ARG_EXPAND_TAIL);
typedef void (*glGetPointerv_PTR)(glGetPointerv_ARG_EXPAND);
#endif
#ifndef glGetPointervEXT_RETURN
#define glGetPointervEXT_RETURN void
#define glGetPointervEXT_ARG_NAMES pname, params
#define glGetPointervEXT_ARG_EXPAND GLenum pname, GLvoid * params
#define glGetPointervEXT_ARG_NAMES_TAIL , pname, params
#define glGetPointervEXT_ARG_EXPAND_TAIL , GLenum pname, GLvoid * params
#define forward_glGetPointervEXT(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPointervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPointervEXT(dst, _pname, _params), NULL); \
    });
#define call_glGetPointervEXT(packed, ret_v) do { \
    glGetPointervEXT_PACKED *unpacked = (glGetPointervEXT_PACKED *)packed; \
    glGetPointervEXT_ARGS *args = (glGetPointervEXT_ARGS *)&unpacked->args; \
    glGetPointervEXT(args->pname, args->params);; \
} while(0)
void glGetPointervEXT(glGetPointervEXT_ARG_EXPAND);
packed_call_t *pack_glGetPointervEXT(glGetPointervEXT_PACKED *_dst glGetPointervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetPointervEXT_PTR)(glGetPointervEXT_ARG_EXPAND);
#endif
#ifndef glGetPolygonStipple_RETURN
#define glGetPolygonStipple_RETURN void
#define glGetPolygonStipple_ARG_NAMES mask
#define glGetPolygonStipple_ARG_EXPAND GLubyte * mask
#define glGetPolygonStipple_ARG_NAMES_TAIL , mask
#define glGetPolygonStipple_ARG_EXPAND_TAIL , GLubyte * mask
#define forward_glGetPolygonStipple(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glGetPolygonStipple_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetPolygonStipple(dst, _mask), NULL); \
    });
#define call_glGetPolygonStipple(packed, ret_v) do { \
    glGetPolygonStipple_PACKED *unpacked = (glGetPolygonStipple_PACKED *)packed; \
    glGetPolygonStipple_ARGS *args = (glGetPolygonStipple_ARGS *)&unpacked->args; \
    glGetPolygonStipple(args->mask);; \
} while(0)
void glGetPolygonStipple(glGetPolygonStipple_ARG_EXPAND);
packed_call_t *pack_glGetPolygonStipple(glGetPolygonStipple_PACKED *_dst glGetPolygonStipple_ARG_EXPAND_TAIL);
typedef void (*glGetPolygonStipple_PTR)(glGetPolygonStipple_ARG_EXPAND);
#endif
#ifndef glGetProgramBinary_RETURN
#define glGetProgramBinary_RETURN void
#define glGetProgramBinary_ARG_NAMES program, bufSize, length, binaryFormat, binary
#define glGetProgramBinary_ARG_EXPAND GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary
#define glGetProgramBinary_ARG_NAMES_TAIL , program, bufSize, length, binaryFormat, binary
#define glGetProgramBinary_ARG_EXPAND_TAIL , GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary
#define forward_glGetProgramBinary(_program, _bufSize, _length, _binaryFormat, _binary) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramBinary_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramBinary(dst, _program, _bufSize, _length, _binaryFormat, _binary), NULL); \
    });
#define call_glGetProgramBinary(packed, ret_v) do { \
    glGetProgramBinary_PACKED *unpacked = (glGetProgramBinary_PACKED *)packed; \
    glGetProgramBinary_ARGS *args = (glGetProgramBinary_ARGS *)&unpacked->args; \
    glGetProgramBinary(args->program, args->bufSize, args->length, args->binaryFormat, args->binary);; \
} while(0)
void glGetProgramBinary(glGetProgramBinary_ARG_EXPAND);
packed_call_t *pack_glGetProgramBinary(glGetProgramBinary_PACKED *_dst glGetProgramBinary_ARG_EXPAND_TAIL);
typedef void (*glGetProgramBinary_PTR)(glGetProgramBinary_ARG_EXPAND);
#endif
#ifndef glGetProgramEnvParameterIivNV_RETURN
#define glGetProgramEnvParameterIivNV_RETURN void
#define glGetProgramEnvParameterIivNV_ARG_NAMES target, index, params
#define glGetProgramEnvParameterIivNV_ARG_EXPAND GLenum target, GLuint index, GLint * params
#define glGetProgramEnvParameterIivNV_ARG_NAMES_TAIL , target, index, params
#define glGetProgramEnvParameterIivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLint * params
#define forward_glGetProgramEnvParameterIivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramEnvParameterIivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramEnvParameterIivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramEnvParameterIivNV(packed, ret_v) do { \
    glGetProgramEnvParameterIivNV_PACKED *unpacked = (glGetProgramEnvParameterIivNV_PACKED *)packed; \
    glGetProgramEnvParameterIivNV_ARGS *args = (glGetProgramEnvParameterIivNV_ARGS *)&unpacked->args; \
    glGetProgramEnvParameterIivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterIivNV(glGetProgramEnvParameterIivNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramEnvParameterIivNV(glGetProgramEnvParameterIivNV_PACKED *_dst glGetProgramEnvParameterIivNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramEnvParameterIivNV_PTR)(glGetProgramEnvParameterIivNV_ARG_EXPAND);
#endif
#ifndef glGetProgramEnvParameterIuivNV_RETURN
#define glGetProgramEnvParameterIuivNV_RETURN void
#define glGetProgramEnvParameterIuivNV_ARG_NAMES target, index, params
#define glGetProgramEnvParameterIuivNV_ARG_EXPAND GLenum target, GLuint index, GLuint * params
#define glGetProgramEnvParameterIuivNV_ARG_NAMES_TAIL , target, index, params
#define glGetProgramEnvParameterIuivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint * params
#define forward_glGetProgramEnvParameterIuivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramEnvParameterIuivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramEnvParameterIuivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramEnvParameterIuivNV(packed, ret_v) do { \
    glGetProgramEnvParameterIuivNV_PACKED *unpacked = (glGetProgramEnvParameterIuivNV_PACKED *)packed; \
    glGetProgramEnvParameterIuivNV_ARGS *args = (glGetProgramEnvParameterIuivNV_ARGS *)&unpacked->args; \
    glGetProgramEnvParameterIuivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterIuivNV(glGetProgramEnvParameterIuivNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramEnvParameterIuivNV(glGetProgramEnvParameterIuivNV_PACKED *_dst glGetProgramEnvParameterIuivNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramEnvParameterIuivNV_PTR)(glGetProgramEnvParameterIuivNV_ARG_EXPAND);
#endif
#ifndef glGetProgramEnvParameterdvARB_RETURN
#define glGetProgramEnvParameterdvARB_RETURN void
#define glGetProgramEnvParameterdvARB_ARG_NAMES target, index, params
#define glGetProgramEnvParameterdvARB_ARG_EXPAND GLenum target, GLuint index, GLdouble * params
#define glGetProgramEnvParameterdvARB_ARG_NAMES_TAIL , target, index, params
#define glGetProgramEnvParameterdvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble * params
#define forward_glGetProgramEnvParameterdvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramEnvParameterdvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramEnvParameterdvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramEnvParameterdvARB(packed, ret_v) do { \
    glGetProgramEnvParameterdvARB_PACKED *unpacked = (glGetProgramEnvParameterdvARB_PACKED *)packed; \
    glGetProgramEnvParameterdvARB_ARGS *args = (glGetProgramEnvParameterdvARB_ARGS *)&unpacked->args; \
    glGetProgramEnvParameterdvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterdvARB(glGetProgramEnvParameterdvARB_ARG_EXPAND);
packed_call_t *pack_glGetProgramEnvParameterdvARB(glGetProgramEnvParameterdvARB_PACKED *_dst glGetProgramEnvParameterdvARB_ARG_EXPAND_TAIL);
typedef void (*glGetProgramEnvParameterdvARB_PTR)(glGetProgramEnvParameterdvARB_ARG_EXPAND);
#endif
#ifndef glGetProgramEnvParameterfvARB_RETURN
#define glGetProgramEnvParameterfvARB_RETURN void
#define glGetProgramEnvParameterfvARB_ARG_NAMES target, index, params
#define glGetProgramEnvParameterfvARB_ARG_EXPAND GLenum target, GLuint index, GLfloat * params
#define glGetProgramEnvParameterfvARB_ARG_NAMES_TAIL , target, index, params
#define glGetProgramEnvParameterfvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat * params
#define forward_glGetProgramEnvParameterfvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramEnvParameterfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramEnvParameterfvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramEnvParameterfvARB(packed, ret_v) do { \
    glGetProgramEnvParameterfvARB_PACKED *unpacked = (glGetProgramEnvParameterfvARB_PACKED *)packed; \
    glGetProgramEnvParameterfvARB_ARGS *args = (glGetProgramEnvParameterfvARB_ARGS *)&unpacked->args; \
    glGetProgramEnvParameterfvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterfvARB(glGetProgramEnvParameterfvARB_ARG_EXPAND);
packed_call_t *pack_glGetProgramEnvParameterfvARB(glGetProgramEnvParameterfvARB_PACKED *_dst glGetProgramEnvParameterfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetProgramEnvParameterfvARB_PTR)(glGetProgramEnvParameterfvARB_ARG_EXPAND);
#endif
#ifndef glGetProgramInfoLog_RETURN
#define glGetProgramInfoLog_RETURN void
#define glGetProgramInfoLog_ARG_NAMES program, bufSize, length, infoLog
#define glGetProgramInfoLog_ARG_EXPAND GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define glGetProgramInfoLog_ARG_NAMES_TAIL , program, bufSize, length, infoLog
#define glGetProgramInfoLog_ARG_EXPAND_TAIL , GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define forward_glGetProgramInfoLog(_program, _bufSize, _length, _infoLog) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramInfoLog_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramInfoLog(dst, _program, _bufSize, _length, _infoLog), NULL); \
    });
#define call_glGetProgramInfoLog(packed, ret_v) do { \
    glGetProgramInfoLog_PACKED *unpacked = (glGetProgramInfoLog_PACKED *)packed; \
    glGetProgramInfoLog_ARGS *args = (glGetProgramInfoLog_ARGS *)&unpacked->args; \
    glGetProgramInfoLog(args->program, args->bufSize, args->length, args->infoLog);; \
} while(0)
void glGetProgramInfoLog(glGetProgramInfoLog_ARG_EXPAND);
packed_call_t *pack_glGetProgramInfoLog(glGetProgramInfoLog_PACKED *_dst glGetProgramInfoLog_ARG_EXPAND_TAIL);
typedef void (*glGetProgramInfoLog_PTR)(glGetProgramInfoLog_ARG_EXPAND);
#endif
#ifndef glGetProgramInterfaceiv_RETURN
#define glGetProgramInterfaceiv_RETURN void
#define glGetProgramInterfaceiv_ARG_NAMES program, programInterface, pname, params
#define glGetProgramInterfaceiv_ARG_EXPAND GLuint program, GLenum programInterface, GLenum pname, GLint * params
#define glGetProgramInterfaceiv_ARG_NAMES_TAIL , program, programInterface, pname, params
#define glGetProgramInterfaceiv_ARG_EXPAND_TAIL , GLuint program, GLenum programInterface, GLenum pname, GLint * params
#define forward_glGetProgramInterfaceiv(_program, _programInterface, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramInterfaceiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramInterfaceiv(dst, _program, _programInterface, _pname, _params), NULL); \
    });
#define call_glGetProgramInterfaceiv(packed, ret_v) do { \
    glGetProgramInterfaceiv_PACKED *unpacked = (glGetProgramInterfaceiv_PACKED *)packed; \
    glGetProgramInterfaceiv_ARGS *args = (glGetProgramInterfaceiv_ARGS *)&unpacked->args; \
    glGetProgramInterfaceiv(args->program, args->programInterface, args->pname, args->params);; \
} while(0)
void glGetProgramInterfaceiv(glGetProgramInterfaceiv_ARG_EXPAND);
packed_call_t *pack_glGetProgramInterfaceiv(glGetProgramInterfaceiv_PACKED *_dst glGetProgramInterfaceiv_ARG_EXPAND_TAIL);
typedef void (*glGetProgramInterfaceiv_PTR)(glGetProgramInterfaceiv_ARG_EXPAND);
#endif
#ifndef glGetProgramLocalParameterIivNV_RETURN
#define glGetProgramLocalParameterIivNV_RETURN void
#define glGetProgramLocalParameterIivNV_ARG_NAMES target, index, params
#define glGetProgramLocalParameterIivNV_ARG_EXPAND GLenum target, GLuint index, GLint * params
#define glGetProgramLocalParameterIivNV_ARG_NAMES_TAIL , target, index, params
#define glGetProgramLocalParameterIivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLint * params
#define forward_glGetProgramLocalParameterIivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramLocalParameterIivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramLocalParameterIivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramLocalParameterIivNV(packed, ret_v) do { \
    glGetProgramLocalParameterIivNV_PACKED *unpacked = (glGetProgramLocalParameterIivNV_PACKED *)packed; \
    glGetProgramLocalParameterIivNV_ARGS *args = (glGetProgramLocalParameterIivNV_ARGS *)&unpacked->args; \
    glGetProgramLocalParameterIivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterIivNV(glGetProgramLocalParameterIivNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramLocalParameterIivNV(glGetProgramLocalParameterIivNV_PACKED *_dst glGetProgramLocalParameterIivNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramLocalParameterIivNV_PTR)(glGetProgramLocalParameterIivNV_ARG_EXPAND);
#endif
#ifndef glGetProgramLocalParameterIuivNV_RETURN
#define glGetProgramLocalParameterIuivNV_RETURN void
#define glGetProgramLocalParameterIuivNV_ARG_NAMES target, index, params
#define glGetProgramLocalParameterIuivNV_ARG_EXPAND GLenum target, GLuint index, GLuint * params
#define glGetProgramLocalParameterIuivNV_ARG_NAMES_TAIL , target, index, params
#define glGetProgramLocalParameterIuivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint * params
#define forward_glGetProgramLocalParameterIuivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramLocalParameterIuivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramLocalParameterIuivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramLocalParameterIuivNV(packed, ret_v) do { \
    glGetProgramLocalParameterIuivNV_PACKED *unpacked = (glGetProgramLocalParameterIuivNV_PACKED *)packed; \
    glGetProgramLocalParameterIuivNV_ARGS *args = (glGetProgramLocalParameterIuivNV_ARGS *)&unpacked->args; \
    glGetProgramLocalParameterIuivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterIuivNV(glGetProgramLocalParameterIuivNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramLocalParameterIuivNV(glGetProgramLocalParameterIuivNV_PACKED *_dst glGetProgramLocalParameterIuivNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramLocalParameterIuivNV_PTR)(glGetProgramLocalParameterIuivNV_ARG_EXPAND);
#endif
#ifndef glGetProgramLocalParameterdvARB_RETURN
#define glGetProgramLocalParameterdvARB_RETURN void
#define glGetProgramLocalParameterdvARB_ARG_NAMES target, index, params
#define glGetProgramLocalParameterdvARB_ARG_EXPAND GLenum target, GLuint index, GLdouble * params
#define glGetProgramLocalParameterdvARB_ARG_NAMES_TAIL , target, index, params
#define glGetProgramLocalParameterdvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble * params
#define forward_glGetProgramLocalParameterdvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramLocalParameterdvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramLocalParameterdvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramLocalParameterdvARB(packed, ret_v) do { \
    glGetProgramLocalParameterdvARB_PACKED *unpacked = (glGetProgramLocalParameterdvARB_PACKED *)packed; \
    glGetProgramLocalParameterdvARB_ARGS *args = (glGetProgramLocalParameterdvARB_ARGS *)&unpacked->args; \
    glGetProgramLocalParameterdvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterdvARB(glGetProgramLocalParameterdvARB_ARG_EXPAND);
packed_call_t *pack_glGetProgramLocalParameterdvARB(glGetProgramLocalParameterdvARB_PACKED *_dst glGetProgramLocalParameterdvARB_ARG_EXPAND_TAIL);
typedef void (*glGetProgramLocalParameterdvARB_PTR)(glGetProgramLocalParameterdvARB_ARG_EXPAND);
#endif
#ifndef glGetProgramLocalParameterfvARB_RETURN
#define glGetProgramLocalParameterfvARB_RETURN void
#define glGetProgramLocalParameterfvARB_ARG_NAMES target, index, params
#define glGetProgramLocalParameterfvARB_ARG_EXPAND GLenum target, GLuint index, GLfloat * params
#define glGetProgramLocalParameterfvARB_ARG_NAMES_TAIL , target, index, params
#define glGetProgramLocalParameterfvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat * params
#define forward_glGetProgramLocalParameterfvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramLocalParameterfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramLocalParameterfvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glGetProgramLocalParameterfvARB(packed, ret_v) do { \
    glGetProgramLocalParameterfvARB_PACKED *unpacked = (glGetProgramLocalParameterfvARB_PACKED *)packed; \
    glGetProgramLocalParameterfvARB_ARGS *args = (glGetProgramLocalParameterfvARB_ARGS *)&unpacked->args; \
    glGetProgramLocalParameterfvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterfvARB(glGetProgramLocalParameterfvARB_ARG_EXPAND);
packed_call_t *pack_glGetProgramLocalParameterfvARB(glGetProgramLocalParameterfvARB_PACKED *_dst glGetProgramLocalParameterfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetProgramLocalParameterfvARB_PTR)(glGetProgramLocalParameterfvARB_ARG_EXPAND);
#endif
#ifndef glGetProgramNamedParameterdvNV_RETURN
#define glGetProgramNamedParameterdvNV_RETURN void
#define glGetProgramNamedParameterdvNV_ARG_NAMES id, len, name, params
#define glGetProgramNamedParameterdvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLdouble * params
#define glGetProgramNamedParameterdvNV_ARG_NAMES_TAIL , id, len, name, params
#define glGetProgramNamedParameterdvNV_ARG_EXPAND_TAIL , GLuint id, GLsizei len, const GLubyte * name, GLdouble * params
#define forward_glGetProgramNamedParameterdvNV(_id, _len, _name, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramNamedParameterdvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramNamedParameterdvNV(dst, _id, _len, _name, _params), NULL); \
    });
#define call_glGetProgramNamedParameterdvNV(packed, ret_v) do { \
    glGetProgramNamedParameterdvNV_PACKED *unpacked = (glGetProgramNamedParameterdvNV_PACKED *)packed; \
    glGetProgramNamedParameterdvNV_ARGS *args = (glGetProgramNamedParameterdvNV_ARGS *)&unpacked->args; \
    glGetProgramNamedParameterdvNV(args->id, args->len, args->name, args->params);; \
} while(0)
void glGetProgramNamedParameterdvNV(glGetProgramNamedParameterdvNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramNamedParameterdvNV(glGetProgramNamedParameterdvNV_PACKED *_dst glGetProgramNamedParameterdvNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramNamedParameterdvNV_PTR)(glGetProgramNamedParameterdvNV_ARG_EXPAND);
#endif
#ifndef glGetProgramNamedParameterfvNV_RETURN
#define glGetProgramNamedParameterfvNV_RETURN void
#define glGetProgramNamedParameterfvNV_ARG_NAMES id, len, name, params
#define glGetProgramNamedParameterfvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLfloat * params
#define glGetProgramNamedParameterfvNV_ARG_NAMES_TAIL , id, len, name, params
#define glGetProgramNamedParameterfvNV_ARG_EXPAND_TAIL , GLuint id, GLsizei len, const GLubyte * name, GLfloat * params
#define forward_glGetProgramNamedParameterfvNV(_id, _len, _name, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramNamedParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramNamedParameterfvNV(dst, _id, _len, _name, _params), NULL); \
    });
#define call_glGetProgramNamedParameterfvNV(packed, ret_v) do { \
    glGetProgramNamedParameterfvNV_PACKED *unpacked = (glGetProgramNamedParameterfvNV_PACKED *)packed; \
    glGetProgramNamedParameterfvNV_ARGS *args = (glGetProgramNamedParameterfvNV_ARGS *)&unpacked->args; \
    glGetProgramNamedParameterfvNV(args->id, args->len, args->name, args->params);; \
} while(0)
void glGetProgramNamedParameterfvNV(glGetProgramNamedParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramNamedParameterfvNV(glGetProgramNamedParameterfvNV_PACKED *_dst glGetProgramNamedParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramNamedParameterfvNV_PTR)(glGetProgramNamedParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetProgramParameterdvNV_RETURN
#define glGetProgramParameterdvNV_RETURN void
#define glGetProgramParameterdvNV_ARG_NAMES target, index, pname, params
#define glGetProgramParameterdvNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLdouble * params
#define glGetProgramParameterdvNV_ARG_NAMES_TAIL , target, index, pname, params
#define glGetProgramParameterdvNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLenum pname, GLdouble * params
#define forward_glGetProgramParameterdvNV(_target, _index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramParameterdvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramParameterdvNV(dst, _target, _index, _pname, _params), NULL); \
    });
#define call_glGetProgramParameterdvNV(packed, ret_v) do { \
    glGetProgramParameterdvNV_PACKED *unpacked = (glGetProgramParameterdvNV_PACKED *)packed; \
    glGetProgramParameterdvNV_ARGS *args = (glGetProgramParameterdvNV_ARGS *)&unpacked->args; \
    glGetProgramParameterdvNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetProgramParameterdvNV(glGetProgramParameterdvNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramParameterdvNV(glGetProgramParameterdvNV_PACKED *_dst glGetProgramParameterdvNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramParameterdvNV_PTR)(glGetProgramParameterdvNV_ARG_EXPAND);
#endif
#ifndef glGetProgramParameterfvNV_RETURN
#define glGetProgramParameterfvNV_RETURN void
#define glGetProgramParameterfvNV_ARG_NAMES target, index, pname, params
#define glGetProgramParameterfvNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLfloat * params
#define glGetProgramParameterfvNV_ARG_NAMES_TAIL , target, index, pname, params
#define glGetProgramParameterfvNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLenum pname, GLfloat * params
#define forward_glGetProgramParameterfvNV(_target, _index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramParameterfvNV(dst, _target, _index, _pname, _params), NULL); \
    });
#define call_glGetProgramParameterfvNV(packed, ret_v) do { \
    glGetProgramParameterfvNV_PACKED *unpacked = (glGetProgramParameterfvNV_PACKED *)packed; \
    glGetProgramParameterfvNV_ARGS *args = (glGetProgramParameterfvNV_ARGS *)&unpacked->args; \
    glGetProgramParameterfvNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetProgramParameterfvNV(glGetProgramParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramParameterfvNV(glGetProgramParameterfvNV_PACKED *_dst glGetProgramParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramParameterfvNV_PTR)(glGetProgramParameterfvNV_ARG_EXPAND);
#endif
#ifndef glGetProgramPipelineInfoLog_RETURN
#define glGetProgramPipelineInfoLog_RETURN void
#define glGetProgramPipelineInfoLog_ARG_NAMES pipeline, bufSize, length, infoLog
#define glGetProgramPipelineInfoLog_ARG_EXPAND GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define glGetProgramPipelineInfoLog_ARG_NAMES_TAIL , pipeline, bufSize, length, infoLog
#define glGetProgramPipelineInfoLog_ARG_EXPAND_TAIL , GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define forward_glGetProgramPipelineInfoLog(_pipeline, _bufSize, _length, _infoLog) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramPipelineInfoLog_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramPipelineInfoLog(dst, _pipeline, _bufSize, _length, _infoLog), NULL); \
    });
#define call_glGetProgramPipelineInfoLog(packed, ret_v) do { \
    glGetProgramPipelineInfoLog_PACKED *unpacked = (glGetProgramPipelineInfoLog_PACKED *)packed; \
    glGetProgramPipelineInfoLog_ARGS *args = (glGetProgramPipelineInfoLog_ARGS *)&unpacked->args; \
    glGetProgramPipelineInfoLog(args->pipeline, args->bufSize, args->length, args->infoLog);; \
} while(0)
void glGetProgramPipelineInfoLog(glGetProgramPipelineInfoLog_ARG_EXPAND);
packed_call_t *pack_glGetProgramPipelineInfoLog(glGetProgramPipelineInfoLog_PACKED *_dst glGetProgramPipelineInfoLog_ARG_EXPAND_TAIL);
typedef void (*glGetProgramPipelineInfoLog_PTR)(glGetProgramPipelineInfoLog_ARG_EXPAND);
#endif
#ifndef glGetProgramPipelineiv_RETURN
#define glGetProgramPipelineiv_RETURN void
#define glGetProgramPipelineiv_ARG_NAMES pipeline, pname, params
#define glGetProgramPipelineiv_ARG_EXPAND GLuint pipeline, GLenum pname, GLint * params
#define glGetProgramPipelineiv_ARG_NAMES_TAIL , pipeline, pname, params
#define glGetProgramPipelineiv_ARG_EXPAND_TAIL , GLuint pipeline, GLenum pname, GLint * params
#define forward_glGetProgramPipelineiv(_pipeline, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramPipelineiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramPipelineiv(dst, _pipeline, _pname, _params), NULL); \
    });
#define call_glGetProgramPipelineiv(packed, ret_v) do { \
    glGetProgramPipelineiv_PACKED *unpacked = (glGetProgramPipelineiv_PACKED *)packed; \
    glGetProgramPipelineiv_ARGS *args = (glGetProgramPipelineiv_ARGS *)&unpacked->args; \
    glGetProgramPipelineiv(args->pipeline, args->pname, args->params);; \
} while(0)
void glGetProgramPipelineiv(glGetProgramPipelineiv_ARG_EXPAND);
packed_call_t *pack_glGetProgramPipelineiv(glGetProgramPipelineiv_PACKED *_dst glGetProgramPipelineiv_ARG_EXPAND_TAIL);
typedef void (*glGetProgramPipelineiv_PTR)(glGetProgramPipelineiv_ARG_EXPAND);
#endif
#ifndef glGetProgramResourceIndex_RETURN
#define glGetProgramResourceIndex_RETURN GLuint
#define glGetProgramResourceIndex_ARG_NAMES program, programInterface, name
#define glGetProgramResourceIndex_ARG_EXPAND GLuint program, GLenum programInterface, const GLchar * name
#define glGetProgramResourceIndex_ARG_NAMES_TAIL , program, programInterface, name
#define glGetProgramResourceIndex_ARG_EXPAND_TAIL , GLuint program, GLenum programInterface, const GLchar * name
#define forward_glGetProgramResourceIndex(_program, _programInterface, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramResourceIndex_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGetProgramResourceIndex(dst, _program, _programInterface, _name), &ret); \
        ret; \
    });
#define call_glGetProgramResourceIndex(packed, ret_v) do { \
    glGetProgramResourceIndex_PACKED *unpacked = (glGetProgramResourceIndex_PACKED *)packed; \
    glGetProgramResourceIndex_ARGS *args = (glGetProgramResourceIndex_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetProgramResourceIndex(args->program, args->programInterface, args->name);; \
    } else { \
        glGetProgramResourceIndex(args->program, args->programInterface, args->name);; \
    } \
} while(0)
GLuint glGetProgramResourceIndex(glGetProgramResourceIndex_ARG_EXPAND);
packed_call_t *pack_glGetProgramResourceIndex(glGetProgramResourceIndex_PACKED *_dst glGetProgramResourceIndex_ARG_EXPAND_TAIL);
typedef GLuint (*glGetProgramResourceIndex_PTR)(glGetProgramResourceIndex_ARG_EXPAND);
#endif
#ifndef glGetProgramResourceLocation_RETURN
#define glGetProgramResourceLocation_RETURN GLint
#define glGetProgramResourceLocation_ARG_NAMES program, programInterface, name
#define glGetProgramResourceLocation_ARG_EXPAND GLuint program, GLenum programInterface, const GLchar * name
#define glGetProgramResourceLocation_ARG_NAMES_TAIL , program, programInterface, name
#define glGetProgramResourceLocation_ARG_EXPAND_TAIL , GLuint program, GLenum programInterface, const GLchar * name
#define forward_glGetProgramResourceLocation(_program, _programInterface, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramResourceLocation_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetProgramResourceLocation(dst, _program, _programInterface, _name), &ret); \
        ret; \
    });
#define call_glGetProgramResourceLocation(packed, ret_v) do { \
    glGetProgramResourceLocation_PACKED *unpacked = (glGetProgramResourceLocation_PACKED *)packed; \
    glGetProgramResourceLocation_ARGS *args = (glGetProgramResourceLocation_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetProgramResourceLocation(args->program, args->programInterface, args->name);; \
    } else { \
        glGetProgramResourceLocation(args->program, args->programInterface, args->name);; \
    } \
} while(0)
GLint glGetProgramResourceLocation(glGetProgramResourceLocation_ARG_EXPAND);
packed_call_t *pack_glGetProgramResourceLocation(glGetProgramResourceLocation_PACKED *_dst glGetProgramResourceLocation_ARG_EXPAND_TAIL);
typedef GLint (*glGetProgramResourceLocation_PTR)(glGetProgramResourceLocation_ARG_EXPAND);
#endif
#ifndef glGetProgramResourceLocationIndex_RETURN
#define glGetProgramResourceLocationIndex_RETURN GLint
#define glGetProgramResourceLocationIndex_ARG_NAMES program, programInterface, name
#define glGetProgramResourceLocationIndex_ARG_EXPAND GLuint program, GLenum programInterface, const GLchar * name
#define glGetProgramResourceLocationIndex_ARG_NAMES_TAIL , program, programInterface, name
#define glGetProgramResourceLocationIndex_ARG_EXPAND_TAIL , GLuint program, GLenum programInterface, const GLchar * name
#define forward_glGetProgramResourceLocationIndex(_program, _programInterface, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramResourceLocationIndex_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetProgramResourceLocationIndex(dst, _program, _programInterface, _name), &ret); \
        ret; \
    });
#define call_glGetProgramResourceLocationIndex(packed, ret_v) do { \
    glGetProgramResourceLocationIndex_PACKED *unpacked = (glGetProgramResourceLocationIndex_PACKED *)packed; \
    glGetProgramResourceLocationIndex_ARGS *args = (glGetProgramResourceLocationIndex_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetProgramResourceLocationIndex(args->program, args->programInterface, args->name);; \
    } else { \
        glGetProgramResourceLocationIndex(args->program, args->programInterface, args->name);; \
    } \
} while(0)
GLint glGetProgramResourceLocationIndex(glGetProgramResourceLocationIndex_ARG_EXPAND);
packed_call_t *pack_glGetProgramResourceLocationIndex(glGetProgramResourceLocationIndex_PACKED *_dst glGetProgramResourceLocationIndex_ARG_EXPAND_TAIL);
typedef GLint (*glGetProgramResourceLocationIndex_PTR)(glGetProgramResourceLocationIndex_ARG_EXPAND);
#endif
#ifndef glGetProgramResourceName_RETURN
#define glGetProgramResourceName_RETURN void
#define glGetProgramResourceName_ARG_NAMES program, programInterface, index, bufSize, length, name
#define glGetProgramResourceName_ARG_EXPAND GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name
#define glGetProgramResourceName_ARG_NAMES_TAIL , program, programInterface, index, bufSize, length, name
#define glGetProgramResourceName_ARG_EXPAND_TAIL , GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name
#define forward_glGetProgramResourceName(_program, _programInterface, _index, _bufSize, _length, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramResourceName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramResourceName(dst, _program, _programInterface, _index, _bufSize, _length, _name), NULL); \
    });
#define call_glGetProgramResourceName(packed, ret_v) do { \
    glGetProgramResourceName_PACKED *unpacked = (glGetProgramResourceName_PACKED *)packed; \
    glGetProgramResourceName_ARGS *args = (glGetProgramResourceName_ARGS *)&unpacked->args; \
    glGetProgramResourceName(args->program, args->programInterface, args->index, args->bufSize, args->length, args->name);; \
} while(0)
void glGetProgramResourceName(glGetProgramResourceName_ARG_EXPAND);
packed_call_t *pack_glGetProgramResourceName(glGetProgramResourceName_PACKED *_dst glGetProgramResourceName_ARG_EXPAND_TAIL);
typedef void (*glGetProgramResourceName_PTR)(glGetProgramResourceName_ARG_EXPAND);
#endif
#ifndef glGetProgramResourceiv_RETURN
#define glGetProgramResourceiv_RETURN void
#define glGetProgramResourceiv_ARG_NAMES program, programInterface, index, propCount, props, bufSize, length, params
#define glGetProgramResourceiv_ARG_EXPAND GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params
#define glGetProgramResourceiv_ARG_NAMES_TAIL , program, programInterface, index, propCount, props, bufSize, length, params
#define glGetProgramResourceiv_ARG_EXPAND_TAIL , GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params
#define forward_glGetProgramResourceiv(_program, _programInterface, _index, _propCount, _props, _bufSize, _length, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramResourceiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramResourceiv(dst, _program, _programInterface, _index, _propCount, _props, _bufSize, _length, _params), NULL); \
    });
#define call_glGetProgramResourceiv(packed, ret_v) do { \
    glGetProgramResourceiv_PACKED *unpacked = (glGetProgramResourceiv_PACKED *)packed; \
    glGetProgramResourceiv_ARGS *args = (glGetProgramResourceiv_ARGS *)&unpacked->args; \
    glGetProgramResourceiv(args->program, args->programInterface, args->index, args->propCount, args->props, args->bufSize, args->length, args->params);; \
} while(0)
void glGetProgramResourceiv(glGetProgramResourceiv_ARG_EXPAND);
packed_call_t *pack_glGetProgramResourceiv(glGetProgramResourceiv_PACKED *_dst glGetProgramResourceiv_ARG_EXPAND_TAIL);
typedef void (*glGetProgramResourceiv_PTR)(glGetProgramResourceiv_ARG_EXPAND);
#endif
#ifndef glGetProgramStageiv_RETURN
#define glGetProgramStageiv_RETURN void
#define glGetProgramStageiv_ARG_NAMES program, shadertype, pname, values
#define glGetProgramStageiv_ARG_EXPAND GLuint program, GLenum shadertype, GLenum pname, GLint * values
#define glGetProgramStageiv_ARG_NAMES_TAIL , program, shadertype, pname, values
#define glGetProgramStageiv_ARG_EXPAND_TAIL , GLuint program, GLenum shadertype, GLenum pname, GLint * values
#define forward_glGetProgramStageiv(_program, _shadertype, _pname, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramStageiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramStageiv(dst, _program, _shadertype, _pname, _values), NULL); \
    });
#define call_glGetProgramStageiv(packed, ret_v) do { \
    glGetProgramStageiv_PACKED *unpacked = (glGetProgramStageiv_PACKED *)packed; \
    glGetProgramStageiv_ARGS *args = (glGetProgramStageiv_ARGS *)&unpacked->args; \
    glGetProgramStageiv(args->program, args->shadertype, args->pname, args->values);; \
} while(0)
void glGetProgramStageiv(glGetProgramStageiv_ARG_EXPAND);
packed_call_t *pack_glGetProgramStageiv(glGetProgramStageiv_PACKED *_dst glGetProgramStageiv_ARG_EXPAND_TAIL);
typedef void (*glGetProgramStageiv_PTR)(glGetProgramStageiv_ARG_EXPAND);
#endif
#ifndef glGetProgramStringARB_RETURN
#define glGetProgramStringARB_RETURN void
#define glGetProgramStringARB_ARG_NAMES target, pname, string
#define glGetProgramStringARB_ARG_EXPAND GLenum target, GLenum pname, GLvoid * string
#define glGetProgramStringARB_ARG_NAMES_TAIL , target, pname, string
#define glGetProgramStringARB_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLvoid * string
#define forward_glGetProgramStringARB(_target, _pname, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramStringARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramStringARB(dst, _target, _pname, _string), NULL); \
    });
#define call_glGetProgramStringARB(packed, ret_v) do { \
    glGetProgramStringARB_PACKED *unpacked = (glGetProgramStringARB_PACKED *)packed; \
    glGetProgramStringARB_ARGS *args = (glGetProgramStringARB_ARGS *)&unpacked->args; \
    glGetProgramStringARB(args->target, args->pname, args->string);; \
} while(0)
void glGetProgramStringARB(glGetProgramStringARB_ARG_EXPAND);
packed_call_t *pack_glGetProgramStringARB(glGetProgramStringARB_PACKED *_dst glGetProgramStringARB_ARG_EXPAND_TAIL);
typedef void (*glGetProgramStringARB_PTR)(glGetProgramStringARB_ARG_EXPAND);
#endif
#ifndef glGetProgramStringNV_RETURN
#define glGetProgramStringNV_RETURN void
#define glGetProgramStringNV_ARG_NAMES id, pname, program
#define glGetProgramStringNV_ARG_EXPAND GLuint id, GLenum pname, GLubyte * program
#define glGetProgramStringNV_ARG_NAMES_TAIL , id, pname, program
#define glGetProgramStringNV_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLubyte * program
#define forward_glGetProgramStringNV(_id, _pname, _program) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramStringNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramStringNV(dst, _id, _pname, _program), NULL); \
    });
#define call_glGetProgramStringNV(packed, ret_v) do { \
    glGetProgramStringNV_PACKED *unpacked = (glGetProgramStringNV_PACKED *)packed; \
    glGetProgramStringNV_ARGS *args = (glGetProgramStringNV_ARGS *)&unpacked->args; \
    glGetProgramStringNV(args->id, args->pname, args->program);; \
} while(0)
void glGetProgramStringNV(glGetProgramStringNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramStringNV(glGetProgramStringNV_PACKED *_dst glGetProgramStringNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramStringNV_PTR)(glGetProgramStringNV_ARG_EXPAND);
#endif
#ifndef glGetProgramSubroutineParameteruivNV_RETURN
#define glGetProgramSubroutineParameteruivNV_RETURN void
#define glGetProgramSubroutineParameteruivNV_ARG_NAMES target, index, param
#define glGetProgramSubroutineParameteruivNV_ARG_EXPAND GLenum target, GLuint index, GLuint * param
#define glGetProgramSubroutineParameteruivNV_ARG_NAMES_TAIL , target, index, param
#define glGetProgramSubroutineParameteruivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint * param
#define forward_glGetProgramSubroutineParameteruivNV(_target, _index, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramSubroutineParameteruivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramSubroutineParameteruivNV(dst, _target, _index, _param), NULL); \
    });
#define call_glGetProgramSubroutineParameteruivNV(packed, ret_v) do { \
    glGetProgramSubroutineParameteruivNV_PACKED *unpacked = (glGetProgramSubroutineParameteruivNV_PACKED *)packed; \
    glGetProgramSubroutineParameteruivNV_ARGS *args = (glGetProgramSubroutineParameteruivNV_ARGS *)&unpacked->args; \
    glGetProgramSubroutineParameteruivNV(args->target, args->index, args->param);; \
} while(0)
void glGetProgramSubroutineParameteruivNV(glGetProgramSubroutineParameteruivNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramSubroutineParameteruivNV(glGetProgramSubroutineParameteruivNV_PACKED *_dst glGetProgramSubroutineParameteruivNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramSubroutineParameteruivNV_PTR)(glGetProgramSubroutineParameteruivNV_ARG_EXPAND);
#endif
#ifndef glGetProgramiv_RETURN
#define glGetProgramiv_RETURN void
#define glGetProgramiv_ARG_NAMES program, pname, params
#define glGetProgramiv_ARG_EXPAND GLuint program, GLenum pname, GLint * params
#define glGetProgramiv_ARG_NAMES_TAIL , program, pname, params
#define glGetProgramiv_ARG_EXPAND_TAIL , GLuint program, GLenum pname, GLint * params
#define forward_glGetProgramiv(_program, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramiv(dst, _program, _pname, _params), NULL); \
    });
#define call_glGetProgramiv(packed, ret_v) do { \
    glGetProgramiv_PACKED *unpacked = (glGetProgramiv_PACKED *)packed; \
    glGetProgramiv_ARGS *args = (glGetProgramiv_ARGS *)&unpacked->args; \
    glGetProgramiv(args->program, args->pname, args->params);; \
} while(0)
void glGetProgramiv(glGetProgramiv_ARG_EXPAND);
packed_call_t *pack_glGetProgramiv(glGetProgramiv_PACKED *_dst glGetProgramiv_ARG_EXPAND_TAIL);
typedef void (*glGetProgramiv_PTR)(glGetProgramiv_ARG_EXPAND);
#endif
#ifndef glGetProgramivARB_RETURN
#define glGetProgramivARB_RETURN void
#define glGetProgramivARB_ARG_NAMES target, pname, params
#define glGetProgramivARB_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetProgramivARB_ARG_NAMES_TAIL , target, pname, params
#define glGetProgramivARB_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetProgramivARB(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramivARB(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetProgramivARB(packed, ret_v) do { \
    glGetProgramivARB_PACKED *unpacked = (glGetProgramivARB_PACKED *)packed; \
    glGetProgramivARB_ARGS *args = (glGetProgramivARB_ARGS *)&unpacked->args; \
    glGetProgramivARB(args->target, args->pname, args->params);; \
} while(0)
void glGetProgramivARB(glGetProgramivARB_ARG_EXPAND);
packed_call_t *pack_glGetProgramivARB(glGetProgramivARB_PACKED *_dst glGetProgramivARB_ARG_EXPAND_TAIL);
typedef void (*glGetProgramivARB_PTR)(glGetProgramivARB_ARG_EXPAND);
#endif
#ifndef glGetProgramivNV_RETURN
#define glGetProgramivNV_RETURN void
#define glGetProgramivNV_ARG_NAMES id, pname, params
#define glGetProgramivNV_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetProgramivNV_ARG_NAMES_TAIL , id, pname, params
#define glGetProgramivNV_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLint * params
#define forward_glGetProgramivNV(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetProgramivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetProgramivNV(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetProgramivNV(packed, ret_v) do { \
    glGetProgramivNV_PACKED *unpacked = (glGetProgramivNV_PACKED *)packed; \
    glGetProgramivNV_ARGS *args = (glGetProgramivNV_ARGS *)&unpacked->args; \
    glGetProgramivNV(args->id, args->pname, args->params);; \
} while(0)
void glGetProgramivNV(glGetProgramivNV_ARG_EXPAND);
packed_call_t *pack_glGetProgramivNV(glGetProgramivNV_PACKED *_dst glGetProgramivNV_ARG_EXPAND_TAIL);
typedef void (*glGetProgramivNV_PTR)(glGetProgramivNV_ARG_EXPAND);
#endif
#ifndef glGetQueryIndexediv_RETURN
#define glGetQueryIndexediv_RETURN void
#define glGetQueryIndexediv_ARG_NAMES target, index, pname, params
#define glGetQueryIndexediv_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLint * params
#define glGetQueryIndexediv_ARG_NAMES_TAIL , target, index, pname, params
#define glGetQueryIndexediv_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLenum pname, GLint * params
#define forward_glGetQueryIndexediv(_target, _index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryIndexediv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryIndexediv(dst, _target, _index, _pname, _params), NULL); \
    });
#define call_glGetQueryIndexediv(packed, ret_v) do { \
    glGetQueryIndexediv_PACKED *unpacked = (glGetQueryIndexediv_PACKED *)packed; \
    glGetQueryIndexediv_ARGS *args = (glGetQueryIndexediv_ARGS *)&unpacked->args; \
    glGetQueryIndexediv(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetQueryIndexediv(glGetQueryIndexediv_ARG_EXPAND);
packed_call_t *pack_glGetQueryIndexediv(glGetQueryIndexediv_PACKED *_dst glGetQueryIndexediv_ARG_EXPAND_TAIL);
typedef void (*glGetQueryIndexediv_PTR)(glGetQueryIndexediv_ARG_EXPAND);
#endif
#ifndef glGetQueryObjecti64v_RETURN
#define glGetQueryObjecti64v_RETURN void
#define glGetQueryObjecti64v_ARG_NAMES id, pname, params
#define glGetQueryObjecti64v_ARG_EXPAND GLuint id, GLenum pname, GLint64 * params
#define glGetQueryObjecti64v_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjecti64v_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLint64 * params
#define forward_glGetQueryObjecti64v(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjecti64v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjecti64v(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjecti64v(packed, ret_v) do { \
    glGetQueryObjecti64v_PACKED *unpacked = (glGetQueryObjecti64v_PACKED *)packed; \
    glGetQueryObjecti64v_ARGS *args = (glGetQueryObjecti64v_ARGS *)&unpacked->args; \
    glGetQueryObjecti64v(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjecti64v(glGetQueryObjecti64v_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjecti64v(glGetQueryObjecti64v_PACKED *_dst glGetQueryObjecti64v_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjecti64v_PTR)(glGetQueryObjecti64v_ARG_EXPAND);
#endif
#ifndef glGetQueryObjecti64vEXT_RETURN
#define glGetQueryObjecti64vEXT_RETURN void
#define glGetQueryObjecti64vEXT_ARG_NAMES id, pname, params
#define glGetQueryObjecti64vEXT_ARG_EXPAND GLuint id, GLenum pname, GLint64EXT * params
#define glGetQueryObjecti64vEXT_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjecti64vEXT_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLint64EXT * params
#define forward_glGetQueryObjecti64vEXT(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjecti64vEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjecti64vEXT(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjecti64vEXT(packed, ret_v) do { \
    glGetQueryObjecti64vEXT_PACKED *unpacked = (glGetQueryObjecti64vEXT_PACKED *)packed; \
    glGetQueryObjecti64vEXT_ARGS *args = (glGetQueryObjecti64vEXT_ARGS *)&unpacked->args; \
    glGetQueryObjecti64vEXT(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjecti64vEXT(glGetQueryObjecti64vEXT_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjecti64vEXT(glGetQueryObjecti64vEXT_PACKED *_dst glGetQueryObjecti64vEXT_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjecti64vEXT_PTR)(glGetQueryObjecti64vEXT_ARG_EXPAND);
#endif
#ifndef glGetQueryObjectiv_RETURN
#define glGetQueryObjectiv_RETURN void
#define glGetQueryObjectiv_ARG_NAMES id, pname, params
#define glGetQueryObjectiv_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetQueryObjectiv_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjectiv_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLint * params
#define forward_glGetQueryObjectiv(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjectiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjectiv(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjectiv(packed, ret_v) do { \
    glGetQueryObjectiv_PACKED *unpacked = (glGetQueryObjectiv_PACKED *)packed; \
    glGetQueryObjectiv_ARGS *args = (glGetQueryObjectiv_ARGS *)&unpacked->args; \
    glGetQueryObjectiv(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectiv(glGetQueryObjectiv_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjectiv(glGetQueryObjectiv_PACKED *_dst glGetQueryObjectiv_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjectiv_PTR)(glGetQueryObjectiv_ARG_EXPAND);
#endif
#ifndef glGetQueryObjectivARB_RETURN
#define glGetQueryObjectivARB_RETURN void
#define glGetQueryObjectivARB_ARG_NAMES id, pname, params
#define glGetQueryObjectivARB_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetQueryObjectivARB_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjectivARB_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLint * params
#define forward_glGetQueryObjectivARB(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjectivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjectivARB(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjectivARB(packed, ret_v) do { \
    glGetQueryObjectivARB_PACKED *unpacked = (glGetQueryObjectivARB_PACKED *)packed; \
    glGetQueryObjectivARB_ARGS *args = (glGetQueryObjectivARB_ARGS *)&unpacked->args; \
    glGetQueryObjectivARB(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectivARB(glGetQueryObjectivARB_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjectivARB(glGetQueryObjectivARB_PACKED *_dst glGetQueryObjectivARB_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjectivARB_PTR)(glGetQueryObjectivARB_ARG_EXPAND);
#endif
#ifndef glGetQueryObjectui64v_RETURN
#define glGetQueryObjectui64v_RETURN void
#define glGetQueryObjectui64v_ARG_NAMES id, pname, params
#define glGetQueryObjectui64v_ARG_EXPAND GLuint id, GLenum pname, GLuint64 * params
#define glGetQueryObjectui64v_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjectui64v_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLuint64 * params
#define forward_glGetQueryObjectui64v(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjectui64v_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjectui64v(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjectui64v(packed, ret_v) do { \
    glGetQueryObjectui64v_PACKED *unpacked = (glGetQueryObjectui64v_PACKED *)packed; \
    glGetQueryObjectui64v_ARGS *args = (glGetQueryObjectui64v_ARGS *)&unpacked->args; \
    glGetQueryObjectui64v(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectui64v(glGetQueryObjectui64v_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjectui64v(glGetQueryObjectui64v_PACKED *_dst glGetQueryObjectui64v_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjectui64v_PTR)(glGetQueryObjectui64v_ARG_EXPAND);
#endif
#ifndef glGetQueryObjectui64vEXT_RETURN
#define glGetQueryObjectui64vEXT_RETURN void
#define glGetQueryObjectui64vEXT_ARG_NAMES id, pname, params
#define glGetQueryObjectui64vEXT_ARG_EXPAND GLuint id, GLenum pname, GLuint64EXT * params
#define glGetQueryObjectui64vEXT_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjectui64vEXT_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLuint64EXT * params
#define forward_glGetQueryObjectui64vEXT(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjectui64vEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjectui64vEXT(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjectui64vEXT(packed, ret_v) do { \
    glGetQueryObjectui64vEXT_PACKED *unpacked = (glGetQueryObjectui64vEXT_PACKED *)packed; \
    glGetQueryObjectui64vEXT_ARGS *args = (glGetQueryObjectui64vEXT_ARGS *)&unpacked->args; \
    glGetQueryObjectui64vEXT(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectui64vEXT(glGetQueryObjectui64vEXT_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjectui64vEXT(glGetQueryObjectui64vEXT_PACKED *_dst glGetQueryObjectui64vEXT_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjectui64vEXT_PTR)(glGetQueryObjectui64vEXT_ARG_EXPAND);
#endif
#ifndef glGetQueryObjectuiv_RETURN
#define glGetQueryObjectuiv_RETURN void
#define glGetQueryObjectuiv_ARG_NAMES id, pname, params
#define glGetQueryObjectuiv_ARG_EXPAND GLuint id, GLenum pname, GLuint * params
#define glGetQueryObjectuiv_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjectuiv_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLuint * params
#define forward_glGetQueryObjectuiv(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjectuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjectuiv(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjectuiv(packed, ret_v) do { \
    glGetQueryObjectuiv_PACKED *unpacked = (glGetQueryObjectuiv_PACKED *)packed; \
    glGetQueryObjectuiv_ARGS *args = (glGetQueryObjectuiv_ARGS *)&unpacked->args; \
    glGetQueryObjectuiv(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectuiv(glGetQueryObjectuiv_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjectuiv(glGetQueryObjectuiv_PACKED *_dst glGetQueryObjectuiv_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjectuiv_PTR)(glGetQueryObjectuiv_ARG_EXPAND);
#endif
#ifndef glGetQueryObjectuivARB_RETURN
#define glGetQueryObjectuivARB_RETURN void
#define glGetQueryObjectuivARB_ARG_NAMES id, pname, params
#define glGetQueryObjectuivARB_ARG_EXPAND GLuint id, GLenum pname, GLuint * params
#define glGetQueryObjectuivARB_ARG_NAMES_TAIL , id, pname, params
#define glGetQueryObjectuivARB_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLuint * params
#define forward_glGetQueryObjectuivARB(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryObjectuivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryObjectuivARB(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetQueryObjectuivARB(packed, ret_v) do { \
    glGetQueryObjectuivARB_PACKED *unpacked = (glGetQueryObjectuivARB_PACKED *)packed; \
    glGetQueryObjectuivARB_ARGS *args = (glGetQueryObjectuivARB_ARGS *)&unpacked->args; \
    glGetQueryObjectuivARB(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectuivARB(glGetQueryObjectuivARB_ARG_EXPAND);
packed_call_t *pack_glGetQueryObjectuivARB(glGetQueryObjectuivARB_PACKED *_dst glGetQueryObjectuivARB_ARG_EXPAND_TAIL);
typedef void (*glGetQueryObjectuivARB_PTR)(glGetQueryObjectuivARB_ARG_EXPAND);
#endif
#ifndef glGetQueryiv_RETURN
#define glGetQueryiv_RETURN void
#define glGetQueryiv_ARG_NAMES target, pname, params
#define glGetQueryiv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetQueryiv_ARG_NAMES_TAIL , target, pname, params
#define glGetQueryiv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetQueryiv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryiv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetQueryiv(packed, ret_v) do { \
    glGetQueryiv_PACKED *unpacked = (glGetQueryiv_PACKED *)packed; \
    glGetQueryiv_ARGS *args = (glGetQueryiv_ARGS *)&unpacked->args; \
    glGetQueryiv(args->target, args->pname, args->params);; \
} while(0)
void glGetQueryiv(glGetQueryiv_ARG_EXPAND);
packed_call_t *pack_glGetQueryiv(glGetQueryiv_PACKED *_dst glGetQueryiv_ARG_EXPAND_TAIL);
typedef void (*glGetQueryiv_PTR)(glGetQueryiv_ARG_EXPAND);
#endif
#ifndef glGetQueryivARB_RETURN
#define glGetQueryivARB_RETURN void
#define glGetQueryivARB_ARG_NAMES target, pname, params
#define glGetQueryivARB_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetQueryivARB_ARG_NAMES_TAIL , target, pname, params
#define glGetQueryivARB_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetQueryivARB(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetQueryivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetQueryivARB(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetQueryivARB(packed, ret_v) do { \
    glGetQueryivARB_PACKED *unpacked = (glGetQueryivARB_PACKED *)packed; \
    glGetQueryivARB_ARGS *args = (glGetQueryivARB_ARGS *)&unpacked->args; \
    glGetQueryivARB(args->target, args->pname, args->params);; \
} while(0)
void glGetQueryivARB(glGetQueryivARB_ARG_EXPAND);
packed_call_t *pack_glGetQueryivARB(glGetQueryivARB_PACKED *_dst glGetQueryivARB_ARG_EXPAND_TAIL);
typedef void (*glGetQueryivARB_PTR)(glGetQueryivARB_ARG_EXPAND);
#endif
#ifndef glGetRenderbufferParameteriv_RETURN
#define glGetRenderbufferParameteriv_RETURN void
#define glGetRenderbufferParameteriv_ARG_NAMES target, pname, params
#define glGetRenderbufferParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetRenderbufferParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetRenderbufferParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetRenderbufferParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetRenderbufferParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetRenderbufferParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetRenderbufferParameteriv(packed, ret_v) do { \
    glGetRenderbufferParameteriv_PACKED *unpacked = (glGetRenderbufferParameteriv_PACKED *)packed; \
    glGetRenderbufferParameteriv_ARGS *args = (glGetRenderbufferParameteriv_ARGS *)&unpacked->args; \
    glGetRenderbufferParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetRenderbufferParameteriv(glGetRenderbufferParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetRenderbufferParameteriv(glGetRenderbufferParameteriv_PACKED *_dst glGetRenderbufferParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetRenderbufferParameteriv_PTR)(glGetRenderbufferParameteriv_ARG_EXPAND);
#endif
#ifndef glGetRenderbufferParameterivEXT_RETURN
#define glGetRenderbufferParameterivEXT_RETURN void
#define glGetRenderbufferParameterivEXT_ARG_NAMES target, pname, params
#define glGetRenderbufferParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetRenderbufferParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetRenderbufferParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetRenderbufferParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetRenderbufferParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetRenderbufferParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetRenderbufferParameterivEXT(packed, ret_v) do { \
    glGetRenderbufferParameterivEXT_PACKED *unpacked = (glGetRenderbufferParameterivEXT_PACKED *)packed; \
    glGetRenderbufferParameterivEXT_ARGS *args = (glGetRenderbufferParameterivEXT_ARGS *)&unpacked->args; \
    glGetRenderbufferParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetRenderbufferParameterivEXT(glGetRenderbufferParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetRenderbufferParameterivEXT(glGetRenderbufferParameterivEXT_PACKED *_dst glGetRenderbufferParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetRenderbufferParameterivEXT_PTR)(glGetRenderbufferParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetSamplerParameterIiv_RETURN
#define glGetSamplerParameterIiv_RETURN void
#define glGetSamplerParameterIiv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameterIiv_ARG_EXPAND GLuint sampler, GLenum pname, GLint * params
#define glGetSamplerParameterIiv_ARG_NAMES_TAIL , sampler, pname, params
#define glGetSamplerParameterIiv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, GLint * params
#define forward_glGetSamplerParameterIiv(_sampler, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSamplerParameterIiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSamplerParameterIiv(dst, _sampler, _pname, _params), NULL); \
    });
#define call_glGetSamplerParameterIiv(packed, ret_v) do { \
    glGetSamplerParameterIiv_PACKED *unpacked = (glGetSamplerParameterIiv_PACKED *)packed; \
    glGetSamplerParameterIiv_ARGS *args = (glGetSamplerParameterIiv_ARGS *)&unpacked->args; \
    glGetSamplerParameterIiv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameterIiv(glGetSamplerParameterIiv_ARG_EXPAND);
packed_call_t *pack_glGetSamplerParameterIiv(glGetSamplerParameterIiv_PACKED *_dst glGetSamplerParameterIiv_ARG_EXPAND_TAIL);
typedef void (*glGetSamplerParameterIiv_PTR)(glGetSamplerParameterIiv_ARG_EXPAND);
#endif
#ifndef glGetSamplerParameterIuiv_RETURN
#define glGetSamplerParameterIuiv_RETURN void
#define glGetSamplerParameterIuiv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameterIuiv_ARG_EXPAND GLuint sampler, GLenum pname, GLuint * params
#define glGetSamplerParameterIuiv_ARG_NAMES_TAIL , sampler, pname, params
#define glGetSamplerParameterIuiv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, GLuint * params
#define forward_glGetSamplerParameterIuiv(_sampler, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSamplerParameterIuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSamplerParameterIuiv(dst, _sampler, _pname, _params), NULL); \
    });
#define call_glGetSamplerParameterIuiv(packed, ret_v) do { \
    glGetSamplerParameterIuiv_PACKED *unpacked = (glGetSamplerParameterIuiv_PACKED *)packed; \
    glGetSamplerParameterIuiv_ARGS *args = (glGetSamplerParameterIuiv_ARGS *)&unpacked->args; \
    glGetSamplerParameterIuiv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameterIuiv(glGetSamplerParameterIuiv_ARG_EXPAND);
packed_call_t *pack_glGetSamplerParameterIuiv(glGetSamplerParameterIuiv_PACKED *_dst glGetSamplerParameterIuiv_ARG_EXPAND_TAIL);
typedef void (*glGetSamplerParameterIuiv_PTR)(glGetSamplerParameterIuiv_ARG_EXPAND);
#endif
#ifndef glGetSamplerParameterfv_RETURN
#define glGetSamplerParameterfv_RETURN void
#define glGetSamplerParameterfv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameterfv_ARG_EXPAND GLuint sampler, GLenum pname, GLfloat * params
#define glGetSamplerParameterfv_ARG_NAMES_TAIL , sampler, pname, params
#define glGetSamplerParameterfv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, GLfloat * params
#define forward_glGetSamplerParameterfv(_sampler, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSamplerParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSamplerParameterfv(dst, _sampler, _pname, _params), NULL); \
    });
#define call_glGetSamplerParameterfv(packed, ret_v) do { \
    glGetSamplerParameterfv_PACKED *unpacked = (glGetSamplerParameterfv_PACKED *)packed; \
    glGetSamplerParameterfv_ARGS *args = (glGetSamplerParameterfv_ARGS *)&unpacked->args; \
    glGetSamplerParameterfv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameterfv(glGetSamplerParameterfv_ARG_EXPAND);
packed_call_t *pack_glGetSamplerParameterfv(glGetSamplerParameterfv_PACKED *_dst glGetSamplerParameterfv_ARG_EXPAND_TAIL);
typedef void (*glGetSamplerParameterfv_PTR)(glGetSamplerParameterfv_ARG_EXPAND);
#endif
#ifndef glGetSamplerParameteriv_RETURN
#define glGetSamplerParameteriv_RETURN void
#define glGetSamplerParameteriv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameteriv_ARG_EXPAND GLuint sampler, GLenum pname, GLint * params
#define glGetSamplerParameteriv_ARG_NAMES_TAIL , sampler, pname, params
#define glGetSamplerParameteriv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, GLint * params
#define forward_glGetSamplerParameteriv(_sampler, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSamplerParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSamplerParameteriv(dst, _sampler, _pname, _params), NULL); \
    });
#define call_glGetSamplerParameteriv(packed, ret_v) do { \
    glGetSamplerParameteriv_PACKED *unpacked = (glGetSamplerParameteriv_PACKED *)packed; \
    glGetSamplerParameteriv_ARGS *args = (glGetSamplerParameteriv_ARGS *)&unpacked->args; \
    glGetSamplerParameteriv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameteriv(glGetSamplerParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetSamplerParameteriv(glGetSamplerParameteriv_PACKED *_dst glGetSamplerParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetSamplerParameteriv_PTR)(glGetSamplerParameteriv_ARG_EXPAND);
#endif
#ifndef glGetSeparableFilter_RETURN
#define glGetSeparableFilter_RETURN void
#define glGetSeparableFilter_ARG_NAMES target, format, type, row, column, span
#define glGetSeparableFilter_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span
#define glGetSeparableFilter_ARG_NAMES_TAIL , target, format, type, row, column, span
#define glGetSeparableFilter_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span
#define forward_glGetSeparableFilter(_target, _format, _type, _row, _column, _span) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSeparableFilter_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSeparableFilter(dst, _target, _format, _type, _row, _column, _span), NULL); \
    });
#define call_glGetSeparableFilter(packed, ret_v) do { \
    glGetSeparableFilter_PACKED *unpacked = (glGetSeparableFilter_PACKED *)packed; \
    glGetSeparableFilter_ARGS *args = (glGetSeparableFilter_ARGS *)&unpacked->args; \
    glGetSeparableFilter(args->target, args->format, args->type, args->row, args->column, args->span);; \
} while(0)
void glGetSeparableFilter(glGetSeparableFilter_ARG_EXPAND);
packed_call_t *pack_glGetSeparableFilter(glGetSeparableFilter_PACKED *_dst glGetSeparableFilter_ARG_EXPAND_TAIL);
typedef void (*glGetSeparableFilter_PTR)(glGetSeparableFilter_ARG_EXPAND);
#endif
#ifndef glGetSeparableFilterEXT_RETURN
#define glGetSeparableFilterEXT_RETURN void
#define glGetSeparableFilterEXT_ARG_NAMES target, format, type, row, column, span
#define glGetSeparableFilterEXT_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span
#define glGetSeparableFilterEXT_ARG_NAMES_TAIL , target, format, type, row, column, span
#define glGetSeparableFilterEXT_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span
#define forward_glGetSeparableFilterEXT(_target, _format, _type, _row, _column, _span) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSeparableFilterEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSeparableFilterEXT(dst, _target, _format, _type, _row, _column, _span), NULL); \
    });
#define call_glGetSeparableFilterEXT(packed, ret_v) do { \
    glGetSeparableFilterEXT_PACKED *unpacked = (glGetSeparableFilterEXT_PACKED *)packed; \
    glGetSeparableFilterEXT_ARGS *args = (glGetSeparableFilterEXT_ARGS *)&unpacked->args; \
    glGetSeparableFilterEXT(args->target, args->format, args->type, args->row, args->column, args->span);; \
} while(0)
void glGetSeparableFilterEXT(glGetSeparableFilterEXT_ARG_EXPAND);
packed_call_t *pack_glGetSeparableFilterEXT(glGetSeparableFilterEXT_PACKED *_dst glGetSeparableFilterEXT_ARG_EXPAND_TAIL);
typedef void (*glGetSeparableFilterEXT_PTR)(glGetSeparableFilterEXT_ARG_EXPAND);
#endif
#ifndef glGetShaderInfoLog_RETURN
#define glGetShaderInfoLog_RETURN void
#define glGetShaderInfoLog_ARG_NAMES shader, bufSize, length, infoLog
#define glGetShaderInfoLog_ARG_EXPAND GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define glGetShaderInfoLog_ARG_NAMES_TAIL , shader, bufSize, length, infoLog
#define glGetShaderInfoLog_ARG_EXPAND_TAIL , GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define forward_glGetShaderInfoLog(_shader, _bufSize, _length, _infoLog) \
    ({ \
        void *dst = remote_dma(sizeof(glGetShaderInfoLog_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetShaderInfoLog(dst, _shader, _bufSize, _length, _infoLog), NULL); \
    });
#define call_glGetShaderInfoLog(packed, ret_v) do { \
    glGetShaderInfoLog_PACKED *unpacked = (glGetShaderInfoLog_PACKED *)packed; \
    glGetShaderInfoLog_ARGS *args = (glGetShaderInfoLog_ARGS *)&unpacked->args; \
    glGetShaderInfoLog(args->shader, args->bufSize, args->length, args->infoLog);; \
} while(0)
void glGetShaderInfoLog(glGetShaderInfoLog_ARG_EXPAND);
packed_call_t *pack_glGetShaderInfoLog(glGetShaderInfoLog_PACKED *_dst glGetShaderInfoLog_ARG_EXPAND_TAIL);
typedef void (*glGetShaderInfoLog_PTR)(glGetShaderInfoLog_ARG_EXPAND);
#endif
#ifndef glGetShaderPrecisionFormat_RETURN
#define glGetShaderPrecisionFormat_RETURN void
#define glGetShaderPrecisionFormat_ARG_NAMES shadertype, precisiontype, range, precision
#define glGetShaderPrecisionFormat_ARG_EXPAND GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision
#define glGetShaderPrecisionFormat_ARG_NAMES_TAIL , shadertype, precisiontype, range, precision
#define glGetShaderPrecisionFormat_ARG_EXPAND_TAIL , GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision
#define forward_glGetShaderPrecisionFormat(_shadertype, _precisiontype, _range, _precision) \
    ({ \
        void *dst = remote_dma(sizeof(glGetShaderPrecisionFormat_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetShaderPrecisionFormat(dst, _shadertype, _precisiontype, _range, _precision), NULL); \
    });
#define call_glGetShaderPrecisionFormat(packed, ret_v) do { \
    glGetShaderPrecisionFormat_PACKED *unpacked = (glGetShaderPrecisionFormat_PACKED *)packed; \
    glGetShaderPrecisionFormat_ARGS *args = (glGetShaderPrecisionFormat_ARGS *)&unpacked->args; \
    glGetShaderPrecisionFormat(args->shadertype, args->precisiontype, args->range, args->precision);; \
} while(0)
void glGetShaderPrecisionFormat(glGetShaderPrecisionFormat_ARG_EXPAND);
packed_call_t *pack_glGetShaderPrecisionFormat(glGetShaderPrecisionFormat_PACKED *_dst glGetShaderPrecisionFormat_ARG_EXPAND_TAIL);
typedef void (*glGetShaderPrecisionFormat_PTR)(glGetShaderPrecisionFormat_ARG_EXPAND);
#endif
#ifndef glGetShaderSource_RETURN
#define glGetShaderSource_RETURN void
#define glGetShaderSource_ARG_NAMES shader, bufSize, length, source
#define glGetShaderSource_ARG_EXPAND GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source
#define glGetShaderSource_ARG_NAMES_TAIL , shader, bufSize, length, source
#define glGetShaderSource_ARG_EXPAND_TAIL , GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source
#define forward_glGetShaderSource(_shader, _bufSize, _length, _source) \
    ({ \
        void *dst = remote_dma(sizeof(glGetShaderSource_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetShaderSource(dst, _shader, _bufSize, _length, _source), NULL); \
    });
#define call_glGetShaderSource(packed, ret_v) do { \
    glGetShaderSource_PACKED *unpacked = (glGetShaderSource_PACKED *)packed; \
    glGetShaderSource_ARGS *args = (glGetShaderSource_ARGS *)&unpacked->args; \
    glGetShaderSource(args->shader, args->bufSize, args->length, args->source);; \
} while(0)
void glGetShaderSource(glGetShaderSource_ARG_EXPAND);
packed_call_t *pack_glGetShaderSource(glGetShaderSource_PACKED *_dst glGetShaderSource_ARG_EXPAND_TAIL);
typedef void (*glGetShaderSource_PTR)(glGetShaderSource_ARG_EXPAND);
#endif
#ifndef glGetShaderSourceARB_RETURN
#define glGetShaderSourceARB_RETURN void
#define glGetShaderSourceARB_ARG_NAMES obj, maxLength, length, source
#define glGetShaderSourceARB_ARG_EXPAND GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source
#define glGetShaderSourceARB_ARG_NAMES_TAIL , obj, maxLength, length, source
#define glGetShaderSourceARB_ARG_EXPAND_TAIL , GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source
#define forward_glGetShaderSourceARB(_obj, _maxLength, _length, _source) \
    ({ \
        void *dst = remote_dma(sizeof(glGetShaderSourceARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetShaderSourceARB(dst, _obj, _maxLength, _length, _source), NULL); \
    });
#define call_glGetShaderSourceARB(packed, ret_v) do { \
    glGetShaderSourceARB_PACKED *unpacked = (glGetShaderSourceARB_PACKED *)packed; \
    glGetShaderSourceARB_ARGS *args = (glGetShaderSourceARB_ARGS *)&unpacked->args; \
    glGetShaderSourceARB(args->obj, args->maxLength, args->length, args->source);; \
} while(0)
void glGetShaderSourceARB(glGetShaderSourceARB_ARG_EXPAND);
packed_call_t *pack_glGetShaderSourceARB(glGetShaderSourceARB_PACKED *_dst glGetShaderSourceARB_ARG_EXPAND_TAIL);
typedef void (*glGetShaderSourceARB_PTR)(glGetShaderSourceARB_ARG_EXPAND);
#endif
#ifndef glGetShaderiv_RETURN
#define glGetShaderiv_RETURN void
#define glGetShaderiv_ARG_NAMES shader, pname, params
#define glGetShaderiv_ARG_EXPAND GLuint shader, GLenum pname, GLint * params
#define glGetShaderiv_ARG_NAMES_TAIL , shader, pname, params
#define glGetShaderiv_ARG_EXPAND_TAIL , GLuint shader, GLenum pname, GLint * params
#define forward_glGetShaderiv(_shader, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetShaderiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetShaderiv(dst, _shader, _pname, _params), NULL); \
    });
#define call_glGetShaderiv(packed, ret_v) do { \
    glGetShaderiv_PACKED *unpacked = (glGetShaderiv_PACKED *)packed; \
    glGetShaderiv_ARGS *args = (glGetShaderiv_ARGS *)&unpacked->args; \
    glGetShaderiv(args->shader, args->pname, args->params);; \
} while(0)
void glGetShaderiv(glGetShaderiv_ARG_EXPAND);
packed_call_t *pack_glGetShaderiv(glGetShaderiv_PACKED *_dst glGetShaderiv_ARG_EXPAND_TAIL);
typedef void (*glGetShaderiv_PTR)(glGetShaderiv_ARG_EXPAND);
#endif
#ifndef glGetSharpenTexFuncSGIS_RETURN
#define glGetSharpenTexFuncSGIS_RETURN void
#define glGetSharpenTexFuncSGIS_ARG_NAMES target, points
#define glGetSharpenTexFuncSGIS_ARG_EXPAND GLenum target, GLfloat * points
#define glGetSharpenTexFuncSGIS_ARG_NAMES_TAIL , target, points
#define glGetSharpenTexFuncSGIS_ARG_EXPAND_TAIL , GLenum target, GLfloat * points
#define forward_glGetSharpenTexFuncSGIS(_target, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSharpenTexFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSharpenTexFuncSGIS(dst, _target, _points), NULL); \
    });
#define call_glGetSharpenTexFuncSGIS(packed, ret_v) do { \
    glGetSharpenTexFuncSGIS_PACKED *unpacked = (glGetSharpenTexFuncSGIS_PACKED *)packed; \
    glGetSharpenTexFuncSGIS_ARGS *args = (glGetSharpenTexFuncSGIS_ARGS *)&unpacked->args; \
    glGetSharpenTexFuncSGIS(args->target, args->points);; \
} while(0)
void glGetSharpenTexFuncSGIS(glGetSharpenTexFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glGetSharpenTexFuncSGIS(glGetSharpenTexFuncSGIS_PACKED *_dst glGetSharpenTexFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glGetSharpenTexFuncSGIS_PTR)(glGetSharpenTexFuncSGIS_ARG_EXPAND);
#endif
#ifndef glGetString_RETURN
#define glGetString_RETURN const GLubyte *
#define glGetString_ARG_NAMES name
#define glGetString_ARG_EXPAND GLenum name
#define glGetString_ARG_NAMES_TAIL , name
#define glGetString_ARG_EXPAND_TAIL , GLenum name
#define forward_glGetString(_name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetString_PACKED)); \
        const GLubyte * ret = (const GLubyte *)0; \
        remote_dma_send((packed_call_t *)pack_glGetString(dst, _name), &ret); \
        ret; \
    });
#define call_glGetString(packed, ret_v) do { \
    glGetString_PACKED *unpacked = (glGetString_PACKED *)packed; \
    glGetString_ARGS *args = (glGetString_ARGS *)&unpacked->args; \
    const GLubyte * *ret = (const GLubyte * *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetString(args->name);; \
    } else { \
        glGetString(args->name);; \
    } \
} while(0)
const GLubyte * glGetString(glGetString_ARG_EXPAND);
packed_call_t *pack_glGetString(glGetString_PACKED *_dst glGetString_ARG_EXPAND_TAIL);
typedef const GLubyte * (*glGetString_PTR)(glGetString_ARG_EXPAND);
#endif
#ifndef glGetStringi_RETURN
#define glGetStringi_RETURN const GLubyte *
#define glGetStringi_ARG_NAMES name, index
#define glGetStringi_ARG_EXPAND GLenum name, GLuint index
#define glGetStringi_ARG_NAMES_TAIL , name, index
#define glGetStringi_ARG_EXPAND_TAIL , GLenum name, GLuint index
#define forward_glGetStringi(_name, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glGetStringi_PACKED)); \
        const GLubyte * ret = (const GLubyte *)0; \
        remote_dma_send((packed_call_t *)pack_glGetStringi(dst, _name, _index), &ret); \
        ret; \
    });
#define call_glGetStringi(packed, ret_v) do { \
    glGetStringi_PACKED *unpacked = (glGetStringi_PACKED *)packed; \
    glGetStringi_ARGS *args = (glGetStringi_ARGS *)&unpacked->args; \
    const GLubyte * *ret = (const GLubyte * *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetStringi(args->name, args->index);; \
    } else { \
        glGetStringi(args->name, args->index);; \
    } \
} while(0)
const GLubyte * glGetStringi(glGetStringi_ARG_EXPAND);
packed_call_t *pack_glGetStringi(glGetStringi_PACKED *_dst glGetStringi_ARG_EXPAND_TAIL);
typedef const GLubyte * (*glGetStringi_PTR)(glGetStringi_ARG_EXPAND);
#endif
#ifndef glGetSubroutineIndex_RETURN
#define glGetSubroutineIndex_RETURN GLuint
#define glGetSubroutineIndex_ARG_NAMES program, shadertype, name
#define glGetSubroutineIndex_ARG_EXPAND GLuint program, GLenum shadertype, const GLchar * name
#define glGetSubroutineIndex_ARG_NAMES_TAIL , program, shadertype, name
#define glGetSubroutineIndex_ARG_EXPAND_TAIL , GLuint program, GLenum shadertype, const GLchar * name
#define forward_glGetSubroutineIndex(_program, _shadertype, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSubroutineIndex_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGetSubroutineIndex(dst, _program, _shadertype, _name), &ret); \
        ret; \
    });
#define call_glGetSubroutineIndex(packed, ret_v) do { \
    glGetSubroutineIndex_PACKED *unpacked = (glGetSubroutineIndex_PACKED *)packed; \
    glGetSubroutineIndex_ARGS *args = (glGetSubroutineIndex_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetSubroutineIndex(args->program, args->shadertype, args->name);; \
    } else { \
        glGetSubroutineIndex(args->program, args->shadertype, args->name);; \
    } \
} while(0)
GLuint glGetSubroutineIndex(glGetSubroutineIndex_ARG_EXPAND);
packed_call_t *pack_glGetSubroutineIndex(glGetSubroutineIndex_PACKED *_dst glGetSubroutineIndex_ARG_EXPAND_TAIL);
typedef GLuint (*glGetSubroutineIndex_PTR)(glGetSubroutineIndex_ARG_EXPAND);
#endif
#ifndef glGetSubroutineUniformLocation_RETURN
#define glGetSubroutineUniformLocation_RETURN GLint
#define glGetSubroutineUniformLocation_ARG_NAMES program, shadertype, name
#define glGetSubroutineUniformLocation_ARG_EXPAND GLuint program, GLenum shadertype, const GLchar * name
#define glGetSubroutineUniformLocation_ARG_NAMES_TAIL , program, shadertype, name
#define glGetSubroutineUniformLocation_ARG_EXPAND_TAIL , GLuint program, GLenum shadertype, const GLchar * name
#define forward_glGetSubroutineUniformLocation(_program, _shadertype, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSubroutineUniformLocation_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetSubroutineUniformLocation(dst, _program, _shadertype, _name), &ret); \
        ret; \
    });
#define call_glGetSubroutineUniformLocation(packed, ret_v) do { \
    glGetSubroutineUniformLocation_PACKED *unpacked = (glGetSubroutineUniformLocation_PACKED *)packed; \
    glGetSubroutineUniformLocation_ARGS *args = (glGetSubroutineUniformLocation_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetSubroutineUniformLocation(args->program, args->shadertype, args->name);; \
    } else { \
        glGetSubroutineUniformLocation(args->program, args->shadertype, args->name);; \
    } \
} while(0)
GLint glGetSubroutineUniformLocation(glGetSubroutineUniformLocation_ARG_EXPAND);
packed_call_t *pack_glGetSubroutineUniformLocation(glGetSubroutineUniformLocation_PACKED *_dst glGetSubroutineUniformLocation_ARG_EXPAND_TAIL);
typedef GLint (*glGetSubroutineUniformLocation_PTR)(glGetSubroutineUniformLocation_ARG_EXPAND);
#endif
#ifndef glGetSynciv_RETURN
#define glGetSynciv_RETURN void
#define glGetSynciv_ARG_NAMES sync, pname, bufSize, length, values
#define glGetSynciv_ARG_EXPAND GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values
#define glGetSynciv_ARG_NAMES_TAIL , sync, pname, bufSize, length, values
#define glGetSynciv_ARG_EXPAND_TAIL , GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values
#define forward_glGetSynciv(_sync, _pname, _bufSize, _length, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetSynciv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetSynciv(dst, _sync, _pname, _bufSize, _length, _values), NULL); \
    });
#define call_glGetSynciv(packed, ret_v) do { \
    glGetSynciv_PACKED *unpacked = (glGetSynciv_PACKED *)packed; \
    glGetSynciv_ARGS *args = (glGetSynciv_ARGS *)&unpacked->args; \
    glGetSynciv(args->sync, args->pname, args->bufSize, args->length, args->values);; \
} while(0)
void glGetSynciv(glGetSynciv_ARG_EXPAND);
packed_call_t *pack_glGetSynciv(glGetSynciv_PACKED *_dst glGetSynciv_ARG_EXPAND_TAIL);
typedef void (*glGetSynciv_PTR)(glGetSynciv_ARG_EXPAND);
#endif
#ifndef glGetTexBumpParameterfvATI_RETURN
#define glGetTexBumpParameterfvATI_RETURN void
#define glGetTexBumpParameterfvATI_ARG_NAMES pname, param
#define glGetTexBumpParameterfvATI_ARG_EXPAND GLenum pname, GLfloat * param
#define glGetTexBumpParameterfvATI_ARG_NAMES_TAIL , pname, param
#define glGetTexBumpParameterfvATI_ARG_EXPAND_TAIL , GLenum pname, GLfloat * param
#define forward_glGetTexBumpParameterfvATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexBumpParameterfvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexBumpParameterfvATI(dst, _pname, _param), NULL); \
    });
#define call_glGetTexBumpParameterfvATI(packed, ret_v) do { \
    glGetTexBumpParameterfvATI_PACKED *unpacked = (glGetTexBumpParameterfvATI_PACKED *)packed; \
    glGetTexBumpParameterfvATI_ARGS *args = (glGetTexBumpParameterfvATI_ARGS *)&unpacked->args; \
    glGetTexBumpParameterfvATI(args->pname, args->param);; \
} while(0)
void glGetTexBumpParameterfvATI(glGetTexBumpParameterfvATI_ARG_EXPAND);
packed_call_t *pack_glGetTexBumpParameterfvATI(glGetTexBumpParameterfvATI_PACKED *_dst glGetTexBumpParameterfvATI_ARG_EXPAND_TAIL);
typedef void (*glGetTexBumpParameterfvATI_PTR)(glGetTexBumpParameterfvATI_ARG_EXPAND);
#endif
#ifndef glGetTexBumpParameterivATI_RETURN
#define glGetTexBumpParameterivATI_RETURN void
#define glGetTexBumpParameterivATI_ARG_NAMES pname, param
#define glGetTexBumpParameterivATI_ARG_EXPAND GLenum pname, GLint * param
#define glGetTexBumpParameterivATI_ARG_NAMES_TAIL , pname, param
#define glGetTexBumpParameterivATI_ARG_EXPAND_TAIL , GLenum pname, GLint * param
#define forward_glGetTexBumpParameterivATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexBumpParameterivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexBumpParameterivATI(dst, _pname, _param), NULL); \
    });
#define call_glGetTexBumpParameterivATI(packed, ret_v) do { \
    glGetTexBumpParameterivATI_PACKED *unpacked = (glGetTexBumpParameterivATI_PACKED *)packed; \
    glGetTexBumpParameterivATI_ARGS *args = (glGetTexBumpParameterivATI_ARGS *)&unpacked->args; \
    glGetTexBumpParameterivATI(args->pname, args->param);; \
} while(0)
void glGetTexBumpParameterivATI(glGetTexBumpParameterivATI_ARG_EXPAND);
packed_call_t *pack_glGetTexBumpParameterivATI(glGetTexBumpParameterivATI_PACKED *_dst glGetTexBumpParameterivATI_ARG_EXPAND_TAIL);
typedef void (*glGetTexBumpParameterivATI_PTR)(glGetTexBumpParameterivATI_ARG_EXPAND);
#endif
#ifndef glGetTexEnvfv_RETURN
#define glGetTexEnvfv_RETURN void
#define glGetTexEnvfv_ARG_NAMES target, pname, params
#define glGetTexEnvfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetTexEnvfv_ARG_NAMES_TAIL , target, pname, params
#define glGetTexEnvfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetTexEnvfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexEnvfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexEnvfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexEnvfv(packed, ret_v) do { \
    glGetTexEnvfv_PACKED *unpacked = (glGetTexEnvfv_PACKED *)packed; \
    glGetTexEnvfv_ARGS *args = (glGetTexEnvfv_ARGS *)&unpacked->args; \
    glGetTexEnvfv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexEnvfv(glGetTexEnvfv_ARG_EXPAND);
packed_call_t *pack_glGetTexEnvfv(glGetTexEnvfv_PACKED *_dst glGetTexEnvfv_ARG_EXPAND_TAIL);
typedef void (*glGetTexEnvfv_PTR)(glGetTexEnvfv_ARG_EXPAND);
#endif
#ifndef glGetTexEnviv_RETURN
#define glGetTexEnviv_RETURN void
#define glGetTexEnviv_ARG_NAMES target, pname, params
#define glGetTexEnviv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexEnviv_ARG_NAMES_TAIL , target, pname, params
#define glGetTexEnviv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetTexEnviv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexEnviv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexEnviv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexEnviv(packed, ret_v) do { \
    glGetTexEnviv_PACKED *unpacked = (glGetTexEnviv_PACKED *)packed; \
    glGetTexEnviv_ARGS *args = (glGetTexEnviv_ARGS *)&unpacked->args; \
    glGetTexEnviv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexEnviv(glGetTexEnviv_ARG_EXPAND);
packed_call_t *pack_glGetTexEnviv(glGetTexEnviv_PACKED *_dst glGetTexEnviv_ARG_EXPAND_TAIL);
typedef void (*glGetTexEnviv_PTR)(glGetTexEnviv_ARG_EXPAND);
#endif
#ifndef glGetTexEnvxvOES_RETURN
#define glGetTexEnvxvOES_RETURN void
#define glGetTexEnvxvOES_ARG_NAMES target, pname, params
#define glGetTexEnvxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetTexEnvxvOES_ARG_NAMES_TAIL , target, pname, params
#define glGetTexEnvxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfixed * params
#define forward_glGetTexEnvxvOES(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexEnvxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexEnvxvOES(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexEnvxvOES(packed, ret_v) do { \
    glGetTexEnvxvOES_PACKED *unpacked = (glGetTexEnvxvOES_PACKED *)packed; \
    glGetTexEnvxvOES_ARGS *args = (glGetTexEnvxvOES_ARGS *)&unpacked->args; \
    glGetTexEnvxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetTexEnvxvOES(glGetTexEnvxvOES_ARG_EXPAND);
packed_call_t *pack_glGetTexEnvxvOES(glGetTexEnvxvOES_PACKED *_dst glGetTexEnvxvOES_ARG_EXPAND_TAIL);
typedef void (*glGetTexEnvxvOES_PTR)(glGetTexEnvxvOES_ARG_EXPAND);
#endif
#ifndef glGetTexFilterFuncSGIS_RETURN
#define glGetTexFilterFuncSGIS_RETURN void
#define glGetTexFilterFuncSGIS_ARG_NAMES target, filter, weights
#define glGetTexFilterFuncSGIS_ARG_EXPAND GLenum target, GLenum filter, GLfloat * weights
#define glGetTexFilterFuncSGIS_ARG_NAMES_TAIL , target, filter, weights
#define glGetTexFilterFuncSGIS_ARG_EXPAND_TAIL , GLenum target, GLenum filter, GLfloat * weights
#define forward_glGetTexFilterFuncSGIS(_target, _filter, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexFilterFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexFilterFuncSGIS(dst, _target, _filter, _weights), NULL); \
    });
#define call_glGetTexFilterFuncSGIS(packed, ret_v) do { \
    glGetTexFilterFuncSGIS_PACKED *unpacked = (glGetTexFilterFuncSGIS_PACKED *)packed; \
    glGetTexFilterFuncSGIS_ARGS *args = (glGetTexFilterFuncSGIS_ARGS *)&unpacked->args; \
    glGetTexFilterFuncSGIS(args->target, args->filter, args->weights);; \
} while(0)
void glGetTexFilterFuncSGIS(glGetTexFilterFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glGetTexFilterFuncSGIS(glGetTexFilterFuncSGIS_PACKED *_dst glGetTexFilterFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glGetTexFilterFuncSGIS_PTR)(glGetTexFilterFuncSGIS_ARG_EXPAND);
#endif
#ifndef glGetTexGendv_RETURN
#define glGetTexGendv_RETURN void
#define glGetTexGendv_ARG_NAMES coord, pname, params
#define glGetTexGendv_ARG_EXPAND GLenum coord, GLenum pname, GLdouble * params
#define glGetTexGendv_ARG_NAMES_TAIL , coord, pname, params
#define glGetTexGendv_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLdouble * params
#define forward_glGetTexGendv(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexGendv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexGendv(dst, _coord, _pname, _params), NULL); \
    });
#define call_glGetTexGendv(packed, ret_v) do { \
    glGetTexGendv_PACKED *unpacked = (glGetTexGendv_PACKED *)packed; \
    glGetTexGendv_ARGS *args = (glGetTexGendv_ARGS *)&unpacked->args; \
    glGetTexGendv(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGendv(glGetTexGendv_ARG_EXPAND);
packed_call_t *pack_glGetTexGendv(glGetTexGendv_PACKED *_dst glGetTexGendv_ARG_EXPAND_TAIL);
typedef void (*glGetTexGendv_PTR)(glGetTexGendv_ARG_EXPAND);
#endif
#ifndef glGetTexGenfv_RETURN
#define glGetTexGenfv_RETURN void
#define glGetTexGenfv_ARG_NAMES coord, pname, params
#define glGetTexGenfv_ARG_EXPAND GLenum coord, GLenum pname, GLfloat * params
#define glGetTexGenfv_ARG_NAMES_TAIL , coord, pname, params
#define glGetTexGenfv_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLfloat * params
#define forward_glGetTexGenfv(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexGenfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexGenfv(dst, _coord, _pname, _params), NULL); \
    });
#define call_glGetTexGenfv(packed, ret_v) do { \
    glGetTexGenfv_PACKED *unpacked = (glGetTexGenfv_PACKED *)packed; \
    glGetTexGenfv_ARGS *args = (glGetTexGenfv_ARGS *)&unpacked->args; \
    glGetTexGenfv(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGenfv(glGetTexGenfv_ARG_EXPAND);
packed_call_t *pack_glGetTexGenfv(glGetTexGenfv_PACKED *_dst glGetTexGenfv_ARG_EXPAND_TAIL);
typedef void (*glGetTexGenfv_PTR)(glGetTexGenfv_ARG_EXPAND);
#endif
#ifndef glGetTexGeniv_RETURN
#define glGetTexGeniv_RETURN void
#define glGetTexGeniv_ARG_NAMES coord, pname, params
#define glGetTexGeniv_ARG_EXPAND GLenum coord, GLenum pname, GLint * params
#define glGetTexGeniv_ARG_NAMES_TAIL , coord, pname, params
#define glGetTexGeniv_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLint * params
#define forward_glGetTexGeniv(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexGeniv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexGeniv(dst, _coord, _pname, _params), NULL); \
    });
#define call_glGetTexGeniv(packed, ret_v) do { \
    glGetTexGeniv_PACKED *unpacked = (glGetTexGeniv_PACKED *)packed; \
    glGetTexGeniv_ARGS *args = (glGetTexGeniv_ARGS *)&unpacked->args; \
    glGetTexGeniv(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGeniv(glGetTexGeniv_ARG_EXPAND);
packed_call_t *pack_glGetTexGeniv(glGetTexGeniv_PACKED *_dst glGetTexGeniv_ARG_EXPAND_TAIL);
typedef void (*glGetTexGeniv_PTR)(glGetTexGeniv_ARG_EXPAND);
#endif
#ifndef glGetTexGenxvOES_RETURN
#define glGetTexGenxvOES_RETURN void
#define glGetTexGenxvOES_ARG_NAMES coord, pname, params
#define glGetTexGenxvOES_ARG_EXPAND GLenum coord, GLenum pname, GLfixed * params
#define glGetTexGenxvOES_ARG_NAMES_TAIL , coord, pname, params
#define glGetTexGenxvOES_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLfixed * params
#define forward_glGetTexGenxvOES(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexGenxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexGenxvOES(dst, _coord, _pname, _params), NULL); \
    });
#define call_glGetTexGenxvOES(packed, ret_v) do { \
    glGetTexGenxvOES_PACKED *unpacked = (glGetTexGenxvOES_PACKED *)packed; \
    glGetTexGenxvOES_ARGS *args = (glGetTexGenxvOES_ARGS *)&unpacked->args; \
    glGetTexGenxvOES(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGenxvOES(glGetTexGenxvOES_ARG_EXPAND);
packed_call_t *pack_glGetTexGenxvOES(glGetTexGenxvOES_PACKED *_dst glGetTexGenxvOES_ARG_EXPAND_TAIL);
typedef void (*glGetTexGenxvOES_PTR)(glGetTexGenxvOES_ARG_EXPAND);
#endif
#ifndef glGetTexImage_RETURN
#define glGetTexImage_RETURN void
#define glGetTexImage_ARG_NAMES target, level, format, type, pixels
#define glGetTexImage_ARG_EXPAND GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define glGetTexImage_ARG_NAMES_TAIL , target, level, format, type, pixels
#define glGetTexImage_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define forward_glGetTexImage(_target, _level, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexImage_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexImage(dst, _target, _level, _format, _type, _pixels), NULL); \
    });
#define call_glGetTexImage(packed, ret_v) do { \
    glGetTexImage_PACKED *unpacked = (glGetTexImage_PACKED *)packed; \
    glGetTexImage_ARGS *args = (glGetTexImage_ARGS *)&unpacked->args; \
    glGetTexImage(args->target, args->level, args->format, args->type, args->pixels);; \
} while(0)
void glGetTexImage(glGetTexImage_ARG_EXPAND);
packed_call_t *pack_glGetTexImage(glGetTexImage_PACKED *_dst glGetTexImage_ARG_EXPAND_TAIL);
typedef void (*glGetTexImage_PTR)(glGetTexImage_ARG_EXPAND);
#endif
#ifndef glGetTexLevelParameterfv_RETURN
#define glGetTexLevelParameterfv_RETURN void
#define glGetTexLevelParameterfv_ARG_NAMES target, level, pname, params
#define glGetTexLevelParameterfv_ARG_EXPAND GLenum target, GLint level, GLenum pname, GLfloat * params
#define glGetTexLevelParameterfv_ARG_NAMES_TAIL , target, level, pname, params
#define glGetTexLevelParameterfv_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum pname, GLfloat * params
#define forward_glGetTexLevelParameterfv(_target, _level, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexLevelParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexLevelParameterfv(dst, _target, _level, _pname, _params), NULL); \
    });
#define call_glGetTexLevelParameterfv(packed, ret_v) do { \
    glGetTexLevelParameterfv_PACKED *unpacked = (glGetTexLevelParameterfv_PACKED *)packed; \
    glGetTexLevelParameterfv_ARGS *args = (glGetTexLevelParameterfv_ARGS *)&unpacked->args; \
    glGetTexLevelParameterfv(args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTexLevelParameterfv(glGetTexLevelParameterfv_ARG_EXPAND);
packed_call_t *pack_glGetTexLevelParameterfv(glGetTexLevelParameterfv_PACKED *_dst glGetTexLevelParameterfv_ARG_EXPAND_TAIL);
typedef void (*glGetTexLevelParameterfv_PTR)(glGetTexLevelParameterfv_ARG_EXPAND);
#endif
#ifndef glGetTexLevelParameteriv_RETURN
#define glGetTexLevelParameteriv_RETURN void
#define glGetTexLevelParameteriv_ARG_NAMES target, level, pname, params
#define glGetTexLevelParameteriv_ARG_EXPAND GLenum target, GLint level, GLenum pname, GLint * params
#define glGetTexLevelParameteriv_ARG_NAMES_TAIL , target, level, pname, params
#define glGetTexLevelParameteriv_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum pname, GLint * params
#define forward_glGetTexLevelParameteriv(_target, _level, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexLevelParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexLevelParameteriv(dst, _target, _level, _pname, _params), NULL); \
    });
#define call_glGetTexLevelParameteriv(packed, ret_v) do { \
    glGetTexLevelParameteriv_PACKED *unpacked = (glGetTexLevelParameteriv_PACKED *)packed; \
    glGetTexLevelParameteriv_ARGS *args = (glGetTexLevelParameteriv_ARGS *)&unpacked->args; \
    glGetTexLevelParameteriv(args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTexLevelParameteriv(glGetTexLevelParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetTexLevelParameteriv(glGetTexLevelParameteriv_PACKED *_dst glGetTexLevelParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetTexLevelParameteriv_PTR)(glGetTexLevelParameteriv_ARG_EXPAND);
#endif
#ifndef glGetTexLevelParameterxvOES_RETURN
#define glGetTexLevelParameterxvOES_RETURN void
#define glGetTexLevelParameterxvOES_ARG_NAMES target, level, pname, params
#define glGetTexLevelParameterxvOES_ARG_EXPAND GLenum target, GLint level, GLenum pname, GLfixed * params
#define glGetTexLevelParameterxvOES_ARG_NAMES_TAIL , target, level, pname, params
#define glGetTexLevelParameterxvOES_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum pname, GLfixed * params
#define forward_glGetTexLevelParameterxvOES(_target, _level, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexLevelParameterxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexLevelParameterxvOES(dst, _target, _level, _pname, _params), NULL); \
    });
#define call_glGetTexLevelParameterxvOES(packed, ret_v) do { \
    glGetTexLevelParameterxvOES_PACKED *unpacked = (glGetTexLevelParameterxvOES_PACKED *)packed; \
    glGetTexLevelParameterxvOES_ARGS *args = (glGetTexLevelParameterxvOES_ARGS *)&unpacked->args; \
    glGetTexLevelParameterxvOES(args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTexLevelParameterxvOES(glGetTexLevelParameterxvOES_ARG_EXPAND);
packed_call_t *pack_glGetTexLevelParameterxvOES(glGetTexLevelParameterxvOES_PACKED *_dst glGetTexLevelParameterxvOES_ARG_EXPAND_TAIL);
typedef void (*glGetTexLevelParameterxvOES_PTR)(glGetTexLevelParameterxvOES_ARG_EXPAND);
#endif
#ifndef glGetTexParameterIiv_RETURN
#define glGetTexParameterIiv_RETURN void
#define glGetTexParameterIiv_ARG_NAMES target, pname, params
#define glGetTexParameterIiv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexParameterIiv_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameterIiv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetTexParameterIiv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameterIiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameterIiv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameterIiv(packed, ret_v) do { \
    glGetTexParameterIiv_PACKED *unpacked = (glGetTexParameterIiv_PACKED *)packed; \
    glGetTexParameterIiv_ARGS *args = (glGetTexParameterIiv_ARGS *)&unpacked->args; \
    glGetTexParameterIiv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIiv(glGetTexParameterIiv_ARG_EXPAND);
packed_call_t *pack_glGetTexParameterIiv(glGetTexParameterIiv_PACKED *_dst glGetTexParameterIiv_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameterIiv_PTR)(glGetTexParameterIiv_ARG_EXPAND);
#endif
#ifndef glGetTexParameterIivEXT_RETURN
#define glGetTexParameterIivEXT_RETURN void
#define glGetTexParameterIivEXT_ARG_NAMES target, pname, params
#define glGetTexParameterIivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexParameterIivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameterIivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetTexParameterIivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameterIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameterIivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameterIivEXT(packed, ret_v) do { \
    glGetTexParameterIivEXT_PACKED *unpacked = (glGetTexParameterIivEXT_PACKED *)packed; \
    glGetTexParameterIivEXT_ARGS *args = (glGetTexParameterIivEXT_ARGS *)&unpacked->args; \
    glGetTexParameterIivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIivEXT(glGetTexParameterIivEXT_ARG_EXPAND);
packed_call_t *pack_glGetTexParameterIivEXT(glGetTexParameterIivEXT_PACKED *_dst glGetTexParameterIivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameterIivEXT_PTR)(glGetTexParameterIivEXT_ARG_EXPAND);
#endif
#ifndef glGetTexParameterIuiv_RETURN
#define glGetTexParameterIuiv_RETURN void
#define glGetTexParameterIuiv_ARG_NAMES target, pname, params
#define glGetTexParameterIuiv_ARG_EXPAND GLenum target, GLenum pname, GLuint * params
#define glGetTexParameterIuiv_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameterIuiv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLuint * params
#define forward_glGetTexParameterIuiv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameterIuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameterIuiv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameterIuiv(packed, ret_v) do { \
    glGetTexParameterIuiv_PACKED *unpacked = (glGetTexParameterIuiv_PACKED *)packed; \
    glGetTexParameterIuiv_ARGS *args = (glGetTexParameterIuiv_ARGS *)&unpacked->args; \
    glGetTexParameterIuiv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIuiv(glGetTexParameterIuiv_ARG_EXPAND);
packed_call_t *pack_glGetTexParameterIuiv(glGetTexParameterIuiv_PACKED *_dst glGetTexParameterIuiv_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameterIuiv_PTR)(glGetTexParameterIuiv_ARG_EXPAND);
#endif
#ifndef glGetTexParameterIuivEXT_RETURN
#define glGetTexParameterIuivEXT_RETURN void
#define glGetTexParameterIuivEXT_ARG_NAMES target, pname, params
#define glGetTexParameterIuivEXT_ARG_EXPAND GLenum target, GLenum pname, GLuint * params
#define glGetTexParameterIuivEXT_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameterIuivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLuint * params
#define forward_glGetTexParameterIuivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameterIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameterIuivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameterIuivEXT(packed, ret_v) do { \
    glGetTexParameterIuivEXT_PACKED *unpacked = (glGetTexParameterIuivEXT_PACKED *)packed; \
    glGetTexParameterIuivEXT_ARGS *args = (glGetTexParameterIuivEXT_ARGS *)&unpacked->args; \
    glGetTexParameterIuivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIuivEXT(glGetTexParameterIuivEXT_ARG_EXPAND);
packed_call_t *pack_glGetTexParameterIuivEXT(glGetTexParameterIuivEXT_PACKED *_dst glGetTexParameterIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameterIuivEXT_PTR)(glGetTexParameterIuivEXT_ARG_EXPAND);
#endif
#ifndef glGetTexParameterPointervAPPLE_RETURN
#define glGetTexParameterPointervAPPLE_RETURN void
#define glGetTexParameterPointervAPPLE_ARG_NAMES target, pname, params
#define glGetTexParameterPointervAPPLE_ARG_EXPAND GLenum target, GLenum pname, GLvoid * params
#define glGetTexParameterPointervAPPLE_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameterPointervAPPLE_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLvoid * params
#define forward_glGetTexParameterPointervAPPLE(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameterPointervAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameterPointervAPPLE(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameterPointervAPPLE(packed, ret_v) do { \
    glGetTexParameterPointervAPPLE_PACKED *unpacked = (glGetTexParameterPointervAPPLE_PACKED *)packed; \
    glGetTexParameterPointervAPPLE_ARGS *args = (glGetTexParameterPointervAPPLE_ARGS *)&unpacked->args; \
    glGetTexParameterPointervAPPLE(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterPointervAPPLE(glGetTexParameterPointervAPPLE_ARG_EXPAND);
packed_call_t *pack_glGetTexParameterPointervAPPLE(glGetTexParameterPointervAPPLE_PACKED *_dst glGetTexParameterPointervAPPLE_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameterPointervAPPLE_PTR)(glGetTexParameterPointervAPPLE_ARG_EXPAND);
#endif
#ifndef glGetTexParameterfv_RETURN
#define glGetTexParameterfv_RETURN void
#define glGetTexParameterfv_ARG_NAMES target, pname, params
#define glGetTexParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetTexParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat * params
#define forward_glGetTexParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameterfv(packed, ret_v) do { \
    glGetTexParameterfv_PACKED *unpacked = (glGetTexParameterfv_PACKED *)packed; \
    glGetTexParameterfv_ARGS *args = (glGetTexParameterfv_ARGS *)&unpacked->args; \
    glGetTexParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterfv(glGetTexParameterfv_ARG_EXPAND);
packed_call_t *pack_glGetTexParameterfv(glGetTexParameterfv_PACKED *_dst glGetTexParameterfv_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameterfv_PTR)(glGetTexParameterfv_ARG_EXPAND);
#endif
#ifndef glGetTexParameteriv_RETURN
#define glGetTexParameteriv_RETURN void
#define glGetTexParameteriv_ARG_NAMES target, pname, params
#define glGetTexParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint * params
#define forward_glGetTexParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameteriv(packed, ret_v) do { \
    glGetTexParameteriv_PACKED *unpacked = (glGetTexParameteriv_PACKED *)packed; \
    glGetTexParameteriv_ARGS *args = (glGetTexParameteriv_ARGS *)&unpacked->args; \
    glGetTexParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameteriv(glGetTexParameteriv_ARG_EXPAND);
packed_call_t *pack_glGetTexParameteriv(glGetTexParameteriv_PACKED *_dst glGetTexParameteriv_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameteriv_PTR)(glGetTexParameteriv_ARG_EXPAND);
#endif
#ifndef glGetTexParameterxvOES_RETURN
#define glGetTexParameterxvOES_RETURN void
#define glGetTexParameterxvOES_ARG_NAMES target, pname, params
#define glGetTexParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetTexParameterxvOES_ARG_NAMES_TAIL , target, pname, params
#define glGetTexParameterxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfixed * params
#define forward_glGetTexParameterxvOES(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTexParameterxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTexParameterxvOES(dst, _target, _pname, _params), NULL); \
    });
#define call_glGetTexParameterxvOES(packed, ret_v) do { \
    glGetTexParameterxvOES_PACKED *unpacked = (glGetTexParameterxvOES_PACKED *)packed; \
    glGetTexParameterxvOES_ARGS *args = (glGetTexParameterxvOES_ARGS *)&unpacked->args; \
    glGetTexParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterxvOES(glGetTexParameterxvOES_ARG_EXPAND);
packed_call_t *pack_glGetTexParameterxvOES(glGetTexParameterxvOES_PACKED *_dst glGetTexParameterxvOES_ARG_EXPAND_TAIL);
typedef void (*glGetTexParameterxvOES_PTR)(glGetTexParameterxvOES_ARG_EXPAND);
#endif
#ifndef glGetTextureHandleNV_RETURN
#define glGetTextureHandleNV_RETURN GLuint64
#define glGetTextureHandleNV_ARG_NAMES texture
#define glGetTextureHandleNV_ARG_EXPAND GLuint texture
#define glGetTextureHandleNV_ARG_NAMES_TAIL , texture
#define glGetTextureHandleNV_ARG_EXPAND_TAIL , GLuint texture
#define forward_glGetTextureHandleNV(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureHandleNV_PACKED)); \
        GLuint64 ret = (GLuint64)0; \
        remote_dma_send((packed_call_t *)pack_glGetTextureHandleNV(dst, _texture), &ret); \
        ret; \
    });
#define call_glGetTextureHandleNV(packed, ret_v) do { \
    glGetTextureHandleNV_PACKED *unpacked = (glGetTextureHandleNV_PACKED *)packed; \
    glGetTextureHandleNV_ARGS *args = (glGetTextureHandleNV_ARGS *)&unpacked->args; \
    GLuint64 *ret = (GLuint64 *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetTextureHandleNV(args->texture);; \
    } else { \
        glGetTextureHandleNV(args->texture);; \
    } \
} while(0)
GLuint64 glGetTextureHandleNV(glGetTextureHandleNV_ARG_EXPAND);
packed_call_t *pack_glGetTextureHandleNV(glGetTextureHandleNV_PACKED *_dst glGetTextureHandleNV_ARG_EXPAND_TAIL);
typedef GLuint64 (*glGetTextureHandleNV_PTR)(glGetTextureHandleNV_ARG_EXPAND);
#endif
#ifndef glGetTextureImageEXT_RETURN
#define glGetTextureImageEXT_RETURN void
#define glGetTextureImageEXT_ARG_NAMES texture, target, level, format, type, pixels
#define glGetTextureImageEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define glGetTextureImageEXT_ARG_NAMES_TAIL , texture, target, level, format, type, pixels
#define glGetTextureImageEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define forward_glGetTextureImageEXT(_texture, _target, _level, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureImageEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTextureImageEXT(dst, _texture, _target, _level, _format, _type, _pixels), NULL); \
    });
#define call_glGetTextureImageEXT(packed, ret_v) do { \
    glGetTextureImageEXT_PACKED *unpacked = (glGetTextureImageEXT_PACKED *)packed; \
    glGetTextureImageEXT_ARGS *args = (glGetTextureImageEXT_ARGS *)&unpacked->args; \
    glGetTextureImageEXT(args->texture, args->target, args->level, args->format, args->type, args->pixels);; \
} while(0)
void glGetTextureImageEXT(glGetTextureImageEXT_ARG_EXPAND);
packed_call_t *pack_glGetTextureImageEXT(glGetTextureImageEXT_PACKED *_dst glGetTextureImageEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTextureImageEXT_PTR)(glGetTextureImageEXT_ARG_EXPAND);
#endif
#ifndef glGetTextureLevelParameterfvEXT_RETURN
#define glGetTextureLevelParameterfvEXT_RETURN void
#define glGetTextureLevelParameterfvEXT_ARG_NAMES texture, target, level, pname, params
#define glGetTextureLevelParameterfvEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params
#define glGetTextureLevelParameterfvEXT_ARG_NAMES_TAIL , texture, target, level, pname, params
#define glGetTextureLevelParameterfvEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params
#define forward_glGetTextureLevelParameterfvEXT(_texture, _target, _level, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureLevelParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTextureLevelParameterfvEXT(dst, _texture, _target, _level, _pname, _params), NULL); \
    });
#define call_glGetTextureLevelParameterfvEXT(packed, ret_v) do { \
    glGetTextureLevelParameterfvEXT_PACKED *unpacked = (glGetTextureLevelParameterfvEXT_PACKED *)packed; \
    glGetTextureLevelParameterfvEXT_ARGS *args = (glGetTextureLevelParameterfvEXT_ARGS *)&unpacked->args; \
    glGetTextureLevelParameterfvEXT(args->texture, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTextureLevelParameterfvEXT(glGetTextureLevelParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetTextureLevelParameterfvEXT(glGetTextureLevelParameterfvEXT_PACKED *_dst glGetTextureLevelParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTextureLevelParameterfvEXT_PTR)(glGetTextureLevelParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetTextureLevelParameterivEXT_RETURN
#define glGetTextureLevelParameterivEXT_RETURN void
#define glGetTextureLevelParameterivEXT_ARG_NAMES texture, target, level, pname, params
#define glGetTextureLevelParameterivEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params
#define glGetTextureLevelParameterivEXT_ARG_NAMES_TAIL , texture, target, level, pname, params
#define glGetTextureLevelParameterivEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params
#define forward_glGetTextureLevelParameterivEXT(_texture, _target, _level, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureLevelParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTextureLevelParameterivEXT(dst, _texture, _target, _level, _pname, _params), NULL); \
    });
#define call_glGetTextureLevelParameterivEXT(packed, ret_v) do { \
    glGetTextureLevelParameterivEXT_PACKED *unpacked = (glGetTextureLevelParameterivEXT_PACKED *)packed; \
    glGetTextureLevelParameterivEXT_ARGS *args = (glGetTextureLevelParameterivEXT_ARGS *)&unpacked->args; \
    glGetTextureLevelParameterivEXT(args->texture, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTextureLevelParameterivEXT(glGetTextureLevelParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetTextureLevelParameterivEXT(glGetTextureLevelParameterivEXT_PACKED *_dst glGetTextureLevelParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTextureLevelParameterivEXT_PTR)(glGetTextureLevelParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetTextureParameterIivEXT_RETURN
#define glGetTextureParameterIivEXT_RETURN void
#define glGetTextureParameterIivEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterIivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLint * params
#define glGetTextureParameterIivEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glGetTextureParameterIivEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, GLint * params
#define forward_glGetTextureParameterIivEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureParameterIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTextureParameterIivEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glGetTextureParameterIivEXT(packed, ret_v) do { \
    glGetTextureParameterIivEXT_PACKED *unpacked = (glGetTextureParameterIivEXT_PACKED *)packed; \
    glGetTextureParameterIivEXT_ARGS *args = (glGetTextureParameterIivEXT_ARGS *)&unpacked->args; \
    glGetTextureParameterIivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterIivEXT(glGetTextureParameterIivEXT_ARG_EXPAND);
packed_call_t *pack_glGetTextureParameterIivEXT(glGetTextureParameterIivEXT_PACKED *_dst glGetTextureParameterIivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTextureParameterIivEXT_PTR)(glGetTextureParameterIivEXT_ARG_EXPAND);
#endif
#ifndef glGetTextureParameterIuivEXT_RETURN
#define glGetTextureParameterIuivEXT_RETURN void
#define glGetTextureParameterIuivEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterIuivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLuint * params
#define glGetTextureParameterIuivEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glGetTextureParameterIuivEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, GLuint * params
#define forward_glGetTextureParameterIuivEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureParameterIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTextureParameterIuivEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glGetTextureParameterIuivEXT(packed, ret_v) do { \
    glGetTextureParameterIuivEXT_PACKED *unpacked = (glGetTextureParameterIuivEXT_PACKED *)packed; \
    glGetTextureParameterIuivEXT_ARGS *args = (glGetTextureParameterIuivEXT_ARGS *)&unpacked->args; \
    glGetTextureParameterIuivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterIuivEXT(glGetTextureParameterIuivEXT_ARG_EXPAND);
packed_call_t *pack_glGetTextureParameterIuivEXT(glGetTextureParameterIuivEXT_PACKED *_dst glGetTextureParameterIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTextureParameterIuivEXT_PTR)(glGetTextureParameterIuivEXT_ARG_EXPAND);
#endif
#ifndef glGetTextureParameterfvEXT_RETURN
#define glGetTextureParameterfvEXT_RETURN void
#define glGetTextureParameterfvEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterfvEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLfloat * params
#define glGetTextureParameterfvEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glGetTextureParameterfvEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, GLfloat * params
#define forward_glGetTextureParameterfvEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTextureParameterfvEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glGetTextureParameterfvEXT(packed, ret_v) do { \
    glGetTextureParameterfvEXT_PACKED *unpacked = (glGetTextureParameterfvEXT_PACKED *)packed; \
    glGetTextureParameterfvEXT_ARGS *args = (glGetTextureParameterfvEXT_ARGS *)&unpacked->args; \
    glGetTextureParameterfvEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterfvEXT(glGetTextureParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glGetTextureParameterfvEXT(glGetTextureParameterfvEXT_PACKED *_dst glGetTextureParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTextureParameterfvEXT_PTR)(glGetTextureParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glGetTextureParameterivEXT_RETURN
#define glGetTextureParameterivEXT_RETURN void
#define glGetTextureParameterivEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLint * params
#define glGetTextureParameterivEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glGetTextureParameterivEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, GLint * params
#define forward_glGetTextureParameterivEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTextureParameterivEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glGetTextureParameterivEXT(packed, ret_v) do { \
    glGetTextureParameterivEXT_PACKED *unpacked = (glGetTextureParameterivEXT_PACKED *)packed; \
    glGetTextureParameterivEXT_ARGS *args = (glGetTextureParameterivEXT_ARGS *)&unpacked->args; \
    glGetTextureParameterivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterivEXT(glGetTextureParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glGetTextureParameterivEXT(glGetTextureParameterivEXT_PACKED *_dst glGetTextureParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTextureParameterivEXT_PTR)(glGetTextureParameterivEXT_ARG_EXPAND);
#endif
#ifndef glGetTextureSamplerHandleNV_RETURN
#define glGetTextureSamplerHandleNV_RETURN GLuint64
#define glGetTextureSamplerHandleNV_ARG_NAMES texture, sampler
#define glGetTextureSamplerHandleNV_ARG_EXPAND GLuint texture, GLuint sampler
#define glGetTextureSamplerHandleNV_ARG_NAMES_TAIL , texture, sampler
#define glGetTextureSamplerHandleNV_ARG_EXPAND_TAIL , GLuint texture, GLuint sampler
#define forward_glGetTextureSamplerHandleNV(_texture, _sampler) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTextureSamplerHandleNV_PACKED)); \
        GLuint64 ret = (GLuint64)0; \
        remote_dma_send((packed_call_t *)pack_glGetTextureSamplerHandleNV(dst, _texture, _sampler), &ret); \
        ret; \
    });
#define call_glGetTextureSamplerHandleNV(packed, ret_v) do { \
    glGetTextureSamplerHandleNV_PACKED *unpacked = (glGetTextureSamplerHandleNV_PACKED *)packed; \
    glGetTextureSamplerHandleNV_ARGS *args = (glGetTextureSamplerHandleNV_ARGS *)&unpacked->args; \
    GLuint64 *ret = (GLuint64 *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetTextureSamplerHandleNV(args->texture, args->sampler);; \
    } else { \
        glGetTextureSamplerHandleNV(args->texture, args->sampler);; \
    } \
} while(0)
GLuint64 glGetTextureSamplerHandleNV(glGetTextureSamplerHandleNV_ARG_EXPAND);
packed_call_t *pack_glGetTextureSamplerHandleNV(glGetTextureSamplerHandleNV_PACKED *_dst glGetTextureSamplerHandleNV_ARG_EXPAND_TAIL);
typedef GLuint64 (*glGetTextureSamplerHandleNV_PTR)(glGetTextureSamplerHandleNV_ARG_EXPAND);
#endif
#ifndef glGetTrackMatrixivNV_RETURN
#define glGetTrackMatrixivNV_RETURN void
#define glGetTrackMatrixivNV_ARG_NAMES target, address, pname, params
#define glGetTrackMatrixivNV_ARG_EXPAND GLenum target, GLuint address, GLenum pname, GLint * params
#define glGetTrackMatrixivNV_ARG_NAMES_TAIL , target, address, pname, params
#define glGetTrackMatrixivNV_ARG_EXPAND_TAIL , GLenum target, GLuint address, GLenum pname, GLint * params
#define forward_glGetTrackMatrixivNV(_target, _address, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTrackMatrixivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTrackMatrixivNV(dst, _target, _address, _pname, _params), NULL); \
    });
#define call_glGetTrackMatrixivNV(packed, ret_v) do { \
    glGetTrackMatrixivNV_PACKED *unpacked = (glGetTrackMatrixivNV_PACKED *)packed; \
    glGetTrackMatrixivNV_ARGS *args = (glGetTrackMatrixivNV_ARGS *)&unpacked->args; \
    glGetTrackMatrixivNV(args->target, args->address, args->pname, args->params);; \
} while(0)
void glGetTrackMatrixivNV(glGetTrackMatrixivNV_ARG_EXPAND);
packed_call_t *pack_glGetTrackMatrixivNV(glGetTrackMatrixivNV_PACKED *_dst glGetTrackMatrixivNV_ARG_EXPAND_TAIL);
typedef void (*glGetTrackMatrixivNV_PTR)(glGetTrackMatrixivNV_ARG_EXPAND);
#endif
#ifndef glGetTransformFeedbackVarying_RETURN
#define glGetTransformFeedbackVarying_RETURN void
#define glGetTransformFeedbackVarying_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetTransformFeedbackVarying_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define glGetTransformFeedbackVarying_ARG_NAMES_TAIL , program, index, bufSize, length, size, type, name
#define glGetTransformFeedbackVarying_ARG_EXPAND_TAIL , GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define forward_glGetTransformFeedbackVarying(_program, _index, _bufSize, _length, _size, _type, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTransformFeedbackVarying_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTransformFeedbackVarying(dst, _program, _index, _bufSize, _length, _size, _type, _name), NULL); \
    });
#define call_glGetTransformFeedbackVarying(packed, ret_v) do { \
    glGetTransformFeedbackVarying_PACKED *unpacked = (glGetTransformFeedbackVarying_PACKED *)packed; \
    glGetTransformFeedbackVarying_ARGS *args = (glGetTransformFeedbackVarying_ARGS *)&unpacked->args; \
    glGetTransformFeedbackVarying(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetTransformFeedbackVarying(glGetTransformFeedbackVarying_ARG_EXPAND);
packed_call_t *pack_glGetTransformFeedbackVarying(glGetTransformFeedbackVarying_PACKED *_dst glGetTransformFeedbackVarying_ARG_EXPAND_TAIL);
typedef void (*glGetTransformFeedbackVarying_PTR)(glGetTransformFeedbackVarying_ARG_EXPAND);
#endif
#ifndef glGetTransformFeedbackVaryingEXT_RETURN
#define glGetTransformFeedbackVaryingEXT_RETURN void
#define glGetTransformFeedbackVaryingEXT_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetTransformFeedbackVaryingEXT_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define glGetTransformFeedbackVaryingEXT_ARG_NAMES_TAIL , program, index, bufSize, length, size, type, name
#define glGetTransformFeedbackVaryingEXT_ARG_EXPAND_TAIL , GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define forward_glGetTransformFeedbackVaryingEXT(_program, _index, _bufSize, _length, _size, _type, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTransformFeedbackVaryingEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTransformFeedbackVaryingEXT(dst, _program, _index, _bufSize, _length, _size, _type, _name), NULL); \
    });
#define call_glGetTransformFeedbackVaryingEXT(packed, ret_v) do { \
    glGetTransformFeedbackVaryingEXT_PACKED *unpacked = (glGetTransformFeedbackVaryingEXT_PACKED *)packed; \
    glGetTransformFeedbackVaryingEXT_ARGS *args = (glGetTransformFeedbackVaryingEXT_ARGS *)&unpacked->args; \
    glGetTransformFeedbackVaryingEXT(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetTransformFeedbackVaryingEXT(glGetTransformFeedbackVaryingEXT_ARG_EXPAND);
packed_call_t *pack_glGetTransformFeedbackVaryingEXT(glGetTransformFeedbackVaryingEXT_PACKED *_dst glGetTransformFeedbackVaryingEXT_ARG_EXPAND_TAIL);
typedef void (*glGetTransformFeedbackVaryingEXT_PTR)(glGetTransformFeedbackVaryingEXT_ARG_EXPAND);
#endif
#ifndef glGetTransformFeedbackVaryingNV_RETURN
#define glGetTransformFeedbackVaryingNV_RETURN void
#define glGetTransformFeedbackVaryingNV_ARG_NAMES program, index, location
#define glGetTransformFeedbackVaryingNV_ARG_EXPAND GLuint program, GLuint index, GLint * location
#define glGetTransformFeedbackVaryingNV_ARG_NAMES_TAIL , program, index, location
#define glGetTransformFeedbackVaryingNV_ARG_EXPAND_TAIL , GLuint program, GLuint index, GLint * location
#define forward_glGetTransformFeedbackVaryingNV(_program, _index, _location) \
    ({ \
        void *dst = remote_dma(sizeof(glGetTransformFeedbackVaryingNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetTransformFeedbackVaryingNV(dst, _program, _index, _location), NULL); \
    });
#define call_glGetTransformFeedbackVaryingNV(packed, ret_v) do { \
    glGetTransformFeedbackVaryingNV_PACKED *unpacked = (glGetTransformFeedbackVaryingNV_PACKED *)packed; \
    glGetTransformFeedbackVaryingNV_ARGS *args = (glGetTransformFeedbackVaryingNV_ARGS *)&unpacked->args; \
    glGetTransformFeedbackVaryingNV(args->program, args->index, args->location);; \
} while(0)
void glGetTransformFeedbackVaryingNV(glGetTransformFeedbackVaryingNV_ARG_EXPAND);
packed_call_t *pack_glGetTransformFeedbackVaryingNV(glGetTransformFeedbackVaryingNV_PACKED *_dst glGetTransformFeedbackVaryingNV_ARG_EXPAND_TAIL);
typedef void (*glGetTransformFeedbackVaryingNV_PTR)(glGetTransformFeedbackVaryingNV_ARG_EXPAND);
#endif
#ifndef glGetUniformBlockIndex_RETURN
#define glGetUniformBlockIndex_RETURN GLuint
#define glGetUniformBlockIndex_ARG_NAMES program, uniformBlockName
#define glGetUniformBlockIndex_ARG_EXPAND GLuint program, const GLchar * uniformBlockName
#define glGetUniformBlockIndex_ARG_NAMES_TAIL , program, uniformBlockName
#define glGetUniformBlockIndex_ARG_EXPAND_TAIL , GLuint program, const GLchar * uniformBlockName
#define forward_glGetUniformBlockIndex(_program, _uniformBlockName) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformBlockIndex_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glGetUniformBlockIndex(dst, _program, _uniformBlockName), &ret); \
        ret; \
    });
#define call_glGetUniformBlockIndex(packed, ret_v) do { \
    glGetUniformBlockIndex_PACKED *unpacked = (glGetUniformBlockIndex_PACKED *)packed; \
    glGetUniformBlockIndex_ARGS *args = (glGetUniformBlockIndex_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformBlockIndex(args->program, args->uniformBlockName);; \
    } else { \
        glGetUniformBlockIndex(args->program, args->uniformBlockName);; \
    } \
} while(0)
GLuint glGetUniformBlockIndex(glGetUniformBlockIndex_ARG_EXPAND);
packed_call_t *pack_glGetUniformBlockIndex(glGetUniformBlockIndex_PACKED *_dst glGetUniformBlockIndex_ARG_EXPAND_TAIL);
typedef GLuint (*glGetUniformBlockIndex_PTR)(glGetUniformBlockIndex_ARG_EXPAND);
#endif
#ifndef glGetUniformBufferSizeEXT_RETURN
#define glGetUniformBufferSizeEXT_RETURN GLint
#define glGetUniformBufferSizeEXT_ARG_NAMES program, location
#define glGetUniformBufferSizeEXT_ARG_EXPAND GLuint program, GLint location
#define glGetUniformBufferSizeEXT_ARG_NAMES_TAIL , program, location
#define glGetUniformBufferSizeEXT_ARG_EXPAND_TAIL , GLuint program, GLint location
#define forward_glGetUniformBufferSizeEXT(_program, _location) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformBufferSizeEXT_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetUniformBufferSizeEXT(dst, _program, _location), &ret); \
        ret; \
    });
#define call_glGetUniformBufferSizeEXT(packed, ret_v) do { \
    glGetUniformBufferSizeEXT_PACKED *unpacked = (glGetUniformBufferSizeEXT_PACKED *)packed; \
    glGetUniformBufferSizeEXT_ARGS *args = (glGetUniformBufferSizeEXT_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformBufferSizeEXT(args->program, args->location);; \
    } else { \
        glGetUniformBufferSizeEXT(args->program, args->location);; \
    } \
} while(0)
GLint glGetUniformBufferSizeEXT(glGetUniformBufferSizeEXT_ARG_EXPAND);
packed_call_t *pack_glGetUniformBufferSizeEXT(glGetUniformBufferSizeEXT_PACKED *_dst glGetUniformBufferSizeEXT_ARG_EXPAND_TAIL);
typedef GLint (*glGetUniformBufferSizeEXT_PTR)(glGetUniformBufferSizeEXT_ARG_EXPAND);
#endif
#ifndef glGetUniformIndices_RETURN
#define glGetUniformIndices_RETURN void
#define glGetUniformIndices_ARG_NAMES program, uniformCount, uniformNames, uniformIndices
#define glGetUniformIndices_ARG_EXPAND GLuint program, GLsizei uniformCount, GLchar*const * uniformNames, GLuint * uniformIndices
#define glGetUniformIndices_ARG_NAMES_TAIL , program, uniformCount, uniformNames, uniformIndices
#define glGetUniformIndices_ARG_EXPAND_TAIL , GLuint program, GLsizei uniformCount, GLchar*const * uniformNames, GLuint * uniformIndices
#define forward_glGetUniformIndices(_program, _uniformCount, _uniformNames, _uniformIndices) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformIndices_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformIndices(dst, _program, _uniformCount, _uniformNames, _uniformIndices), NULL); \
    });
#define call_glGetUniformIndices(packed, ret_v) do { \
    glGetUniformIndices_PACKED *unpacked = (glGetUniformIndices_PACKED *)packed; \
    glGetUniformIndices_ARGS *args = (glGetUniformIndices_ARGS *)&unpacked->args; \
    glGetUniformIndices(args->program, args->uniformCount, args->uniformNames, args->uniformIndices);; \
} while(0)
void glGetUniformIndices(glGetUniformIndices_ARG_EXPAND);
packed_call_t *pack_glGetUniformIndices(glGetUniformIndices_PACKED *_dst glGetUniformIndices_ARG_EXPAND_TAIL);
typedef void (*glGetUniformIndices_PTR)(glGetUniformIndices_ARG_EXPAND);
#endif
#ifndef glGetUniformLocation_RETURN
#define glGetUniformLocation_RETURN GLint
#define glGetUniformLocation_ARG_NAMES program, name
#define glGetUniformLocation_ARG_EXPAND GLuint program, const GLchar * name
#define glGetUniformLocation_ARG_NAMES_TAIL , program, name
#define glGetUniformLocation_ARG_EXPAND_TAIL , GLuint program, const GLchar * name
#define forward_glGetUniformLocation(_program, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformLocation_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetUniformLocation(dst, _program, _name), &ret); \
        ret; \
    });
#define call_glGetUniformLocation(packed, ret_v) do { \
    glGetUniformLocation_PACKED *unpacked = (glGetUniformLocation_PACKED *)packed; \
    glGetUniformLocation_ARGS *args = (glGetUniformLocation_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformLocation(args->program, args->name);; \
    } else { \
        glGetUniformLocation(args->program, args->name);; \
    } \
} while(0)
GLint glGetUniformLocation(glGetUniformLocation_ARG_EXPAND);
packed_call_t *pack_glGetUniformLocation(glGetUniformLocation_PACKED *_dst glGetUniformLocation_ARG_EXPAND_TAIL);
typedef GLint (*glGetUniformLocation_PTR)(glGetUniformLocation_ARG_EXPAND);
#endif
#ifndef glGetUniformLocationARB_RETURN
#define glGetUniformLocationARB_RETURN GLint
#define glGetUniformLocationARB_ARG_NAMES programObj, name
#define glGetUniformLocationARB_ARG_EXPAND GLhandleARB programObj, const GLcharARB * name
#define glGetUniformLocationARB_ARG_NAMES_TAIL , programObj, name
#define glGetUniformLocationARB_ARG_EXPAND_TAIL , GLhandleARB programObj, const GLcharARB * name
#define forward_glGetUniformLocationARB(_programObj, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformLocationARB_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetUniformLocationARB(dst, _programObj, _name), &ret); \
        ret; \
    });
#define call_glGetUniformLocationARB(packed, ret_v) do { \
    glGetUniformLocationARB_PACKED *unpacked = (glGetUniformLocationARB_PACKED *)packed; \
    glGetUniformLocationARB_ARGS *args = (glGetUniformLocationARB_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformLocationARB(args->programObj, args->name);; \
    } else { \
        glGetUniformLocationARB(args->programObj, args->name);; \
    } \
} while(0)
GLint glGetUniformLocationARB(glGetUniformLocationARB_ARG_EXPAND);
packed_call_t *pack_glGetUniformLocationARB(glGetUniformLocationARB_PACKED *_dst glGetUniformLocationARB_ARG_EXPAND_TAIL);
typedef GLint (*glGetUniformLocationARB_PTR)(glGetUniformLocationARB_ARG_EXPAND);
#endif
#ifndef glGetUniformOffsetEXT_RETURN
#define glGetUniformOffsetEXT_RETURN GLintptr
#define glGetUniformOffsetEXT_ARG_NAMES program, location
#define glGetUniformOffsetEXT_ARG_EXPAND GLuint program, GLint location
#define glGetUniformOffsetEXT_ARG_NAMES_TAIL , program, location
#define glGetUniformOffsetEXT_ARG_EXPAND_TAIL , GLuint program, GLint location
#define forward_glGetUniformOffsetEXT(_program, _location) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformOffsetEXT_PACKED)); \
        GLintptr ret = (GLintptr)0; \
        remote_dma_send((packed_call_t *)pack_glGetUniformOffsetEXT(dst, _program, _location), &ret); \
        ret; \
    });
#define call_glGetUniformOffsetEXT(packed, ret_v) do { \
    glGetUniformOffsetEXT_PACKED *unpacked = (glGetUniformOffsetEXT_PACKED *)packed; \
    glGetUniformOffsetEXT_ARGS *args = (glGetUniformOffsetEXT_ARGS *)&unpacked->args; \
    GLintptr *ret = (GLintptr *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformOffsetEXT(args->program, args->location);; \
    } else { \
        glGetUniformOffsetEXT(args->program, args->location);; \
    } \
} while(0)
GLintptr glGetUniformOffsetEXT(glGetUniformOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glGetUniformOffsetEXT(glGetUniformOffsetEXT_PACKED *_dst glGetUniformOffsetEXT_ARG_EXPAND_TAIL);
typedef GLintptr (*glGetUniformOffsetEXT_PTR)(glGetUniformOffsetEXT_ARG_EXPAND);
#endif
#ifndef glGetUniformSubroutineuiv_RETURN
#define glGetUniformSubroutineuiv_RETURN void
#define glGetUniformSubroutineuiv_ARG_NAMES shadertype, location, params
#define glGetUniformSubroutineuiv_ARG_EXPAND GLenum shadertype, GLint location, GLuint * params
#define glGetUniformSubroutineuiv_ARG_NAMES_TAIL , shadertype, location, params
#define glGetUniformSubroutineuiv_ARG_EXPAND_TAIL , GLenum shadertype, GLint location, GLuint * params
#define forward_glGetUniformSubroutineuiv(_shadertype, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformSubroutineuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformSubroutineuiv(dst, _shadertype, _location, _params), NULL); \
    });
#define call_glGetUniformSubroutineuiv(packed, ret_v) do { \
    glGetUniformSubroutineuiv_PACKED *unpacked = (glGetUniformSubroutineuiv_PACKED *)packed; \
    glGetUniformSubroutineuiv_ARGS *args = (glGetUniformSubroutineuiv_ARGS *)&unpacked->args; \
    glGetUniformSubroutineuiv(args->shadertype, args->location, args->params);; \
} while(0)
void glGetUniformSubroutineuiv(glGetUniformSubroutineuiv_ARG_EXPAND);
packed_call_t *pack_glGetUniformSubroutineuiv(glGetUniformSubroutineuiv_PACKED *_dst glGetUniformSubroutineuiv_ARG_EXPAND_TAIL);
typedef void (*glGetUniformSubroutineuiv_PTR)(glGetUniformSubroutineuiv_ARG_EXPAND);
#endif
#ifndef glGetUniformdv_RETURN
#define glGetUniformdv_RETURN void
#define glGetUniformdv_ARG_NAMES program, location, params
#define glGetUniformdv_ARG_EXPAND GLuint program, GLint location, GLdouble * params
#define glGetUniformdv_ARG_NAMES_TAIL , program, location, params
#define glGetUniformdv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble * params
#define forward_glGetUniformdv(_program, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformdv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformdv(dst, _program, _location, _params), NULL); \
    });
#define call_glGetUniformdv(packed, ret_v) do { \
    glGetUniformdv_PACKED *unpacked = (glGetUniformdv_PACKED *)packed; \
    glGetUniformdv_ARGS *args = (glGetUniformdv_ARGS *)&unpacked->args; \
    glGetUniformdv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformdv(glGetUniformdv_ARG_EXPAND);
packed_call_t *pack_glGetUniformdv(glGetUniformdv_PACKED *_dst glGetUniformdv_ARG_EXPAND_TAIL);
typedef void (*glGetUniformdv_PTR)(glGetUniformdv_ARG_EXPAND);
#endif
#ifndef glGetUniformfv_RETURN
#define glGetUniformfv_RETURN void
#define glGetUniformfv_ARG_NAMES program, location, params
#define glGetUniformfv_ARG_EXPAND GLuint program, GLint location, GLfloat * params
#define glGetUniformfv_ARG_NAMES_TAIL , program, location, params
#define glGetUniformfv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat * params
#define forward_glGetUniformfv(_program, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformfv(dst, _program, _location, _params), NULL); \
    });
#define call_glGetUniformfv(packed, ret_v) do { \
    glGetUniformfv_PACKED *unpacked = (glGetUniformfv_PACKED *)packed; \
    glGetUniformfv_ARGS *args = (glGetUniformfv_ARGS *)&unpacked->args; \
    glGetUniformfv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformfv(glGetUniformfv_ARG_EXPAND);
packed_call_t *pack_glGetUniformfv(glGetUniformfv_PACKED *_dst glGetUniformfv_ARG_EXPAND_TAIL);
typedef void (*glGetUniformfv_PTR)(glGetUniformfv_ARG_EXPAND);
#endif
#ifndef glGetUniformfvARB_RETURN
#define glGetUniformfvARB_RETURN void
#define glGetUniformfvARB_ARG_NAMES programObj, location, params
#define glGetUniformfvARB_ARG_EXPAND GLhandleARB programObj, GLint location, GLfloat * params
#define glGetUniformfvARB_ARG_NAMES_TAIL , programObj, location, params
#define glGetUniformfvARB_ARG_EXPAND_TAIL , GLhandleARB programObj, GLint location, GLfloat * params
#define forward_glGetUniformfvARB(_programObj, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformfvARB(dst, _programObj, _location, _params), NULL); \
    });
#define call_glGetUniformfvARB(packed, ret_v) do { \
    glGetUniformfvARB_PACKED *unpacked = (glGetUniformfvARB_PACKED *)packed; \
    glGetUniformfvARB_ARGS *args = (glGetUniformfvARB_ARGS *)&unpacked->args; \
    glGetUniformfvARB(args->programObj, args->location, args->params);; \
} while(0)
void glGetUniformfvARB(glGetUniformfvARB_ARG_EXPAND);
packed_call_t *pack_glGetUniformfvARB(glGetUniformfvARB_PACKED *_dst glGetUniformfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetUniformfvARB_PTR)(glGetUniformfvARB_ARG_EXPAND);
#endif
#ifndef glGetUniformi64vNV_RETURN
#define glGetUniformi64vNV_RETURN void
#define glGetUniformi64vNV_ARG_NAMES program, location, params
#define glGetUniformi64vNV_ARG_EXPAND GLuint program, GLint location, GLint64EXT * params
#define glGetUniformi64vNV_ARG_NAMES_TAIL , program, location, params
#define glGetUniformi64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint64EXT * params
#define forward_glGetUniformi64vNV(_program, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformi64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformi64vNV(dst, _program, _location, _params), NULL); \
    });
#define call_glGetUniformi64vNV(packed, ret_v) do { \
    glGetUniformi64vNV_PACKED *unpacked = (glGetUniformi64vNV_PACKED *)packed; \
    glGetUniformi64vNV_ARGS *args = (glGetUniformi64vNV_ARGS *)&unpacked->args; \
    glGetUniformi64vNV(args->program, args->location, args->params);; \
} while(0)
void glGetUniformi64vNV(glGetUniformi64vNV_ARG_EXPAND);
packed_call_t *pack_glGetUniformi64vNV(glGetUniformi64vNV_PACKED *_dst glGetUniformi64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetUniformi64vNV_PTR)(glGetUniformi64vNV_ARG_EXPAND);
#endif
#ifndef glGetUniformiv_RETURN
#define glGetUniformiv_RETURN void
#define glGetUniformiv_ARG_NAMES program, location, params
#define glGetUniformiv_ARG_EXPAND GLuint program, GLint location, GLint * params
#define glGetUniformiv_ARG_NAMES_TAIL , program, location, params
#define glGetUniformiv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint * params
#define forward_glGetUniformiv(_program, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformiv(dst, _program, _location, _params), NULL); \
    });
#define call_glGetUniformiv(packed, ret_v) do { \
    glGetUniformiv_PACKED *unpacked = (glGetUniformiv_PACKED *)packed; \
    glGetUniformiv_ARGS *args = (glGetUniformiv_ARGS *)&unpacked->args; \
    glGetUniformiv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformiv(glGetUniformiv_ARG_EXPAND);
packed_call_t *pack_glGetUniformiv(glGetUniformiv_PACKED *_dst glGetUniformiv_ARG_EXPAND_TAIL);
typedef void (*glGetUniformiv_PTR)(glGetUniformiv_ARG_EXPAND);
#endif
#ifndef glGetUniformivARB_RETURN
#define glGetUniformivARB_RETURN void
#define glGetUniformivARB_ARG_NAMES programObj, location, params
#define glGetUniformivARB_ARG_EXPAND GLhandleARB programObj, GLint location, GLint * params
#define glGetUniformivARB_ARG_NAMES_TAIL , programObj, location, params
#define glGetUniformivARB_ARG_EXPAND_TAIL , GLhandleARB programObj, GLint location, GLint * params
#define forward_glGetUniformivARB(_programObj, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformivARB(dst, _programObj, _location, _params), NULL); \
    });
#define call_glGetUniformivARB(packed, ret_v) do { \
    glGetUniformivARB_PACKED *unpacked = (glGetUniformivARB_PACKED *)packed; \
    glGetUniformivARB_ARGS *args = (glGetUniformivARB_ARGS *)&unpacked->args; \
    glGetUniformivARB(args->programObj, args->location, args->params);; \
} while(0)
void glGetUniformivARB(glGetUniformivARB_ARG_EXPAND);
packed_call_t *pack_glGetUniformivARB(glGetUniformivARB_PACKED *_dst glGetUniformivARB_ARG_EXPAND_TAIL);
typedef void (*glGetUniformivARB_PTR)(glGetUniformivARB_ARG_EXPAND);
#endif
#ifndef glGetUniformui64vNV_RETURN
#define glGetUniformui64vNV_RETURN void
#define glGetUniformui64vNV_ARG_NAMES program, location, params
#define glGetUniformui64vNV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT * params
#define glGetUniformui64vNV_ARG_NAMES_TAIL , program, location, params
#define glGetUniformui64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint64EXT * params
#define forward_glGetUniformui64vNV(_program, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformui64vNV(dst, _program, _location, _params), NULL); \
    });
#define call_glGetUniformui64vNV(packed, ret_v) do { \
    glGetUniformui64vNV_PACKED *unpacked = (glGetUniformui64vNV_PACKED *)packed; \
    glGetUniformui64vNV_ARGS *args = (glGetUniformui64vNV_ARGS *)&unpacked->args; \
    glGetUniformui64vNV(args->program, args->location, args->params);; \
} while(0)
void glGetUniformui64vNV(glGetUniformui64vNV_ARG_EXPAND);
packed_call_t *pack_glGetUniformui64vNV(glGetUniformui64vNV_PACKED *_dst glGetUniformui64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetUniformui64vNV_PTR)(glGetUniformui64vNV_ARG_EXPAND);
#endif
#ifndef glGetUniformuiv_RETURN
#define glGetUniformuiv_RETURN void
#define glGetUniformuiv_ARG_NAMES program, location, params
#define glGetUniformuiv_ARG_EXPAND GLuint program, GLint location, GLuint * params
#define glGetUniformuiv_ARG_NAMES_TAIL , program, location, params
#define glGetUniformuiv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint * params
#define forward_glGetUniformuiv(_program, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformuiv(dst, _program, _location, _params), NULL); \
    });
#define call_glGetUniformuiv(packed, ret_v) do { \
    glGetUniformuiv_PACKED *unpacked = (glGetUniformuiv_PACKED *)packed; \
    glGetUniformuiv_ARGS *args = (glGetUniformuiv_ARGS *)&unpacked->args; \
    glGetUniformuiv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformuiv(glGetUniformuiv_ARG_EXPAND);
packed_call_t *pack_glGetUniformuiv(glGetUniformuiv_PACKED *_dst glGetUniformuiv_ARG_EXPAND_TAIL);
typedef void (*glGetUniformuiv_PTR)(glGetUniformuiv_ARG_EXPAND);
#endif
#ifndef glGetUniformuivEXT_RETURN
#define glGetUniformuivEXT_RETURN void
#define glGetUniformuivEXT_ARG_NAMES program, location, params
#define glGetUniformuivEXT_ARG_EXPAND GLuint program, GLint location, GLuint * params
#define glGetUniformuivEXT_ARG_NAMES_TAIL , program, location, params
#define glGetUniformuivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint * params
#define forward_glGetUniformuivEXT(_program, _location, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetUniformuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetUniformuivEXT(dst, _program, _location, _params), NULL); \
    });
#define call_glGetUniformuivEXT(packed, ret_v) do { \
    glGetUniformuivEXT_PACKED *unpacked = (glGetUniformuivEXT_PACKED *)packed; \
    glGetUniformuivEXT_ARGS *args = (glGetUniformuivEXT_ARGS *)&unpacked->args; \
    glGetUniformuivEXT(args->program, args->location, args->params);; \
} while(0)
void glGetUniformuivEXT(glGetUniformuivEXT_ARG_EXPAND);
packed_call_t *pack_glGetUniformuivEXT(glGetUniformuivEXT_PACKED *_dst glGetUniformuivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetUniformuivEXT_PTR)(glGetUniformuivEXT_ARG_EXPAND);
#endif
#ifndef glGetVariantArrayObjectfvATI_RETURN
#define glGetVariantArrayObjectfvATI_RETURN void
#define glGetVariantArrayObjectfvATI_ARG_NAMES id, pname, params
#define glGetVariantArrayObjectfvATI_ARG_EXPAND GLuint id, GLenum pname, GLfloat * params
#define glGetVariantArrayObjectfvATI_ARG_NAMES_TAIL , id, pname, params
#define glGetVariantArrayObjectfvATI_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLfloat * params
#define forward_glGetVariantArrayObjectfvATI(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVariantArrayObjectfvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVariantArrayObjectfvATI(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetVariantArrayObjectfvATI(packed, ret_v) do { \
    glGetVariantArrayObjectfvATI_PACKED *unpacked = (glGetVariantArrayObjectfvATI_PACKED *)packed; \
    glGetVariantArrayObjectfvATI_ARGS *args = (glGetVariantArrayObjectfvATI_ARGS *)&unpacked->args; \
    glGetVariantArrayObjectfvATI(args->id, args->pname, args->params);; \
} while(0)
void glGetVariantArrayObjectfvATI(glGetVariantArrayObjectfvATI_ARG_EXPAND);
packed_call_t *pack_glGetVariantArrayObjectfvATI(glGetVariantArrayObjectfvATI_PACKED *_dst glGetVariantArrayObjectfvATI_ARG_EXPAND_TAIL);
typedef void (*glGetVariantArrayObjectfvATI_PTR)(glGetVariantArrayObjectfvATI_ARG_EXPAND);
#endif
#ifndef glGetVariantArrayObjectivATI_RETURN
#define glGetVariantArrayObjectivATI_RETURN void
#define glGetVariantArrayObjectivATI_ARG_NAMES id, pname, params
#define glGetVariantArrayObjectivATI_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetVariantArrayObjectivATI_ARG_NAMES_TAIL , id, pname, params
#define glGetVariantArrayObjectivATI_ARG_EXPAND_TAIL , GLuint id, GLenum pname, GLint * params
#define forward_glGetVariantArrayObjectivATI(_id, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVariantArrayObjectivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVariantArrayObjectivATI(dst, _id, _pname, _params), NULL); \
    });
#define call_glGetVariantArrayObjectivATI(packed, ret_v) do { \
    glGetVariantArrayObjectivATI_PACKED *unpacked = (glGetVariantArrayObjectivATI_PACKED *)packed; \
    glGetVariantArrayObjectivATI_ARGS *args = (glGetVariantArrayObjectivATI_ARGS *)&unpacked->args; \
    glGetVariantArrayObjectivATI(args->id, args->pname, args->params);; \
} while(0)
void glGetVariantArrayObjectivATI(glGetVariantArrayObjectivATI_ARG_EXPAND);
packed_call_t *pack_glGetVariantArrayObjectivATI(glGetVariantArrayObjectivATI_PACKED *_dst glGetVariantArrayObjectivATI_ARG_EXPAND_TAIL);
typedef void (*glGetVariantArrayObjectivATI_PTR)(glGetVariantArrayObjectivATI_ARG_EXPAND);
#endif
#ifndef glGetVariantBooleanvEXT_RETURN
#define glGetVariantBooleanvEXT_RETURN void
#define glGetVariantBooleanvEXT_ARG_NAMES id, value, data
#define glGetVariantBooleanvEXT_ARG_EXPAND GLuint id, GLenum value, GLboolean * data
#define glGetVariantBooleanvEXT_ARG_NAMES_TAIL , id, value, data
#define glGetVariantBooleanvEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLboolean * data
#define forward_glGetVariantBooleanvEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVariantBooleanvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVariantBooleanvEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetVariantBooleanvEXT(packed, ret_v) do { \
    glGetVariantBooleanvEXT_PACKED *unpacked = (glGetVariantBooleanvEXT_PACKED *)packed; \
    glGetVariantBooleanvEXT_ARGS *args = (glGetVariantBooleanvEXT_ARGS *)&unpacked->args; \
    glGetVariantBooleanvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantBooleanvEXT(glGetVariantBooleanvEXT_ARG_EXPAND);
packed_call_t *pack_glGetVariantBooleanvEXT(glGetVariantBooleanvEXT_PACKED *_dst glGetVariantBooleanvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVariantBooleanvEXT_PTR)(glGetVariantBooleanvEXT_ARG_EXPAND);
#endif
#ifndef glGetVariantFloatvEXT_RETURN
#define glGetVariantFloatvEXT_RETURN void
#define glGetVariantFloatvEXT_ARG_NAMES id, value, data
#define glGetVariantFloatvEXT_ARG_EXPAND GLuint id, GLenum value, GLfloat * data
#define glGetVariantFloatvEXT_ARG_NAMES_TAIL , id, value, data
#define glGetVariantFloatvEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLfloat * data
#define forward_glGetVariantFloatvEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVariantFloatvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVariantFloatvEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetVariantFloatvEXT(packed, ret_v) do { \
    glGetVariantFloatvEXT_PACKED *unpacked = (glGetVariantFloatvEXT_PACKED *)packed; \
    glGetVariantFloatvEXT_ARGS *args = (glGetVariantFloatvEXT_ARGS *)&unpacked->args; \
    glGetVariantFloatvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantFloatvEXT(glGetVariantFloatvEXT_ARG_EXPAND);
packed_call_t *pack_glGetVariantFloatvEXT(glGetVariantFloatvEXT_PACKED *_dst glGetVariantFloatvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVariantFloatvEXT_PTR)(glGetVariantFloatvEXT_ARG_EXPAND);
#endif
#ifndef glGetVariantIntegervEXT_RETURN
#define glGetVariantIntegervEXT_RETURN void
#define glGetVariantIntegervEXT_ARG_NAMES id, value, data
#define glGetVariantIntegervEXT_ARG_EXPAND GLuint id, GLenum value, GLint * data
#define glGetVariantIntegervEXT_ARG_NAMES_TAIL , id, value, data
#define glGetVariantIntegervEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLint * data
#define forward_glGetVariantIntegervEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVariantIntegervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVariantIntegervEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetVariantIntegervEXT(packed, ret_v) do { \
    glGetVariantIntegervEXT_PACKED *unpacked = (glGetVariantIntegervEXT_PACKED *)packed; \
    glGetVariantIntegervEXT_ARGS *args = (glGetVariantIntegervEXT_ARGS *)&unpacked->args; \
    glGetVariantIntegervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantIntegervEXT(glGetVariantIntegervEXT_ARG_EXPAND);
packed_call_t *pack_glGetVariantIntegervEXT(glGetVariantIntegervEXT_PACKED *_dst glGetVariantIntegervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVariantIntegervEXT_PTR)(glGetVariantIntegervEXT_ARG_EXPAND);
#endif
#ifndef glGetVariantPointervEXT_RETURN
#define glGetVariantPointervEXT_RETURN void
#define glGetVariantPointervEXT_ARG_NAMES id, value, data
#define glGetVariantPointervEXT_ARG_EXPAND GLuint id, GLenum value, GLvoid * data
#define glGetVariantPointervEXT_ARG_NAMES_TAIL , id, value, data
#define glGetVariantPointervEXT_ARG_EXPAND_TAIL , GLuint id, GLenum value, GLvoid * data
#define forward_glGetVariantPointervEXT(_id, _value, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVariantPointervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVariantPointervEXT(dst, _id, _value, _data), NULL); \
    });
#define call_glGetVariantPointervEXT(packed, ret_v) do { \
    glGetVariantPointervEXT_PACKED *unpacked = (glGetVariantPointervEXT_PACKED *)packed; \
    glGetVariantPointervEXT_ARGS *args = (glGetVariantPointervEXT_ARGS *)&unpacked->args; \
    glGetVariantPointervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantPointervEXT(glGetVariantPointervEXT_ARG_EXPAND);
packed_call_t *pack_glGetVariantPointervEXT(glGetVariantPointervEXT_PACKED *_dst glGetVariantPointervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVariantPointervEXT_PTR)(glGetVariantPointervEXT_ARG_EXPAND);
#endif
#ifndef glGetVaryingLocationNV_RETURN
#define glGetVaryingLocationNV_RETURN GLint
#define glGetVaryingLocationNV_ARG_NAMES program, name
#define glGetVaryingLocationNV_ARG_EXPAND GLuint program, const GLchar * name
#define glGetVaryingLocationNV_ARG_NAMES_TAIL , program, name
#define glGetVaryingLocationNV_ARG_EXPAND_TAIL , GLuint program, const GLchar * name
#define forward_glGetVaryingLocationNV(_program, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVaryingLocationNV_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glGetVaryingLocationNV(dst, _program, _name), &ret); \
        ret; \
    });
#define call_glGetVaryingLocationNV(packed, ret_v) do { \
    glGetVaryingLocationNV_PACKED *unpacked = (glGetVaryingLocationNV_PACKED *)packed; \
    glGetVaryingLocationNV_ARGS *args = (glGetVaryingLocationNV_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetVaryingLocationNV(args->program, args->name);; \
    } else { \
        glGetVaryingLocationNV(args->program, args->name);; \
    } \
} while(0)
GLint glGetVaryingLocationNV(glGetVaryingLocationNV_ARG_EXPAND);
packed_call_t *pack_glGetVaryingLocationNV(glGetVaryingLocationNV_PACKED *_dst glGetVaryingLocationNV_ARG_EXPAND_TAIL);
typedef GLint (*glGetVaryingLocationNV_PTR)(glGetVaryingLocationNV_ARG_EXPAND);
#endif
#ifndef glGetVertexArrayIntegeri_vEXT_RETURN
#define glGetVertexArrayIntegeri_vEXT_RETURN void
#define glGetVertexArrayIntegeri_vEXT_ARG_NAMES vaobj, index, pname, param
#define glGetVertexArrayIntegeri_vEXT_ARG_EXPAND GLuint vaobj, GLuint index, GLenum pname, GLint * param
#define glGetVertexArrayIntegeri_vEXT_ARG_NAMES_TAIL , vaobj, index, pname, param
#define glGetVertexArrayIntegeri_vEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint index, GLenum pname, GLint * param
#define forward_glGetVertexArrayIntegeri_vEXT(_vaobj, _index, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexArrayIntegeri_vEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexArrayIntegeri_vEXT(dst, _vaobj, _index, _pname, _param), NULL); \
    });
#define call_glGetVertexArrayIntegeri_vEXT(packed, ret_v) do { \
    glGetVertexArrayIntegeri_vEXT_PACKED *unpacked = (glGetVertexArrayIntegeri_vEXT_PACKED *)packed; \
    glGetVertexArrayIntegeri_vEXT_ARGS *args = (glGetVertexArrayIntegeri_vEXT_ARGS *)&unpacked->args; \
    glGetVertexArrayIntegeri_vEXT(args->vaobj, args->index, args->pname, args->param);; \
} while(0)
void glGetVertexArrayIntegeri_vEXT(glGetVertexArrayIntegeri_vEXT_ARG_EXPAND);
packed_call_t *pack_glGetVertexArrayIntegeri_vEXT(glGetVertexArrayIntegeri_vEXT_PACKED *_dst glGetVertexArrayIntegeri_vEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVertexArrayIntegeri_vEXT_PTR)(glGetVertexArrayIntegeri_vEXT_ARG_EXPAND);
#endif
#ifndef glGetVertexArrayIntegervEXT_RETURN
#define glGetVertexArrayIntegervEXT_RETURN void
#define glGetVertexArrayIntegervEXT_ARG_NAMES vaobj, pname, param
#define glGetVertexArrayIntegervEXT_ARG_EXPAND GLuint vaobj, GLenum pname, GLint * param
#define glGetVertexArrayIntegervEXT_ARG_NAMES_TAIL , vaobj, pname, param
#define glGetVertexArrayIntegervEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLenum pname, GLint * param
#define forward_glGetVertexArrayIntegervEXT(_vaobj, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexArrayIntegervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexArrayIntegervEXT(dst, _vaobj, _pname, _param), NULL); \
    });
#define call_glGetVertexArrayIntegervEXT(packed, ret_v) do { \
    glGetVertexArrayIntegervEXT_PACKED *unpacked = (glGetVertexArrayIntegervEXT_PACKED *)packed; \
    glGetVertexArrayIntegervEXT_ARGS *args = (glGetVertexArrayIntegervEXT_ARGS *)&unpacked->args; \
    glGetVertexArrayIntegervEXT(args->vaobj, args->pname, args->param);; \
} while(0)
void glGetVertexArrayIntegervEXT(glGetVertexArrayIntegervEXT_ARG_EXPAND);
packed_call_t *pack_glGetVertexArrayIntegervEXT(glGetVertexArrayIntegervEXT_PACKED *_dst glGetVertexArrayIntegervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVertexArrayIntegervEXT_PTR)(glGetVertexArrayIntegervEXT_ARG_EXPAND);
#endif
#ifndef glGetVertexArrayPointeri_vEXT_RETURN
#define glGetVertexArrayPointeri_vEXT_RETURN void
#define glGetVertexArrayPointeri_vEXT_ARG_NAMES vaobj, index, pname, param
#define glGetVertexArrayPointeri_vEXT_ARG_EXPAND GLuint vaobj, GLuint index, GLenum pname, GLvoid * param
#define glGetVertexArrayPointeri_vEXT_ARG_NAMES_TAIL , vaobj, index, pname, param
#define glGetVertexArrayPointeri_vEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint index, GLenum pname, GLvoid * param
#define forward_glGetVertexArrayPointeri_vEXT(_vaobj, _index, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexArrayPointeri_vEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexArrayPointeri_vEXT(dst, _vaobj, _index, _pname, _param), NULL); \
    });
#define call_glGetVertexArrayPointeri_vEXT(packed, ret_v) do { \
    glGetVertexArrayPointeri_vEXT_PACKED *unpacked = (glGetVertexArrayPointeri_vEXT_PACKED *)packed; \
    glGetVertexArrayPointeri_vEXT_ARGS *args = (glGetVertexArrayPointeri_vEXT_ARGS *)&unpacked->args; \
    glGetVertexArrayPointeri_vEXT(args->vaobj, args->index, args->pname, args->param);; \
} while(0)
void glGetVertexArrayPointeri_vEXT(glGetVertexArrayPointeri_vEXT_ARG_EXPAND);
packed_call_t *pack_glGetVertexArrayPointeri_vEXT(glGetVertexArrayPointeri_vEXT_PACKED *_dst glGetVertexArrayPointeri_vEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVertexArrayPointeri_vEXT_PTR)(glGetVertexArrayPointeri_vEXT_ARG_EXPAND);
#endif
#ifndef glGetVertexArrayPointervEXT_RETURN
#define glGetVertexArrayPointervEXT_RETURN void
#define glGetVertexArrayPointervEXT_ARG_NAMES vaobj, pname, param
#define glGetVertexArrayPointervEXT_ARG_EXPAND GLuint vaobj, GLenum pname, GLvoid * param
#define glGetVertexArrayPointervEXT_ARG_NAMES_TAIL , vaobj, pname, param
#define glGetVertexArrayPointervEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLenum pname, GLvoid * param
#define forward_glGetVertexArrayPointervEXT(_vaobj, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexArrayPointervEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexArrayPointervEXT(dst, _vaobj, _pname, _param), NULL); \
    });
#define call_glGetVertexArrayPointervEXT(packed, ret_v) do { \
    glGetVertexArrayPointervEXT_PACKED *unpacked = (glGetVertexArrayPointervEXT_PACKED *)packed; \
    glGetVertexArrayPointervEXT_ARGS *args = (glGetVertexArrayPointervEXT_ARGS *)&unpacked->args; \
    glGetVertexArrayPointervEXT(args->vaobj, args->pname, args->param);; \
} while(0)
void glGetVertexArrayPointervEXT(glGetVertexArrayPointervEXT_ARG_EXPAND);
packed_call_t *pack_glGetVertexArrayPointervEXT(glGetVertexArrayPointervEXT_PACKED *_dst glGetVertexArrayPointervEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVertexArrayPointervEXT_PTR)(glGetVertexArrayPointervEXT_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribArrayObjectfvATI_RETURN
#define glGetVertexAttribArrayObjectfvATI_RETURN void
#define glGetVertexAttribArrayObjectfvATI_ARG_NAMES index, pname, params
#define glGetVertexAttribArrayObjectfvATI_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribArrayObjectfvATI_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribArrayObjectfvATI_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLfloat * params
#define forward_glGetVertexAttribArrayObjectfvATI(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribArrayObjectfvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribArrayObjectfvATI(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribArrayObjectfvATI(packed, ret_v) do { \
    glGetVertexAttribArrayObjectfvATI_PACKED *unpacked = (glGetVertexAttribArrayObjectfvATI_PACKED *)packed; \
    glGetVertexAttribArrayObjectfvATI_ARGS *args = (glGetVertexAttribArrayObjectfvATI_ARGS *)&unpacked->args; \
    glGetVertexAttribArrayObjectfvATI(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribArrayObjectfvATI(glGetVertexAttribArrayObjectfvATI_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribArrayObjectfvATI(glGetVertexAttribArrayObjectfvATI_PACKED *_dst glGetVertexAttribArrayObjectfvATI_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribArrayObjectfvATI_PTR)(glGetVertexAttribArrayObjectfvATI_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribArrayObjectivATI_RETURN
#define glGetVertexAttribArrayObjectivATI_RETURN void
#define glGetVertexAttribArrayObjectivATI_ARG_NAMES index, pname, params
#define glGetVertexAttribArrayObjectivATI_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribArrayObjectivATI_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribArrayObjectivATI_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLint * params
#define forward_glGetVertexAttribArrayObjectivATI(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribArrayObjectivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribArrayObjectivATI(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribArrayObjectivATI(packed, ret_v) do { \
    glGetVertexAttribArrayObjectivATI_PACKED *unpacked = (glGetVertexAttribArrayObjectivATI_PACKED *)packed; \
    glGetVertexAttribArrayObjectivATI_ARGS *args = (glGetVertexAttribArrayObjectivATI_ARGS *)&unpacked->args; \
    glGetVertexAttribArrayObjectivATI(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribArrayObjectivATI(glGetVertexAttribArrayObjectivATI_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribArrayObjectivATI(glGetVertexAttribArrayObjectivATI_PACKED *_dst glGetVertexAttribArrayObjectivATI_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribArrayObjectivATI_PTR)(glGetVertexAttribArrayObjectivATI_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribIiv_RETURN
#define glGetVertexAttribIiv_RETURN void
#define glGetVertexAttribIiv_ARG_NAMES index, pname, params
#define glGetVertexAttribIiv_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribIiv_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribIiv_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLint * params
#define forward_glGetVertexAttribIiv(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribIiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribIiv(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribIiv(packed, ret_v) do { \
    glGetVertexAttribIiv_PACKED *unpacked = (glGetVertexAttribIiv_PACKED *)packed; \
    glGetVertexAttribIiv_ARGS *args = (glGetVertexAttribIiv_ARGS *)&unpacked->args; \
    glGetVertexAttribIiv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIiv(glGetVertexAttribIiv_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribIiv(glGetVertexAttribIiv_PACKED *_dst glGetVertexAttribIiv_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribIiv_PTR)(glGetVertexAttribIiv_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribIivEXT_RETURN
#define glGetVertexAttribIivEXT_RETURN void
#define glGetVertexAttribIivEXT_ARG_NAMES index, pname, params
#define glGetVertexAttribIivEXT_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribIivEXT_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribIivEXT_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLint * params
#define forward_glGetVertexAttribIivEXT(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribIivEXT(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribIivEXT(packed, ret_v) do { \
    glGetVertexAttribIivEXT_PACKED *unpacked = (glGetVertexAttribIivEXT_PACKED *)packed; \
    glGetVertexAttribIivEXT_ARGS *args = (glGetVertexAttribIivEXT_ARGS *)&unpacked->args; \
    glGetVertexAttribIivEXT(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIivEXT(glGetVertexAttribIivEXT_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribIivEXT(glGetVertexAttribIivEXT_PACKED *_dst glGetVertexAttribIivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribIivEXT_PTR)(glGetVertexAttribIivEXT_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribIuiv_RETURN
#define glGetVertexAttribIuiv_RETURN void
#define glGetVertexAttribIuiv_ARG_NAMES index, pname, params
#define glGetVertexAttribIuiv_ARG_EXPAND GLuint index, GLenum pname, GLuint * params
#define glGetVertexAttribIuiv_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribIuiv_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLuint * params
#define forward_glGetVertexAttribIuiv(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribIuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribIuiv(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribIuiv(packed, ret_v) do { \
    glGetVertexAttribIuiv_PACKED *unpacked = (glGetVertexAttribIuiv_PACKED *)packed; \
    glGetVertexAttribIuiv_ARGS *args = (glGetVertexAttribIuiv_ARGS *)&unpacked->args; \
    glGetVertexAttribIuiv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIuiv(glGetVertexAttribIuiv_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribIuiv(glGetVertexAttribIuiv_PACKED *_dst glGetVertexAttribIuiv_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribIuiv_PTR)(glGetVertexAttribIuiv_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribIuivEXT_RETURN
#define glGetVertexAttribIuivEXT_RETURN void
#define glGetVertexAttribIuivEXT_ARG_NAMES index, pname, params
#define glGetVertexAttribIuivEXT_ARG_EXPAND GLuint index, GLenum pname, GLuint * params
#define glGetVertexAttribIuivEXT_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribIuivEXT_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLuint * params
#define forward_glGetVertexAttribIuivEXT(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribIuivEXT(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribIuivEXT(packed, ret_v) do { \
    glGetVertexAttribIuivEXT_PACKED *unpacked = (glGetVertexAttribIuivEXT_PACKED *)packed; \
    glGetVertexAttribIuivEXT_ARGS *args = (glGetVertexAttribIuivEXT_ARGS *)&unpacked->args; \
    glGetVertexAttribIuivEXT(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIuivEXT(glGetVertexAttribIuivEXT_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribIuivEXT(glGetVertexAttribIuivEXT_PACKED *_dst glGetVertexAttribIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribIuivEXT_PTR)(glGetVertexAttribIuivEXT_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribLdv_RETURN
#define glGetVertexAttribLdv_RETURN void
#define glGetVertexAttribLdv_ARG_NAMES index, pname, params
#define glGetVertexAttribLdv_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribLdv_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribLdv_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLdouble * params
#define forward_glGetVertexAttribLdv(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribLdv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribLdv(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribLdv(packed, ret_v) do { \
    glGetVertexAttribLdv_PACKED *unpacked = (glGetVertexAttribLdv_PACKED *)packed; \
    glGetVertexAttribLdv_ARGS *args = (glGetVertexAttribLdv_ARGS *)&unpacked->args; \
    glGetVertexAttribLdv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLdv(glGetVertexAttribLdv_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribLdv(glGetVertexAttribLdv_PACKED *_dst glGetVertexAttribLdv_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribLdv_PTR)(glGetVertexAttribLdv_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribLdvEXT_RETURN
#define glGetVertexAttribLdvEXT_RETURN void
#define glGetVertexAttribLdvEXT_ARG_NAMES index, pname, params
#define glGetVertexAttribLdvEXT_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribLdvEXT_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribLdvEXT_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLdouble * params
#define forward_glGetVertexAttribLdvEXT(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribLdvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribLdvEXT(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribLdvEXT(packed, ret_v) do { \
    glGetVertexAttribLdvEXT_PACKED *unpacked = (glGetVertexAttribLdvEXT_PACKED *)packed; \
    glGetVertexAttribLdvEXT_ARGS *args = (glGetVertexAttribLdvEXT_ARGS *)&unpacked->args; \
    glGetVertexAttribLdvEXT(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLdvEXT(glGetVertexAttribLdvEXT_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribLdvEXT(glGetVertexAttribLdvEXT_PACKED *_dst glGetVertexAttribLdvEXT_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribLdvEXT_PTR)(glGetVertexAttribLdvEXT_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribLi64vNV_RETURN
#define glGetVertexAttribLi64vNV_RETURN void
#define glGetVertexAttribLi64vNV_ARG_NAMES index, pname, params
#define glGetVertexAttribLi64vNV_ARG_EXPAND GLuint index, GLenum pname, GLint64EXT * params
#define glGetVertexAttribLi64vNV_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribLi64vNV_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLint64EXT * params
#define forward_glGetVertexAttribLi64vNV(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribLi64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribLi64vNV(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribLi64vNV(packed, ret_v) do { \
    glGetVertexAttribLi64vNV_PACKED *unpacked = (glGetVertexAttribLi64vNV_PACKED *)packed; \
    glGetVertexAttribLi64vNV_ARGS *args = (glGetVertexAttribLi64vNV_ARGS *)&unpacked->args; \
    glGetVertexAttribLi64vNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLi64vNV(glGetVertexAttribLi64vNV_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribLi64vNV(glGetVertexAttribLi64vNV_PACKED *_dst glGetVertexAttribLi64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribLi64vNV_PTR)(glGetVertexAttribLi64vNV_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribLui64vNV_RETURN
#define glGetVertexAttribLui64vNV_RETURN void
#define glGetVertexAttribLui64vNV_ARG_NAMES index, pname, params
#define glGetVertexAttribLui64vNV_ARG_EXPAND GLuint index, GLenum pname, GLuint64EXT * params
#define glGetVertexAttribLui64vNV_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribLui64vNV_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLuint64EXT * params
#define forward_glGetVertexAttribLui64vNV(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribLui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribLui64vNV(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribLui64vNV(packed, ret_v) do { \
    glGetVertexAttribLui64vNV_PACKED *unpacked = (glGetVertexAttribLui64vNV_PACKED *)packed; \
    glGetVertexAttribLui64vNV_ARGS *args = (glGetVertexAttribLui64vNV_ARGS *)&unpacked->args; \
    glGetVertexAttribLui64vNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLui64vNV(glGetVertexAttribLui64vNV_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribLui64vNV(glGetVertexAttribLui64vNV_PACKED *_dst glGetVertexAttribLui64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribLui64vNV_PTR)(glGetVertexAttribLui64vNV_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribPointerv_RETURN
#define glGetVertexAttribPointerv_RETURN void
#define glGetVertexAttribPointerv_ARG_NAMES index, pname, pointer
#define glGetVertexAttribPointerv_ARG_EXPAND GLuint index, GLenum pname, GLvoid ** pointer
#define glGetVertexAttribPointerv_ARG_NAMES_TAIL , index, pname, pointer
#define glGetVertexAttribPointerv_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLvoid ** pointer
#define forward_glGetVertexAttribPointerv(_index, _pname, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribPointerv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribPointerv(dst, _index, _pname, _pointer), NULL); \
    });
#define call_glGetVertexAttribPointerv(packed, ret_v) do { \
    glGetVertexAttribPointerv_PACKED *unpacked = (glGetVertexAttribPointerv_PACKED *)packed; \
    glGetVertexAttribPointerv_ARGS *args = (glGetVertexAttribPointerv_ARGS *)&unpacked->args; \
    glGetVertexAttribPointerv(args->index, args->pname, args->pointer);; \
} while(0)
void glGetVertexAttribPointerv(glGetVertexAttribPointerv_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribPointerv(glGetVertexAttribPointerv_PACKED *_dst glGetVertexAttribPointerv_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribPointerv_PTR)(glGetVertexAttribPointerv_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribPointervARB_RETURN
#define glGetVertexAttribPointervARB_RETURN void
#define glGetVertexAttribPointervARB_ARG_NAMES index, pname, pointer
#define glGetVertexAttribPointervARB_ARG_EXPAND GLuint index, GLenum pname, GLvoid ** pointer
#define glGetVertexAttribPointervARB_ARG_NAMES_TAIL , index, pname, pointer
#define glGetVertexAttribPointervARB_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLvoid ** pointer
#define forward_glGetVertexAttribPointervARB(_index, _pname, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribPointervARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribPointervARB(dst, _index, _pname, _pointer), NULL); \
    });
#define call_glGetVertexAttribPointervARB(packed, ret_v) do { \
    glGetVertexAttribPointervARB_PACKED *unpacked = (glGetVertexAttribPointervARB_PACKED *)packed; \
    glGetVertexAttribPointervARB_ARGS *args = (glGetVertexAttribPointervARB_ARGS *)&unpacked->args; \
    glGetVertexAttribPointervARB(args->index, args->pname, args->pointer);; \
} while(0)
void glGetVertexAttribPointervARB(glGetVertexAttribPointervARB_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribPointervARB(glGetVertexAttribPointervARB_PACKED *_dst glGetVertexAttribPointervARB_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribPointervARB_PTR)(glGetVertexAttribPointervARB_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribPointervNV_RETURN
#define glGetVertexAttribPointervNV_RETURN void
#define glGetVertexAttribPointervNV_ARG_NAMES index, pname, pointer
#define glGetVertexAttribPointervNV_ARG_EXPAND GLuint index, GLenum pname, GLvoid ** pointer
#define glGetVertexAttribPointervNV_ARG_NAMES_TAIL , index, pname, pointer
#define glGetVertexAttribPointervNV_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLvoid ** pointer
#define forward_glGetVertexAttribPointervNV(_index, _pname, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribPointervNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribPointervNV(dst, _index, _pname, _pointer), NULL); \
    });
#define call_glGetVertexAttribPointervNV(packed, ret_v) do { \
    glGetVertexAttribPointervNV_PACKED *unpacked = (glGetVertexAttribPointervNV_PACKED *)packed; \
    glGetVertexAttribPointervNV_ARGS *args = (glGetVertexAttribPointervNV_ARGS *)&unpacked->args; \
    glGetVertexAttribPointervNV(args->index, args->pname, args->pointer);; \
} while(0)
void glGetVertexAttribPointervNV(glGetVertexAttribPointervNV_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribPointervNV(glGetVertexAttribPointervNV_PACKED *_dst glGetVertexAttribPointervNV_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribPointervNV_PTR)(glGetVertexAttribPointervNV_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribdv_RETURN
#define glGetVertexAttribdv_RETURN void
#define glGetVertexAttribdv_ARG_NAMES index, pname, params
#define glGetVertexAttribdv_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribdv_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribdv_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLdouble * params
#define forward_glGetVertexAttribdv(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribdv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribdv(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribdv(packed, ret_v) do { \
    glGetVertexAttribdv_PACKED *unpacked = (glGetVertexAttribdv_PACKED *)packed; \
    glGetVertexAttribdv_ARGS *args = (glGetVertexAttribdv_ARGS *)&unpacked->args; \
    glGetVertexAttribdv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribdv(glGetVertexAttribdv_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribdv(glGetVertexAttribdv_PACKED *_dst glGetVertexAttribdv_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribdv_PTR)(glGetVertexAttribdv_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribdvARB_RETURN
#define glGetVertexAttribdvARB_RETURN void
#define glGetVertexAttribdvARB_ARG_NAMES index, pname, params
#define glGetVertexAttribdvARB_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribdvARB_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribdvARB_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLdouble * params
#define forward_glGetVertexAttribdvARB(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribdvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribdvARB(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribdvARB(packed, ret_v) do { \
    glGetVertexAttribdvARB_PACKED *unpacked = (glGetVertexAttribdvARB_PACKED *)packed; \
    glGetVertexAttribdvARB_ARGS *args = (glGetVertexAttribdvARB_ARGS *)&unpacked->args; \
    glGetVertexAttribdvARB(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribdvARB(glGetVertexAttribdvARB_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribdvARB(glGetVertexAttribdvARB_PACKED *_dst glGetVertexAttribdvARB_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribdvARB_PTR)(glGetVertexAttribdvARB_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribdvNV_RETURN
#define glGetVertexAttribdvNV_RETURN void
#define glGetVertexAttribdvNV_ARG_NAMES index, pname, params
#define glGetVertexAttribdvNV_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribdvNV_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribdvNV_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLdouble * params
#define forward_glGetVertexAttribdvNV(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribdvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribdvNV(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribdvNV(packed, ret_v) do { \
    glGetVertexAttribdvNV_PACKED *unpacked = (glGetVertexAttribdvNV_PACKED *)packed; \
    glGetVertexAttribdvNV_ARGS *args = (glGetVertexAttribdvNV_ARGS *)&unpacked->args; \
    glGetVertexAttribdvNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribdvNV(glGetVertexAttribdvNV_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribdvNV(glGetVertexAttribdvNV_PACKED *_dst glGetVertexAttribdvNV_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribdvNV_PTR)(glGetVertexAttribdvNV_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribfv_RETURN
#define glGetVertexAttribfv_RETURN void
#define glGetVertexAttribfv_ARG_NAMES index, pname, params
#define glGetVertexAttribfv_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribfv_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribfv_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLfloat * params
#define forward_glGetVertexAttribfv(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribfv(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribfv(packed, ret_v) do { \
    glGetVertexAttribfv_PACKED *unpacked = (glGetVertexAttribfv_PACKED *)packed; \
    glGetVertexAttribfv_ARGS *args = (glGetVertexAttribfv_ARGS *)&unpacked->args; \
    glGetVertexAttribfv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribfv(glGetVertexAttribfv_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribfv(glGetVertexAttribfv_PACKED *_dst glGetVertexAttribfv_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribfv_PTR)(glGetVertexAttribfv_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribfvARB_RETURN
#define glGetVertexAttribfvARB_RETURN void
#define glGetVertexAttribfvARB_ARG_NAMES index, pname, params
#define glGetVertexAttribfvARB_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribfvARB_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribfvARB_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLfloat * params
#define forward_glGetVertexAttribfvARB(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribfvARB(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribfvARB(packed, ret_v) do { \
    glGetVertexAttribfvARB_PACKED *unpacked = (glGetVertexAttribfvARB_PACKED *)packed; \
    glGetVertexAttribfvARB_ARGS *args = (glGetVertexAttribfvARB_ARGS *)&unpacked->args; \
    glGetVertexAttribfvARB(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribfvARB(glGetVertexAttribfvARB_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribfvARB(glGetVertexAttribfvARB_PACKED *_dst glGetVertexAttribfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribfvARB_PTR)(glGetVertexAttribfvARB_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribfvNV_RETURN
#define glGetVertexAttribfvNV_RETURN void
#define glGetVertexAttribfvNV_ARG_NAMES index, pname, params
#define glGetVertexAttribfvNV_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribfvNV_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribfvNV_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLfloat * params
#define forward_glGetVertexAttribfvNV(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribfvNV(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribfvNV(packed, ret_v) do { \
    glGetVertexAttribfvNV_PACKED *unpacked = (glGetVertexAttribfvNV_PACKED *)packed; \
    glGetVertexAttribfvNV_ARGS *args = (glGetVertexAttribfvNV_ARGS *)&unpacked->args; \
    glGetVertexAttribfvNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribfvNV(glGetVertexAttribfvNV_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribfvNV(glGetVertexAttribfvNV_PACKED *_dst glGetVertexAttribfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribfvNV_PTR)(glGetVertexAttribfvNV_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribiv_RETURN
#define glGetVertexAttribiv_RETURN void
#define glGetVertexAttribiv_ARG_NAMES index, pname, params
#define glGetVertexAttribiv_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribiv_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribiv_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLint * params
#define forward_glGetVertexAttribiv(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribiv(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribiv(packed, ret_v) do { \
    glGetVertexAttribiv_PACKED *unpacked = (glGetVertexAttribiv_PACKED *)packed; \
    glGetVertexAttribiv_ARGS *args = (glGetVertexAttribiv_ARGS *)&unpacked->args; \
    glGetVertexAttribiv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribiv(glGetVertexAttribiv_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribiv(glGetVertexAttribiv_PACKED *_dst glGetVertexAttribiv_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribiv_PTR)(glGetVertexAttribiv_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribivARB_RETURN
#define glGetVertexAttribivARB_RETURN void
#define glGetVertexAttribivARB_ARG_NAMES index, pname, params
#define glGetVertexAttribivARB_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribivARB_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribivARB_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLint * params
#define forward_glGetVertexAttribivARB(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribivARB(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribivARB(packed, ret_v) do { \
    glGetVertexAttribivARB_PACKED *unpacked = (glGetVertexAttribivARB_PACKED *)packed; \
    glGetVertexAttribivARB_ARGS *args = (glGetVertexAttribivARB_ARGS *)&unpacked->args; \
    glGetVertexAttribivARB(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribivARB(glGetVertexAttribivARB_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribivARB(glGetVertexAttribivARB_PACKED *_dst glGetVertexAttribivARB_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribivARB_PTR)(glGetVertexAttribivARB_ARG_EXPAND);
#endif
#ifndef glGetVertexAttribivNV_RETURN
#define glGetVertexAttribivNV_RETURN void
#define glGetVertexAttribivNV_ARG_NAMES index, pname, params
#define glGetVertexAttribivNV_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribivNV_ARG_NAMES_TAIL , index, pname, params
#define glGetVertexAttribivNV_ARG_EXPAND_TAIL , GLuint index, GLenum pname, GLint * params
#define forward_glGetVertexAttribivNV(_index, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVertexAttribivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVertexAttribivNV(dst, _index, _pname, _params), NULL); \
    });
#define call_glGetVertexAttribivNV(packed, ret_v) do { \
    glGetVertexAttribivNV_PACKED *unpacked = (glGetVertexAttribivNV_PACKED *)packed; \
    glGetVertexAttribivNV_ARGS *args = (glGetVertexAttribivNV_ARGS *)&unpacked->args; \
    glGetVertexAttribivNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribivNV(glGetVertexAttribivNV_ARG_EXPAND);
packed_call_t *pack_glGetVertexAttribivNV(glGetVertexAttribivNV_PACKED *_dst glGetVertexAttribivNV_ARG_EXPAND_TAIL);
typedef void (*glGetVertexAttribivNV_PTR)(glGetVertexAttribivNV_ARG_EXPAND);
#endif
#ifndef glGetVideoCaptureStreamdvNV_RETURN
#define glGetVideoCaptureStreamdvNV_RETURN void
#define glGetVideoCaptureStreamdvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamdvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params
#define glGetVideoCaptureStreamdvNV_ARG_NAMES_TAIL , video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamdvNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params
#define forward_glGetVideoCaptureStreamdvNV(_video_capture_slot, _stream, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideoCaptureStreamdvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideoCaptureStreamdvNV(dst, _video_capture_slot, _stream, _pname, _params), NULL); \
    });
#define call_glGetVideoCaptureStreamdvNV(packed, ret_v) do { \
    glGetVideoCaptureStreamdvNV_PACKED *unpacked = (glGetVideoCaptureStreamdvNV_PACKED *)packed; \
    glGetVideoCaptureStreamdvNV_ARGS *args = (glGetVideoCaptureStreamdvNV_ARGS *)&unpacked->args; \
    glGetVideoCaptureStreamdvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureStreamdvNV(glGetVideoCaptureStreamdvNV_ARG_EXPAND);
packed_call_t *pack_glGetVideoCaptureStreamdvNV(glGetVideoCaptureStreamdvNV_PACKED *_dst glGetVideoCaptureStreamdvNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideoCaptureStreamdvNV_PTR)(glGetVideoCaptureStreamdvNV_ARG_EXPAND);
#endif
#ifndef glGetVideoCaptureStreamfvNV_RETURN
#define glGetVideoCaptureStreamfvNV_RETURN void
#define glGetVideoCaptureStreamfvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamfvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params
#define glGetVideoCaptureStreamfvNV_ARG_NAMES_TAIL , video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamfvNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params
#define forward_glGetVideoCaptureStreamfvNV(_video_capture_slot, _stream, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideoCaptureStreamfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideoCaptureStreamfvNV(dst, _video_capture_slot, _stream, _pname, _params), NULL); \
    });
#define call_glGetVideoCaptureStreamfvNV(packed, ret_v) do { \
    glGetVideoCaptureStreamfvNV_PACKED *unpacked = (glGetVideoCaptureStreamfvNV_PACKED *)packed; \
    glGetVideoCaptureStreamfvNV_ARGS *args = (glGetVideoCaptureStreamfvNV_ARGS *)&unpacked->args; \
    glGetVideoCaptureStreamfvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureStreamfvNV(glGetVideoCaptureStreamfvNV_ARG_EXPAND);
packed_call_t *pack_glGetVideoCaptureStreamfvNV(glGetVideoCaptureStreamfvNV_PACKED *_dst glGetVideoCaptureStreamfvNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideoCaptureStreamfvNV_PTR)(glGetVideoCaptureStreamfvNV_ARG_EXPAND);
#endif
#ifndef glGetVideoCaptureStreamivNV_RETURN
#define glGetVideoCaptureStreamivNV_RETURN void
#define glGetVideoCaptureStreamivNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamivNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params
#define glGetVideoCaptureStreamivNV_ARG_NAMES_TAIL , video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamivNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params
#define forward_glGetVideoCaptureStreamivNV(_video_capture_slot, _stream, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideoCaptureStreamivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideoCaptureStreamivNV(dst, _video_capture_slot, _stream, _pname, _params), NULL); \
    });
#define call_glGetVideoCaptureStreamivNV(packed, ret_v) do { \
    glGetVideoCaptureStreamivNV_PACKED *unpacked = (glGetVideoCaptureStreamivNV_PACKED *)packed; \
    glGetVideoCaptureStreamivNV_ARGS *args = (glGetVideoCaptureStreamivNV_ARGS *)&unpacked->args; \
    glGetVideoCaptureStreamivNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureStreamivNV(glGetVideoCaptureStreamivNV_ARG_EXPAND);
packed_call_t *pack_glGetVideoCaptureStreamivNV(glGetVideoCaptureStreamivNV_PACKED *_dst glGetVideoCaptureStreamivNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideoCaptureStreamivNV_PTR)(glGetVideoCaptureStreamivNV_ARG_EXPAND);
#endif
#ifndef glGetVideoCaptureivNV_RETURN
#define glGetVideoCaptureivNV_RETURN void
#define glGetVideoCaptureivNV_ARG_NAMES video_capture_slot, pname, params
#define glGetVideoCaptureivNV_ARG_EXPAND GLuint video_capture_slot, GLenum pname, GLint * params
#define glGetVideoCaptureivNV_ARG_NAMES_TAIL , video_capture_slot, pname, params
#define glGetVideoCaptureivNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLenum pname, GLint * params
#define forward_glGetVideoCaptureivNV(_video_capture_slot, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideoCaptureivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideoCaptureivNV(dst, _video_capture_slot, _pname, _params), NULL); \
    });
#define call_glGetVideoCaptureivNV(packed, ret_v) do { \
    glGetVideoCaptureivNV_PACKED *unpacked = (glGetVideoCaptureivNV_PACKED *)packed; \
    glGetVideoCaptureivNV_ARGS *args = (glGetVideoCaptureivNV_ARGS *)&unpacked->args; \
    glGetVideoCaptureivNV(args->video_capture_slot, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureivNV(glGetVideoCaptureivNV_ARG_EXPAND);
packed_call_t *pack_glGetVideoCaptureivNV(glGetVideoCaptureivNV_PACKED *_dst glGetVideoCaptureivNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideoCaptureivNV_PTR)(glGetVideoCaptureivNV_ARG_EXPAND);
#endif
#ifndef glGetVideoi64vNV_RETURN
#define glGetVideoi64vNV_RETURN void
#define glGetVideoi64vNV_ARG_NAMES video_slot, pname, params
#define glGetVideoi64vNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLint64EXT * params
#define glGetVideoi64vNV_ARG_NAMES_TAIL , video_slot, pname, params
#define glGetVideoi64vNV_ARG_EXPAND_TAIL , GLuint video_slot, GLenum pname, GLint64EXT * params
#define forward_glGetVideoi64vNV(_video_slot, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideoi64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideoi64vNV(dst, _video_slot, _pname, _params), NULL); \
    });
#define call_glGetVideoi64vNV(packed, ret_v) do { \
    glGetVideoi64vNV_PACKED *unpacked = (glGetVideoi64vNV_PACKED *)packed; \
    glGetVideoi64vNV_ARGS *args = (glGetVideoi64vNV_ARGS *)&unpacked->args; \
    glGetVideoi64vNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideoi64vNV(glGetVideoi64vNV_ARG_EXPAND);
packed_call_t *pack_glGetVideoi64vNV(glGetVideoi64vNV_PACKED *_dst glGetVideoi64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideoi64vNV_PTR)(glGetVideoi64vNV_ARG_EXPAND);
#endif
#ifndef glGetVideoivNV_RETURN
#define glGetVideoivNV_RETURN void
#define glGetVideoivNV_ARG_NAMES video_slot, pname, params
#define glGetVideoivNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLint * params
#define glGetVideoivNV_ARG_NAMES_TAIL , video_slot, pname, params
#define glGetVideoivNV_ARG_EXPAND_TAIL , GLuint video_slot, GLenum pname, GLint * params
#define forward_glGetVideoivNV(_video_slot, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideoivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideoivNV(dst, _video_slot, _pname, _params), NULL); \
    });
#define call_glGetVideoivNV(packed, ret_v) do { \
    glGetVideoivNV_PACKED *unpacked = (glGetVideoivNV_PACKED *)packed; \
    glGetVideoivNV_ARGS *args = (glGetVideoivNV_ARGS *)&unpacked->args; \
    glGetVideoivNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideoivNV(glGetVideoivNV_ARG_EXPAND);
packed_call_t *pack_glGetVideoivNV(glGetVideoivNV_PACKED *_dst glGetVideoivNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideoivNV_PTR)(glGetVideoivNV_ARG_EXPAND);
#endif
#ifndef glGetVideoui64vNV_RETURN
#define glGetVideoui64vNV_RETURN void
#define glGetVideoui64vNV_ARG_NAMES video_slot, pname, params
#define glGetVideoui64vNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLuint64EXT * params
#define glGetVideoui64vNV_ARG_NAMES_TAIL , video_slot, pname, params
#define glGetVideoui64vNV_ARG_EXPAND_TAIL , GLuint video_slot, GLenum pname, GLuint64EXT * params
#define forward_glGetVideoui64vNV(_video_slot, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideoui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideoui64vNV(dst, _video_slot, _pname, _params), NULL); \
    });
#define call_glGetVideoui64vNV(packed, ret_v) do { \
    glGetVideoui64vNV_PACKED *unpacked = (glGetVideoui64vNV_PACKED *)packed; \
    glGetVideoui64vNV_ARGS *args = (glGetVideoui64vNV_ARGS *)&unpacked->args; \
    glGetVideoui64vNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideoui64vNV(glGetVideoui64vNV_ARG_EXPAND);
packed_call_t *pack_glGetVideoui64vNV(glGetVideoui64vNV_PACKED *_dst glGetVideoui64vNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideoui64vNV_PTR)(glGetVideoui64vNV_ARG_EXPAND);
#endif
#ifndef glGetVideouivNV_RETURN
#define glGetVideouivNV_RETURN void
#define glGetVideouivNV_ARG_NAMES video_slot, pname, params
#define glGetVideouivNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLuint * params
#define glGetVideouivNV_ARG_NAMES_TAIL , video_slot, pname, params
#define glGetVideouivNV_ARG_EXPAND_TAIL , GLuint video_slot, GLenum pname, GLuint * params
#define forward_glGetVideouivNV(_video_slot, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetVideouivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetVideouivNV(dst, _video_slot, _pname, _params), NULL); \
    });
#define call_glGetVideouivNV(packed, ret_v) do { \
    glGetVideouivNV_PACKED *unpacked = (glGetVideouivNV_PACKED *)packed; \
    glGetVideouivNV_ARGS *args = (glGetVideouivNV_ARGS *)&unpacked->args; \
    glGetVideouivNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideouivNV(glGetVideouivNV_ARG_EXPAND);
packed_call_t *pack_glGetVideouivNV(glGetVideouivNV_PACKED *_dst glGetVideouivNV_ARG_EXPAND_TAIL);
typedef void (*glGetVideouivNV_PTR)(glGetVideouivNV_ARG_EXPAND);
#endif
#ifndef glGetnColorTableARB_RETURN
#define glGetnColorTableARB_RETURN void
#define glGetnColorTableARB_ARG_NAMES target, format, type, bufSize, table
#define glGetnColorTableARB_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * table
#define glGetnColorTableARB_ARG_NAMES_TAIL , target, format, type, bufSize, table
#define glGetnColorTableARB_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * table
#define forward_glGetnColorTableARB(_target, _format, _type, _bufSize, _table) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnColorTableARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnColorTableARB(dst, _target, _format, _type, _bufSize, _table), NULL); \
    });
#define call_glGetnColorTableARB(packed, ret_v) do { \
    glGetnColorTableARB_PACKED *unpacked = (glGetnColorTableARB_PACKED *)packed; \
    glGetnColorTableARB_ARGS *args = (glGetnColorTableARB_ARGS *)&unpacked->args; \
    glGetnColorTableARB(args->target, args->format, args->type, args->bufSize, args->table);; \
} while(0)
void glGetnColorTableARB(glGetnColorTableARB_ARG_EXPAND);
packed_call_t *pack_glGetnColorTableARB(glGetnColorTableARB_PACKED *_dst glGetnColorTableARB_ARG_EXPAND_TAIL);
typedef void (*glGetnColorTableARB_PTR)(glGetnColorTableARB_ARG_EXPAND);
#endif
#ifndef glGetnCompressedTexImageARB_RETURN
#define glGetnCompressedTexImageARB_RETURN void
#define glGetnCompressedTexImageARB_ARG_NAMES target, lod, bufSize, img
#define glGetnCompressedTexImageARB_ARG_EXPAND GLenum target, GLint lod, GLsizei bufSize, GLvoid * img
#define glGetnCompressedTexImageARB_ARG_NAMES_TAIL , target, lod, bufSize, img
#define glGetnCompressedTexImageARB_ARG_EXPAND_TAIL , GLenum target, GLint lod, GLsizei bufSize, GLvoid * img
#define forward_glGetnCompressedTexImageARB(_target, _lod, _bufSize, _img) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnCompressedTexImageARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnCompressedTexImageARB(dst, _target, _lod, _bufSize, _img), NULL); \
    });
#define call_glGetnCompressedTexImageARB(packed, ret_v) do { \
    glGetnCompressedTexImageARB_PACKED *unpacked = (glGetnCompressedTexImageARB_PACKED *)packed; \
    glGetnCompressedTexImageARB_ARGS *args = (glGetnCompressedTexImageARB_ARGS *)&unpacked->args; \
    glGetnCompressedTexImageARB(args->target, args->lod, args->bufSize, args->img);; \
} while(0)
void glGetnCompressedTexImageARB(glGetnCompressedTexImageARB_ARG_EXPAND);
packed_call_t *pack_glGetnCompressedTexImageARB(glGetnCompressedTexImageARB_PACKED *_dst glGetnCompressedTexImageARB_ARG_EXPAND_TAIL);
typedef void (*glGetnCompressedTexImageARB_PTR)(glGetnCompressedTexImageARB_ARG_EXPAND);
#endif
#ifndef glGetnConvolutionFilterARB_RETURN
#define glGetnConvolutionFilterARB_RETURN void
#define glGetnConvolutionFilterARB_ARG_NAMES target, format, type, bufSize, image
#define glGetnConvolutionFilterARB_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * image
#define glGetnConvolutionFilterARB_ARG_NAMES_TAIL , target, format, type, bufSize, image
#define glGetnConvolutionFilterARB_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * image
#define forward_glGetnConvolutionFilterARB(_target, _format, _type, _bufSize, _image) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnConvolutionFilterARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnConvolutionFilterARB(dst, _target, _format, _type, _bufSize, _image), NULL); \
    });
#define call_glGetnConvolutionFilterARB(packed, ret_v) do { \
    glGetnConvolutionFilterARB_PACKED *unpacked = (glGetnConvolutionFilterARB_PACKED *)packed; \
    glGetnConvolutionFilterARB_ARGS *args = (glGetnConvolutionFilterARB_ARGS *)&unpacked->args; \
    glGetnConvolutionFilterARB(args->target, args->format, args->type, args->bufSize, args->image);; \
} while(0)
void glGetnConvolutionFilterARB(glGetnConvolutionFilterARB_ARG_EXPAND);
packed_call_t *pack_glGetnConvolutionFilterARB(glGetnConvolutionFilterARB_PACKED *_dst glGetnConvolutionFilterARB_ARG_EXPAND_TAIL);
typedef void (*glGetnConvolutionFilterARB_PTR)(glGetnConvolutionFilterARB_ARG_EXPAND);
#endif
#ifndef glGetnHistogramARB_RETURN
#define glGetnHistogramARB_RETURN void
#define glGetnHistogramARB_ARG_NAMES target, reset, format, type, bufSize, values
#define glGetnHistogramARB_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values
#define glGetnHistogramARB_ARG_NAMES_TAIL , target, reset, format, type, bufSize, values
#define glGetnHistogramARB_ARG_EXPAND_TAIL , GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values
#define forward_glGetnHistogramARB(_target, _reset, _format, _type, _bufSize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnHistogramARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnHistogramARB(dst, _target, _reset, _format, _type, _bufSize, _values), NULL); \
    });
#define call_glGetnHistogramARB(packed, ret_v) do { \
    glGetnHistogramARB_PACKED *unpacked = (glGetnHistogramARB_PACKED *)packed; \
    glGetnHistogramARB_ARGS *args = (glGetnHistogramARB_ARGS *)&unpacked->args; \
    glGetnHistogramARB(args->target, args->reset, args->format, args->type, args->bufSize, args->values);; \
} while(0)
void glGetnHistogramARB(glGetnHistogramARB_ARG_EXPAND);
packed_call_t *pack_glGetnHistogramARB(glGetnHistogramARB_PACKED *_dst glGetnHistogramARB_ARG_EXPAND_TAIL);
typedef void (*glGetnHistogramARB_PTR)(glGetnHistogramARB_ARG_EXPAND);
#endif
#ifndef glGetnMapdvARB_RETURN
#define glGetnMapdvARB_RETURN void
#define glGetnMapdvARB_ARG_NAMES target, query, bufSize, v
#define glGetnMapdvARB_ARG_EXPAND GLenum target, GLenum query, GLsizei bufSize, GLdouble * v
#define glGetnMapdvARB_ARG_NAMES_TAIL , target, query, bufSize, v
#define glGetnMapdvARB_ARG_EXPAND_TAIL , GLenum target, GLenum query, GLsizei bufSize, GLdouble * v
#define forward_glGetnMapdvARB(_target, _query, _bufSize, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnMapdvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnMapdvARB(dst, _target, _query, _bufSize, _v), NULL); \
    });
#define call_glGetnMapdvARB(packed, ret_v) do { \
    glGetnMapdvARB_PACKED *unpacked = (glGetnMapdvARB_PACKED *)packed; \
    glGetnMapdvARB_ARGS *args = (glGetnMapdvARB_ARGS *)&unpacked->args; \
    glGetnMapdvARB(args->target, args->query, args->bufSize, args->v);; \
} while(0)
void glGetnMapdvARB(glGetnMapdvARB_ARG_EXPAND);
packed_call_t *pack_glGetnMapdvARB(glGetnMapdvARB_PACKED *_dst glGetnMapdvARB_ARG_EXPAND_TAIL);
typedef void (*glGetnMapdvARB_PTR)(glGetnMapdvARB_ARG_EXPAND);
#endif
#ifndef glGetnMapfvARB_RETURN
#define glGetnMapfvARB_RETURN void
#define glGetnMapfvARB_ARG_NAMES target, query, bufSize, v
#define glGetnMapfvARB_ARG_EXPAND GLenum target, GLenum query, GLsizei bufSize, GLfloat * v
#define glGetnMapfvARB_ARG_NAMES_TAIL , target, query, bufSize, v
#define glGetnMapfvARB_ARG_EXPAND_TAIL , GLenum target, GLenum query, GLsizei bufSize, GLfloat * v
#define forward_glGetnMapfvARB(_target, _query, _bufSize, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnMapfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnMapfvARB(dst, _target, _query, _bufSize, _v), NULL); \
    });
#define call_glGetnMapfvARB(packed, ret_v) do { \
    glGetnMapfvARB_PACKED *unpacked = (glGetnMapfvARB_PACKED *)packed; \
    glGetnMapfvARB_ARGS *args = (glGetnMapfvARB_ARGS *)&unpacked->args; \
    glGetnMapfvARB(args->target, args->query, args->bufSize, args->v);; \
} while(0)
void glGetnMapfvARB(glGetnMapfvARB_ARG_EXPAND);
packed_call_t *pack_glGetnMapfvARB(glGetnMapfvARB_PACKED *_dst glGetnMapfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetnMapfvARB_PTR)(glGetnMapfvARB_ARG_EXPAND);
#endif
#ifndef glGetnMapivARB_RETURN
#define glGetnMapivARB_RETURN void
#define glGetnMapivARB_ARG_NAMES target, query, bufSize, v
#define glGetnMapivARB_ARG_EXPAND GLenum target, GLenum query, GLsizei bufSize, GLint * v
#define glGetnMapivARB_ARG_NAMES_TAIL , target, query, bufSize, v
#define glGetnMapivARB_ARG_EXPAND_TAIL , GLenum target, GLenum query, GLsizei bufSize, GLint * v
#define forward_glGetnMapivARB(_target, _query, _bufSize, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnMapivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnMapivARB(dst, _target, _query, _bufSize, _v), NULL); \
    });
#define call_glGetnMapivARB(packed, ret_v) do { \
    glGetnMapivARB_PACKED *unpacked = (glGetnMapivARB_PACKED *)packed; \
    glGetnMapivARB_ARGS *args = (glGetnMapivARB_ARGS *)&unpacked->args; \
    glGetnMapivARB(args->target, args->query, args->bufSize, args->v);; \
} while(0)
void glGetnMapivARB(glGetnMapivARB_ARG_EXPAND);
packed_call_t *pack_glGetnMapivARB(glGetnMapivARB_PACKED *_dst glGetnMapivARB_ARG_EXPAND_TAIL);
typedef void (*glGetnMapivARB_PTR)(glGetnMapivARB_ARG_EXPAND);
#endif
#ifndef glGetnMinmaxARB_RETURN
#define glGetnMinmaxARB_RETURN void
#define glGetnMinmaxARB_ARG_NAMES target, reset, format, type, bufSize, values
#define glGetnMinmaxARB_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values
#define glGetnMinmaxARB_ARG_NAMES_TAIL , target, reset, format, type, bufSize, values
#define glGetnMinmaxARB_ARG_EXPAND_TAIL , GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values
#define forward_glGetnMinmaxARB(_target, _reset, _format, _type, _bufSize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnMinmaxARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnMinmaxARB(dst, _target, _reset, _format, _type, _bufSize, _values), NULL); \
    });
#define call_glGetnMinmaxARB(packed, ret_v) do { \
    glGetnMinmaxARB_PACKED *unpacked = (glGetnMinmaxARB_PACKED *)packed; \
    glGetnMinmaxARB_ARGS *args = (glGetnMinmaxARB_ARGS *)&unpacked->args; \
    glGetnMinmaxARB(args->target, args->reset, args->format, args->type, args->bufSize, args->values);; \
} while(0)
void glGetnMinmaxARB(glGetnMinmaxARB_ARG_EXPAND);
packed_call_t *pack_glGetnMinmaxARB(glGetnMinmaxARB_PACKED *_dst glGetnMinmaxARB_ARG_EXPAND_TAIL);
typedef void (*glGetnMinmaxARB_PTR)(glGetnMinmaxARB_ARG_EXPAND);
#endif
#ifndef glGetnPixelMapfvARB_RETURN
#define glGetnPixelMapfvARB_RETURN void
#define glGetnPixelMapfvARB_ARG_NAMES map, bufSize, values
#define glGetnPixelMapfvARB_ARG_EXPAND GLenum map, GLsizei bufSize, GLfloat * values
#define glGetnPixelMapfvARB_ARG_NAMES_TAIL , map, bufSize, values
#define glGetnPixelMapfvARB_ARG_EXPAND_TAIL , GLenum map, GLsizei bufSize, GLfloat * values
#define forward_glGetnPixelMapfvARB(_map, _bufSize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnPixelMapfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnPixelMapfvARB(dst, _map, _bufSize, _values), NULL); \
    });
#define call_glGetnPixelMapfvARB(packed, ret_v) do { \
    glGetnPixelMapfvARB_PACKED *unpacked = (glGetnPixelMapfvARB_PACKED *)packed; \
    glGetnPixelMapfvARB_ARGS *args = (glGetnPixelMapfvARB_ARGS *)&unpacked->args; \
    glGetnPixelMapfvARB(args->map, args->bufSize, args->values);; \
} while(0)
void glGetnPixelMapfvARB(glGetnPixelMapfvARB_ARG_EXPAND);
packed_call_t *pack_glGetnPixelMapfvARB(glGetnPixelMapfvARB_PACKED *_dst glGetnPixelMapfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetnPixelMapfvARB_PTR)(glGetnPixelMapfvARB_ARG_EXPAND);
#endif
#ifndef glGetnPixelMapuivARB_RETURN
#define glGetnPixelMapuivARB_RETURN void
#define glGetnPixelMapuivARB_ARG_NAMES map, bufSize, values
#define glGetnPixelMapuivARB_ARG_EXPAND GLenum map, GLsizei bufSize, GLuint * values
#define glGetnPixelMapuivARB_ARG_NAMES_TAIL , map, bufSize, values
#define glGetnPixelMapuivARB_ARG_EXPAND_TAIL , GLenum map, GLsizei bufSize, GLuint * values
#define forward_glGetnPixelMapuivARB(_map, _bufSize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnPixelMapuivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnPixelMapuivARB(dst, _map, _bufSize, _values), NULL); \
    });
#define call_glGetnPixelMapuivARB(packed, ret_v) do { \
    glGetnPixelMapuivARB_PACKED *unpacked = (glGetnPixelMapuivARB_PACKED *)packed; \
    glGetnPixelMapuivARB_ARGS *args = (glGetnPixelMapuivARB_ARGS *)&unpacked->args; \
    glGetnPixelMapuivARB(args->map, args->bufSize, args->values);; \
} while(0)
void glGetnPixelMapuivARB(glGetnPixelMapuivARB_ARG_EXPAND);
packed_call_t *pack_glGetnPixelMapuivARB(glGetnPixelMapuivARB_PACKED *_dst glGetnPixelMapuivARB_ARG_EXPAND_TAIL);
typedef void (*glGetnPixelMapuivARB_PTR)(glGetnPixelMapuivARB_ARG_EXPAND);
#endif
#ifndef glGetnPixelMapusvARB_RETURN
#define glGetnPixelMapusvARB_RETURN void
#define glGetnPixelMapusvARB_ARG_NAMES map, bufSize, values
#define glGetnPixelMapusvARB_ARG_EXPAND GLenum map, GLsizei bufSize, GLushort * values
#define glGetnPixelMapusvARB_ARG_NAMES_TAIL , map, bufSize, values
#define glGetnPixelMapusvARB_ARG_EXPAND_TAIL , GLenum map, GLsizei bufSize, GLushort * values
#define forward_glGetnPixelMapusvARB(_map, _bufSize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnPixelMapusvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnPixelMapusvARB(dst, _map, _bufSize, _values), NULL); \
    });
#define call_glGetnPixelMapusvARB(packed, ret_v) do { \
    glGetnPixelMapusvARB_PACKED *unpacked = (glGetnPixelMapusvARB_PACKED *)packed; \
    glGetnPixelMapusvARB_ARGS *args = (glGetnPixelMapusvARB_ARGS *)&unpacked->args; \
    glGetnPixelMapusvARB(args->map, args->bufSize, args->values);; \
} while(0)
void glGetnPixelMapusvARB(glGetnPixelMapusvARB_ARG_EXPAND);
packed_call_t *pack_glGetnPixelMapusvARB(glGetnPixelMapusvARB_PACKED *_dst glGetnPixelMapusvARB_ARG_EXPAND_TAIL);
typedef void (*glGetnPixelMapusvARB_PTR)(glGetnPixelMapusvARB_ARG_EXPAND);
#endif
#ifndef glGetnPolygonStippleARB_RETURN
#define glGetnPolygonStippleARB_RETURN void
#define glGetnPolygonStippleARB_ARG_NAMES bufSize, pattern
#define glGetnPolygonStippleARB_ARG_EXPAND GLsizei bufSize, GLubyte * pattern
#define glGetnPolygonStippleARB_ARG_NAMES_TAIL , bufSize, pattern
#define glGetnPolygonStippleARB_ARG_EXPAND_TAIL , GLsizei bufSize, GLubyte * pattern
#define forward_glGetnPolygonStippleARB(_bufSize, _pattern) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnPolygonStippleARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnPolygonStippleARB(dst, _bufSize, _pattern), NULL); \
    });
#define call_glGetnPolygonStippleARB(packed, ret_v) do { \
    glGetnPolygonStippleARB_PACKED *unpacked = (glGetnPolygonStippleARB_PACKED *)packed; \
    glGetnPolygonStippleARB_ARGS *args = (glGetnPolygonStippleARB_ARGS *)&unpacked->args; \
    glGetnPolygonStippleARB(args->bufSize, args->pattern);; \
} while(0)
void glGetnPolygonStippleARB(glGetnPolygonStippleARB_ARG_EXPAND);
packed_call_t *pack_glGetnPolygonStippleARB(glGetnPolygonStippleARB_PACKED *_dst glGetnPolygonStippleARB_ARG_EXPAND_TAIL);
typedef void (*glGetnPolygonStippleARB_PTR)(glGetnPolygonStippleARB_ARG_EXPAND);
#endif
#ifndef glGetnSeparableFilterARB_RETURN
#define glGetnSeparableFilterARB_RETURN void
#define glGetnSeparableFilterARB_ARG_NAMES target, format, type, rowBufSize, row, columnBufSize, column, span
#define glGetnSeparableFilterARB_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid * row, GLsizei columnBufSize, GLvoid * column, GLvoid * span
#define glGetnSeparableFilterARB_ARG_NAMES_TAIL , target, format, type, rowBufSize, row, columnBufSize, column, span
#define glGetnSeparableFilterARB_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid * row, GLsizei columnBufSize, GLvoid * column, GLvoid * span
#define forward_glGetnSeparableFilterARB(_target, _format, _type, _rowBufSize, _row, _columnBufSize, _column, _span) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnSeparableFilterARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnSeparableFilterARB(dst, _target, _format, _type, _rowBufSize, _row, _columnBufSize, _column, _span), NULL); \
    });
#define call_glGetnSeparableFilterARB(packed, ret_v) do { \
    glGetnSeparableFilterARB_PACKED *unpacked = (glGetnSeparableFilterARB_PACKED *)packed; \
    glGetnSeparableFilterARB_ARGS *args = (glGetnSeparableFilterARB_ARGS *)&unpacked->args; \
    glGetnSeparableFilterARB(args->target, args->format, args->type, args->rowBufSize, args->row, args->columnBufSize, args->column, args->span);; \
} while(0)
void glGetnSeparableFilterARB(glGetnSeparableFilterARB_ARG_EXPAND);
packed_call_t *pack_glGetnSeparableFilterARB(glGetnSeparableFilterARB_PACKED *_dst glGetnSeparableFilterARB_ARG_EXPAND_TAIL);
typedef void (*glGetnSeparableFilterARB_PTR)(glGetnSeparableFilterARB_ARG_EXPAND);
#endif
#ifndef glGetnTexImageARB_RETURN
#define glGetnTexImageARB_RETURN void
#define glGetnTexImageARB_ARG_NAMES target, level, format, type, bufSize, img
#define glGetnTexImageARB_ARG_EXPAND GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * img
#define glGetnTexImageARB_ARG_NAMES_TAIL , target, level, format, type, bufSize, img
#define glGetnTexImageARB_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * img
#define forward_glGetnTexImageARB(_target, _level, _format, _type, _bufSize, _img) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnTexImageARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnTexImageARB(dst, _target, _level, _format, _type, _bufSize, _img), NULL); \
    });
#define call_glGetnTexImageARB(packed, ret_v) do { \
    glGetnTexImageARB_PACKED *unpacked = (glGetnTexImageARB_PACKED *)packed; \
    glGetnTexImageARB_ARGS *args = (glGetnTexImageARB_ARGS *)&unpacked->args; \
    glGetnTexImageARB(args->target, args->level, args->format, args->type, args->bufSize, args->img);; \
} while(0)
void glGetnTexImageARB(glGetnTexImageARB_ARG_EXPAND);
packed_call_t *pack_glGetnTexImageARB(glGetnTexImageARB_PACKED *_dst glGetnTexImageARB_ARG_EXPAND_TAIL);
typedef void (*glGetnTexImageARB_PTR)(glGetnTexImageARB_ARG_EXPAND);
#endif
#ifndef glGetnUniformdvARB_RETURN
#define glGetnUniformdvARB_RETURN void
#define glGetnUniformdvARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformdvARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLdouble * params
#define glGetnUniformdvARB_ARG_NAMES_TAIL , program, location, bufSize, params
#define glGetnUniformdvARB_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei bufSize, GLdouble * params
#define forward_glGetnUniformdvARB(_program, _location, _bufSize, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnUniformdvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnUniformdvARB(dst, _program, _location, _bufSize, _params), NULL); \
    });
#define call_glGetnUniformdvARB(packed, ret_v) do { \
    glGetnUniformdvARB_PACKED *unpacked = (glGetnUniformdvARB_PACKED *)packed; \
    glGetnUniformdvARB_ARGS *args = (glGetnUniformdvARB_ARGS *)&unpacked->args; \
    glGetnUniformdvARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformdvARB(glGetnUniformdvARB_ARG_EXPAND);
packed_call_t *pack_glGetnUniformdvARB(glGetnUniformdvARB_PACKED *_dst glGetnUniformdvARB_ARG_EXPAND_TAIL);
typedef void (*glGetnUniformdvARB_PTR)(glGetnUniformdvARB_ARG_EXPAND);
#endif
#ifndef glGetnUniformfvARB_RETURN
#define glGetnUniformfvARB_RETURN void
#define glGetnUniformfvARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformfvARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLfloat * params
#define glGetnUniformfvARB_ARG_NAMES_TAIL , program, location, bufSize, params
#define glGetnUniformfvARB_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei bufSize, GLfloat * params
#define forward_glGetnUniformfvARB(_program, _location, _bufSize, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnUniformfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnUniformfvARB(dst, _program, _location, _bufSize, _params), NULL); \
    });
#define call_glGetnUniformfvARB(packed, ret_v) do { \
    glGetnUniformfvARB_PACKED *unpacked = (glGetnUniformfvARB_PACKED *)packed; \
    glGetnUniformfvARB_ARGS *args = (glGetnUniformfvARB_ARGS *)&unpacked->args; \
    glGetnUniformfvARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformfvARB(glGetnUniformfvARB_ARG_EXPAND);
packed_call_t *pack_glGetnUniformfvARB(glGetnUniformfvARB_PACKED *_dst glGetnUniformfvARB_ARG_EXPAND_TAIL);
typedef void (*glGetnUniformfvARB_PTR)(glGetnUniformfvARB_ARG_EXPAND);
#endif
#ifndef glGetnUniformivARB_RETURN
#define glGetnUniformivARB_RETURN void
#define glGetnUniformivARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformivARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLint * params
#define glGetnUniformivARB_ARG_NAMES_TAIL , program, location, bufSize, params
#define glGetnUniformivARB_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei bufSize, GLint * params
#define forward_glGetnUniformivARB(_program, _location, _bufSize, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnUniformivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnUniformivARB(dst, _program, _location, _bufSize, _params), NULL); \
    });
#define call_glGetnUniformivARB(packed, ret_v) do { \
    glGetnUniformivARB_PACKED *unpacked = (glGetnUniformivARB_PACKED *)packed; \
    glGetnUniformivARB_ARGS *args = (glGetnUniformivARB_ARGS *)&unpacked->args; \
    glGetnUniformivARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformivARB(glGetnUniformivARB_ARG_EXPAND);
packed_call_t *pack_glGetnUniformivARB(glGetnUniformivARB_PACKED *_dst glGetnUniformivARB_ARG_EXPAND_TAIL);
typedef void (*glGetnUniformivARB_PTR)(glGetnUniformivARB_ARG_EXPAND);
#endif
#ifndef glGetnUniformuivARB_RETURN
#define glGetnUniformuivARB_RETURN void
#define glGetnUniformuivARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformuivARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLuint * params
#define glGetnUniformuivARB_ARG_NAMES_TAIL , program, location, bufSize, params
#define glGetnUniformuivARB_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei bufSize, GLuint * params
#define forward_glGetnUniformuivARB(_program, _location, _bufSize, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glGetnUniformuivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGetnUniformuivARB(dst, _program, _location, _bufSize, _params), NULL); \
    });
#define call_glGetnUniformuivARB(packed, ret_v) do { \
    glGetnUniformuivARB_PACKED *unpacked = (glGetnUniformuivARB_PACKED *)packed; \
    glGetnUniformuivARB_ARGS *args = (glGetnUniformuivARB_ARGS *)&unpacked->args; \
    glGetnUniformuivARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformuivARB(glGetnUniformuivARB_ARG_EXPAND);
packed_call_t *pack_glGetnUniformuivARB(glGetnUniformuivARB_PACKED *_dst glGetnUniformuivARB_ARG_EXPAND_TAIL);
typedef void (*glGetnUniformuivARB_PTR)(glGetnUniformuivARB_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactorbSUN_RETURN
#define glGlobalAlphaFactorbSUN_RETURN void
#define glGlobalAlphaFactorbSUN_ARG_NAMES factor
#define glGlobalAlphaFactorbSUN_ARG_EXPAND GLbyte factor
#define glGlobalAlphaFactorbSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactorbSUN_ARG_EXPAND_TAIL , GLbyte factor
#define forward_glGlobalAlphaFactorbSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactorbSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactorbSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactorbSUN(packed, ret_v) do { \
    glGlobalAlphaFactorbSUN_PACKED *unpacked = (glGlobalAlphaFactorbSUN_PACKED *)packed; \
    glGlobalAlphaFactorbSUN_ARGS *args = (glGlobalAlphaFactorbSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactorbSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorbSUN(glGlobalAlphaFactorbSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactorbSUN(glGlobalAlphaFactorbSUN_PACKED *_dst glGlobalAlphaFactorbSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactorbSUN_PTR)(glGlobalAlphaFactorbSUN_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactordSUN_RETURN
#define glGlobalAlphaFactordSUN_RETURN void
#define glGlobalAlphaFactordSUN_ARG_NAMES factor
#define glGlobalAlphaFactordSUN_ARG_EXPAND GLdouble factor
#define glGlobalAlphaFactordSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactordSUN_ARG_EXPAND_TAIL , GLdouble factor
#define forward_glGlobalAlphaFactordSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactordSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactordSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactordSUN(packed, ret_v) do { \
    glGlobalAlphaFactordSUN_PACKED *unpacked = (glGlobalAlphaFactordSUN_PACKED *)packed; \
    glGlobalAlphaFactordSUN_ARGS *args = (glGlobalAlphaFactordSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactordSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactordSUN(glGlobalAlphaFactordSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactordSUN(glGlobalAlphaFactordSUN_PACKED *_dst glGlobalAlphaFactordSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactordSUN_PTR)(glGlobalAlphaFactordSUN_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactorfSUN_RETURN
#define glGlobalAlphaFactorfSUN_RETURN void
#define glGlobalAlphaFactorfSUN_ARG_NAMES factor
#define glGlobalAlphaFactorfSUN_ARG_EXPAND GLfloat factor
#define glGlobalAlphaFactorfSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactorfSUN_ARG_EXPAND_TAIL , GLfloat factor
#define forward_glGlobalAlphaFactorfSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactorfSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactorfSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactorfSUN(packed, ret_v) do { \
    glGlobalAlphaFactorfSUN_PACKED *unpacked = (glGlobalAlphaFactorfSUN_PACKED *)packed; \
    glGlobalAlphaFactorfSUN_ARGS *args = (glGlobalAlphaFactorfSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactorfSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorfSUN(glGlobalAlphaFactorfSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactorfSUN(glGlobalAlphaFactorfSUN_PACKED *_dst glGlobalAlphaFactorfSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactorfSUN_PTR)(glGlobalAlphaFactorfSUN_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactoriSUN_RETURN
#define glGlobalAlphaFactoriSUN_RETURN void
#define glGlobalAlphaFactoriSUN_ARG_NAMES factor
#define glGlobalAlphaFactoriSUN_ARG_EXPAND GLint factor
#define glGlobalAlphaFactoriSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactoriSUN_ARG_EXPAND_TAIL , GLint factor
#define forward_glGlobalAlphaFactoriSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactoriSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactoriSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactoriSUN(packed, ret_v) do { \
    glGlobalAlphaFactoriSUN_PACKED *unpacked = (glGlobalAlphaFactoriSUN_PACKED *)packed; \
    glGlobalAlphaFactoriSUN_ARGS *args = (glGlobalAlphaFactoriSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactoriSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactoriSUN(glGlobalAlphaFactoriSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactoriSUN(glGlobalAlphaFactoriSUN_PACKED *_dst glGlobalAlphaFactoriSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactoriSUN_PTR)(glGlobalAlphaFactoriSUN_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactorsSUN_RETURN
#define glGlobalAlphaFactorsSUN_RETURN void
#define glGlobalAlphaFactorsSUN_ARG_NAMES factor
#define glGlobalAlphaFactorsSUN_ARG_EXPAND GLshort factor
#define glGlobalAlphaFactorsSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactorsSUN_ARG_EXPAND_TAIL , GLshort factor
#define forward_glGlobalAlphaFactorsSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactorsSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactorsSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactorsSUN(packed, ret_v) do { \
    glGlobalAlphaFactorsSUN_PACKED *unpacked = (glGlobalAlphaFactorsSUN_PACKED *)packed; \
    glGlobalAlphaFactorsSUN_ARGS *args = (glGlobalAlphaFactorsSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactorsSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorsSUN(glGlobalAlphaFactorsSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactorsSUN(glGlobalAlphaFactorsSUN_PACKED *_dst glGlobalAlphaFactorsSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactorsSUN_PTR)(glGlobalAlphaFactorsSUN_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactorubSUN_RETURN
#define glGlobalAlphaFactorubSUN_RETURN void
#define glGlobalAlphaFactorubSUN_ARG_NAMES factor
#define glGlobalAlphaFactorubSUN_ARG_EXPAND GLubyte factor
#define glGlobalAlphaFactorubSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactorubSUN_ARG_EXPAND_TAIL , GLubyte factor
#define forward_glGlobalAlphaFactorubSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactorubSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactorubSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactorubSUN(packed, ret_v) do { \
    glGlobalAlphaFactorubSUN_PACKED *unpacked = (glGlobalAlphaFactorubSUN_PACKED *)packed; \
    glGlobalAlphaFactorubSUN_ARGS *args = (glGlobalAlphaFactorubSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactorubSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorubSUN(glGlobalAlphaFactorubSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactorubSUN(glGlobalAlphaFactorubSUN_PACKED *_dst glGlobalAlphaFactorubSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactorubSUN_PTR)(glGlobalAlphaFactorubSUN_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactoruiSUN_RETURN
#define glGlobalAlphaFactoruiSUN_RETURN void
#define glGlobalAlphaFactoruiSUN_ARG_NAMES factor
#define glGlobalAlphaFactoruiSUN_ARG_EXPAND GLuint factor
#define glGlobalAlphaFactoruiSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactoruiSUN_ARG_EXPAND_TAIL , GLuint factor
#define forward_glGlobalAlphaFactoruiSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactoruiSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactoruiSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactoruiSUN(packed, ret_v) do { \
    glGlobalAlphaFactoruiSUN_PACKED *unpacked = (glGlobalAlphaFactoruiSUN_PACKED *)packed; \
    glGlobalAlphaFactoruiSUN_ARGS *args = (glGlobalAlphaFactoruiSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactoruiSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactoruiSUN(glGlobalAlphaFactoruiSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactoruiSUN(glGlobalAlphaFactoruiSUN_PACKED *_dst glGlobalAlphaFactoruiSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactoruiSUN_PTR)(glGlobalAlphaFactoruiSUN_ARG_EXPAND);
#endif
#ifndef glGlobalAlphaFactorusSUN_RETURN
#define glGlobalAlphaFactorusSUN_RETURN void
#define glGlobalAlphaFactorusSUN_ARG_NAMES factor
#define glGlobalAlphaFactorusSUN_ARG_EXPAND GLushort factor
#define glGlobalAlphaFactorusSUN_ARG_NAMES_TAIL , factor
#define glGlobalAlphaFactorusSUN_ARG_EXPAND_TAIL , GLushort factor
#define forward_glGlobalAlphaFactorusSUN(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glGlobalAlphaFactorusSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glGlobalAlphaFactorusSUN(dst, _factor), NULL); \
    });
#define call_glGlobalAlphaFactorusSUN(packed, ret_v) do { \
    glGlobalAlphaFactorusSUN_PACKED *unpacked = (glGlobalAlphaFactorusSUN_PACKED *)packed; \
    glGlobalAlphaFactorusSUN_ARGS *args = (glGlobalAlphaFactorusSUN_ARGS *)&unpacked->args; \
    glGlobalAlphaFactorusSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorusSUN(glGlobalAlphaFactorusSUN_ARG_EXPAND);
packed_call_t *pack_glGlobalAlphaFactorusSUN(glGlobalAlphaFactorusSUN_PACKED *_dst glGlobalAlphaFactorusSUN_ARG_EXPAND_TAIL);
typedef void (*glGlobalAlphaFactorusSUN_PTR)(glGlobalAlphaFactorusSUN_ARG_EXPAND);
#endif
#ifndef glHint_RETURN
#define glHint_RETURN void
#define glHint_ARG_NAMES target, mode
#define glHint_ARG_EXPAND GLenum target, GLenum mode
#define glHint_ARG_NAMES_TAIL , target, mode
#define glHint_ARG_EXPAND_TAIL , GLenum target, GLenum mode
#define forward_glHint(_target, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glHint_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glHint(dst, _target, _mode), NULL); \
    });
#define call_glHint(packed, ret_v) do { \
    glHint_PACKED *unpacked = (glHint_PACKED *)packed; \
    glHint_ARGS *args = (glHint_ARGS *)&unpacked->args; \
    glHint(args->target, args->mode);; \
} while(0)
void glHint(glHint_ARG_EXPAND);
packed_call_t *pack_glHint(glHint_PACKED *_dst glHint_ARG_EXPAND_TAIL);
typedef void (*glHint_PTR)(glHint_ARG_EXPAND);
#endif
#ifndef glHintPGI_RETURN
#define glHintPGI_RETURN void
#define glHintPGI_ARG_NAMES target, mode
#define glHintPGI_ARG_EXPAND GLenum target, GLint mode
#define glHintPGI_ARG_NAMES_TAIL , target, mode
#define glHintPGI_ARG_EXPAND_TAIL , GLenum target, GLint mode
#define forward_glHintPGI(_target, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glHintPGI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glHintPGI(dst, _target, _mode), NULL); \
    });
#define call_glHintPGI(packed, ret_v) do { \
    glHintPGI_PACKED *unpacked = (glHintPGI_PACKED *)packed; \
    glHintPGI_ARGS *args = (glHintPGI_ARGS *)&unpacked->args; \
    glHintPGI(args->target, args->mode);; \
} while(0)
void glHintPGI(glHintPGI_ARG_EXPAND);
packed_call_t *pack_glHintPGI(glHintPGI_PACKED *_dst glHintPGI_ARG_EXPAND_TAIL);
typedef void (*glHintPGI_PTR)(glHintPGI_ARG_EXPAND);
#endif
#ifndef glHistogram_RETURN
#define glHistogram_RETURN void
#define glHistogram_ARG_NAMES target, width, internalformat, sink
#define glHistogram_ARG_EXPAND GLenum target, GLsizei width, GLenum internalformat, GLboolean sink
#define glHistogram_ARG_NAMES_TAIL , target, width, internalformat, sink
#define glHistogram_ARG_EXPAND_TAIL , GLenum target, GLsizei width, GLenum internalformat, GLboolean sink
#define forward_glHistogram(_target, _width, _internalformat, _sink) \
    ({ \
        void *dst = remote_dma(sizeof(glHistogram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glHistogram(dst, _target, _width, _internalformat, _sink), NULL); \
    });
#define call_glHistogram(packed, ret_v) do { \
    glHistogram_PACKED *unpacked = (glHistogram_PACKED *)packed; \
    glHistogram_ARGS *args = (glHistogram_ARGS *)&unpacked->args; \
    glHistogram(args->target, args->width, args->internalformat, args->sink);; \
} while(0)
void glHistogram(glHistogram_ARG_EXPAND);
packed_call_t *pack_glHistogram(glHistogram_PACKED *_dst glHistogram_ARG_EXPAND_TAIL);
typedef void (*glHistogram_PTR)(glHistogram_ARG_EXPAND);
#endif
#ifndef glHistogramEXT_RETURN
#define glHistogramEXT_RETURN void
#define glHistogramEXT_ARG_NAMES target, width, internalformat, sink
#define glHistogramEXT_ARG_EXPAND GLenum target, GLsizei width, GLenum internalformat, GLboolean sink
#define glHistogramEXT_ARG_NAMES_TAIL , target, width, internalformat, sink
#define glHistogramEXT_ARG_EXPAND_TAIL , GLenum target, GLsizei width, GLenum internalformat, GLboolean sink
#define forward_glHistogramEXT(_target, _width, _internalformat, _sink) \
    ({ \
        void *dst = remote_dma(sizeof(glHistogramEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glHistogramEXT(dst, _target, _width, _internalformat, _sink), NULL); \
    });
#define call_glHistogramEXT(packed, ret_v) do { \
    glHistogramEXT_PACKED *unpacked = (glHistogramEXT_PACKED *)packed; \
    glHistogramEXT_ARGS *args = (glHistogramEXT_ARGS *)&unpacked->args; \
    glHistogramEXT(args->target, args->width, args->internalformat, args->sink);; \
} while(0)
void glHistogramEXT(glHistogramEXT_ARG_EXPAND);
packed_call_t *pack_glHistogramEXT(glHistogramEXT_PACKED *_dst glHistogramEXT_ARG_EXPAND_TAIL);
typedef void (*glHistogramEXT_PTR)(glHistogramEXT_ARG_EXPAND);
#endif
#ifndef glIglooInterfaceSGIX_RETURN
#define glIglooInterfaceSGIX_RETURN void
#define glIglooInterfaceSGIX_ARG_NAMES pname, params
#define glIglooInterfaceSGIX_ARG_EXPAND GLenum pname, const GLvoid * params
#define glIglooInterfaceSGIX_ARG_NAMES_TAIL , pname, params
#define glIglooInterfaceSGIX_ARG_EXPAND_TAIL , GLenum pname, const GLvoid * params
#define forward_glIglooInterfaceSGIX(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glIglooInterfaceSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIglooInterfaceSGIX(dst, _pname, _params), NULL); \
    });
#define call_glIglooInterfaceSGIX(packed, ret_v) do { \
    glIglooInterfaceSGIX_PACKED *unpacked = (glIglooInterfaceSGIX_PACKED *)packed; \
    glIglooInterfaceSGIX_ARGS *args = (glIglooInterfaceSGIX_ARGS *)&unpacked->args; \
    glIglooInterfaceSGIX(args->pname, args->params);; \
} while(0)
void glIglooInterfaceSGIX(glIglooInterfaceSGIX_ARG_EXPAND);
packed_call_t *pack_glIglooInterfaceSGIX(glIglooInterfaceSGIX_PACKED *_dst glIglooInterfaceSGIX_ARG_EXPAND_TAIL);
typedef void (*glIglooInterfaceSGIX_PTR)(glIglooInterfaceSGIX_ARG_EXPAND);
#endif
#ifndef glImageTransformParameterfHP_RETURN
#define glImageTransformParameterfHP_RETURN void
#define glImageTransformParameterfHP_ARG_NAMES target, pname, param
#define glImageTransformParameterfHP_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glImageTransformParameterfHP_ARG_NAMES_TAIL , target, pname, param
#define glImageTransformParameterfHP_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat param
#define forward_glImageTransformParameterfHP(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glImageTransformParameterfHP_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glImageTransformParameterfHP(dst, _target, _pname, _param), NULL); \
    });
#define call_glImageTransformParameterfHP(packed, ret_v) do { \
    glImageTransformParameterfHP_PACKED *unpacked = (glImageTransformParameterfHP_PACKED *)packed; \
    glImageTransformParameterfHP_ARGS *args = (glImageTransformParameterfHP_ARGS *)&unpacked->args; \
    glImageTransformParameterfHP(args->target, args->pname, args->param);; \
} while(0)
void glImageTransformParameterfHP(glImageTransformParameterfHP_ARG_EXPAND);
packed_call_t *pack_glImageTransformParameterfHP(glImageTransformParameterfHP_PACKED *_dst glImageTransformParameterfHP_ARG_EXPAND_TAIL);
typedef void (*glImageTransformParameterfHP_PTR)(glImageTransformParameterfHP_ARG_EXPAND);
#endif
#ifndef glImageTransformParameterfvHP_RETURN
#define glImageTransformParameterfvHP_RETURN void
#define glImageTransformParameterfvHP_ARG_NAMES target, pname, params
#define glImageTransformParameterfvHP_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glImageTransformParameterfvHP_ARG_NAMES_TAIL , target, pname, params
#define glImageTransformParameterfvHP_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glImageTransformParameterfvHP(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glImageTransformParameterfvHP_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glImageTransformParameterfvHP(dst, _target, _pname, _params), NULL); \
    });
#define call_glImageTransformParameterfvHP(packed, ret_v) do { \
    glImageTransformParameterfvHP_PACKED *unpacked = (glImageTransformParameterfvHP_PACKED *)packed; \
    glImageTransformParameterfvHP_ARGS *args = (glImageTransformParameterfvHP_ARGS *)&unpacked->args; \
    glImageTransformParameterfvHP(args->target, args->pname, args->params);; \
} while(0)
void glImageTransformParameterfvHP(glImageTransformParameterfvHP_ARG_EXPAND);
packed_call_t *pack_glImageTransformParameterfvHP(glImageTransformParameterfvHP_PACKED *_dst glImageTransformParameterfvHP_ARG_EXPAND_TAIL);
typedef void (*glImageTransformParameterfvHP_PTR)(glImageTransformParameterfvHP_ARG_EXPAND);
#endif
#ifndef glImageTransformParameteriHP_RETURN
#define glImageTransformParameteriHP_RETURN void
#define glImageTransformParameteriHP_ARG_NAMES target, pname, param
#define glImageTransformParameteriHP_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glImageTransformParameteriHP_ARG_NAMES_TAIL , target, pname, param
#define glImageTransformParameteriHP_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint param
#define forward_glImageTransformParameteriHP(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glImageTransformParameteriHP_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glImageTransformParameteriHP(dst, _target, _pname, _param), NULL); \
    });
#define call_glImageTransformParameteriHP(packed, ret_v) do { \
    glImageTransformParameteriHP_PACKED *unpacked = (glImageTransformParameteriHP_PACKED *)packed; \
    glImageTransformParameteriHP_ARGS *args = (glImageTransformParameteriHP_ARGS *)&unpacked->args; \
    glImageTransformParameteriHP(args->target, args->pname, args->param);; \
} while(0)
void glImageTransformParameteriHP(glImageTransformParameteriHP_ARG_EXPAND);
packed_call_t *pack_glImageTransformParameteriHP(glImageTransformParameteriHP_PACKED *_dst glImageTransformParameteriHP_ARG_EXPAND_TAIL);
typedef void (*glImageTransformParameteriHP_PTR)(glImageTransformParameteriHP_ARG_EXPAND);
#endif
#ifndef glImageTransformParameterivHP_RETURN
#define glImageTransformParameterivHP_RETURN void
#define glImageTransformParameterivHP_ARG_NAMES target, pname, params
#define glImageTransformParameterivHP_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glImageTransformParameterivHP_ARG_NAMES_TAIL , target, pname, params
#define glImageTransformParameterivHP_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glImageTransformParameterivHP(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glImageTransformParameterivHP_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glImageTransformParameterivHP(dst, _target, _pname, _params), NULL); \
    });
#define call_glImageTransformParameterivHP(packed, ret_v) do { \
    glImageTransformParameterivHP_PACKED *unpacked = (glImageTransformParameterivHP_PACKED *)packed; \
    glImageTransformParameterivHP_ARGS *args = (glImageTransformParameterivHP_ARGS *)&unpacked->args; \
    glImageTransformParameterivHP(args->target, args->pname, args->params);; \
} while(0)
void glImageTransformParameterivHP(glImageTransformParameterivHP_ARG_EXPAND);
packed_call_t *pack_glImageTransformParameterivHP(glImageTransformParameterivHP_PACKED *_dst glImageTransformParameterivHP_ARG_EXPAND_TAIL);
typedef void (*glImageTransformParameterivHP_PTR)(glImageTransformParameterivHP_ARG_EXPAND);
#endif
#ifndef glImportSyncEXT_RETURN
#define glImportSyncEXT_RETURN GLsync
#define glImportSyncEXT_ARG_NAMES external_sync_type, external_sync, flags
#define glImportSyncEXT_ARG_EXPAND GLenum external_sync_type, GLintptr external_sync, GLbitfield flags
#define glImportSyncEXT_ARG_NAMES_TAIL , external_sync_type, external_sync, flags
#define glImportSyncEXT_ARG_EXPAND_TAIL , GLenum external_sync_type, GLintptr external_sync, GLbitfield flags
#define forward_glImportSyncEXT(_external_sync_type, _external_sync, _flags) \
    ({ \
        void *dst = remote_dma(sizeof(glImportSyncEXT_PACKED)); \
        GLsync ret = (GLsync)0; \
        remote_dma_send((packed_call_t *)pack_glImportSyncEXT(dst, _external_sync_type, _external_sync, _flags), &ret); \
        ret; \
    });
#define call_glImportSyncEXT(packed, ret_v) do { \
    glImportSyncEXT_PACKED *unpacked = (glImportSyncEXT_PACKED *)packed; \
    glImportSyncEXT_ARGS *args = (glImportSyncEXT_ARGS *)&unpacked->args; \
    GLsync *ret = (GLsync *)ret_v; \
    if (ret != NULL) { \
        *ret = glImportSyncEXT(args->external_sync_type, args->external_sync, args->flags);; \
    } else { \
        glImportSyncEXT(args->external_sync_type, args->external_sync, args->flags);; \
    } \
} while(0)
GLsync glImportSyncEXT(glImportSyncEXT_ARG_EXPAND);
packed_call_t *pack_glImportSyncEXT(glImportSyncEXT_PACKED *_dst glImportSyncEXT_ARG_EXPAND_TAIL);
typedef GLsync (*glImportSyncEXT_PTR)(glImportSyncEXT_ARG_EXPAND);
#endif
#ifndef glIndexFormatNV_RETURN
#define glIndexFormatNV_RETURN void
#define glIndexFormatNV_ARG_NAMES type, stride
#define glIndexFormatNV_ARG_EXPAND GLenum type, GLsizei stride
#define glIndexFormatNV_ARG_NAMES_TAIL , type, stride
#define glIndexFormatNV_ARG_EXPAND_TAIL , GLenum type, GLsizei stride
#define forward_glIndexFormatNV(_type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexFormatNV(dst, _type, _stride), NULL); \
    });
#define call_glIndexFormatNV(packed, ret_v) do { \
    glIndexFormatNV_PACKED *unpacked = (glIndexFormatNV_PACKED *)packed; \
    glIndexFormatNV_ARGS *args = (glIndexFormatNV_ARGS *)&unpacked->args; \
    glIndexFormatNV(args->type, args->stride);; \
} while(0)
void glIndexFormatNV(glIndexFormatNV_ARG_EXPAND);
packed_call_t *pack_glIndexFormatNV(glIndexFormatNV_PACKED *_dst glIndexFormatNV_ARG_EXPAND_TAIL);
typedef void (*glIndexFormatNV_PTR)(glIndexFormatNV_ARG_EXPAND);
#endif
#ifndef glIndexFuncEXT_RETURN
#define glIndexFuncEXT_RETURN void
#define glIndexFuncEXT_ARG_NAMES func, ref
#define glIndexFuncEXT_ARG_EXPAND GLenum func, GLclampf ref
#define glIndexFuncEXT_ARG_NAMES_TAIL , func, ref
#define glIndexFuncEXT_ARG_EXPAND_TAIL , GLenum func, GLclampf ref
#define forward_glIndexFuncEXT(_func, _ref) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexFuncEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexFuncEXT(dst, _func, _ref), NULL); \
    });
#define call_glIndexFuncEXT(packed, ret_v) do { \
    glIndexFuncEXT_PACKED *unpacked = (glIndexFuncEXT_PACKED *)packed; \
    glIndexFuncEXT_ARGS *args = (glIndexFuncEXT_ARGS *)&unpacked->args; \
    glIndexFuncEXT(args->func, args->ref);; \
} while(0)
void glIndexFuncEXT(glIndexFuncEXT_ARG_EXPAND);
packed_call_t *pack_glIndexFuncEXT(glIndexFuncEXT_PACKED *_dst glIndexFuncEXT_ARG_EXPAND_TAIL);
typedef void (*glIndexFuncEXT_PTR)(glIndexFuncEXT_ARG_EXPAND);
#endif
#ifndef glIndexMask_RETURN
#define glIndexMask_RETURN void
#define glIndexMask_ARG_NAMES mask
#define glIndexMask_ARG_EXPAND GLuint mask
#define glIndexMask_ARG_NAMES_TAIL , mask
#define glIndexMask_ARG_EXPAND_TAIL , GLuint mask
#define forward_glIndexMask(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexMask_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexMask(dst, _mask), NULL); \
    });
#define call_glIndexMask(packed, ret_v) do { \
    glIndexMask_PACKED *unpacked = (glIndexMask_PACKED *)packed; \
    glIndexMask_ARGS *args = (glIndexMask_ARGS *)&unpacked->args; \
    glIndexMask(args->mask);; \
} while(0)
void glIndexMask(glIndexMask_ARG_EXPAND);
packed_call_t *pack_glIndexMask(glIndexMask_PACKED *_dst glIndexMask_ARG_EXPAND_TAIL);
typedef void (*glIndexMask_PTR)(glIndexMask_ARG_EXPAND);
#endif
#ifndef glIndexMaterialEXT_RETURN
#define glIndexMaterialEXT_RETURN void
#define glIndexMaterialEXT_ARG_NAMES face, mode
#define glIndexMaterialEXT_ARG_EXPAND GLenum face, GLenum mode
#define glIndexMaterialEXT_ARG_NAMES_TAIL , face, mode
#define glIndexMaterialEXT_ARG_EXPAND_TAIL , GLenum face, GLenum mode
#define forward_glIndexMaterialEXT(_face, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexMaterialEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexMaterialEXT(dst, _face, _mode), NULL); \
    });
#define call_glIndexMaterialEXT(packed, ret_v) do { \
    glIndexMaterialEXT_PACKED *unpacked = (glIndexMaterialEXT_PACKED *)packed; \
    glIndexMaterialEXT_ARGS *args = (glIndexMaterialEXT_ARGS *)&unpacked->args; \
    glIndexMaterialEXT(args->face, args->mode);; \
} while(0)
void glIndexMaterialEXT(glIndexMaterialEXT_ARG_EXPAND);
packed_call_t *pack_glIndexMaterialEXT(glIndexMaterialEXT_PACKED *_dst glIndexMaterialEXT_ARG_EXPAND_TAIL);
typedef void (*glIndexMaterialEXT_PTR)(glIndexMaterialEXT_ARG_EXPAND);
#endif
#ifndef glIndexPointer_RETURN
#define glIndexPointer_RETURN void
#define glIndexPointer_ARG_NAMES type, stride, pointer
#define glIndexPointer_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glIndexPointer_ARG_NAMES_TAIL , type, stride, pointer
#define glIndexPointer_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glIndexPointer(_type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexPointer(dst, _type, _stride, _pointer), NULL); \
    });
#define call_glIndexPointer(packed, ret_v) do { \
    glIndexPointer_PACKED *unpacked = (glIndexPointer_PACKED *)packed; \
    glIndexPointer_ARGS *args = (glIndexPointer_ARGS *)&unpacked->args; \
    glIndexPointer(args->type, args->stride, args->pointer);; \
} while(0)
void glIndexPointer(glIndexPointer_ARG_EXPAND);
packed_call_t *pack_glIndexPointer(glIndexPointer_PACKED *_dst glIndexPointer_ARG_EXPAND_TAIL);
typedef void (*glIndexPointer_PTR)(glIndexPointer_ARG_EXPAND);
#endif
#ifndef glIndexPointerEXT_RETURN
#define glIndexPointerEXT_RETURN void
#define glIndexPointerEXT_ARG_NAMES type, stride, count, pointer
#define glIndexPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glIndexPointerEXT_ARG_NAMES_TAIL , type, stride, count, pointer
#define glIndexPointerEXT_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define forward_glIndexPointerEXT(_type, _stride, _count, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexPointerEXT(dst, _type, _stride, _count, _pointer), NULL); \
    });
#define call_glIndexPointerEXT(packed, ret_v) do { \
    glIndexPointerEXT_PACKED *unpacked = (glIndexPointerEXT_PACKED *)packed; \
    glIndexPointerEXT_ARGS *args = (glIndexPointerEXT_ARGS *)&unpacked->args; \
    glIndexPointerEXT(args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glIndexPointerEXT(glIndexPointerEXT_ARG_EXPAND);
packed_call_t *pack_glIndexPointerEXT(glIndexPointerEXT_PACKED *_dst glIndexPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glIndexPointerEXT_PTR)(glIndexPointerEXT_ARG_EXPAND);
#endif
#ifndef glIndexPointerListIBM_RETURN
#define glIndexPointerListIBM_RETURN void
#define glIndexPointerListIBM_ARG_NAMES type, stride, pointer, ptrstride
#define glIndexPointerListIBM_ARG_EXPAND GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glIndexPointerListIBM_ARG_NAMES_TAIL , type, stride, pointer, ptrstride
#define glIndexPointerListIBM_ARG_EXPAND_TAIL , GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define forward_glIndexPointerListIBM(_type, _stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexPointerListIBM(dst, _type, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glIndexPointerListIBM(packed, ret_v) do { \
    glIndexPointerListIBM_PACKED *unpacked = (glIndexPointerListIBM_PACKED *)packed; \
    glIndexPointerListIBM_ARGS *args = (glIndexPointerListIBM_ARGS *)&unpacked->args; \
    glIndexPointerListIBM(args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glIndexPointerListIBM(glIndexPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glIndexPointerListIBM(glIndexPointerListIBM_PACKED *_dst glIndexPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glIndexPointerListIBM_PTR)(glIndexPointerListIBM_ARG_EXPAND);
#endif
#ifndef glIndexd_RETURN
#define glIndexd_RETURN void
#define glIndexd_ARG_NAMES c
#define glIndexd_ARG_EXPAND GLdouble c
#define glIndexd_ARG_NAMES_TAIL , c
#define glIndexd_ARG_EXPAND_TAIL , GLdouble c
#define forward_glIndexd(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexd(dst, _c), NULL); \
    });
#define call_glIndexd(packed, ret_v) do { \
    glIndexd_PACKED *unpacked = (glIndexd_PACKED *)packed; \
    glIndexd_ARGS *args = (glIndexd_ARGS *)&unpacked->args; \
    glIndexd(args->c);; \
} while(0)
void glIndexd(glIndexd_ARG_EXPAND);
packed_call_t *pack_glIndexd(glIndexd_PACKED *_dst glIndexd_ARG_EXPAND_TAIL);
typedef void (*glIndexd_PTR)(glIndexd_ARG_EXPAND);
#endif
#ifndef glIndexdv_RETURN
#define glIndexdv_RETURN void
#define glIndexdv_ARG_NAMES c
#define glIndexdv_ARG_EXPAND const GLdouble * c
#define glIndexdv_ARG_NAMES_TAIL , c
#define glIndexdv_ARG_EXPAND_TAIL , const GLdouble * c
#define forward_glIndexdv(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexdv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexdv(dst, _c), NULL); \
    });
#define call_glIndexdv(packed, ret_v) do { \
    glIndexdv_PACKED *unpacked = (glIndexdv_PACKED *)packed; \
    glIndexdv_ARGS *args = (glIndexdv_ARGS *)&unpacked->args; \
    glIndexdv(args->c);; \
} while(0)
void glIndexdv(glIndexdv_ARG_EXPAND);
packed_call_t *pack_glIndexdv(glIndexdv_PACKED *_dst glIndexdv_ARG_EXPAND_TAIL);
typedef void (*glIndexdv_PTR)(glIndexdv_ARG_EXPAND);
#endif
#ifndef glIndexf_RETURN
#define glIndexf_RETURN void
#define glIndexf_ARG_NAMES c
#define glIndexf_ARG_EXPAND GLfloat c
#define glIndexf_ARG_NAMES_TAIL , c
#define glIndexf_ARG_EXPAND_TAIL , GLfloat c
#define forward_glIndexf(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexf(dst, _c), NULL); \
    });
#define call_glIndexf(packed, ret_v) do { \
    glIndexf_PACKED *unpacked = (glIndexf_PACKED *)packed; \
    glIndexf_ARGS *args = (glIndexf_ARGS *)&unpacked->args; \
    glIndexf(args->c);; \
} while(0)
void glIndexf(glIndexf_ARG_EXPAND);
packed_call_t *pack_glIndexf(glIndexf_PACKED *_dst glIndexf_ARG_EXPAND_TAIL);
typedef void (*glIndexf_PTR)(glIndexf_ARG_EXPAND);
#endif
#ifndef glIndexfv_RETURN
#define glIndexfv_RETURN void
#define glIndexfv_ARG_NAMES c
#define glIndexfv_ARG_EXPAND const GLfloat * c
#define glIndexfv_ARG_NAMES_TAIL , c
#define glIndexfv_ARG_EXPAND_TAIL , const GLfloat * c
#define forward_glIndexfv(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexfv(dst, _c), NULL); \
    });
#define call_glIndexfv(packed, ret_v) do { \
    glIndexfv_PACKED *unpacked = (glIndexfv_PACKED *)packed; \
    glIndexfv_ARGS *args = (glIndexfv_ARGS *)&unpacked->args; \
    glIndexfv(args->c);; \
} while(0)
void glIndexfv(glIndexfv_ARG_EXPAND);
packed_call_t *pack_glIndexfv(glIndexfv_PACKED *_dst glIndexfv_ARG_EXPAND_TAIL);
typedef void (*glIndexfv_PTR)(glIndexfv_ARG_EXPAND);
#endif
#ifndef glIndexi_RETURN
#define glIndexi_RETURN void
#define glIndexi_ARG_NAMES c
#define glIndexi_ARG_EXPAND GLint c
#define glIndexi_ARG_NAMES_TAIL , c
#define glIndexi_ARG_EXPAND_TAIL , GLint c
#define forward_glIndexi(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexi_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexi(dst, _c), NULL); \
    });
#define call_glIndexi(packed, ret_v) do { \
    glIndexi_PACKED *unpacked = (glIndexi_PACKED *)packed; \
    glIndexi_ARGS *args = (glIndexi_ARGS *)&unpacked->args; \
    glIndexi(args->c);; \
} while(0)
void glIndexi(glIndexi_ARG_EXPAND);
packed_call_t *pack_glIndexi(glIndexi_PACKED *_dst glIndexi_ARG_EXPAND_TAIL);
typedef void (*glIndexi_PTR)(glIndexi_ARG_EXPAND);
#endif
#ifndef glIndexiv_RETURN
#define glIndexiv_RETURN void
#define glIndexiv_ARG_NAMES c
#define glIndexiv_ARG_EXPAND const GLint * c
#define glIndexiv_ARG_NAMES_TAIL , c
#define glIndexiv_ARG_EXPAND_TAIL , const GLint * c
#define forward_glIndexiv(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexiv(dst, _c), NULL); \
    });
#define call_glIndexiv(packed, ret_v) do { \
    glIndexiv_PACKED *unpacked = (glIndexiv_PACKED *)packed; \
    glIndexiv_ARGS *args = (glIndexiv_ARGS *)&unpacked->args; \
    glIndexiv(args->c);; \
} while(0)
void glIndexiv(glIndexiv_ARG_EXPAND);
packed_call_t *pack_glIndexiv(glIndexiv_PACKED *_dst glIndexiv_ARG_EXPAND_TAIL);
typedef void (*glIndexiv_PTR)(glIndexiv_ARG_EXPAND);
#endif
#ifndef glIndexs_RETURN
#define glIndexs_RETURN void
#define glIndexs_ARG_NAMES c
#define glIndexs_ARG_EXPAND GLshort c
#define glIndexs_ARG_NAMES_TAIL , c
#define glIndexs_ARG_EXPAND_TAIL , GLshort c
#define forward_glIndexs(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexs_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexs(dst, _c), NULL); \
    });
#define call_glIndexs(packed, ret_v) do { \
    glIndexs_PACKED *unpacked = (glIndexs_PACKED *)packed; \
    glIndexs_ARGS *args = (glIndexs_ARGS *)&unpacked->args; \
    glIndexs(args->c);; \
} while(0)
void glIndexs(glIndexs_ARG_EXPAND);
packed_call_t *pack_glIndexs(glIndexs_PACKED *_dst glIndexs_ARG_EXPAND_TAIL);
typedef void (*glIndexs_PTR)(glIndexs_ARG_EXPAND);
#endif
#ifndef glIndexsv_RETURN
#define glIndexsv_RETURN void
#define glIndexsv_ARG_NAMES c
#define glIndexsv_ARG_EXPAND const GLshort * c
#define glIndexsv_ARG_NAMES_TAIL , c
#define glIndexsv_ARG_EXPAND_TAIL , const GLshort * c
#define forward_glIndexsv(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexsv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexsv(dst, _c), NULL); \
    });
#define call_glIndexsv(packed, ret_v) do { \
    glIndexsv_PACKED *unpacked = (glIndexsv_PACKED *)packed; \
    glIndexsv_ARGS *args = (glIndexsv_ARGS *)&unpacked->args; \
    glIndexsv(args->c);; \
} while(0)
void glIndexsv(glIndexsv_ARG_EXPAND);
packed_call_t *pack_glIndexsv(glIndexsv_PACKED *_dst glIndexsv_ARG_EXPAND_TAIL);
typedef void (*glIndexsv_PTR)(glIndexsv_ARG_EXPAND);
#endif
#ifndef glIndexub_RETURN
#define glIndexub_RETURN void
#define glIndexub_ARG_NAMES c
#define glIndexub_ARG_EXPAND GLubyte c
#define glIndexub_ARG_NAMES_TAIL , c
#define glIndexub_ARG_EXPAND_TAIL , GLubyte c
#define forward_glIndexub(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexub_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexub(dst, _c), NULL); \
    });
#define call_glIndexub(packed, ret_v) do { \
    glIndexub_PACKED *unpacked = (glIndexub_PACKED *)packed; \
    glIndexub_ARGS *args = (glIndexub_ARGS *)&unpacked->args; \
    glIndexub(args->c);; \
} while(0)
void glIndexub(glIndexub_ARG_EXPAND);
packed_call_t *pack_glIndexub(glIndexub_PACKED *_dst glIndexub_ARG_EXPAND_TAIL);
typedef void (*glIndexub_PTR)(glIndexub_ARG_EXPAND);
#endif
#ifndef glIndexubv_RETURN
#define glIndexubv_RETURN void
#define glIndexubv_ARG_NAMES c
#define glIndexubv_ARG_EXPAND const GLubyte * c
#define glIndexubv_ARG_NAMES_TAIL , c
#define glIndexubv_ARG_EXPAND_TAIL , const GLubyte * c
#define forward_glIndexubv(_c) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexubv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexubv(dst, _c), NULL); \
    });
#define call_glIndexubv(packed, ret_v) do { \
    glIndexubv_PACKED *unpacked = (glIndexubv_PACKED *)packed; \
    glIndexubv_ARGS *args = (glIndexubv_ARGS *)&unpacked->args; \
    glIndexubv(args->c);; \
} while(0)
void glIndexubv(glIndexubv_ARG_EXPAND);
packed_call_t *pack_glIndexubv(glIndexubv_PACKED *_dst glIndexubv_ARG_EXPAND_TAIL);
typedef void (*glIndexubv_PTR)(glIndexubv_ARG_EXPAND);
#endif
#ifndef glIndexxOES_RETURN
#define glIndexxOES_RETURN void
#define glIndexxOES_ARG_NAMES component
#define glIndexxOES_ARG_EXPAND GLfixed component
#define glIndexxOES_ARG_NAMES_TAIL , component
#define glIndexxOES_ARG_EXPAND_TAIL , GLfixed component
#define forward_glIndexxOES(_component) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexxOES(dst, _component), NULL); \
    });
#define call_glIndexxOES(packed, ret_v) do { \
    glIndexxOES_PACKED *unpacked = (glIndexxOES_PACKED *)packed; \
    glIndexxOES_ARGS *args = (glIndexxOES_ARGS *)&unpacked->args; \
    glIndexxOES(args->component);; \
} while(0)
void glIndexxOES(glIndexxOES_ARG_EXPAND);
packed_call_t *pack_glIndexxOES(glIndexxOES_PACKED *_dst glIndexxOES_ARG_EXPAND_TAIL);
typedef void (*glIndexxOES_PTR)(glIndexxOES_ARG_EXPAND);
#endif
#ifndef glIndexxvOES_RETURN
#define glIndexxvOES_RETURN void
#define glIndexxvOES_ARG_NAMES component
#define glIndexxvOES_ARG_EXPAND const GLfixed * component
#define glIndexxvOES_ARG_NAMES_TAIL , component
#define glIndexxvOES_ARG_EXPAND_TAIL , const GLfixed * component
#define forward_glIndexxvOES(_component) \
    ({ \
        void *dst = remote_dma(sizeof(glIndexxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glIndexxvOES(dst, _component), NULL); \
    });
#define call_glIndexxvOES(packed, ret_v) do { \
    glIndexxvOES_PACKED *unpacked = (glIndexxvOES_PACKED *)packed; \
    glIndexxvOES_ARGS *args = (glIndexxvOES_ARGS *)&unpacked->args; \
    glIndexxvOES(args->component);; \
} while(0)
void glIndexxvOES(glIndexxvOES_ARG_EXPAND);
packed_call_t *pack_glIndexxvOES(glIndexxvOES_PACKED *_dst glIndexxvOES_ARG_EXPAND_TAIL);
typedef void (*glIndexxvOES_PTR)(glIndexxvOES_ARG_EXPAND);
#endif
#ifndef glInitNames_RETURN
#define glInitNames_RETURN void
#define glInitNames_ARG_NAMES 
#define glInitNames_ARG_EXPAND 
#define glInitNames_ARG_NAMES_TAIL 
#define glInitNames_ARG_EXPAND_TAIL 
#define forward_glInitNames() \
    ({ \
        void *dst = remote_dma(sizeof(glInitNames_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInitNames(dst), NULL); \
    });
#define call_glInitNames(packed, ret_v) do { \
    glInitNames();; \
} while(0)
void glInitNames(glInitNames_ARG_EXPAND);
packed_call_t *pack_glInitNames(glInitNames_PACKED *_dst glInitNames_ARG_EXPAND_TAIL);
typedef void (*glInitNames_PTR)(glInitNames_ARG_EXPAND);
#endif
#ifndef glInsertComponentEXT_RETURN
#define glInsertComponentEXT_RETURN void
#define glInsertComponentEXT_ARG_NAMES res, src, num
#define glInsertComponentEXT_ARG_EXPAND GLuint res, GLuint src, GLuint num
#define glInsertComponentEXT_ARG_NAMES_TAIL , res, src, num
#define glInsertComponentEXT_ARG_EXPAND_TAIL , GLuint res, GLuint src, GLuint num
#define forward_glInsertComponentEXT(_res, _src, _num) \
    ({ \
        void *dst = remote_dma(sizeof(glInsertComponentEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInsertComponentEXT(dst, _res, _src, _num), NULL); \
    });
#define call_glInsertComponentEXT(packed, ret_v) do { \
    glInsertComponentEXT_PACKED *unpacked = (glInsertComponentEXT_PACKED *)packed; \
    glInsertComponentEXT_ARGS *args = (glInsertComponentEXT_ARGS *)&unpacked->args; \
    glInsertComponentEXT(args->res, args->src, args->num);; \
} while(0)
void glInsertComponentEXT(glInsertComponentEXT_ARG_EXPAND);
packed_call_t *pack_glInsertComponentEXT(glInsertComponentEXT_PACKED *_dst glInsertComponentEXT_ARG_EXPAND_TAIL);
typedef void (*glInsertComponentEXT_PTR)(glInsertComponentEXT_ARG_EXPAND);
#endif
#ifndef glInstrumentsBufferSGIX_RETURN
#define glInstrumentsBufferSGIX_RETURN void
#define glInstrumentsBufferSGIX_ARG_NAMES size, buffer
#define glInstrumentsBufferSGIX_ARG_EXPAND GLsizei size, GLint * buffer
#define glInstrumentsBufferSGIX_ARG_NAMES_TAIL , size, buffer
#define glInstrumentsBufferSGIX_ARG_EXPAND_TAIL , GLsizei size, GLint * buffer
#define forward_glInstrumentsBufferSGIX(_size, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glInstrumentsBufferSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInstrumentsBufferSGIX(dst, _size, _buffer), NULL); \
    });
#define call_glInstrumentsBufferSGIX(packed, ret_v) do { \
    glInstrumentsBufferSGIX_PACKED *unpacked = (glInstrumentsBufferSGIX_PACKED *)packed; \
    glInstrumentsBufferSGIX_ARGS *args = (glInstrumentsBufferSGIX_ARGS *)&unpacked->args; \
    glInstrumentsBufferSGIX(args->size, args->buffer);; \
} while(0)
void glInstrumentsBufferSGIX(glInstrumentsBufferSGIX_ARG_EXPAND);
packed_call_t *pack_glInstrumentsBufferSGIX(glInstrumentsBufferSGIX_PACKED *_dst glInstrumentsBufferSGIX_ARG_EXPAND_TAIL);
typedef void (*glInstrumentsBufferSGIX_PTR)(glInstrumentsBufferSGIX_ARG_EXPAND);
#endif
#ifndef glInterleavedArrays_RETURN
#define glInterleavedArrays_RETURN void
#define glInterleavedArrays_ARG_NAMES format, stride, pointer
#define glInterleavedArrays_ARG_EXPAND GLenum format, GLsizei stride, const GLvoid * pointer
#define glInterleavedArrays_ARG_NAMES_TAIL , format, stride, pointer
#define glInterleavedArrays_ARG_EXPAND_TAIL , GLenum format, GLsizei stride, const GLvoid * pointer
#define forward_glInterleavedArrays(_format, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glInterleavedArrays_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInterleavedArrays(dst, _format, _stride, _pointer), NULL); \
    });
#define call_glInterleavedArrays(packed, ret_v) do { \
    glInterleavedArrays_PACKED *unpacked = (glInterleavedArrays_PACKED *)packed; \
    glInterleavedArrays_ARGS *args = (glInterleavedArrays_ARGS *)&unpacked->args; \
    glInterleavedArrays(args->format, args->stride, args->pointer);; \
} while(0)
void glInterleavedArrays(glInterleavedArrays_ARG_EXPAND);
packed_call_t *pack_glInterleavedArrays(glInterleavedArrays_PACKED *_dst glInterleavedArrays_ARG_EXPAND_TAIL);
typedef void (*glInterleavedArrays_PTR)(glInterleavedArrays_ARG_EXPAND);
#endif
#ifndef glInterpolatePathsNV_RETURN
#define glInterpolatePathsNV_RETURN void
#define glInterpolatePathsNV_ARG_NAMES resultPath, pathA, pathB, weight
#define glInterpolatePathsNV_ARG_EXPAND GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight
#define glInterpolatePathsNV_ARG_NAMES_TAIL , resultPath, pathA, pathB, weight
#define glInterpolatePathsNV_ARG_EXPAND_TAIL , GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight
#define forward_glInterpolatePathsNV(_resultPath, _pathA, _pathB, _weight) \
    ({ \
        void *dst = remote_dma(sizeof(glInterpolatePathsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInterpolatePathsNV(dst, _resultPath, _pathA, _pathB, _weight), NULL); \
    });
#define call_glInterpolatePathsNV(packed, ret_v) do { \
    glInterpolatePathsNV_PACKED *unpacked = (glInterpolatePathsNV_PACKED *)packed; \
    glInterpolatePathsNV_ARGS *args = (glInterpolatePathsNV_ARGS *)&unpacked->args; \
    glInterpolatePathsNV(args->resultPath, args->pathA, args->pathB, args->weight);; \
} while(0)
void glInterpolatePathsNV(glInterpolatePathsNV_ARG_EXPAND);
packed_call_t *pack_glInterpolatePathsNV(glInterpolatePathsNV_PACKED *_dst glInterpolatePathsNV_ARG_EXPAND_TAIL);
typedef void (*glInterpolatePathsNV_PTR)(glInterpolatePathsNV_ARG_EXPAND);
#endif
#ifndef glInvalidateBufferData_RETURN
#define glInvalidateBufferData_RETURN void
#define glInvalidateBufferData_ARG_NAMES buffer
#define glInvalidateBufferData_ARG_EXPAND GLuint buffer
#define glInvalidateBufferData_ARG_NAMES_TAIL , buffer
#define glInvalidateBufferData_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glInvalidateBufferData(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glInvalidateBufferData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInvalidateBufferData(dst, _buffer), NULL); \
    });
#define call_glInvalidateBufferData(packed, ret_v) do { \
    glInvalidateBufferData_PACKED *unpacked = (glInvalidateBufferData_PACKED *)packed; \
    glInvalidateBufferData_ARGS *args = (glInvalidateBufferData_ARGS *)&unpacked->args; \
    glInvalidateBufferData(args->buffer);; \
} while(0)
void glInvalidateBufferData(glInvalidateBufferData_ARG_EXPAND);
packed_call_t *pack_glInvalidateBufferData(glInvalidateBufferData_PACKED *_dst glInvalidateBufferData_ARG_EXPAND_TAIL);
typedef void (*glInvalidateBufferData_PTR)(glInvalidateBufferData_ARG_EXPAND);
#endif
#ifndef glInvalidateBufferSubData_RETURN
#define glInvalidateBufferSubData_RETURN void
#define glInvalidateBufferSubData_ARG_NAMES buffer, offset, length
#define glInvalidateBufferSubData_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr length
#define glInvalidateBufferSubData_ARG_NAMES_TAIL , buffer, offset, length
#define glInvalidateBufferSubData_ARG_EXPAND_TAIL , GLuint buffer, GLintptr offset, GLsizeiptr length
#define forward_glInvalidateBufferSubData(_buffer, _offset, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glInvalidateBufferSubData_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInvalidateBufferSubData(dst, _buffer, _offset, _length), NULL); \
    });
#define call_glInvalidateBufferSubData(packed, ret_v) do { \
    glInvalidateBufferSubData_PACKED *unpacked = (glInvalidateBufferSubData_PACKED *)packed; \
    glInvalidateBufferSubData_ARGS *args = (glInvalidateBufferSubData_ARGS *)&unpacked->args; \
    glInvalidateBufferSubData(args->buffer, args->offset, args->length);; \
} while(0)
void glInvalidateBufferSubData(glInvalidateBufferSubData_ARG_EXPAND);
packed_call_t *pack_glInvalidateBufferSubData(glInvalidateBufferSubData_PACKED *_dst glInvalidateBufferSubData_ARG_EXPAND_TAIL);
typedef void (*glInvalidateBufferSubData_PTR)(glInvalidateBufferSubData_ARG_EXPAND);
#endif
#ifndef glInvalidateFramebuffer_RETURN
#define glInvalidateFramebuffer_RETURN void
#define glInvalidateFramebuffer_ARG_NAMES target, numAttachments, attachments
#define glInvalidateFramebuffer_ARG_EXPAND GLenum target, GLsizei numAttachments, const GLenum * attachments
#define glInvalidateFramebuffer_ARG_NAMES_TAIL , target, numAttachments, attachments
#define glInvalidateFramebuffer_ARG_EXPAND_TAIL , GLenum target, GLsizei numAttachments, const GLenum * attachments
#define forward_glInvalidateFramebuffer(_target, _numAttachments, _attachments) \
    ({ \
        void *dst = remote_dma(sizeof(glInvalidateFramebuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInvalidateFramebuffer(dst, _target, _numAttachments, _attachments), NULL); \
    });
#define call_glInvalidateFramebuffer(packed, ret_v) do { \
    glInvalidateFramebuffer_PACKED *unpacked = (glInvalidateFramebuffer_PACKED *)packed; \
    glInvalidateFramebuffer_ARGS *args = (glInvalidateFramebuffer_ARGS *)&unpacked->args; \
    glInvalidateFramebuffer(args->target, args->numAttachments, args->attachments);; \
} while(0)
void glInvalidateFramebuffer(glInvalidateFramebuffer_ARG_EXPAND);
packed_call_t *pack_glInvalidateFramebuffer(glInvalidateFramebuffer_PACKED *_dst glInvalidateFramebuffer_ARG_EXPAND_TAIL);
typedef void (*glInvalidateFramebuffer_PTR)(glInvalidateFramebuffer_ARG_EXPAND);
#endif
#ifndef glInvalidateSubFramebuffer_RETURN
#define glInvalidateSubFramebuffer_RETURN void
#define glInvalidateSubFramebuffer_ARG_NAMES target, numAttachments, attachments, x, y, width, height
#define glInvalidateSubFramebuffer_ARG_EXPAND GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height
#define glInvalidateSubFramebuffer_ARG_NAMES_TAIL , target, numAttachments, attachments, x, y, width, height
#define glInvalidateSubFramebuffer_ARG_EXPAND_TAIL , GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glInvalidateSubFramebuffer(_target, _numAttachments, _attachments, _x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glInvalidateSubFramebuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInvalidateSubFramebuffer(dst, _target, _numAttachments, _attachments, _x, _y, _width, _height), NULL); \
    });
#define call_glInvalidateSubFramebuffer(packed, ret_v) do { \
    glInvalidateSubFramebuffer_PACKED *unpacked = (glInvalidateSubFramebuffer_PACKED *)packed; \
    glInvalidateSubFramebuffer_ARGS *args = (glInvalidateSubFramebuffer_ARGS *)&unpacked->args; \
    glInvalidateSubFramebuffer(args->target, args->numAttachments, args->attachments, args->x, args->y, args->width, args->height);; \
} while(0)
void glInvalidateSubFramebuffer(glInvalidateSubFramebuffer_ARG_EXPAND);
packed_call_t *pack_glInvalidateSubFramebuffer(glInvalidateSubFramebuffer_PACKED *_dst glInvalidateSubFramebuffer_ARG_EXPAND_TAIL);
typedef void (*glInvalidateSubFramebuffer_PTR)(glInvalidateSubFramebuffer_ARG_EXPAND);
#endif
#ifndef glInvalidateTexImage_RETURN
#define glInvalidateTexImage_RETURN void
#define glInvalidateTexImage_ARG_NAMES texture, level
#define glInvalidateTexImage_ARG_EXPAND GLuint texture, GLint level
#define glInvalidateTexImage_ARG_NAMES_TAIL , texture, level
#define glInvalidateTexImage_ARG_EXPAND_TAIL , GLuint texture, GLint level
#define forward_glInvalidateTexImage(_texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glInvalidateTexImage_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInvalidateTexImage(dst, _texture, _level), NULL); \
    });
#define call_glInvalidateTexImage(packed, ret_v) do { \
    glInvalidateTexImage_PACKED *unpacked = (glInvalidateTexImage_PACKED *)packed; \
    glInvalidateTexImage_ARGS *args = (glInvalidateTexImage_ARGS *)&unpacked->args; \
    glInvalidateTexImage(args->texture, args->level);; \
} while(0)
void glInvalidateTexImage(glInvalidateTexImage_ARG_EXPAND);
packed_call_t *pack_glInvalidateTexImage(glInvalidateTexImage_PACKED *_dst glInvalidateTexImage_ARG_EXPAND_TAIL);
typedef void (*glInvalidateTexImage_PTR)(glInvalidateTexImage_ARG_EXPAND);
#endif
#ifndef glInvalidateTexSubImage_RETURN
#define glInvalidateTexSubImage_RETURN void
#define glInvalidateTexSubImage_ARG_NAMES texture, level, xoffset, yoffset, zoffset, width, height, depth
#define glInvalidateTexSubImage_ARG_EXPAND GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth
#define glInvalidateTexSubImage_ARG_NAMES_TAIL , texture, level, xoffset, yoffset, zoffset, width, height, depth
#define glInvalidateTexSubImage_ARG_EXPAND_TAIL , GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth
#define forward_glInvalidateTexSubImage(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth) \
    ({ \
        void *dst = remote_dma(sizeof(glInvalidateTexSubImage_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glInvalidateTexSubImage(dst, _texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth), NULL); \
    });
#define call_glInvalidateTexSubImage(packed, ret_v) do { \
    glInvalidateTexSubImage_PACKED *unpacked = (glInvalidateTexSubImage_PACKED *)packed; \
    glInvalidateTexSubImage_ARGS *args = (glInvalidateTexSubImage_ARGS *)&unpacked->args; \
    glInvalidateTexSubImage(args->texture, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth);; \
} while(0)
void glInvalidateTexSubImage(glInvalidateTexSubImage_ARG_EXPAND);
packed_call_t *pack_glInvalidateTexSubImage(glInvalidateTexSubImage_PACKED *_dst glInvalidateTexSubImage_ARG_EXPAND_TAIL);
typedef void (*glInvalidateTexSubImage_PTR)(glInvalidateTexSubImage_ARG_EXPAND);
#endif
#ifndef glIsAsyncMarkerSGIX_RETURN
#define glIsAsyncMarkerSGIX_RETURN GLboolean
#define glIsAsyncMarkerSGIX_ARG_NAMES marker
#define glIsAsyncMarkerSGIX_ARG_EXPAND GLuint marker
#define glIsAsyncMarkerSGIX_ARG_NAMES_TAIL , marker
#define glIsAsyncMarkerSGIX_ARG_EXPAND_TAIL , GLuint marker
#define forward_glIsAsyncMarkerSGIX(_marker) \
    ({ \
        void *dst = remote_dma(sizeof(glIsAsyncMarkerSGIX_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsAsyncMarkerSGIX(dst, _marker), &ret); \
        ret; \
    });
#define call_glIsAsyncMarkerSGIX(packed, ret_v) do { \
    glIsAsyncMarkerSGIX_PACKED *unpacked = (glIsAsyncMarkerSGIX_PACKED *)packed; \
    glIsAsyncMarkerSGIX_ARGS *args = (glIsAsyncMarkerSGIX_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsAsyncMarkerSGIX(args->marker);; \
    } else { \
        glIsAsyncMarkerSGIX(args->marker);; \
    } \
} while(0)
GLboolean glIsAsyncMarkerSGIX(glIsAsyncMarkerSGIX_ARG_EXPAND);
packed_call_t *pack_glIsAsyncMarkerSGIX(glIsAsyncMarkerSGIX_PACKED *_dst glIsAsyncMarkerSGIX_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsAsyncMarkerSGIX_PTR)(glIsAsyncMarkerSGIX_ARG_EXPAND);
#endif
#ifndef glIsBuffer_RETURN
#define glIsBuffer_RETURN GLboolean
#define glIsBuffer_ARG_NAMES buffer
#define glIsBuffer_ARG_EXPAND GLuint buffer
#define glIsBuffer_ARG_NAMES_TAIL , buffer
#define glIsBuffer_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glIsBuffer(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsBuffer_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsBuffer(dst, _buffer), &ret); \
        ret; \
    });
#define call_glIsBuffer(packed, ret_v) do { \
    glIsBuffer_PACKED *unpacked = (glIsBuffer_PACKED *)packed; \
    glIsBuffer_ARGS *args = (glIsBuffer_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsBuffer(args->buffer);; \
    } else { \
        glIsBuffer(args->buffer);; \
    } \
} while(0)
GLboolean glIsBuffer(glIsBuffer_ARG_EXPAND);
packed_call_t *pack_glIsBuffer(glIsBuffer_PACKED *_dst glIsBuffer_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsBuffer_PTR)(glIsBuffer_ARG_EXPAND);
#endif
#ifndef glIsBufferARB_RETURN
#define glIsBufferARB_RETURN GLboolean
#define glIsBufferARB_ARG_NAMES buffer
#define glIsBufferARB_ARG_EXPAND GLuint buffer
#define glIsBufferARB_ARG_NAMES_TAIL , buffer
#define glIsBufferARB_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glIsBufferARB(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsBufferARB_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsBufferARB(dst, _buffer), &ret); \
        ret; \
    });
#define call_glIsBufferARB(packed, ret_v) do { \
    glIsBufferARB_PACKED *unpacked = (glIsBufferARB_PACKED *)packed; \
    glIsBufferARB_ARGS *args = (glIsBufferARB_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsBufferARB(args->buffer);; \
    } else { \
        glIsBufferARB(args->buffer);; \
    } \
} while(0)
GLboolean glIsBufferARB(glIsBufferARB_ARG_EXPAND);
packed_call_t *pack_glIsBufferARB(glIsBufferARB_PACKED *_dst glIsBufferARB_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsBufferARB_PTR)(glIsBufferARB_ARG_EXPAND);
#endif
#ifndef glIsBufferResidentNV_RETURN
#define glIsBufferResidentNV_RETURN GLboolean
#define glIsBufferResidentNV_ARG_NAMES target
#define glIsBufferResidentNV_ARG_EXPAND GLenum target
#define glIsBufferResidentNV_ARG_NAMES_TAIL , target
#define glIsBufferResidentNV_ARG_EXPAND_TAIL , GLenum target
#define forward_glIsBufferResidentNV(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glIsBufferResidentNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsBufferResidentNV(dst, _target), &ret); \
        ret; \
    });
#define call_glIsBufferResidentNV(packed, ret_v) do { \
    glIsBufferResidentNV_PACKED *unpacked = (glIsBufferResidentNV_PACKED *)packed; \
    glIsBufferResidentNV_ARGS *args = (glIsBufferResidentNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsBufferResidentNV(args->target);; \
    } else { \
        glIsBufferResidentNV(args->target);; \
    } \
} while(0)
GLboolean glIsBufferResidentNV(glIsBufferResidentNV_ARG_EXPAND);
packed_call_t *pack_glIsBufferResidentNV(glIsBufferResidentNV_PACKED *_dst glIsBufferResidentNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsBufferResidentNV_PTR)(glIsBufferResidentNV_ARG_EXPAND);
#endif
#ifndef glIsEnabled_RETURN
#define glIsEnabled_RETURN GLboolean
#define glIsEnabled_ARG_NAMES cap
#define glIsEnabled_ARG_EXPAND GLenum cap
#define glIsEnabled_ARG_NAMES_TAIL , cap
#define glIsEnabled_ARG_EXPAND_TAIL , GLenum cap
#define forward_glIsEnabled(_cap) \
    ({ \
        void *dst = remote_dma(sizeof(glIsEnabled_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsEnabled(dst, _cap), &ret); \
        ret; \
    });
#define call_glIsEnabled(packed, ret_v) do { \
    glIsEnabled_PACKED *unpacked = (glIsEnabled_PACKED *)packed; \
    glIsEnabled_ARGS *args = (glIsEnabled_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsEnabled(args->cap);; \
    } else { \
        glIsEnabled(args->cap);; \
    } \
} while(0)
GLboolean glIsEnabled(glIsEnabled_ARG_EXPAND);
packed_call_t *pack_glIsEnabled(glIsEnabled_PACKED *_dst glIsEnabled_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsEnabled_PTR)(glIsEnabled_ARG_EXPAND);
#endif
#ifndef glIsEnabledIndexedEXT_RETURN
#define glIsEnabledIndexedEXT_RETURN GLboolean
#define glIsEnabledIndexedEXT_ARG_NAMES target, index
#define glIsEnabledIndexedEXT_ARG_EXPAND GLenum target, GLuint index
#define glIsEnabledIndexedEXT_ARG_NAMES_TAIL , target, index
#define glIsEnabledIndexedEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index
#define forward_glIsEnabledIndexedEXT(_target, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glIsEnabledIndexedEXT_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsEnabledIndexedEXT(dst, _target, _index), &ret); \
        ret; \
    });
#define call_glIsEnabledIndexedEXT(packed, ret_v) do { \
    glIsEnabledIndexedEXT_PACKED *unpacked = (glIsEnabledIndexedEXT_PACKED *)packed; \
    glIsEnabledIndexedEXT_ARGS *args = (glIsEnabledIndexedEXT_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsEnabledIndexedEXT(args->target, args->index);; \
    } else { \
        glIsEnabledIndexedEXT(args->target, args->index);; \
    } \
} while(0)
GLboolean glIsEnabledIndexedEXT(glIsEnabledIndexedEXT_ARG_EXPAND);
packed_call_t *pack_glIsEnabledIndexedEXT(glIsEnabledIndexedEXT_PACKED *_dst glIsEnabledIndexedEXT_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsEnabledIndexedEXT_PTR)(glIsEnabledIndexedEXT_ARG_EXPAND);
#endif
#ifndef glIsEnabledi_RETURN
#define glIsEnabledi_RETURN GLboolean
#define glIsEnabledi_ARG_NAMES target, index
#define glIsEnabledi_ARG_EXPAND GLenum target, GLuint index
#define glIsEnabledi_ARG_NAMES_TAIL , target, index
#define glIsEnabledi_ARG_EXPAND_TAIL , GLenum target, GLuint index
#define forward_glIsEnabledi(_target, _index) \
    ({ \
        void *dst = remote_dma(sizeof(glIsEnabledi_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsEnabledi(dst, _target, _index), &ret); \
        ret; \
    });
#define call_glIsEnabledi(packed, ret_v) do { \
    glIsEnabledi_PACKED *unpacked = (glIsEnabledi_PACKED *)packed; \
    glIsEnabledi_ARGS *args = (glIsEnabledi_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsEnabledi(args->target, args->index);; \
    } else { \
        glIsEnabledi(args->target, args->index);; \
    } \
} while(0)
GLboolean glIsEnabledi(glIsEnabledi_ARG_EXPAND);
packed_call_t *pack_glIsEnabledi(glIsEnabledi_PACKED *_dst glIsEnabledi_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsEnabledi_PTR)(glIsEnabledi_ARG_EXPAND);
#endif
#ifndef glIsFenceAPPLE_RETURN
#define glIsFenceAPPLE_RETURN GLboolean
#define glIsFenceAPPLE_ARG_NAMES fence
#define glIsFenceAPPLE_ARG_EXPAND GLuint fence
#define glIsFenceAPPLE_ARG_NAMES_TAIL , fence
#define glIsFenceAPPLE_ARG_EXPAND_TAIL , GLuint fence
#define forward_glIsFenceAPPLE(_fence) \
    ({ \
        void *dst = remote_dma(sizeof(glIsFenceAPPLE_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsFenceAPPLE(dst, _fence), &ret); \
        ret; \
    });
#define call_glIsFenceAPPLE(packed, ret_v) do { \
    glIsFenceAPPLE_PACKED *unpacked = (glIsFenceAPPLE_PACKED *)packed; \
    glIsFenceAPPLE_ARGS *args = (glIsFenceAPPLE_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFenceAPPLE(args->fence);; \
    } else { \
        glIsFenceAPPLE(args->fence);; \
    } \
} while(0)
GLboolean glIsFenceAPPLE(glIsFenceAPPLE_ARG_EXPAND);
packed_call_t *pack_glIsFenceAPPLE(glIsFenceAPPLE_PACKED *_dst glIsFenceAPPLE_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsFenceAPPLE_PTR)(glIsFenceAPPLE_ARG_EXPAND);
#endif
#ifndef glIsFenceNV_RETURN
#define glIsFenceNV_RETURN GLboolean
#define glIsFenceNV_ARG_NAMES fence
#define glIsFenceNV_ARG_EXPAND GLuint fence
#define glIsFenceNV_ARG_NAMES_TAIL , fence
#define glIsFenceNV_ARG_EXPAND_TAIL , GLuint fence
#define forward_glIsFenceNV(_fence) \
    ({ \
        void *dst = remote_dma(sizeof(glIsFenceNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsFenceNV(dst, _fence), &ret); \
        ret; \
    });
#define call_glIsFenceNV(packed, ret_v) do { \
    glIsFenceNV_PACKED *unpacked = (glIsFenceNV_PACKED *)packed; \
    glIsFenceNV_ARGS *args = (glIsFenceNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFenceNV(args->fence);; \
    } else { \
        glIsFenceNV(args->fence);; \
    } \
} while(0)
GLboolean glIsFenceNV(glIsFenceNV_ARG_EXPAND);
packed_call_t *pack_glIsFenceNV(glIsFenceNV_PACKED *_dst glIsFenceNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsFenceNV_PTR)(glIsFenceNV_ARG_EXPAND);
#endif
#ifndef glIsFramebuffer_RETURN
#define glIsFramebuffer_RETURN GLboolean
#define glIsFramebuffer_ARG_NAMES framebuffer
#define glIsFramebuffer_ARG_EXPAND GLuint framebuffer
#define glIsFramebuffer_ARG_NAMES_TAIL , framebuffer
#define glIsFramebuffer_ARG_EXPAND_TAIL , GLuint framebuffer
#define forward_glIsFramebuffer(_framebuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsFramebuffer_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsFramebuffer(dst, _framebuffer), &ret); \
        ret; \
    });
#define call_glIsFramebuffer(packed, ret_v) do { \
    glIsFramebuffer_PACKED *unpacked = (glIsFramebuffer_PACKED *)packed; \
    glIsFramebuffer_ARGS *args = (glIsFramebuffer_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFramebuffer(args->framebuffer);; \
    } else { \
        glIsFramebuffer(args->framebuffer);; \
    } \
} while(0)
GLboolean glIsFramebuffer(glIsFramebuffer_ARG_EXPAND);
packed_call_t *pack_glIsFramebuffer(glIsFramebuffer_PACKED *_dst glIsFramebuffer_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsFramebuffer_PTR)(glIsFramebuffer_ARG_EXPAND);
#endif
#ifndef glIsFramebufferEXT_RETURN
#define glIsFramebufferEXT_RETURN GLboolean
#define glIsFramebufferEXT_ARG_NAMES framebuffer
#define glIsFramebufferEXT_ARG_EXPAND GLuint framebuffer
#define glIsFramebufferEXT_ARG_NAMES_TAIL , framebuffer
#define glIsFramebufferEXT_ARG_EXPAND_TAIL , GLuint framebuffer
#define forward_glIsFramebufferEXT(_framebuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsFramebufferEXT_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsFramebufferEXT(dst, _framebuffer), &ret); \
        ret; \
    });
#define call_glIsFramebufferEXT(packed, ret_v) do { \
    glIsFramebufferEXT_PACKED *unpacked = (glIsFramebufferEXT_PACKED *)packed; \
    glIsFramebufferEXT_ARGS *args = (glIsFramebufferEXT_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFramebufferEXT(args->framebuffer);; \
    } else { \
        glIsFramebufferEXT(args->framebuffer);; \
    } \
} while(0)
GLboolean glIsFramebufferEXT(glIsFramebufferEXT_ARG_EXPAND);
packed_call_t *pack_glIsFramebufferEXT(glIsFramebufferEXT_PACKED *_dst glIsFramebufferEXT_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsFramebufferEXT_PTR)(glIsFramebufferEXT_ARG_EXPAND);
#endif
#ifndef glIsImageHandleResidentNV_RETURN
#define glIsImageHandleResidentNV_RETURN GLboolean
#define glIsImageHandleResidentNV_ARG_NAMES handle
#define glIsImageHandleResidentNV_ARG_EXPAND GLuint64 handle
#define glIsImageHandleResidentNV_ARG_NAMES_TAIL , handle
#define glIsImageHandleResidentNV_ARG_EXPAND_TAIL , GLuint64 handle
#define forward_glIsImageHandleResidentNV(_handle) \
    ({ \
        void *dst = remote_dma(sizeof(glIsImageHandleResidentNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsImageHandleResidentNV(dst, _handle), &ret); \
        ret; \
    });
#define call_glIsImageHandleResidentNV(packed, ret_v) do { \
    glIsImageHandleResidentNV_PACKED *unpacked = (glIsImageHandleResidentNV_PACKED *)packed; \
    glIsImageHandleResidentNV_ARGS *args = (glIsImageHandleResidentNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsImageHandleResidentNV(args->handle);; \
    } else { \
        glIsImageHandleResidentNV(args->handle);; \
    } \
} while(0)
GLboolean glIsImageHandleResidentNV(glIsImageHandleResidentNV_ARG_EXPAND);
packed_call_t *pack_glIsImageHandleResidentNV(glIsImageHandleResidentNV_PACKED *_dst glIsImageHandleResidentNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsImageHandleResidentNV_PTR)(glIsImageHandleResidentNV_ARG_EXPAND);
#endif
#ifndef glIsList_RETURN
#define glIsList_RETURN GLboolean
#define glIsList_ARG_NAMES list
#define glIsList_ARG_EXPAND GLuint list
#define glIsList_ARG_NAMES_TAIL , list
#define glIsList_ARG_EXPAND_TAIL , GLuint list
#define forward_glIsList(_list) \
    ({ \
        void *dst = remote_dma(sizeof(glIsList_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsList(dst, _list), &ret); \
        ret; \
    });
#define call_glIsList(packed, ret_v) do { \
    glIsList_PACKED *unpacked = (glIsList_PACKED *)packed; \
    glIsList_ARGS *args = (glIsList_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsList(args->list);; \
    } else { \
        glIsList(args->list);; \
    } \
} while(0)
GLboolean glIsList(glIsList_ARG_EXPAND);
packed_call_t *pack_glIsList(glIsList_PACKED *_dst glIsList_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsList_PTR)(glIsList_ARG_EXPAND);
#endif
#ifndef glIsNameAMD_RETURN
#define glIsNameAMD_RETURN GLboolean
#define glIsNameAMD_ARG_NAMES identifier, name
#define glIsNameAMD_ARG_EXPAND GLenum identifier, GLuint name
#define glIsNameAMD_ARG_NAMES_TAIL , identifier, name
#define glIsNameAMD_ARG_EXPAND_TAIL , GLenum identifier, GLuint name
#define forward_glIsNameAMD(_identifier, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glIsNameAMD_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsNameAMD(dst, _identifier, _name), &ret); \
        ret; \
    });
#define call_glIsNameAMD(packed, ret_v) do { \
    glIsNameAMD_PACKED *unpacked = (glIsNameAMD_PACKED *)packed; \
    glIsNameAMD_ARGS *args = (glIsNameAMD_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsNameAMD(args->identifier, args->name);; \
    } else { \
        glIsNameAMD(args->identifier, args->name);; \
    } \
} while(0)
GLboolean glIsNameAMD(glIsNameAMD_ARG_EXPAND);
packed_call_t *pack_glIsNameAMD(glIsNameAMD_PACKED *_dst glIsNameAMD_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsNameAMD_PTR)(glIsNameAMD_ARG_EXPAND);
#endif
#ifndef glIsNamedBufferResidentNV_RETURN
#define glIsNamedBufferResidentNV_RETURN GLboolean
#define glIsNamedBufferResidentNV_ARG_NAMES buffer
#define glIsNamedBufferResidentNV_ARG_EXPAND GLuint buffer
#define glIsNamedBufferResidentNV_ARG_NAMES_TAIL , buffer
#define glIsNamedBufferResidentNV_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glIsNamedBufferResidentNV(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsNamedBufferResidentNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsNamedBufferResidentNV(dst, _buffer), &ret); \
        ret; \
    });
#define call_glIsNamedBufferResidentNV(packed, ret_v) do { \
    glIsNamedBufferResidentNV_PACKED *unpacked = (glIsNamedBufferResidentNV_PACKED *)packed; \
    glIsNamedBufferResidentNV_ARGS *args = (glIsNamedBufferResidentNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsNamedBufferResidentNV(args->buffer);; \
    } else { \
        glIsNamedBufferResidentNV(args->buffer);; \
    } \
} while(0)
GLboolean glIsNamedBufferResidentNV(glIsNamedBufferResidentNV_ARG_EXPAND);
packed_call_t *pack_glIsNamedBufferResidentNV(glIsNamedBufferResidentNV_PACKED *_dst glIsNamedBufferResidentNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsNamedBufferResidentNV_PTR)(glIsNamedBufferResidentNV_ARG_EXPAND);
#endif
#ifndef glIsNamedStringARB_RETURN
#define glIsNamedStringARB_RETURN GLboolean
#define glIsNamedStringARB_ARG_NAMES namelen, name
#define glIsNamedStringARB_ARG_EXPAND GLint namelen, const GLchar * name
#define glIsNamedStringARB_ARG_NAMES_TAIL , namelen, name
#define glIsNamedStringARB_ARG_EXPAND_TAIL , GLint namelen, const GLchar * name
#define forward_glIsNamedStringARB(_namelen, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glIsNamedStringARB_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsNamedStringARB(dst, _namelen, _name), &ret); \
        ret; \
    });
#define call_glIsNamedStringARB(packed, ret_v) do { \
    glIsNamedStringARB_PACKED *unpacked = (glIsNamedStringARB_PACKED *)packed; \
    glIsNamedStringARB_ARGS *args = (glIsNamedStringARB_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsNamedStringARB(args->namelen, args->name);; \
    } else { \
        glIsNamedStringARB(args->namelen, args->name);; \
    } \
} while(0)
GLboolean glIsNamedStringARB(glIsNamedStringARB_ARG_EXPAND);
packed_call_t *pack_glIsNamedStringARB(glIsNamedStringARB_PACKED *_dst glIsNamedStringARB_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsNamedStringARB_PTR)(glIsNamedStringARB_ARG_EXPAND);
#endif
#ifndef glIsObjectBufferATI_RETURN
#define glIsObjectBufferATI_RETURN GLboolean
#define glIsObjectBufferATI_ARG_NAMES buffer
#define glIsObjectBufferATI_ARG_EXPAND GLuint buffer
#define glIsObjectBufferATI_ARG_NAMES_TAIL , buffer
#define glIsObjectBufferATI_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glIsObjectBufferATI(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsObjectBufferATI_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsObjectBufferATI(dst, _buffer), &ret); \
        ret; \
    });
#define call_glIsObjectBufferATI(packed, ret_v) do { \
    glIsObjectBufferATI_PACKED *unpacked = (glIsObjectBufferATI_PACKED *)packed; \
    glIsObjectBufferATI_ARGS *args = (glIsObjectBufferATI_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsObjectBufferATI(args->buffer);; \
    } else { \
        glIsObjectBufferATI(args->buffer);; \
    } \
} while(0)
GLboolean glIsObjectBufferATI(glIsObjectBufferATI_ARG_EXPAND);
packed_call_t *pack_glIsObjectBufferATI(glIsObjectBufferATI_PACKED *_dst glIsObjectBufferATI_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsObjectBufferATI_PTR)(glIsObjectBufferATI_ARG_EXPAND);
#endif
#ifndef glIsOcclusionQueryNV_RETURN
#define glIsOcclusionQueryNV_RETURN GLboolean
#define glIsOcclusionQueryNV_ARG_NAMES id
#define glIsOcclusionQueryNV_ARG_EXPAND GLuint id
#define glIsOcclusionQueryNV_ARG_NAMES_TAIL , id
#define glIsOcclusionQueryNV_ARG_EXPAND_TAIL , GLuint id
#define forward_glIsOcclusionQueryNV(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glIsOcclusionQueryNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsOcclusionQueryNV(dst, _id), &ret); \
        ret; \
    });
#define call_glIsOcclusionQueryNV(packed, ret_v) do { \
    glIsOcclusionQueryNV_PACKED *unpacked = (glIsOcclusionQueryNV_PACKED *)packed; \
    glIsOcclusionQueryNV_ARGS *args = (glIsOcclusionQueryNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsOcclusionQueryNV(args->id);; \
    } else { \
        glIsOcclusionQueryNV(args->id);; \
    } \
} while(0)
GLboolean glIsOcclusionQueryNV(glIsOcclusionQueryNV_ARG_EXPAND);
packed_call_t *pack_glIsOcclusionQueryNV(glIsOcclusionQueryNV_PACKED *_dst glIsOcclusionQueryNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsOcclusionQueryNV_PTR)(glIsOcclusionQueryNV_ARG_EXPAND);
#endif
#ifndef glIsPathNV_RETURN
#define glIsPathNV_RETURN GLboolean
#define glIsPathNV_ARG_NAMES path
#define glIsPathNV_ARG_EXPAND GLuint path
#define glIsPathNV_ARG_NAMES_TAIL , path
#define glIsPathNV_ARG_EXPAND_TAIL , GLuint path
#define forward_glIsPathNV(_path) \
    ({ \
        void *dst = remote_dma(sizeof(glIsPathNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsPathNV(dst, _path), &ret); \
        ret; \
    });
#define call_glIsPathNV(packed, ret_v) do { \
    glIsPathNV_PACKED *unpacked = (glIsPathNV_PACKED *)packed; \
    glIsPathNV_ARGS *args = (glIsPathNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsPathNV(args->path);; \
    } else { \
        glIsPathNV(args->path);; \
    } \
} while(0)
GLboolean glIsPathNV(glIsPathNV_ARG_EXPAND);
packed_call_t *pack_glIsPathNV(glIsPathNV_PACKED *_dst glIsPathNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsPathNV_PTR)(glIsPathNV_ARG_EXPAND);
#endif
#ifndef glIsPointInFillPathNV_RETURN
#define glIsPointInFillPathNV_RETURN GLboolean
#define glIsPointInFillPathNV_ARG_NAMES path, mask, x, y
#define glIsPointInFillPathNV_ARG_EXPAND GLuint path, GLuint mask, GLfloat x, GLfloat y
#define glIsPointInFillPathNV_ARG_NAMES_TAIL , path, mask, x, y
#define glIsPointInFillPathNV_ARG_EXPAND_TAIL , GLuint path, GLuint mask, GLfloat x, GLfloat y
#define forward_glIsPointInFillPathNV(_path, _mask, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glIsPointInFillPathNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsPointInFillPathNV(dst, _path, _mask, _x, _y), &ret); \
        ret; \
    });
#define call_glIsPointInFillPathNV(packed, ret_v) do { \
    glIsPointInFillPathNV_PACKED *unpacked = (glIsPointInFillPathNV_PACKED *)packed; \
    glIsPointInFillPathNV_ARGS *args = (glIsPointInFillPathNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsPointInFillPathNV(args->path, args->mask, args->x, args->y);; \
    } else { \
        glIsPointInFillPathNV(args->path, args->mask, args->x, args->y);; \
    } \
} while(0)
GLboolean glIsPointInFillPathNV(glIsPointInFillPathNV_ARG_EXPAND);
packed_call_t *pack_glIsPointInFillPathNV(glIsPointInFillPathNV_PACKED *_dst glIsPointInFillPathNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsPointInFillPathNV_PTR)(glIsPointInFillPathNV_ARG_EXPAND);
#endif
#ifndef glIsPointInStrokePathNV_RETURN
#define glIsPointInStrokePathNV_RETURN GLboolean
#define glIsPointInStrokePathNV_ARG_NAMES path, x, y
#define glIsPointInStrokePathNV_ARG_EXPAND GLuint path, GLfloat x, GLfloat y
#define glIsPointInStrokePathNV_ARG_NAMES_TAIL , path, x, y
#define glIsPointInStrokePathNV_ARG_EXPAND_TAIL , GLuint path, GLfloat x, GLfloat y
#define forward_glIsPointInStrokePathNV(_path, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glIsPointInStrokePathNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsPointInStrokePathNV(dst, _path, _x, _y), &ret); \
        ret; \
    });
#define call_glIsPointInStrokePathNV(packed, ret_v) do { \
    glIsPointInStrokePathNV_PACKED *unpacked = (glIsPointInStrokePathNV_PACKED *)packed; \
    glIsPointInStrokePathNV_ARGS *args = (glIsPointInStrokePathNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsPointInStrokePathNV(args->path, args->x, args->y);; \
    } else { \
        glIsPointInStrokePathNV(args->path, args->x, args->y);; \
    } \
} while(0)
GLboolean glIsPointInStrokePathNV(glIsPointInStrokePathNV_ARG_EXPAND);
packed_call_t *pack_glIsPointInStrokePathNV(glIsPointInStrokePathNV_PACKED *_dst glIsPointInStrokePathNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsPointInStrokePathNV_PTR)(glIsPointInStrokePathNV_ARG_EXPAND);
#endif
#ifndef glIsProgram_RETURN
#define glIsProgram_RETURN GLboolean
#define glIsProgram_ARG_NAMES program
#define glIsProgram_ARG_EXPAND GLuint program
#define glIsProgram_ARG_NAMES_TAIL , program
#define glIsProgram_ARG_EXPAND_TAIL , GLuint program
#define forward_glIsProgram(_program) \
    ({ \
        void *dst = remote_dma(sizeof(glIsProgram_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsProgram(dst, _program), &ret); \
        ret; \
    });
#define call_glIsProgram(packed, ret_v) do { \
    glIsProgram_PACKED *unpacked = (glIsProgram_PACKED *)packed; \
    glIsProgram_ARGS *args = (glIsProgram_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgram(args->program);; \
    } else { \
        glIsProgram(args->program);; \
    } \
} while(0)
GLboolean glIsProgram(glIsProgram_ARG_EXPAND);
packed_call_t *pack_glIsProgram(glIsProgram_PACKED *_dst glIsProgram_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsProgram_PTR)(glIsProgram_ARG_EXPAND);
#endif
#ifndef glIsProgramARB_RETURN
#define glIsProgramARB_RETURN GLboolean
#define glIsProgramARB_ARG_NAMES program
#define glIsProgramARB_ARG_EXPAND GLuint program
#define glIsProgramARB_ARG_NAMES_TAIL , program
#define glIsProgramARB_ARG_EXPAND_TAIL , GLuint program
#define forward_glIsProgramARB(_program) \
    ({ \
        void *dst = remote_dma(sizeof(glIsProgramARB_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsProgramARB(dst, _program), &ret); \
        ret; \
    });
#define call_glIsProgramARB(packed, ret_v) do { \
    glIsProgramARB_PACKED *unpacked = (glIsProgramARB_PACKED *)packed; \
    glIsProgramARB_ARGS *args = (glIsProgramARB_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgramARB(args->program);; \
    } else { \
        glIsProgramARB(args->program);; \
    } \
} while(0)
GLboolean glIsProgramARB(glIsProgramARB_ARG_EXPAND);
packed_call_t *pack_glIsProgramARB(glIsProgramARB_PACKED *_dst glIsProgramARB_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsProgramARB_PTR)(glIsProgramARB_ARG_EXPAND);
#endif
#ifndef glIsProgramNV_RETURN
#define glIsProgramNV_RETURN GLboolean
#define glIsProgramNV_ARG_NAMES id
#define glIsProgramNV_ARG_EXPAND GLuint id
#define glIsProgramNV_ARG_NAMES_TAIL , id
#define glIsProgramNV_ARG_EXPAND_TAIL , GLuint id
#define forward_glIsProgramNV(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glIsProgramNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsProgramNV(dst, _id), &ret); \
        ret; \
    });
#define call_glIsProgramNV(packed, ret_v) do { \
    glIsProgramNV_PACKED *unpacked = (glIsProgramNV_PACKED *)packed; \
    glIsProgramNV_ARGS *args = (glIsProgramNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgramNV(args->id);; \
    } else { \
        glIsProgramNV(args->id);; \
    } \
} while(0)
GLboolean glIsProgramNV(glIsProgramNV_ARG_EXPAND);
packed_call_t *pack_glIsProgramNV(glIsProgramNV_PACKED *_dst glIsProgramNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsProgramNV_PTR)(glIsProgramNV_ARG_EXPAND);
#endif
#ifndef glIsProgramPipeline_RETURN
#define glIsProgramPipeline_RETURN GLboolean
#define glIsProgramPipeline_ARG_NAMES pipeline
#define glIsProgramPipeline_ARG_EXPAND GLuint pipeline
#define glIsProgramPipeline_ARG_NAMES_TAIL , pipeline
#define glIsProgramPipeline_ARG_EXPAND_TAIL , GLuint pipeline
#define forward_glIsProgramPipeline(_pipeline) \
    ({ \
        void *dst = remote_dma(sizeof(glIsProgramPipeline_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsProgramPipeline(dst, _pipeline), &ret); \
        ret; \
    });
#define call_glIsProgramPipeline(packed, ret_v) do { \
    glIsProgramPipeline_PACKED *unpacked = (glIsProgramPipeline_PACKED *)packed; \
    glIsProgramPipeline_ARGS *args = (glIsProgramPipeline_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgramPipeline(args->pipeline);; \
    } else { \
        glIsProgramPipeline(args->pipeline);; \
    } \
} while(0)
GLboolean glIsProgramPipeline(glIsProgramPipeline_ARG_EXPAND);
packed_call_t *pack_glIsProgramPipeline(glIsProgramPipeline_PACKED *_dst glIsProgramPipeline_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsProgramPipeline_PTR)(glIsProgramPipeline_ARG_EXPAND);
#endif
#ifndef glIsQuery_RETURN
#define glIsQuery_RETURN GLboolean
#define glIsQuery_ARG_NAMES id
#define glIsQuery_ARG_EXPAND GLuint id
#define glIsQuery_ARG_NAMES_TAIL , id
#define glIsQuery_ARG_EXPAND_TAIL , GLuint id
#define forward_glIsQuery(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glIsQuery_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsQuery(dst, _id), &ret); \
        ret; \
    });
#define call_glIsQuery(packed, ret_v) do { \
    glIsQuery_PACKED *unpacked = (glIsQuery_PACKED *)packed; \
    glIsQuery_ARGS *args = (glIsQuery_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsQuery(args->id);; \
    } else { \
        glIsQuery(args->id);; \
    } \
} while(0)
GLboolean glIsQuery(glIsQuery_ARG_EXPAND);
packed_call_t *pack_glIsQuery(glIsQuery_PACKED *_dst glIsQuery_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsQuery_PTR)(glIsQuery_ARG_EXPAND);
#endif
#ifndef glIsQueryARB_RETURN
#define glIsQueryARB_RETURN GLboolean
#define glIsQueryARB_ARG_NAMES id
#define glIsQueryARB_ARG_EXPAND GLuint id
#define glIsQueryARB_ARG_NAMES_TAIL , id
#define glIsQueryARB_ARG_EXPAND_TAIL , GLuint id
#define forward_glIsQueryARB(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glIsQueryARB_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsQueryARB(dst, _id), &ret); \
        ret; \
    });
#define call_glIsQueryARB(packed, ret_v) do { \
    glIsQueryARB_PACKED *unpacked = (glIsQueryARB_PACKED *)packed; \
    glIsQueryARB_ARGS *args = (glIsQueryARB_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsQueryARB(args->id);; \
    } else { \
        glIsQueryARB(args->id);; \
    } \
} while(0)
GLboolean glIsQueryARB(glIsQueryARB_ARG_EXPAND);
packed_call_t *pack_glIsQueryARB(glIsQueryARB_PACKED *_dst glIsQueryARB_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsQueryARB_PTR)(glIsQueryARB_ARG_EXPAND);
#endif
#ifndef glIsRenderbuffer_RETURN
#define glIsRenderbuffer_RETURN GLboolean
#define glIsRenderbuffer_ARG_NAMES renderbuffer
#define glIsRenderbuffer_ARG_EXPAND GLuint renderbuffer
#define glIsRenderbuffer_ARG_NAMES_TAIL , renderbuffer
#define glIsRenderbuffer_ARG_EXPAND_TAIL , GLuint renderbuffer
#define forward_glIsRenderbuffer(_renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsRenderbuffer_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsRenderbuffer(dst, _renderbuffer), &ret); \
        ret; \
    });
#define call_glIsRenderbuffer(packed, ret_v) do { \
    glIsRenderbuffer_PACKED *unpacked = (glIsRenderbuffer_PACKED *)packed; \
    glIsRenderbuffer_ARGS *args = (glIsRenderbuffer_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsRenderbuffer(args->renderbuffer);; \
    } else { \
        glIsRenderbuffer(args->renderbuffer);; \
    } \
} while(0)
GLboolean glIsRenderbuffer(glIsRenderbuffer_ARG_EXPAND);
packed_call_t *pack_glIsRenderbuffer(glIsRenderbuffer_PACKED *_dst glIsRenderbuffer_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsRenderbuffer_PTR)(glIsRenderbuffer_ARG_EXPAND);
#endif
#ifndef glIsRenderbufferEXT_RETURN
#define glIsRenderbufferEXT_RETURN GLboolean
#define glIsRenderbufferEXT_ARG_NAMES renderbuffer
#define glIsRenderbufferEXT_ARG_EXPAND GLuint renderbuffer
#define glIsRenderbufferEXT_ARG_NAMES_TAIL , renderbuffer
#define glIsRenderbufferEXT_ARG_EXPAND_TAIL , GLuint renderbuffer
#define forward_glIsRenderbufferEXT(_renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glIsRenderbufferEXT_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsRenderbufferEXT(dst, _renderbuffer), &ret); \
        ret; \
    });
#define call_glIsRenderbufferEXT(packed, ret_v) do { \
    glIsRenderbufferEXT_PACKED *unpacked = (glIsRenderbufferEXT_PACKED *)packed; \
    glIsRenderbufferEXT_ARGS *args = (glIsRenderbufferEXT_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsRenderbufferEXT(args->renderbuffer);; \
    } else { \
        glIsRenderbufferEXT(args->renderbuffer);; \
    } \
} while(0)
GLboolean glIsRenderbufferEXT(glIsRenderbufferEXT_ARG_EXPAND);
packed_call_t *pack_glIsRenderbufferEXT(glIsRenderbufferEXT_PACKED *_dst glIsRenderbufferEXT_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsRenderbufferEXT_PTR)(glIsRenderbufferEXT_ARG_EXPAND);
#endif
#ifndef glIsSampler_RETURN
#define glIsSampler_RETURN GLboolean
#define glIsSampler_ARG_NAMES sampler
#define glIsSampler_ARG_EXPAND GLuint sampler
#define glIsSampler_ARG_NAMES_TAIL , sampler
#define glIsSampler_ARG_EXPAND_TAIL , GLuint sampler
#define forward_glIsSampler(_sampler) \
    ({ \
        void *dst = remote_dma(sizeof(glIsSampler_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsSampler(dst, _sampler), &ret); \
        ret; \
    });
#define call_glIsSampler(packed, ret_v) do { \
    glIsSampler_PACKED *unpacked = (glIsSampler_PACKED *)packed; \
    glIsSampler_ARGS *args = (glIsSampler_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsSampler(args->sampler);; \
    } else { \
        glIsSampler(args->sampler);; \
    } \
} while(0)
GLboolean glIsSampler(glIsSampler_ARG_EXPAND);
packed_call_t *pack_glIsSampler(glIsSampler_PACKED *_dst glIsSampler_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsSampler_PTR)(glIsSampler_ARG_EXPAND);
#endif
#ifndef glIsShader_RETURN
#define glIsShader_RETURN GLboolean
#define glIsShader_ARG_NAMES shader
#define glIsShader_ARG_EXPAND GLuint shader
#define glIsShader_ARG_NAMES_TAIL , shader
#define glIsShader_ARG_EXPAND_TAIL , GLuint shader
#define forward_glIsShader(_shader) \
    ({ \
        void *dst = remote_dma(sizeof(glIsShader_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsShader(dst, _shader), &ret); \
        ret; \
    });
#define call_glIsShader(packed, ret_v) do { \
    glIsShader_PACKED *unpacked = (glIsShader_PACKED *)packed; \
    glIsShader_ARGS *args = (glIsShader_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsShader(args->shader);; \
    } else { \
        glIsShader(args->shader);; \
    } \
} while(0)
GLboolean glIsShader(glIsShader_ARG_EXPAND);
packed_call_t *pack_glIsShader(glIsShader_PACKED *_dst glIsShader_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsShader_PTR)(glIsShader_ARG_EXPAND);
#endif
#ifndef glIsSync_RETURN
#define glIsSync_RETURN GLboolean
#define glIsSync_ARG_NAMES sync
#define glIsSync_ARG_EXPAND GLsync sync
#define glIsSync_ARG_NAMES_TAIL , sync
#define glIsSync_ARG_EXPAND_TAIL , GLsync sync
#define forward_glIsSync(_sync) \
    ({ \
        void *dst = remote_dma(sizeof(glIsSync_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsSync(dst, _sync), &ret); \
        ret; \
    });
#define call_glIsSync(packed, ret_v) do { \
    glIsSync_PACKED *unpacked = (glIsSync_PACKED *)packed; \
    glIsSync_ARGS *args = (glIsSync_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsSync(args->sync);; \
    } else { \
        glIsSync(args->sync);; \
    } \
} while(0)
GLboolean glIsSync(glIsSync_ARG_EXPAND);
packed_call_t *pack_glIsSync(glIsSync_PACKED *_dst glIsSync_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsSync_PTR)(glIsSync_ARG_EXPAND);
#endif
#ifndef glIsTexture_RETURN
#define glIsTexture_RETURN GLboolean
#define glIsTexture_ARG_NAMES texture
#define glIsTexture_ARG_EXPAND GLuint texture
#define glIsTexture_ARG_NAMES_TAIL , texture
#define glIsTexture_ARG_EXPAND_TAIL , GLuint texture
#define forward_glIsTexture(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glIsTexture_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsTexture(dst, _texture), &ret); \
        ret; \
    });
#define call_glIsTexture(packed, ret_v) do { \
    glIsTexture_PACKED *unpacked = (glIsTexture_PACKED *)packed; \
    glIsTexture_ARGS *args = (glIsTexture_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTexture(args->texture);; \
    } else { \
        glIsTexture(args->texture);; \
    } \
} while(0)
GLboolean glIsTexture(glIsTexture_ARG_EXPAND);
packed_call_t *pack_glIsTexture(glIsTexture_PACKED *_dst glIsTexture_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsTexture_PTR)(glIsTexture_ARG_EXPAND);
#endif
#ifndef glIsTextureEXT_RETURN
#define glIsTextureEXT_RETURN GLboolean
#define glIsTextureEXT_ARG_NAMES texture
#define glIsTextureEXT_ARG_EXPAND GLuint texture
#define glIsTextureEXT_ARG_NAMES_TAIL , texture
#define glIsTextureEXT_ARG_EXPAND_TAIL , GLuint texture
#define forward_glIsTextureEXT(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glIsTextureEXT_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsTextureEXT(dst, _texture), &ret); \
        ret; \
    });
#define call_glIsTextureEXT(packed, ret_v) do { \
    glIsTextureEXT_PACKED *unpacked = (glIsTextureEXT_PACKED *)packed; \
    glIsTextureEXT_ARGS *args = (glIsTextureEXT_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTextureEXT(args->texture);; \
    } else { \
        glIsTextureEXT(args->texture);; \
    } \
} while(0)
GLboolean glIsTextureEXT(glIsTextureEXT_ARG_EXPAND);
packed_call_t *pack_glIsTextureEXT(glIsTextureEXT_PACKED *_dst glIsTextureEXT_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsTextureEXT_PTR)(glIsTextureEXT_ARG_EXPAND);
#endif
#ifndef glIsTextureHandleResidentNV_RETURN
#define glIsTextureHandleResidentNV_RETURN GLboolean
#define glIsTextureHandleResidentNV_ARG_NAMES handle
#define glIsTextureHandleResidentNV_ARG_EXPAND GLuint64 handle
#define glIsTextureHandleResidentNV_ARG_NAMES_TAIL , handle
#define glIsTextureHandleResidentNV_ARG_EXPAND_TAIL , GLuint64 handle
#define forward_glIsTextureHandleResidentNV(_handle) \
    ({ \
        void *dst = remote_dma(sizeof(glIsTextureHandleResidentNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsTextureHandleResidentNV(dst, _handle), &ret); \
        ret; \
    });
#define call_glIsTextureHandleResidentNV(packed, ret_v) do { \
    glIsTextureHandleResidentNV_PACKED *unpacked = (glIsTextureHandleResidentNV_PACKED *)packed; \
    glIsTextureHandleResidentNV_ARGS *args = (glIsTextureHandleResidentNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTextureHandleResidentNV(args->handle);; \
    } else { \
        glIsTextureHandleResidentNV(args->handle);; \
    } \
} while(0)
GLboolean glIsTextureHandleResidentNV(glIsTextureHandleResidentNV_ARG_EXPAND);
packed_call_t *pack_glIsTextureHandleResidentNV(glIsTextureHandleResidentNV_PACKED *_dst glIsTextureHandleResidentNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsTextureHandleResidentNV_PTR)(glIsTextureHandleResidentNV_ARG_EXPAND);
#endif
#ifndef glIsTransformFeedback_RETURN
#define glIsTransformFeedback_RETURN GLboolean
#define glIsTransformFeedback_ARG_NAMES id
#define glIsTransformFeedback_ARG_EXPAND GLuint id
#define glIsTransformFeedback_ARG_NAMES_TAIL , id
#define glIsTransformFeedback_ARG_EXPAND_TAIL , GLuint id
#define forward_glIsTransformFeedback(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glIsTransformFeedback_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsTransformFeedback(dst, _id), &ret); \
        ret; \
    });
#define call_glIsTransformFeedback(packed, ret_v) do { \
    glIsTransformFeedback_PACKED *unpacked = (glIsTransformFeedback_PACKED *)packed; \
    glIsTransformFeedback_ARGS *args = (glIsTransformFeedback_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTransformFeedback(args->id);; \
    } else { \
        glIsTransformFeedback(args->id);; \
    } \
} while(0)
GLboolean glIsTransformFeedback(glIsTransformFeedback_ARG_EXPAND);
packed_call_t *pack_glIsTransformFeedback(glIsTransformFeedback_PACKED *_dst glIsTransformFeedback_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsTransformFeedback_PTR)(glIsTransformFeedback_ARG_EXPAND);
#endif
#ifndef glIsTransformFeedbackNV_RETURN
#define glIsTransformFeedbackNV_RETURN GLboolean
#define glIsTransformFeedbackNV_ARG_NAMES id
#define glIsTransformFeedbackNV_ARG_EXPAND GLuint id
#define glIsTransformFeedbackNV_ARG_NAMES_TAIL , id
#define glIsTransformFeedbackNV_ARG_EXPAND_TAIL , GLuint id
#define forward_glIsTransformFeedbackNV(_id) \
    ({ \
        void *dst = remote_dma(sizeof(glIsTransformFeedbackNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsTransformFeedbackNV(dst, _id), &ret); \
        ret; \
    });
#define call_glIsTransformFeedbackNV(packed, ret_v) do { \
    glIsTransformFeedbackNV_PACKED *unpacked = (glIsTransformFeedbackNV_PACKED *)packed; \
    glIsTransformFeedbackNV_ARGS *args = (glIsTransformFeedbackNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTransformFeedbackNV(args->id);; \
    } else { \
        glIsTransformFeedbackNV(args->id);; \
    } \
} while(0)
GLboolean glIsTransformFeedbackNV(glIsTransformFeedbackNV_ARG_EXPAND);
packed_call_t *pack_glIsTransformFeedbackNV(glIsTransformFeedbackNV_PACKED *_dst glIsTransformFeedbackNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsTransformFeedbackNV_PTR)(glIsTransformFeedbackNV_ARG_EXPAND);
#endif
#ifndef glIsVariantEnabledEXT_RETURN
#define glIsVariantEnabledEXT_RETURN GLboolean
#define glIsVariantEnabledEXT_ARG_NAMES id, cap
#define glIsVariantEnabledEXT_ARG_EXPAND GLuint id, GLenum cap
#define glIsVariantEnabledEXT_ARG_NAMES_TAIL , id, cap
#define glIsVariantEnabledEXT_ARG_EXPAND_TAIL , GLuint id, GLenum cap
#define forward_glIsVariantEnabledEXT(_id, _cap) \
    ({ \
        void *dst = remote_dma(sizeof(glIsVariantEnabledEXT_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsVariantEnabledEXT(dst, _id, _cap), &ret); \
        ret; \
    });
#define call_glIsVariantEnabledEXT(packed, ret_v) do { \
    glIsVariantEnabledEXT_PACKED *unpacked = (glIsVariantEnabledEXT_PACKED *)packed; \
    glIsVariantEnabledEXT_ARGS *args = (glIsVariantEnabledEXT_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVariantEnabledEXT(args->id, args->cap);; \
    } else { \
        glIsVariantEnabledEXT(args->id, args->cap);; \
    } \
} while(0)
GLboolean glIsVariantEnabledEXT(glIsVariantEnabledEXT_ARG_EXPAND);
packed_call_t *pack_glIsVariantEnabledEXT(glIsVariantEnabledEXT_PACKED *_dst glIsVariantEnabledEXT_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsVariantEnabledEXT_PTR)(glIsVariantEnabledEXT_ARG_EXPAND);
#endif
#ifndef glIsVertexArray_RETURN
#define glIsVertexArray_RETURN GLboolean
#define glIsVertexArray_ARG_NAMES array
#define glIsVertexArray_ARG_EXPAND GLuint array
#define glIsVertexArray_ARG_NAMES_TAIL , array
#define glIsVertexArray_ARG_EXPAND_TAIL , GLuint array
#define forward_glIsVertexArray(_array) \
    ({ \
        void *dst = remote_dma(sizeof(glIsVertexArray_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsVertexArray(dst, _array), &ret); \
        ret; \
    });
#define call_glIsVertexArray(packed, ret_v) do { \
    glIsVertexArray_PACKED *unpacked = (glIsVertexArray_PACKED *)packed; \
    glIsVertexArray_ARGS *args = (glIsVertexArray_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVertexArray(args->array);; \
    } else { \
        glIsVertexArray(args->array);; \
    } \
} while(0)
GLboolean glIsVertexArray(glIsVertexArray_ARG_EXPAND);
packed_call_t *pack_glIsVertexArray(glIsVertexArray_PACKED *_dst glIsVertexArray_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsVertexArray_PTR)(glIsVertexArray_ARG_EXPAND);
#endif
#ifndef glIsVertexArrayAPPLE_RETURN
#define glIsVertexArrayAPPLE_RETURN GLboolean
#define glIsVertexArrayAPPLE_ARG_NAMES array
#define glIsVertexArrayAPPLE_ARG_EXPAND GLuint array
#define glIsVertexArrayAPPLE_ARG_NAMES_TAIL , array
#define glIsVertexArrayAPPLE_ARG_EXPAND_TAIL , GLuint array
#define forward_glIsVertexArrayAPPLE(_array) \
    ({ \
        void *dst = remote_dma(sizeof(glIsVertexArrayAPPLE_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsVertexArrayAPPLE(dst, _array), &ret); \
        ret; \
    });
#define call_glIsVertexArrayAPPLE(packed, ret_v) do { \
    glIsVertexArrayAPPLE_PACKED *unpacked = (glIsVertexArrayAPPLE_PACKED *)packed; \
    glIsVertexArrayAPPLE_ARGS *args = (glIsVertexArrayAPPLE_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVertexArrayAPPLE(args->array);; \
    } else { \
        glIsVertexArrayAPPLE(args->array);; \
    } \
} while(0)
GLboolean glIsVertexArrayAPPLE(glIsVertexArrayAPPLE_ARG_EXPAND);
packed_call_t *pack_glIsVertexArrayAPPLE(glIsVertexArrayAPPLE_PACKED *_dst glIsVertexArrayAPPLE_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsVertexArrayAPPLE_PTR)(glIsVertexArrayAPPLE_ARG_EXPAND);
#endif
#ifndef glIsVertexAttribEnabledAPPLE_RETURN
#define glIsVertexAttribEnabledAPPLE_RETURN GLboolean
#define glIsVertexAttribEnabledAPPLE_ARG_NAMES index, pname
#define glIsVertexAttribEnabledAPPLE_ARG_EXPAND GLuint index, GLenum pname
#define glIsVertexAttribEnabledAPPLE_ARG_NAMES_TAIL , index, pname
#define glIsVertexAttribEnabledAPPLE_ARG_EXPAND_TAIL , GLuint index, GLenum pname
#define forward_glIsVertexAttribEnabledAPPLE(_index, _pname) \
    ({ \
        void *dst = remote_dma(sizeof(glIsVertexAttribEnabledAPPLE_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glIsVertexAttribEnabledAPPLE(dst, _index, _pname), &ret); \
        ret; \
    });
#define call_glIsVertexAttribEnabledAPPLE(packed, ret_v) do { \
    glIsVertexAttribEnabledAPPLE_PACKED *unpacked = (glIsVertexAttribEnabledAPPLE_PACKED *)packed; \
    glIsVertexAttribEnabledAPPLE_ARGS *args = (glIsVertexAttribEnabledAPPLE_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVertexAttribEnabledAPPLE(args->index, args->pname);; \
    } else { \
        glIsVertexAttribEnabledAPPLE(args->index, args->pname);; \
    } \
} while(0)
GLboolean glIsVertexAttribEnabledAPPLE(glIsVertexAttribEnabledAPPLE_ARG_EXPAND);
packed_call_t *pack_glIsVertexAttribEnabledAPPLE(glIsVertexAttribEnabledAPPLE_PACKED *_dst glIsVertexAttribEnabledAPPLE_ARG_EXPAND_TAIL);
typedef GLboolean (*glIsVertexAttribEnabledAPPLE_PTR)(glIsVertexAttribEnabledAPPLE_ARG_EXPAND);
#endif
#ifndef glLightEnviSGIX_RETURN
#define glLightEnviSGIX_RETURN void
#define glLightEnviSGIX_ARG_NAMES pname, param
#define glLightEnviSGIX_ARG_EXPAND GLenum pname, GLint param
#define glLightEnviSGIX_ARG_NAMES_TAIL , pname, param
#define glLightEnviSGIX_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glLightEnviSGIX(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLightEnviSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightEnviSGIX(dst, _pname, _param), NULL); \
    });
#define call_glLightEnviSGIX(packed, ret_v) do { \
    glLightEnviSGIX_PACKED *unpacked = (glLightEnviSGIX_PACKED *)packed; \
    glLightEnviSGIX_ARGS *args = (glLightEnviSGIX_ARGS *)&unpacked->args; \
    glLightEnviSGIX(args->pname, args->param);; \
} while(0)
void glLightEnviSGIX(glLightEnviSGIX_ARG_EXPAND);
packed_call_t *pack_glLightEnviSGIX(glLightEnviSGIX_PACKED *_dst glLightEnviSGIX_ARG_EXPAND_TAIL);
typedef void (*glLightEnviSGIX_PTR)(glLightEnviSGIX_ARG_EXPAND);
#endif
#ifndef glLightModelf_RETURN
#define glLightModelf_RETURN void
#define glLightModelf_ARG_NAMES pname, param
#define glLightModelf_ARG_EXPAND GLenum pname, GLfloat param
#define glLightModelf_ARG_NAMES_TAIL , pname, param
#define glLightModelf_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glLightModelf(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLightModelf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightModelf(dst, _pname, _param), NULL); \
    });
#define call_glLightModelf(packed, ret_v) do { \
    glLightModelf_PACKED *unpacked = (glLightModelf_PACKED *)packed; \
    glLightModelf_ARGS *args = (glLightModelf_ARGS *)&unpacked->args; \
    glLightModelf(args->pname, args->param);; \
} while(0)
void glLightModelf(glLightModelf_ARG_EXPAND);
packed_call_t *pack_glLightModelf(glLightModelf_PACKED *_dst glLightModelf_ARG_EXPAND_TAIL);
typedef void (*glLightModelf_PTR)(glLightModelf_ARG_EXPAND);
#endif
#ifndef glLightModelfv_RETURN
#define glLightModelfv_RETURN void
#define glLightModelfv_ARG_NAMES pname, params
#define glLightModelfv_ARG_EXPAND GLenum pname, const GLfloat * params
#define glLightModelfv_ARG_NAMES_TAIL , pname, params
#define glLightModelfv_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glLightModelfv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glLightModelfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightModelfv(dst, _pname, _params), NULL); \
    });
#define call_glLightModelfv(packed, ret_v) do { \
    glLightModelfv_PACKED *unpacked = (glLightModelfv_PACKED *)packed; \
    glLightModelfv_ARGS *args = (glLightModelfv_ARGS *)&unpacked->args; \
    glLightModelfv(args->pname, args->params);; \
} while(0)
void glLightModelfv(glLightModelfv_ARG_EXPAND);
packed_call_t *pack_glLightModelfv(glLightModelfv_PACKED *_dst glLightModelfv_ARG_EXPAND_TAIL);
typedef void (*glLightModelfv_PTR)(glLightModelfv_ARG_EXPAND);
#endif
#ifndef glLightModeli_RETURN
#define glLightModeli_RETURN void
#define glLightModeli_ARG_NAMES pname, param
#define glLightModeli_ARG_EXPAND GLenum pname, GLint param
#define glLightModeli_ARG_NAMES_TAIL , pname, param
#define glLightModeli_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glLightModeli(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLightModeli_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightModeli(dst, _pname, _param), NULL); \
    });
#define call_glLightModeli(packed, ret_v) do { \
    glLightModeli_PACKED *unpacked = (glLightModeli_PACKED *)packed; \
    glLightModeli_ARGS *args = (glLightModeli_ARGS *)&unpacked->args; \
    glLightModeli(args->pname, args->param);; \
} while(0)
void glLightModeli(glLightModeli_ARG_EXPAND);
packed_call_t *pack_glLightModeli(glLightModeli_PACKED *_dst glLightModeli_ARG_EXPAND_TAIL);
typedef void (*glLightModeli_PTR)(glLightModeli_ARG_EXPAND);
#endif
#ifndef glLightModeliv_RETURN
#define glLightModeliv_RETURN void
#define glLightModeliv_ARG_NAMES pname, params
#define glLightModeliv_ARG_EXPAND GLenum pname, const GLint * params
#define glLightModeliv_ARG_NAMES_TAIL , pname, params
#define glLightModeliv_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glLightModeliv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glLightModeliv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightModeliv(dst, _pname, _params), NULL); \
    });
#define call_glLightModeliv(packed, ret_v) do { \
    glLightModeliv_PACKED *unpacked = (glLightModeliv_PACKED *)packed; \
    glLightModeliv_ARGS *args = (glLightModeliv_ARGS *)&unpacked->args; \
    glLightModeliv(args->pname, args->params);; \
} while(0)
void glLightModeliv(glLightModeliv_ARG_EXPAND);
packed_call_t *pack_glLightModeliv(glLightModeliv_PACKED *_dst glLightModeliv_ARG_EXPAND_TAIL);
typedef void (*glLightModeliv_PTR)(glLightModeliv_ARG_EXPAND);
#endif
#ifndef glLightModelxOES_RETURN
#define glLightModelxOES_RETURN void
#define glLightModelxOES_ARG_NAMES pname, param
#define glLightModelxOES_ARG_EXPAND GLenum pname, GLfixed param
#define glLightModelxOES_ARG_NAMES_TAIL , pname, param
#define glLightModelxOES_ARG_EXPAND_TAIL , GLenum pname, GLfixed param
#define forward_glLightModelxOES(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLightModelxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightModelxOES(dst, _pname, _param), NULL); \
    });
#define call_glLightModelxOES(packed, ret_v) do { \
    glLightModelxOES_PACKED *unpacked = (glLightModelxOES_PACKED *)packed; \
    glLightModelxOES_ARGS *args = (glLightModelxOES_ARGS *)&unpacked->args; \
    glLightModelxOES(args->pname, args->param);; \
} while(0)
void glLightModelxOES(glLightModelxOES_ARG_EXPAND);
packed_call_t *pack_glLightModelxOES(glLightModelxOES_PACKED *_dst glLightModelxOES_ARG_EXPAND_TAIL);
typedef void (*glLightModelxOES_PTR)(glLightModelxOES_ARG_EXPAND);
#endif
#ifndef glLightModelxvOES_RETURN
#define glLightModelxvOES_RETURN void
#define glLightModelxvOES_ARG_NAMES pname, param
#define glLightModelxvOES_ARG_EXPAND GLenum pname, const GLfixed * param
#define glLightModelxvOES_ARG_NAMES_TAIL , pname, param
#define glLightModelxvOES_ARG_EXPAND_TAIL , GLenum pname, const GLfixed * param
#define forward_glLightModelxvOES(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLightModelxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightModelxvOES(dst, _pname, _param), NULL); \
    });
#define call_glLightModelxvOES(packed, ret_v) do { \
    glLightModelxvOES_PACKED *unpacked = (glLightModelxvOES_PACKED *)packed; \
    glLightModelxvOES_ARGS *args = (glLightModelxvOES_ARGS *)&unpacked->args; \
    glLightModelxvOES(args->pname, args->param);; \
} while(0)
void glLightModelxvOES(glLightModelxvOES_ARG_EXPAND);
packed_call_t *pack_glLightModelxvOES(glLightModelxvOES_PACKED *_dst glLightModelxvOES_ARG_EXPAND_TAIL);
typedef void (*glLightModelxvOES_PTR)(glLightModelxvOES_ARG_EXPAND);
#endif
#ifndef glLightf_RETURN
#define glLightf_RETURN void
#define glLightf_ARG_NAMES light, pname, param
#define glLightf_ARG_EXPAND GLenum light, GLenum pname, GLfloat param
#define glLightf_ARG_NAMES_TAIL , light, pname, param
#define glLightf_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLfloat param
#define forward_glLightf(_light, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLightf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightf(dst, _light, _pname, _param), NULL); \
    });
#define call_glLightf(packed, ret_v) do { \
    glLightf_PACKED *unpacked = (glLightf_PACKED *)packed; \
    glLightf_ARGS *args = (glLightf_ARGS *)&unpacked->args; \
    glLightf(args->light, args->pname, args->param);; \
} while(0)
void glLightf(glLightf_ARG_EXPAND);
packed_call_t *pack_glLightf(glLightf_PACKED *_dst glLightf_ARG_EXPAND_TAIL);
typedef void (*glLightf_PTR)(glLightf_ARG_EXPAND);
#endif
#ifndef glLightfv_RETURN
#define glLightfv_RETURN void
#define glLightfv_ARG_NAMES light, pname, params
#define glLightfv_ARG_EXPAND GLenum light, GLenum pname, const GLfloat * params
#define glLightfv_ARG_NAMES_TAIL , light, pname, params
#define glLightfv_ARG_EXPAND_TAIL , GLenum light, GLenum pname, const GLfloat * params
#define forward_glLightfv(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glLightfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightfv(dst, _light, _pname, _params), NULL); \
    });
#define call_glLightfv(packed, ret_v) do { \
    glLightfv_PACKED *unpacked = (glLightfv_PACKED *)packed; \
    glLightfv_ARGS *args = (glLightfv_ARGS *)&unpacked->args; \
    glLightfv(args->light, args->pname, args->params);; \
} while(0)
void glLightfv(glLightfv_ARG_EXPAND);
packed_call_t *pack_glLightfv(glLightfv_PACKED *_dst glLightfv_ARG_EXPAND_TAIL);
typedef void (*glLightfv_PTR)(glLightfv_ARG_EXPAND);
#endif
#ifndef glLighti_RETURN
#define glLighti_RETURN void
#define glLighti_ARG_NAMES light, pname, param
#define glLighti_ARG_EXPAND GLenum light, GLenum pname, GLint param
#define glLighti_ARG_NAMES_TAIL , light, pname, param
#define glLighti_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLint param
#define forward_glLighti(_light, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLighti_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLighti(dst, _light, _pname, _param), NULL); \
    });
#define call_glLighti(packed, ret_v) do { \
    glLighti_PACKED *unpacked = (glLighti_PACKED *)packed; \
    glLighti_ARGS *args = (glLighti_ARGS *)&unpacked->args; \
    glLighti(args->light, args->pname, args->param);; \
} while(0)
void glLighti(glLighti_ARG_EXPAND);
packed_call_t *pack_glLighti(glLighti_PACKED *_dst glLighti_ARG_EXPAND_TAIL);
typedef void (*glLighti_PTR)(glLighti_ARG_EXPAND);
#endif
#ifndef glLightiv_RETURN
#define glLightiv_RETURN void
#define glLightiv_ARG_NAMES light, pname, params
#define glLightiv_ARG_EXPAND GLenum light, GLenum pname, const GLint * params
#define glLightiv_ARG_NAMES_TAIL , light, pname, params
#define glLightiv_ARG_EXPAND_TAIL , GLenum light, GLenum pname, const GLint * params
#define forward_glLightiv(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glLightiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightiv(dst, _light, _pname, _params), NULL); \
    });
#define call_glLightiv(packed, ret_v) do { \
    glLightiv_PACKED *unpacked = (glLightiv_PACKED *)packed; \
    glLightiv_ARGS *args = (glLightiv_ARGS *)&unpacked->args; \
    glLightiv(args->light, args->pname, args->params);; \
} while(0)
void glLightiv(glLightiv_ARG_EXPAND);
packed_call_t *pack_glLightiv(glLightiv_PACKED *_dst glLightiv_ARG_EXPAND_TAIL);
typedef void (*glLightiv_PTR)(glLightiv_ARG_EXPAND);
#endif
#ifndef glLightxOES_RETURN
#define glLightxOES_RETURN void
#define glLightxOES_ARG_NAMES light, pname, param
#define glLightxOES_ARG_EXPAND GLenum light, GLenum pname, GLfixed param
#define glLightxOES_ARG_NAMES_TAIL , light, pname, param
#define glLightxOES_ARG_EXPAND_TAIL , GLenum light, GLenum pname, GLfixed param
#define forward_glLightxOES(_light, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glLightxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightxOES(dst, _light, _pname, _param), NULL); \
    });
#define call_glLightxOES(packed, ret_v) do { \
    glLightxOES_PACKED *unpacked = (glLightxOES_PACKED *)packed; \
    glLightxOES_ARGS *args = (glLightxOES_ARGS *)&unpacked->args; \
    glLightxOES(args->light, args->pname, args->param);; \
} while(0)
void glLightxOES(glLightxOES_ARG_EXPAND);
packed_call_t *pack_glLightxOES(glLightxOES_PACKED *_dst glLightxOES_ARG_EXPAND_TAIL);
typedef void (*glLightxOES_PTR)(glLightxOES_ARG_EXPAND);
#endif
#ifndef glLightxvOES_RETURN
#define glLightxvOES_RETURN void
#define glLightxvOES_ARG_NAMES light, pname, params
#define glLightxvOES_ARG_EXPAND GLenum light, GLenum pname, const GLfixed * params
#define glLightxvOES_ARG_NAMES_TAIL , light, pname, params
#define glLightxvOES_ARG_EXPAND_TAIL , GLenum light, GLenum pname, const GLfixed * params
#define forward_glLightxvOES(_light, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glLightxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLightxvOES(dst, _light, _pname, _params), NULL); \
    });
#define call_glLightxvOES(packed, ret_v) do { \
    glLightxvOES_PACKED *unpacked = (glLightxvOES_PACKED *)packed; \
    glLightxvOES_ARGS *args = (glLightxvOES_ARGS *)&unpacked->args; \
    glLightxvOES(args->light, args->pname, args->params);; \
} while(0)
void glLightxvOES(glLightxvOES_ARG_EXPAND);
packed_call_t *pack_glLightxvOES(glLightxvOES_PACKED *_dst glLightxvOES_ARG_EXPAND_TAIL);
typedef void (*glLightxvOES_PTR)(glLightxvOES_ARG_EXPAND);
#endif
#ifndef glLineStipple_RETURN
#define glLineStipple_RETURN void
#define glLineStipple_ARG_NAMES factor, pattern
#define glLineStipple_ARG_EXPAND GLint factor, GLushort pattern
#define glLineStipple_ARG_NAMES_TAIL , factor, pattern
#define glLineStipple_ARG_EXPAND_TAIL , GLint factor, GLushort pattern
#define forward_glLineStipple(_factor, _pattern) \
    ({ \
        void *dst = remote_dma(sizeof(glLineStipple_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLineStipple(dst, _factor, _pattern), NULL); \
    });
#define call_glLineStipple(packed, ret_v) do { \
    glLineStipple_PACKED *unpacked = (glLineStipple_PACKED *)packed; \
    glLineStipple_ARGS *args = (glLineStipple_ARGS *)&unpacked->args; \
    glLineStipple(args->factor, args->pattern);; \
} while(0)
void glLineStipple(glLineStipple_ARG_EXPAND);
packed_call_t *pack_glLineStipple(glLineStipple_PACKED *_dst glLineStipple_ARG_EXPAND_TAIL);
typedef void (*glLineStipple_PTR)(glLineStipple_ARG_EXPAND);
#endif
#ifndef glLineWidth_RETURN
#define glLineWidth_RETURN void
#define glLineWidth_ARG_NAMES width
#define glLineWidth_ARG_EXPAND GLfloat width
#define glLineWidth_ARG_NAMES_TAIL , width
#define glLineWidth_ARG_EXPAND_TAIL , GLfloat width
#define forward_glLineWidth(_width) \
    ({ \
        void *dst = remote_dma(sizeof(glLineWidth_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLineWidth(dst, _width), NULL); \
    });
#define call_glLineWidth(packed, ret_v) do { \
    glLineWidth_PACKED *unpacked = (glLineWidth_PACKED *)packed; \
    glLineWidth_ARGS *args = (glLineWidth_ARGS *)&unpacked->args; \
    glLineWidth(args->width);; \
} while(0)
void glLineWidth(glLineWidth_ARG_EXPAND);
packed_call_t *pack_glLineWidth(glLineWidth_PACKED *_dst glLineWidth_ARG_EXPAND_TAIL);
typedef void (*glLineWidth_PTR)(glLineWidth_ARG_EXPAND);
#endif
#ifndef glLineWidthxOES_RETURN
#define glLineWidthxOES_RETURN void
#define glLineWidthxOES_ARG_NAMES width
#define glLineWidthxOES_ARG_EXPAND GLfixed width
#define glLineWidthxOES_ARG_NAMES_TAIL , width
#define glLineWidthxOES_ARG_EXPAND_TAIL , GLfixed width
#define forward_glLineWidthxOES(_width) \
    ({ \
        void *dst = remote_dma(sizeof(glLineWidthxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLineWidthxOES(dst, _width), NULL); \
    });
#define call_glLineWidthxOES(packed, ret_v) do { \
    glLineWidthxOES_PACKED *unpacked = (glLineWidthxOES_PACKED *)packed; \
    glLineWidthxOES_ARGS *args = (glLineWidthxOES_ARGS *)&unpacked->args; \
    glLineWidthxOES(args->width);; \
} while(0)
void glLineWidthxOES(glLineWidthxOES_ARG_EXPAND);
packed_call_t *pack_glLineWidthxOES(glLineWidthxOES_PACKED *_dst glLineWidthxOES_ARG_EXPAND_TAIL);
typedef void (*glLineWidthxOES_PTR)(glLineWidthxOES_ARG_EXPAND);
#endif
#ifndef glLinkProgram_RETURN
#define glLinkProgram_RETURN void
#define glLinkProgram_ARG_NAMES program
#define glLinkProgram_ARG_EXPAND GLuint program
#define glLinkProgram_ARG_NAMES_TAIL , program
#define glLinkProgram_ARG_EXPAND_TAIL , GLuint program
#define forward_glLinkProgram(_program) \
    ({ \
        void *dst = remote_dma(sizeof(glLinkProgram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLinkProgram(dst, _program), NULL); \
    });
#define call_glLinkProgram(packed, ret_v) do { \
    glLinkProgram_PACKED *unpacked = (glLinkProgram_PACKED *)packed; \
    glLinkProgram_ARGS *args = (glLinkProgram_ARGS *)&unpacked->args; \
    glLinkProgram(args->program);; \
} while(0)
void glLinkProgram(glLinkProgram_ARG_EXPAND);
packed_call_t *pack_glLinkProgram(glLinkProgram_PACKED *_dst glLinkProgram_ARG_EXPAND_TAIL);
typedef void (*glLinkProgram_PTR)(glLinkProgram_ARG_EXPAND);
#endif
#ifndef glLinkProgramARB_RETURN
#define glLinkProgramARB_RETURN void
#define glLinkProgramARB_ARG_NAMES programObj
#define glLinkProgramARB_ARG_EXPAND GLhandleARB programObj
#define glLinkProgramARB_ARG_NAMES_TAIL , programObj
#define glLinkProgramARB_ARG_EXPAND_TAIL , GLhandleARB programObj
#define forward_glLinkProgramARB(_programObj) \
    ({ \
        void *dst = remote_dma(sizeof(glLinkProgramARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLinkProgramARB(dst, _programObj), NULL); \
    });
#define call_glLinkProgramARB(packed, ret_v) do { \
    glLinkProgramARB_PACKED *unpacked = (glLinkProgramARB_PACKED *)packed; \
    glLinkProgramARB_ARGS *args = (glLinkProgramARB_ARGS *)&unpacked->args; \
    glLinkProgramARB(args->programObj);; \
} while(0)
void glLinkProgramARB(glLinkProgramARB_ARG_EXPAND);
packed_call_t *pack_glLinkProgramARB(glLinkProgramARB_PACKED *_dst glLinkProgramARB_ARG_EXPAND_TAIL);
typedef void (*glLinkProgramARB_PTR)(glLinkProgramARB_ARG_EXPAND);
#endif
#ifndef glListBase_RETURN
#define glListBase_RETURN void
#define glListBase_ARG_NAMES base
#define glListBase_ARG_EXPAND GLuint base
#define glListBase_ARG_NAMES_TAIL , base
#define glListBase_ARG_EXPAND_TAIL , GLuint base
#define forward_glListBase(_base) \
    ({ \
        void *dst = remote_dma(sizeof(glListBase_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glListBase(dst, _base), NULL); \
    });
#define call_glListBase(packed, ret_v) do { \
    glListBase_PACKED *unpacked = (glListBase_PACKED *)packed; \
    glListBase_ARGS *args = (glListBase_ARGS *)&unpacked->args; \
    glListBase(args->base);; \
} while(0)
void glListBase(glListBase_ARG_EXPAND);
packed_call_t *pack_glListBase(glListBase_PACKED *_dst glListBase_ARG_EXPAND_TAIL);
typedef void (*glListBase_PTR)(glListBase_ARG_EXPAND);
#endif
#ifndef glListParameterfSGIX_RETURN
#define glListParameterfSGIX_RETURN void
#define glListParameterfSGIX_ARG_NAMES list, pname, param
#define glListParameterfSGIX_ARG_EXPAND GLuint list, GLenum pname, GLfloat param
#define glListParameterfSGIX_ARG_NAMES_TAIL , list, pname, param
#define glListParameterfSGIX_ARG_EXPAND_TAIL , GLuint list, GLenum pname, GLfloat param
#define forward_glListParameterfSGIX(_list, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glListParameterfSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glListParameterfSGIX(dst, _list, _pname, _param), NULL); \
    });
#define call_glListParameterfSGIX(packed, ret_v) do { \
    glListParameterfSGIX_PACKED *unpacked = (glListParameterfSGIX_PACKED *)packed; \
    glListParameterfSGIX_ARGS *args = (glListParameterfSGIX_ARGS *)&unpacked->args; \
    glListParameterfSGIX(args->list, args->pname, args->param);; \
} while(0)
void glListParameterfSGIX(glListParameterfSGIX_ARG_EXPAND);
packed_call_t *pack_glListParameterfSGIX(glListParameterfSGIX_PACKED *_dst glListParameterfSGIX_ARG_EXPAND_TAIL);
typedef void (*glListParameterfSGIX_PTR)(glListParameterfSGIX_ARG_EXPAND);
#endif
#ifndef glListParameterfvSGIX_RETURN
#define glListParameterfvSGIX_RETURN void
#define glListParameterfvSGIX_ARG_NAMES list, pname, params
#define glListParameterfvSGIX_ARG_EXPAND GLuint list, GLenum pname, const GLfloat * params
#define glListParameterfvSGIX_ARG_NAMES_TAIL , list, pname, params
#define glListParameterfvSGIX_ARG_EXPAND_TAIL , GLuint list, GLenum pname, const GLfloat * params
#define forward_glListParameterfvSGIX(_list, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glListParameterfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glListParameterfvSGIX(dst, _list, _pname, _params), NULL); \
    });
#define call_glListParameterfvSGIX(packed, ret_v) do { \
    glListParameterfvSGIX_PACKED *unpacked = (glListParameterfvSGIX_PACKED *)packed; \
    glListParameterfvSGIX_ARGS *args = (glListParameterfvSGIX_ARGS *)&unpacked->args; \
    glListParameterfvSGIX(args->list, args->pname, args->params);; \
} while(0)
void glListParameterfvSGIX(glListParameterfvSGIX_ARG_EXPAND);
packed_call_t *pack_glListParameterfvSGIX(glListParameterfvSGIX_PACKED *_dst glListParameterfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glListParameterfvSGIX_PTR)(glListParameterfvSGIX_ARG_EXPAND);
#endif
#ifndef glListParameteriSGIX_RETURN
#define glListParameteriSGIX_RETURN void
#define glListParameteriSGIX_ARG_NAMES list, pname, param
#define glListParameteriSGIX_ARG_EXPAND GLuint list, GLenum pname, GLint param
#define glListParameteriSGIX_ARG_NAMES_TAIL , list, pname, param
#define glListParameteriSGIX_ARG_EXPAND_TAIL , GLuint list, GLenum pname, GLint param
#define forward_glListParameteriSGIX(_list, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glListParameteriSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glListParameteriSGIX(dst, _list, _pname, _param), NULL); \
    });
#define call_glListParameteriSGIX(packed, ret_v) do { \
    glListParameteriSGIX_PACKED *unpacked = (glListParameteriSGIX_PACKED *)packed; \
    glListParameteriSGIX_ARGS *args = (glListParameteriSGIX_ARGS *)&unpacked->args; \
    glListParameteriSGIX(args->list, args->pname, args->param);; \
} while(0)
void glListParameteriSGIX(glListParameteriSGIX_ARG_EXPAND);
packed_call_t *pack_glListParameteriSGIX(glListParameteriSGIX_PACKED *_dst glListParameteriSGIX_ARG_EXPAND_TAIL);
typedef void (*glListParameteriSGIX_PTR)(glListParameteriSGIX_ARG_EXPAND);
#endif
#ifndef glListParameterivSGIX_RETURN
#define glListParameterivSGIX_RETURN void
#define glListParameterivSGIX_ARG_NAMES list, pname, params
#define glListParameterivSGIX_ARG_EXPAND GLuint list, GLenum pname, const GLint * params
#define glListParameterivSGIX_ARG_NAMES_TAIL , list, pname, params
#define glListParameterivSGIX_ARG_EXPAND_TAIL , GLuint list, GLenum pname, const GLint * params
#define forward_glListParameterivSGIX(_list, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glListParameterivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glListParameterivSGIX(dst, _list, _pname, _params), NULL); \
    });
#define call_glListParameterivSGIX(packed, ret_v) do { \
    glListParameterivSGIX_PACKED *unpacked = (glListParameterivSGIX_PACKED *)packed; \
    glListParameterivSGIX_ARGS *args = (glListParameterivSGIX_ARGS *)&unpacked->args; \
    glListParameterivSGIX(args->list, args->pname, args->params);; \
} while(0)
void glListParameterivSGIX(glListParameterivSGIX_ARG_EXPAND);
packed_call_t *pack_glListParameterivSGIX(glListParameterivSGIX_PACKED *_dst glListParameterivSGIX_ARG_EXPAND_TAIL);
typedef void (*glListParameterivSGIX_PTR)(glListParameterivSGIX_ARG_EXPAND);
#endif
#ifndef glLoadIdentity_RETURN
#define glLoadIdentity_RETURN void
#define glLoadIdentity_ARG_NAMES 
#define glLoadIdentity_ARG_EXPAND 
#define glLoadIdentity_ARG_NAMES_TAIL 
#define glLoadIdentity_ARG_EXPAND_TAIL 
#define forward_glLoadIdentity() \
    ({ \
        void *dst = remote_dma(sizeof(glLoadIdentity_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadIdentity(dst), NULL); \
    });
#define call_glLoadIdentity(packed, ret_v) do { \
    glLoadIdentity();; \
} while(0)
void glLoadIdentity(glLoadIdentity_ARG_EXPAND);
packed_call_t *pack_glLoadIdentity(glLoadIdentity_PACKED *_dst glLoadIdentity_ARG_EXPAND_TAIL);
typedef void (*glLoadIdentity_PTR)(glLoadIdentity_ARG_EXPAND);
#endif
#ifndef glLoadIdentityDeformationMapSGIX_RETURN
#define glLoadIdentityDeformationMapSGIX_RETURN void
#define glLoadIdentityDeformationMapSGIX_ARG_NAMES mask
#define glLoadIdentityDeformationMapSGIX_ARG_EXPAND GLbitfield mask
#define glLoadIdentityDeformationMapSGIX_ARG_NAMES_TAIL , mask
#define glLoadIdentityDeformationMapSGIX_ARG_EXPAND_TAIL , GLbitfield mask
#define forward_glLoadIdentityDeformationMapSGIX(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadIdentityDeformationMapSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadIdentityDeformationMapSGIX(dst, _mask), NULL); \
    });
#define call_glLoadIdentityDeformationMapSGIX(packed, ret_v) do { \
    glLoadIdentityDeformationMapSGIX_PACKED *unpacked = (glLoadIdentityDeformationMapSGIX_PACKED *)packed; \
    glLoadIdentityDeformationMapSGIX_ARGS *args = (glLoadIdentityDeformationMapSGIX_ARGS *)&unpacked->args; \
    glLoadIdentityDeformationMapSGIX(args->mask);; \
} while(0)
void glLoadIdentityDeformationMapSGIX(glLoadIdentityDeformationMapSGIX_ARG_EXPAND);
packed_call_t *pack_glLoadIdentityDeformationMapSGIX(glLoadIdentityDeformationMapSGIX_PACKED *_dst glLoadIdentityDeformationMapSGIX_ARG_EXPAND_TAIL);
typedef void (*glLoadIdentityDeformationMapSGIX_PTR)(glLoadIdentityDeformationMapSGIX_ARG_EXPAND);
#endif
#ifndef glLoadMatrixd_RETURN
#define glLoadMatrixd_RETURN void
#define glLoadMatrixd_ARG_NAMES m
#define glLoadMatrixd_ARG_EXPAND const GLdouble * m
#define glLoadMatrixd_ARG_NAMES_TAIL , m
#define glLoadMatrixd_ARG_EXPAND_TAIL , const GLdouble * m
#define forward_glLoadMatrixd(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadMatrixd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadMatrixd(dst, _m), NULL); \
    });
#define call_glLoadMatrixd(packed, ret_v) do { \
    glLoadMatrixd_PACKED *unpacked = (glLoadMatrixd_PACKED *)packed; \
    glLoadMatrixd_ARGS *args = (glLoadMatrixd_ARGS *)&unpacked->args; \
    glLoadMatrixd(args->m);; \
} while(0)
void glLoadMatrixd(glLoadMatrixd_ARG_EXPAND);
packed_call_t *pack_glLoadMatrixd(glLoadMatrixd_PACKED *_dst glLoadMatrixd_ARG_EXPAND_TAIL);
typedef void (*glLoadMatrixd_PTR)(glLoadMatrixd_ARG_EXPAND);
#endif
#ifndef glLoadMatrixf_RETURN
#define glLoadMatrixf_RETURN void
#define glLoadMatrixf_ARG_NAMES m
#define glLoadMatrixf_ARG_EXPAND const GLfloat * m
#define glLoadMatrixf_ARG_NAMES_TAIL , m
#define glLoadMatrixf_ARG_EXPAND_TAIL , const GLfloat * m
#define forward_glLoadMatrixf(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadMatrixf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadMatrixf(dst, _m), NULL); \
    });
#define call_glLoadMatrixf(packed, ret_v) do { \
    glLoadMatrixf_PACKED *unpacked = (glLoadMatrixf_PACKED *)packed; \
    glLoadMatrixf_ARGS *args = (glLoadMatrixf_ARGS *)&unpacked->args; \
    glLoadMatrixf(args->m);; \
} while(0)
void glLoadMatrixf(glLoadMatrixf_ARG_EXPAND);
packed_call_t *pack_glLoadMatrixf(glLoadMatrixf_PACKED *_dst glLoadMatrixf_ARG_EXPAND_TAIL);
typedef void (*glLoadMatrixf_PTR)(glLoadMatrixf_ARG_EXPAND);
#endif
#ifndef glLoadMatrixxOES_RETURN
#define glLoadMatrixxOES_RETURN void
#define glLoadMatrixxOES_ARG_NAMES m
#define glLoadMatrixxOES_ARG_EXPAND const GLfixed * m
#define glLoadMatrixxOES_ARG_NAMES_TAIL , m
#define glLoadMatrixxOES_ARG_EXPAND_TAIL , const GLfixed * m
#define forward_glLoadMatrixxOES(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadMatrixxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadMatrixxOES(dst, _m), NULL); \
    });
#define call_glLoadMatrixxOES(packed, ret_v) do { \
    glLoadMatrixxOES_PACKED *unpacked = (glLoadMatrixxOES_PACKED *)packed; \
    glLoadMatrixxOES_ARGS *args = (glLoadMatrixxOES_ARGS *)&unpacked->args; \
    glLoadMatrixxOES(args->m);; \
} while(0)
void glLoadMatrixxOES(glLoadMatrixxOES_ARG_EXPAND);
packed_call_t *pack_glLoadMatrixxOES(glLoadMatrixxOES_PACKED *_dst glLoadMatrixxOES_ARG_EXPAND_TAIL);
typedef void (*glLoadMatrixxOES_PTR)(glLoadMatrixxOES_ARG_EXPAND);
#endif
#ifndef glLoadName_RETURN
#define glLoadName_RETURN void
#define glLoadName_ARG_NAMES name
#define glLoadName_ARG_EXPAND GLuint name
#define glLoadName_ARG_NAMES_TAIL , name
#define glLoadName_ARG_EXPAND_TAIL , GLuint name
#define forward_glLoadName(_name) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadName(dst, _name), NULL); \
    });
#define call_glLoadName(packed, ret_v) do { \
    glLoadName_PACKED *unpacked = (glLoadName_PACKED *)packed; \
    glLoadName_ARGS *args = (glLoadName_ARGS *)&unpacked->args; \
    glLoadName(args->name);; \
} while(0)
void glLoadName(glLoadName_ARG_EXPAND);
packed_call_t *pack_glLoadName(glLoadName_PACKED *_dst glLoadName_ARG_EXPAND_TAIL);
typedef void (*glLoadName_PTR)(glLoadName_ARG_EXPAND);
#endif
#ifndef glLoadProgramNV_RETURN
#define glLoadProgramNV_RETURN void
#define glLoadProgramNV_ARG_NAMES target, id, len, program
#define glLoadProgramNV_ARG_EXPAND GLenum target, GLuint id, GLsizei len, const GLubyte * program
#define glLoadProgramNV_ARG_NAMES_TAIL , target, id, len, program
#define glLoadProgramNV_ARG_EXPAND_TAIL , GLenum target, GLuint id, GLsizei len, const GLubyte * program
#define forward_glLoadProgramNV(_target, _id, _len, _program) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadProgramNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadProgramNV(dst, _target, _id, _len, _program), NULL); \
    });
#define call_glLoadProgramNV(packed, ret_v) do { \
    glLoadProgramNV_PACKED *unpacked = (glLoadProgramNV_PACKED *)packed; \
    glLoadProgramNV_ARGS *args = (glLoadProgramNV_ARGS *)&unpacked->args; \
    glLoadProgramNV(args->target, args->id, args->len, args->program);; \
} while(0)
void glLoadProgramNV(glLoadProgramNV_ARG_EXPAND);
packed_call_t *pack_glLoadProgramNV(glLoadProgramNV_PACKED *_dst glLoadProgramNV_ARG_EXPAND_TAIL);
typedef void (*glLoadProgramNV_PTR)(glLoadProgramNV_ARG_EXPAND);
#endif
#ifndef glLoadTransposeMatrixd_RETURN
#define glLoadTransposeMatrixd_RETURN void
#define glLoadTransposeMatrixd_ARG_NAMES m
#define glLoadTransposeMatrixd_ARG_EXPAND const GLdouble * m
#define glLoadTransposeMatrixd_ARG_NAMES_TAIL , m
#define glLoadTransposeMatrixd_ARG_EXPAND_TAIL , const GLdouble * m
#define forward_glLoadTransposeMatrixd(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadTransposeMatrixd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadTransposeMatrixd(dst, _m), NULL); \
    });
#define call_glLoadTransposeMatrixd(packed, ret_v) do { \
    glLoadTransposeMatrixd_PACKED *unpacked = (glLoadTransposeMatrixd_PACKED *)packed; \
    glLoadTransposeMatrixd_ARGS *args = (glLoadTransposeMatrixd_ARGS *)&unpacked->args; \
    glLoadTransposeMatrixd(args->m);; \
} while(0)
void glLoadTransposeMatrixd(glLoadTransposeMatrixd_ARG_EXPAND);
packed_call_t *pack_glLoadTransposeMatrixd(glLoadTransposeMatrixd_PACKED *_dst glLoadTransposeMatrixd_ARG_EXPAND_TAIL);
typedef void (*glLoadTransposeMatrixd_PTR)(glLoadTransposeMatrixd_ARG_EXPAND);
#endif
#ifndef glLoadTransposeMatrixdARB_RETURN
#define glLoadTransposeMatrixdARB_RETURN void
#define glLoadTransposeMatrixdARB_ARG_NAMES m
#define glLoadTransposeMatrixdARB_ARG_EXPAND const GLdouble * m
#define glLoadTransposeMatrixdARB_ARG_NAMES_TAIL , m
#define glLoadTransposeMatrixdARB_ARG_EXPAND_TAIL , const GLdouble * m
#define forward_glLoadTransposeMatrixdARB(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadTransposeMatrixdARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadTransposeMatrixdARB(dst, _m), NULL); \
    });
#define call_glLoadTransposeMatrixdARB(packed, ret_v) do { \
    glLoadTransposeMatrixdARB_PACKED *unpacked = (glLoadTransposeMatrixdARB_PACKED *)packed; \
    glLoadTransposeMatrixdARB_ARGS *args = (glLoadTransposeMatrixdARB_ARGS *)&unpacked->args; \
    glLoadTransposeMatrixdARB(args->m);; \
} while(0)
void glLoadTransposeMatrixdARB(glLoadTransposeMatrixdARB_ARG_EXPAND);
packed_call_t *pack_glLoadTransposeMatrixdARB(glLoadTransposeMatrixdARB_PACKED *_dst glLoadTransposeMatrixdARB_ARG_EXPAND_TAIL);
typedef void (*glLoadTransposeMatrixdARB_PTR)(glLoadTransposeMatrixdARB_ARG_EXPAND);
#endif
#ifndef glLoadTransposeMatrixf_RETURN
#define glLoadTransposeMatrixf_RETURN void
#define glLoadTransposeMatrixf_ARG_NAMES m
#define glLoadTransposeMatrixf_ARG_EXPAND const GLfloat * m
#define glLoadTransposeMatrixf_ARG_NAMES_TAIL , m
#define glLoadTransposeMatrixf_ARG_EXPAND_TAIL , const GLfloat * m
#define forward_glLoadTransposeMatrixf(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadTransposeMatrixf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadTransposeMatrixf(dst, _m), NULL); \
    });
#define call_glLoadTransposeMatrixf(packed, ret_v) do { \
    glLoadTransposeMatrixf_PACKED *unpacked = (glLoadTransposeMatrixf_PACKED *)packed; \
    glLoadTransposeMatrixf_ARGS *args = (glLoadTransposeMatrixf_ARGS *)&unpacked->args; \
    glLoadTransposeMatrixf(args->m);; \
} while(0)
void glLoadTransposeMatrixf(glLoadTransposeMatrixf_ARG_EXPAND);
packed_call_t *pack_glLoadTransposeMatrixf(glLoadTransposeMatrixf_PACKED *_dst glLoadTransposeMatrixf_ARG_EXPAND_TAIL);
typedef void (*glLoadTransposeMatrixf_PTR)(glLoadTransposeMatrixf_ARG_EXPAND);
#endif
#ifndef glLoadTransposeMatrixfARB_RETURN
#define glLoadTransposeMatrixfARB_RETURN void
#define glLoadTransposeMatrixfARB_ARG_NAMES m
#define glLoadTransposeMatrixfARB_ARG_EXPAND const GLfloat * m
#define glLoadTransposeMatrixfARB_ARG_NAMES_TAIL , m
#define glLoadTransposeMatrixfARB_ARG_EXPAND_TAIL , const GLfloat * m
#define forward_glLoadTransposeMatrixfARB(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadTransposeMatrixfARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadTransposeMatrixfARB(dst, _m), NULL); \
    });
#define call_glLoadTransposeMatrixfARB(packed, ret_v) do { \
    glLoadTransposeMatrixfARB_PACKED *unpacked = (glLoadTransposeMatrixfARB_PACKED *)packed; \
    glLoadTransposeMatrixfARB_ARGS *args = (glLoadTransposeMatrixfARB_ARGS *)&unpacked->args; \
    glLoadTransposeMatrixfARB(args->m);; \
} while(0)
void glLoadTransposeMatrixfARB(glLoadTransposeMatrixfARB_ARG_EXPAND);
packed_call_t *pack_glLoadTransposeMatrixfARB(glLoadTransposeMatrixfARB_PACKED *_dst glLoadTransposeMatrixfARB_ARG_EXPAND_TAIL);
typedef void (*glLoadTransposeMatrixfARB_PTR)(glLoadTransposeMatrixfARB_ARG_EXPAND);
#endif
#ifndef glLoadTransposeMatrixxOES_RETURN
#define glLoadTransposeMatrixxOES_RETURN void
#define glLoadTransposeMatrixxOES_ARG_NAMES m
#define glLoadTransposeMatrixxOES_ARG_EXPAND const GLfixed * m
#define glLoadTransposeMatrixxOES_ARG_NAMES_TAIL , m
#define glLoadTransposeMatrixxOES_ARG_EXPAND_TAIL , const GLfixed * m
#define forward_glLoadTransposeMatrixxOES(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glLoadTransposeMatrixxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLoadTransposeMatrixxOES(dst, _m), NULL); \
    });
#define call_glLoadTransposeMatrixxOES(packed, ret_v) do { \
    glLoadTransposeMatrixxOES_PACKED *unpacked = (glLoadTransposeMatrixxOES_PACKED *)packed; \
    glLoadTransposeMatrixxOES_ARGS *args = (glLoadTransposeMatrixxOES_ARGS *)&unpacked->args; \
    glLoadTransposeMatrixxOES(args->m);; \
} while(0)
void glLoadTransposeMatrixxOES(glLoadTransposeMatrixxOES_ARG_EXPAND);
packed_call_t *pack_glLoadTransposeMatrixxOES(glLoadTransposeMatrixxOES_PACKED *_dst glLoadTransposeMatrixxOES_ARG_EXPAND_TAIL);
typedef void (*glLoadTransposeMatrixxOES_PTR)(glLoadTransposeMatrixxOES_ARG_EXPAND);
#endif
#ifndef glLockArraysEXT_RETURN
#define glLockArraysEXT_RETURN void
#define glLockArraysEXT_ARG_NAMES first, count
#define glLockArraysEXT_ARG_EXPAND GLint first, GLsizei count
#define glLockArraysEXT_ARG_NAMES_TAIL , first, count
#define glLockArraysEXT_ARG_EXPAND_TAIL , GLint first, GLsizei count
#define forward_glLockArraysEXT(_first, _count) \
    ({ \
        void *dst = remote_dma(sizeof(glLockArraysEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLockArraysEXT(dst, _first, _count), NULL); \
    });
#define call_glLockArraysEXT(packed, ret_v) do { \
    glLockArraysEXT_PACKED *unpacked = (glLockArraysEXT_PACKED *)packed; \
    glLockArraysEXT_ARGS *args = (glLockArraysEXT_ARGS *)&unpacked->args; \
    glLockArraysEXT(args->first, args->count);; \
} while(0)
void glLockArraysEXT(glLockArraysEXT_ARG_EXPAND);
packed_call_t *pack_glLockArraysEXT(glLockArraysEXT_PACKED *_dst glLockArraysEXT_ARG_EXPAND_TAIL);
typedef void (*glLockArraysEXT_PTR)(glLockArraysEXT_ARG_EXPAND);
#endif
#ifndef glLogicOp_RETURN
#define glLogicOp_RETURN void
#define glLogicOp_ARG_NAMES opcode
#define glLogicOp_ARG_EXPAND GLenum opcode
#define glLogicOp_ARG_NAMES_TAIL , opcode
#define glLogicOp_ARG_EXPAND_TAIL , GLenum opcode
#define forward_glLogicOp(_opcode) \
    ({ \
        void *dst = remote_dma(sizeof(glLogicOp_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glLogicOp(dst, _opcode), NULL); \
    });
#define call_glLogicOp(packed, ret_v) do { \
    glLogicOp_PACKED *unpacked = (glLogicOp_PACKED *)packed; \
    glLogicOp_ARGS *args = (glLogicOp_ARGS *)&unpacked->args; \
    glLogicOp(args->opcode);; \
} while(0)
void glLogicOp(glLogicOp_ARG_EXPAND);
packed_call_t *pack_glLogicOp(glLogicOp_PACKED *_dst glLogicOp_ARG_EXPAND_TAIL);
typedef void (*glLogicOp_PTR)(glLogicOp_ARG_EXPAND);
#endif
#ifndef glMakeBufferNonResidentNV_RETURN
#define glMakeBufferNonResidentNV_RETURN void
#define glMakeBufferNonResidentNV_ARG_NAMES target
#define glMakeBufferNonResidentNV_ARG_EXPAND GLenum target
#define glMakeBufferNonResidentNV_ARG_NAMES_TAIL , target
#define glMakeBufferNonResidentNV_ARG_EXPAND_TAIL , GLenum target
#define forward_glMakeBufferNonResidentNV(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeBufferNonResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeBufferNonResidentNV(dst, _target), NULL); \
    });
#define call_glMakeBufferNonResidentNV(packed, ret_v) do { \
    glMakeBufferNonResidentNV_PACKED *unpacked = (glMakeBufferNonResidentNV_PACKED *)packed; \
    glMakeBufferNonResidentNV_ARGS *args = (glMakeBufferNonResidentNV_ARGS *)&unpacked->args; \
    glMakeBufferNonResidentNV(args->target);; \
} while(0)
void glMakeBufferNonResidentNV(glMakeBufferNonResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeBufferNonResidentNV(glMakeBufferNonResidentNV_PACKED *_dst glMakeBufferNonResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeBufferNonResidentNV_PTR)(glMakeBufferNonResidentNV_ARG_EXPAND);
#endif
#ifndef glMakeBufferResidentNV_RETURN
#define glMakeBufferResidentNV_RETURN void
#define glMakeBufferResidentNV_ARG_NAMES target, access
#define glMakeBufferResidentNV_ARG_EXPAND GLenum target, GLenum access
#define glMakeBufferResidentNV_ARG_NAMES_TAIL , target, access
#define glMakeBufferResidentNV_ARG_EXPAND_TAIL , GLenum target, GLenum access
#define forward_glMakeBufferResidentNV(_target, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeBufferResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeBufferResidentNV(dst, _target, _access), NULL); \
    });
#define call_glMakeBufferResidentNV(packed, ret_v) do { \
    glMakeBufferResidentNV_PACKED *unpacked = (glMakeBufferResidentNV_PACKED *)packed; \
    glMakeBufferResidentNV_ARGS *args = (glMakeBufferResidentNV_ARGS *)&unpacked->args; \
    glMakeBufferResidentNV(args->target, args->access);; \
} while(0)
void glMakeBufferResidentNV(glMakeBufferResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeBufferResidentNV(glMakeBufferResidentNV_PACKED *_dst glMakeBufferResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeBufferResidentNV_PTR)(glMakeBufferResidentNV_ARG_EXPAND);
#endif
#ifndef glMakeImageHandleNonResidentNV_RETURN
#define glMakeImageHandleNonResidentNV_RETURN void
#define glMakeImageHandleNonResidentNV_ARG_NAMES handle
#define glMakeImageHandleNonResidentNV_ARG_EXPAND GLuint64 handle
#define glMakeImageHandleNonResidentNV_ARG_NAMES_TAIL , handle
#define glMakeImageHandleNonResidentNV_ARG_EXPAND_TAIL , GLuint64 handle
#define forward_glMakeImageHandleNonResidentNV(_handle) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeImageHandleNonResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeImageHandleNonResidentNV(dst, _handle), NULL); \
    });
#define call_glMakeImageHandleNonResidentNV(packed, ret_v) do { \
    glMakeImageHandleNonResidentNV_PACKED *unpacked = (glMakeImageHandleNonResidentNV_PACKED *)packed; \
    glMakeImageHandleNonResidentNV_ARGS *args = (glMakeImageHandleNonResidentNV_ARGS *)&unpacked->args; \
    glMakeImageHandleNonResidentNV(args->handle);; \
} while(0)
void glMakeImageHandleNonResidentNV(glMakeImageHandleNonResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeImageHandleNonResidentNV(glMakeImageHandleNonResidentNV_PACKED *_dst glMakeImageHandleNonResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeImageHandleNonResidentNV_PTR)(glMakeImageHandleNonResidentNV_ARG_EXPAND);
#endif
#ifndef glMakeImageHandleResidentNV_RETURN
#define glMakeImageHandleResidentNV_RETURN void
#define glMakeImageHandleResidentNV_ARG_NAMES handle, access
#define glMakeImageHandleResidentNV_ARG_EXPAND GLuint64 handle, GLenum access
#define glMakeImageHandleResidentNV_ARG_NAMES_TAIL , handle, access
#define glMakeImageHandleResidentNV_ARG_EXPAND_TAIL , GLuint64 handle, GLenum access
#define forward_glMakeImageHandleResidentNV(_handle, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeImageHandleResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeImageHandleResidentNV(dst, _handle, _access), NULL); \
    });
#define call_glMakeImageHandleResidentNV(packed, ret_v) do { \
    glMakeImageHandleResidentNV_PACKED *unpacked = (glMakeImageHandleResidentNV_PACKED *)packed; \
    glMakeImageHandleResidentNV_ARGS *args = (glMakeImageHandleResidentNV_ARGS *)&unpacked->args; \
    glMakeImageHandleResidentNV(args->handle, args->access);; \
} while(0)
void glMakeImageHandleResidentNV(glMakeImageHandleResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeImageHandleResidentNV(glMakeImageHandleResidentNV_PACKED *_dst glMakeImageHandleResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeImageHandleResidentNV_PTR)(glMakeImageHandleResidentNV_ARG_EXPAND);
#endif
#ifndef glMakeNamedBufferNonResidentNV_RETURN
#define glMakeNamedBufferNonResidentNV_RETURN void
#define glMakeNamedBufferNonResidentNV_ARG_NAMES buffer
#define glMakeNamedBufferNonResidentNV_ARG_EXPAND GLuint buffer
#define glMakeNamedBufferNonResidentNV_ARG_NAMES_TAIL , buffer
#define glMakeNamedBufferNonResidentNV_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glMakeNamedBufferNonResidentNV(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeNamedBufferNonResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeNamedBufferNonResidentNV(dst, _buffer), NULL); \
    });
#define call_glMakeNamedBufferNonResidentNV(packed, ret_v) do { \
    glMakeNamedBufferNonResidentNV_PACKED *unpacked = (glMakeNamedBufferNonResidentNV_PACKED *)packed; \
    glMakeNamedBufferNonResidentNV_ARGS *args = (glMakeNamedBufferNonResidentNV_ARGS *)&unpacked->args; \
    glMakeNamedBufferNonResidentNV(args->buffer);; \
} while(0)
void glMakeNamedBufferNonResidentNV(glMakeNamedBufferNonResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeNamedBufferNonResidentNV(glMakeNamedBufferNonResidentNV_PACKED *_dst glMakeNamedBufferNonResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeNamedBufferNonResidentNV_PTR)(glMakeNamedBufferNonResidentNV_ARG_EXPAND);
#endif
#ifndef glMakeNamedBufferResidentNV_RETURN
#define glMakeNamedBufferResidentNV_RETURN void
#define glMakeNamedBufferResidentNV_ARG_NAMES buffer, access
#define glMakeNamedBufferResidentNV_ARG_EXPAND GLuint buffer, GLenum access
#define glMakeNamedBufferResidentNV_ARG_NAMES_TAIL , buffer, access
#define glMakeNamedBufferResidentNV_ARG_EXPAND_TAIL , GLuint buffer, GLenum access
#define forward_glMakeNamedBufferResidentNV(_buffer, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeNamedBufferResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeNamedBufferResidentNV(dst, _buffer, _access), NULL); \
    });
#define call_glMakeNamedBufferResidentNV(packed, ret_v) do { \
    glMakeNamedBufferResidentNV_PACKED *unpacked = (glMakeNamedBufferResidentNV_PACKED *)packed; \
    glMakeNamedBufferResidentNV_ARGS *args = (glMakeNamedBufferResidentNV_ARGS *)&unpacked->args; \
    glMakeNamedBufferResidentNV(args->buffer, args->access);; \
} while(0)
void glMakeNamedBufferResidentNV(glMakeNamedBufferResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeNamedBufferResidentNV(glMakeNamedBufferResidentNV_PACKED *_dst glMakeNamedBufferResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeNamedBufferResidentNV_PTR)(glMakeNamedBufferResidentNV_ARG_EXPAND);
#endif
#ifndef glMakeTextureHandleNonResidentNV_RETURN
#define glMakeTextureHandleNonResidentNV_RETURN void
#define glMakeTextureHandleNonResidentNV_ARG_NAMES handle
#define glMakeTextureHandleNonResidentNV_ARG_EXPAND GLuint64 handle
#define glMakeTextureHandleNonResidentNV_ARG_NAMES_TAIL , handle
#define glMakeTextureHandleNonResidentNV_ARG_EXPAND_TAIL , GLuint64 handle
#define forward_glMakeTextureHandleNonResidentNV(_handle) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeTextureHandleNonResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeTextureHandleNonResidentNV(dst, _handle), NULL); \
    });
#define call_glMakeTextureHandleNonResidentNV(packed, ret_v) do { \
    glMakeTextureHandleNonResidentNV_PACKED *unpacked = (glMakeTextureHandleNonResidentNV_PACKED *)packed; \
    glMakeTextureHandleNonResidentNV_ARGS *args = (glMakeTextureHandleNonResidentNV_ARGS *)&unpacked->args; \
    glMakeTextureHandleNonResidentNV(args->handle);; \
} while(0)
void glMakeTextureHandleNonResidentNV(glMakeTextureHandleNonResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeTextureHandleNonResidentNV(glMakeTextureHandleNonResidentNV_PACKED *_dst glMakeTextureHandleNonResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeTextureHandleNonResidentNV_PTR)(glMakeTextureHandleNonResidentNV_ARG_EXPAND);
#endif
#ifndef glMakeTextureHandleResidentNV_RETURN
#define glMakeTextureHandleResidentNV_RETURN void
#define glMakeTextureHandleResidentNV_ARG_NAMES handle
#define glMakeTextureHandleResidentNV_ARG_EXPAND GLuint64 handle
#define glMakeTextureHandleResidentNV_ARG_NAMES_TAIL , handle
#define glMakeTextureHandleResidentNV_ARG_EXPAND_TAIL , GLuint64 handle
#define forward_glMakeTextureHandleResidentNV(_handle) \
    ({ \
        void *dst = remote_dma(sizeof(glMakeTextureHandleResidentNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMakeTextureHandleResidentNV(dst, _handle), NULL); \
    });
#define call_glMakeTextureHandleResidentNV(packed, ret_v) do { \
    glMakeTextureHandleResidentNV_PACKED *unpacked = (glMakeTextureHandleResidentNV_PACKED *)packed; \
    glMakeTextureHandleResidentNV_ARGS *args = (glMakeTextureHandleResidentNV_ARGS *)&unpacked->args; \
    glMakeTextureHandleResidentNV(args->handle);; \
} while(0)
void glMakeTextureHandleResidentNV(glMakeTextureHandleResidentNV_ARG_EXPAND);
packed_call_t *pack_glMakeTextureHandleResidentNV(glMakeTextureHandleResidentNV_PACKED *_dst glMakeTextureHandleResidentNV_ARG_EXPAND_TAIL);
typedef void (*glMakeTextureHandleResidentNV_PTR)(glMakeTextureHandleResidentNV_ARG_EXPAND);
#endif
#ifndef glMap1d_RETURN
#define glMap1d_RETURN void
#define glMap1d_ARG_NAMES target, u1, u2, stride, order, points
#define glMap1d_ARG_EXPAND GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points
#define glMap1d_ARG_NAMES_TAIL , target, u1, u2, stride, order, points
#define glMap1d_ARG_EXPAND_TAIL , GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points
#define forward_glMap1d(_target, _u1, _u2, _stride, _order, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMap1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMap1d(dst, _target, _u1, _u2, _stride, _order, _points), NULL); \
    });
#define call_glMap1d(packed, ret_v) do { \
    glMap1d_PACKED *unpacked = (glMap1d_PACKED *)packed; \
    glMap1d_ARGS *args = (glMap1d_ARGS *)&unpacked->args; \
    glMap1d(args->target, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMap1d(glMap1d_ARG_EXPAND);
packed_call_t *pack_glMap1d(glMap1d_PACKED *_dst glMap1d_ARG_EXPAND_TAIL);
typedef void (*glMap1d_PTR)(glMap1d_ARG_EXPAND);
#endif
#ifndef glMap1f_RETURN
#define glMap1f_RETURN void
#define glMap1f_ARG_NAMES target, u1, u2, stride, order, points
#define glMap1f_ARG_EXPAND GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points
#define glMap1f_ARG_NAMES_TAIL , target, u1, u2, stride, order, points
#define glMap1f_ARG_EXPAND_TAIL , GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points
#define forward_glMap1f(_target, _u1, _u2, _stride, _order, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMap1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMap1f(dst, _target, _u1, _u2, _stride, _order, _points), NULL); \
    });
#define call_glMap1f(packed, ret_v) do { \
    glMap1f_PACKED *unpacked = (glMap1f_PACKED *)packed; \
    glMap1f_ARGS *args = (glMap1f_ARGS *)&unpacked->args; \
    glMap1f(args->target, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMap1f(glMap1f_ARG_EXPAND);
packed_call_t *pack_glMap1f(glMap1f_PACKED *_dst glMap1f_ARG_EXPAND_TAIL);
typedef void (*glMap1f_PTR)(glMap1f_ARG_EXPAND);
#endif
#ifndef glMap1xOES_RETURN
#define glMap1xOES_RETURN void
#define glMap1xOES_ARG_NAMES target, u1, u2, stride, order, points
#define glMap1xOES_ARG_EXPAND GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points
#define glMap1xOES_ARG_NAMES_TAIL , target, u1, u2, stride, order, points
#define glMap1xOES_ARG_EXPAND_TAIL , GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points
#define forward_glMap1xOES(_target, _u1, _u2, _stride, _order, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMap1xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMap1xOES(dst, _target, _u1, _u2, _stride, _order, _points), NULL); \
    });
#define call_glMap1xOES(packed, ret_v) do { \
    glMap1xOES_PACKED *unpacked = (glMap1xOES_PACKED *)packed; \
    glMap1xOES_ARGS *args = (glMap1xOES_ARGS *)&unpacked->args; \
    glMap1xOES(args->target, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMap1xOES(glMap1xOES_ARG_EXPAND);
packed_call_t *pack_glMap1xOES(glMap1xOES_PACKED *_dst glMap1xOES_ARG_EXPAND_TAIL);
typedef void (*glMap1xOES_PTR)(glMap1xOES_ARG_EXPAND);
#endif
#ifndef glMap2d_RETURN
#define glMap2d_RETURN void
#define glMap2d_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2d_ARG_EXPAND GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points
#define glMap2d_ARG_NAMES_TAIL , target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2d_ARG_EXPAND_TAIL , GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points
#define forward_glMap2d(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMap2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMap2d(dst, _target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points), NULL); \
    });
#define call_glMap2d(packed, ret_v) do { \
    glMap2d_PACKED *unpacked = (glMap2d_PACKED *)packed; \
    glMap2d_ARGS *args = (glMap2d_ARGS *)&unpacked->args; \
    glMap2d(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMap2d(glMap2d_ARG_EXPAND);
packed_call_t *pack_glMap2d(glMap2d_PACKED *_dst glMap2d_ARG_EXPAND_TAIL);
typedef void (*glMap2d_PTR)(glMap2d_ARG_EXPAND);
#endif
#ifndef glMap2f_RETURN
#define glMap2f_RETURN void
#define glMap2f_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2f_ARG_EXPAND GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points
#define glMap2f_ARG_NAMES_TAIL , target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2f_ARG_EXPAND_TAIL , GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points
#define forward_glMap2f(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMap2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMap2f(dst, _target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points), NULL); \
    });
#define call_glMap2f(packed, ret_v) do { \
    glMap2f_PACKED *unpacked = (glMap2f_PACKED *)packed; \
    glMap2f_ARGS *args = (glMap2f_ARGS *)&unpacked->args; \
    glMap2f(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMap2f(glMap2f_ARG_EXPAND);
packed_call_t *pack_glMap2f(glMap2f_PACKED *_dst glMap2f_ARG_EXPAND_TAIL);
typedef void (*glMap2f_PTR)(glMap2f_ARG_EXPAND);
#endif
#ifndef glMap2xOES_RETURN
#define glMap2xOES_RETURN void
#define glMap2xOES_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2xOES_ARG_EXPAND GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points
#define glMap2xOES_ARG_NAMES_TAIL , target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2xOES_ARG_EXPAND_TAIL , GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points
#define forward_glMap2xOES(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMap2xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMap2xOES(dst, _target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points), NULL); \
    });
#define call_glMap2xOES(packed, ret_v) do { \
    glMap2xOES_PACKED *unpacked = (glMap2xOES_PACKED *)packed; \
    glMap2xOES_ARGS *args = (glMap2xOES_ARGS *)&unpacked->args; \
    glMap2xOES(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMap2xOES(glMap2xOES_ARG_EXPAND);
packed_call_t *pack_glMap2xOES(glMap2xOES_PACKED *_dst glMap2xOES_ARG_EXPAND_TAIL);
typedef void (*glMap2xOES_PTR)(glMap2xOES_ARG_EXPAND);
#endif
#ifndef glMapBuffer_RETURN
#define glMapBuffer_RETURN GLvoid *
#define glMapBuffer_ARG_NAMES target, access
#define glMapBuffer_ARG_EXPAND GLenum target, GLenum access
#define glMapBuffer_ARG_NAMES_TAIL , target, access
#define glMapBuffer_ARG_EXPAND_TAIL , GLenum target, GLenum access
#define forward_glMapBuffer(_target, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMapBuffer_PACKED)); \
        GLvoid * ret = (GLvoid *)0; \
        remote_dma_send((packed_call_t *)pack_glMapBuffer(dst, _target, _access), &ret); \
        ret; \
    });
#define call_glMapBuffer(packed, ret_v) do { \
    glMapBuffer_PACKED *unpacked = (glMapBuffer_PACKED *)packed; \
    glMapBuffer_ARGS *args = (glMapBuffer_ARGS *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapBuffer(args->target, args->access);; \
    } else { \
        glMapBuffer(args->target, args->access);; \
    } \
} while(0)
GLvoid * glMapBuffer(glMapBuffer_ARG_EXPAND);
packed_call_t *pack_glMapBuffer(glMapBuffer_PACKED *_dst glMapBuffer_ARG_EXPAND_TAIL);
typedef GLvoid * (*glMapBuffer_PTR)(glMapBuffer_ARG_EXPAND);
#endif
#ifndef glMapBufferARB_RETURN
#define glMapBufferARB_RETURN GLvoid *
#define glMapBufferARB_ARG_NAMES target, access
#define glMapBufferARB_ARG_EXPAND GLenum target, GLenum access
#define glMapBufferARB_ARG_NAMES_TAIL , target, access
#define glMapBufferARB_ARG_EXPAND_TAIL , GLenum target, GLenum access
#define forward_glMapBufferARB(_target, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMapBufferARB_PACKED)); \
        GLvoid * ret = (GLvoid *)0; \
        remote_dma_send((packed_call_t *)pack_glMapBufferARB(dst, _target, _access), &ret); \
        ret; \
    });
#define call_glMapBufferARB(packed, ret_v) do { \
    glMapBufferARB_PACKED *unpacked = (glMapBufferARB_PACKED *)packed; \
    glMapBufferARB_ARGS *args = (glMapBufferARB_ARGS *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapBufferARB(args->target, args->access);; \
    } else { \
        glMapBufferARB(args->target, args->access);; \
    } \
} while(0)
GLvoid * glMapBufferARB(glMapBufferARB_ARG_EXPAND);
packed_call_t *pack_glMapBufferARB(glMapBufferARB_PACKED *_dst glMapBufferARB_ARG_EXPAND_TAIL);
typedef GLvoid * (*glMapBufferARB_PTR)(glMapBufferARB_ARG_EXPAND);
#endif
#ifndef glMapBufferRange_RETURN
#define glMapBufferRange_RETURN GLvoid *
#define glMapBufferRange_ARG_NAMES target, offset, length, access
#define glMapBufferRange_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access
#define glMapBufferRange_ARG_NAMES_TAIL , target, offset, length, access
#define glMapBufferRange_ARG_EXPAND_TAIL , GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access
#define forward_glMapBufferRange(_target, _offset, _length, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMapBufferRange_PACKED)); \
        GLvoid * ret = (GLvoid *)0; \
        remote_dma_send((packed_call_t *)pack_glMapBufferRange(dst, _target, _offset, _length, _access), &ret); \
        ret; \
    });
#define call_glMapBufferRange(packed, ret_v) do { \
    glMapBufferRange_PACKED *unpacked = (glMapBufferRange_PACKED *)packed; \
    glMapBufferRange_ARGS *args = (glMapBufferRange_ARGS *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapBufferRange(args->target, args->offset, args->length, args->access);; \
    } else { \
        glMapBufferRange(args->target, args->offset, args->length, args->access);; \
    } \
} while(0)
GLvoid * glMapBufferRange(glMapBufferRange_ARG_EXPAND);
packed_call_t *pack_glMapBufferRange(glMapBufferRange_PACKED *_dst glMapBufferRange_ARG_EXPAND_TAIL);
typedef GLvoid * (*glMapBufferRange_PTR)(glMapBufferRange_ARG_EXPAND);
#endif
#ifndef glMapControlPointsNV_RETURN
#define glMapControlPointsNV_RETURN void
#define glMapControlPointsNV_ARG_NAMES target, index, type, ustride, vstride, uorder, vorder, packed, points
#define glMapControlPointsNV_ARG_EXPAND GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid * points
#define glMapControlPointsNV_ARG_NAMES_TAIL , target, index, type, ustride, vstride, uorder, vorder, packed, points
#define glMapControlPointsNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid * points
#define forward_glMapControlPointsNV(_target, _index, _type, _ustride, _vstride, _uorder, _vorder, _packed, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMapControlPointsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapControlPointsNV(dst, _target, _index, _type, _ustride, _vstride, _uorder, _vorder, _packed, _points), NULL); \
    });
#define call_glMapControlPointsNV(packed, ret_v) do { \
    glMapControlPointsNV_PACKED *unpacked = (glMapControlPointsNV_PACKED *)packed; \
    glMapControlPointsNV_ARGS *args = (glMapControlPointsNV_ARGS *)&unpacked->args; \
    glMapControlPointsNV(args->target, args->index, args->type, args->ustride, args->vstride, args->uorder, args->vorder, args->packed, args->points);; \
} while(0)
void glMapControlPointsNV(glMapControlPointsNV_ARG_EXPAND);
packed_call_t *pack_glMapControlPointsNV(glMapControlPointsNV_PACKED *_dst glMapControlPointsNV_ARG_EXPAND_TAIL);
typedef void (*glMapControlPointsNV_PTR)(glMapControlPointsNV_ARG_EXPAND);
#endif
#ifndef glMapGrid1d_RETURN
#define glMapGrid1d_RETURN void
#define glMapGrid1d_ARG_NAMES un, u1, u2
#define glMapGrid1d_ARG_EXPAND GLint un, GLdouble u1, GLdouble u2
#define glMapGrid1d_ARG_NAMES_TAIL , un, u1, u2
#define glMapGrid1d_ARG_EXPAND_TAIL , GLint un, GLdouble u1, GLdouble u2
#define forward_glMapGrid1d(_un, _u1, _u2) \
    ({ \
        void *dst = remote_dma(sizeof(glMapGrid1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapGrid1d(dst, _un, _u1, _u2), NULL); \
    });
#define call_glMapGrid1d(packed, ret_v) do { \
    glMapGrid1d_PACKED *unpacked = (glMapGrid1d_PACKED *)packed; \
    glMapGrid1d_ARGS *args = (glMapGrid1d_ARGS *)&unpacked->args; \
    glMapGrid1d(args->un, args->u1, args->u2);; \
} while(0)
void glMapGrid1d(glMapGrid1d_ARG_EXPAND);
packed_call_t *pack_glMapGrid1d(glMapGrid1d_PACKED *_dst glMapGrid1d_ARG_EXPAND_TAIL);
typedef void (*glMapGrid1d_PTR)(glMapGrid1d_ARG_EXPAND);
#endif
#ifndef glMapGrid1f_RETURN
#define glMapGrid1f_RETURN void
#define glMapGrid1f_ARG_NAMES un, u1, u2
#define glMapGrid1f_ARG_EXPAND GLint un, GLfloat u1, GLfloat u2
#define glMapGrid1f_ARG_NAMES_TAIL , un, u1, u2
#define glMapGrid1f_ARG_EXPAND_TAIL , GLint un, GLfloat u1, GLfloat u2
#define forward_glMapGrid1f(_un, _u1, _u2) \
    ({ \
        void *dst = remote_dma(sizeof(glMapGrid1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapGrid1f(dst, _un, _u1, _u2), NULL); \
    });
#define call_glMapGrid1f(packed, ret_v) do { \
    glMapGrid1f_PACKED *unpacked = (glMapGrid1f_PACKED *)packed; \
    glMapGrid1f_ARGS *args = (glMapGrid1f_ARGS *)&unpacked->args; \
    glMapGrid1f(args->un, args->u1, args->u2);; \
} while(0)
void glMapGrid1f(glMapGrid1f_ARG_EXPAND);
packed_call_t *pack_glMapGrid1f(glMapGrid1f_PACKED *_dst glMapGrid1f_ARG_EXPAND_TAIL);
typedef void (*glMapGrid1f_PTR)(glMapGrid1f_ARG_EXPAND);
#endif
#ifndef glMapGrid1xOES_RETURN
#define glMapGrid1xOES_RETURN void
#define glMapGrid1xOES_ARG_NAMES n, u1, u2
#define glMapGrid1xOES_ARG_EXPAND GLint n, GLfixed u1, GLfixed u2
#define glMapGrid1xOES_ARG_NAMES_TAIL , n, u1, u2
#define glMapGrid1xOES_ARG_EXPAND_TAIL , GLint n, GLfixed u1, GLfixed u2
#define forward_glMapGrid1xOES(_n, _u1, _u2) \
    ({ \
        void *dst = remote_dma(sizeof(glMapGrid1xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapGrid1xOES(dst, _n, _u1, _u2), NULL); \
    });
#define call_glMapGrid1xOES(packed, ret_v) do { \
    glMapGrid1xOES_PACKED *unpacked = (glMapGrid1xOES_PACKED *)packed; \
    glMapGrid1xOES_ARGS *args = (glMapGrid1xOES_ARGS *)&unpacked->args; \
    glMapGrid1xOES(args->n, args->u1, args->u2);; \
} while(0)
void glMapGrid1xOES(glMapGrid1xOES_ARG_EXPAND);
packed_call_t *pack_glMapGrid1xOES(glMapGrid1xOES_PACKED *_dst glMapGrid1xOES_ARG_EXPAND_TAIL);
typedef void (*glMapGrid1xOES_PTR)(glMapGrid1xOES_ARG_EXPAND);
#endif
#ifndef glMapGrid2d_RETURN
#define glMapGrid2d_RETURN void
#define glMapGrid2d_ARG_NAMES un, u1, u2, vn, v1, v2
#define glMapGrid2d_ARG_EXPAND GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2
#define glMapGrid2d_ARG_NAMES_TAIL , un, u1, u2, vn, v1, v2
#define glMapGrid2d_ARG_EXPAND_TAIL , GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2
#define forward_glMapGrid2d(_un, _u1, _u2, _vn, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glMapGrid2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapGrid2d(dst, _un, _u1, _u2, _vn, _v1, _v2), NULL); \
    });
#define call_glMapGrid2d(packed, ret_v) do { \
    glMapGrid2d_PACKED *unpacked = (glMapGrid2d_PACKED *)packed; \
    glMapGrid2d_ARGS *args = (glMapGrid2d_ARGS *)&unpacked->args; \
    glMapGrid2d(args->un, args->u1, args->u2, args->vn, args->v1, args->v2);; \
} while(0)
void glMapGrid2d(glMapGrid2d_ARG_EXPAND);
packed_call_t *pack_glMapGrid2d(glMapGrid2d_PACKED *_dst glMapGrid2d_ARG_EXPAND_TAIL);
typedef void (*glMapGrid2d_PTR)(glMapGrid2d_ARG_EXPAND);
#endif
#ifndef glMapGrid2f_RETURN
#define glMapGrid2f_RETURN void
#define glMapGrid2f_ARG_NAMES un, u1, u2, vn, v1, v2
#define glMapGrid2f_ARG_EXPAND GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2
#define glMapGrid2f_ARG_NAMES_TAIL , un, u1, u2, vn, v1, v2
#define glMapGrid2f_ARG_EXPAND_TAIL , GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2
#define forward_glMapGrid2f(_un, _u1, _u2, _vn, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glMapGrid2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapGrid2f(dst, _un, _u1, _u2, _vn, _v1, _v2), NULL); \
    });
#define call_glMapGrid2f(packed, ret_v) do { \
    glMapGrid2f_PACKED *unpacked = (glMapGrid2f_PACKED *)packed; \
    glMapGrid2f_ARGS *args = (glMapGrid2f_ARGS *)&unpacked->args; \
    glMapGrid2f(args->un, args->u1, args->u2, args->vn, args->v1, args->v2);; \
} while(0)
void glMapGrid2f(glMapGrid2f_ARG_EXPAND);
packed_call_t *pack_glMapGrid2f(glMapGrid2f_PACKED *_dst glMapGrid2f_ARG_EXPAND_TAIL);
typedef void (*glMapGrid2f_PTR)(glMapGrid2f_ARG_EXPAND);
#endif
#ifndef glMapGrid2xOES_RETURN
#define glMapGrid2xOES_RETURN void
#define glMapGrid2xOES_ARG_NAMES n, u1, u2, v1, v2
#define glMapGrid2xOES_ARG_EXPAND GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2
#define glMapGrid2xOES_ARG_NAMES_TAIL , n, u1, u2, v1, v2
#define glMapGrid2xOES_ARG_EXPAND_TAIL , GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2
#define forward_glMapGrid2xOES(_n, _u1, _u2, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glMapGrid2xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapGrid2xOES(dst, _n, _u1, _u2, _v1, _v2), NULL); \
    });
#define call_glMapGrid2xOES(packed, ret_v) do { \
    glMapGrid2xOES_PACKED *unpacked = (glMapGrid2xOES_PACKED *)packed; \
    glMapGrid2xOES_ARGS *args = (glMapGrid2xOES_ARGS *)&unpacked->args; \
    glMapGrid2xOES(args->n, args->u1, args->u2, args->v1, args->v2);; \
} while(0)
void glMapGrid2xOES(glMapGrid2xOES_ARG_EXPAND);
packed_call_t *pack_glMapGrid2xOES(glMapGrid2xOES_PACKED *_dst glMapGrid2xOES_ARG_EXPAND_TAIL);
typedef void (*glMapGrid2xOES_PTR)(glMapGrid2xOES_ARG_EXPAND);
#endif
#ifndef glMapNamedBufferEXT_RETURN
#define glMapNamedBufferEXT_RETURN GLvoid *
#define glMapNamedBufferEXT_ARG_NAMES buffer, access
#define glMapNamedBufferEXT_ARG_EXPAND GLuint buffer, GLenum access
#define glMapNamedBufferEXT_ARG_NAMES_TAIL , buffer, access
#define glMapNamedBufferEXT_ARG_EXPAND_TAIL , GLuint buffer, GLenum access
#define forward_glMapNamedBufferEXT(_buffer, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMapNamedBufferEXT_PACKED)); \
        GLvoid * ret = (GLvoid *)0; \
        remote_dma_send((packed_call_t *)pack_glMapNamedBufferEXT(dst, _buffer, _access), &ret); \
        ret; \
    });
#define call_glMapNamedBufferEXT(packed, ret_v) do { \
    glMapNamedBufferEXT_PACKED *unpacked = (glMapNamedBufferEXT_PACKED *)packed; \
    glMapNamedBufferEXT_ARGS *args = (glMapNamedBufferEXT_ARGS *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapNamedBufferEXT(args->buffer, args->access);; \
    } else { \
        glMapNamedBufferEXT(args->buffer, args->access);; \
    } \
} while(0)
GLvoid * glMapNamedBufferEXT(glMapNamedBufferEXT_ARG_EXPAND);
packed_call_t *pack_glMapNamedBufferEXT(glMapNamedBufferEXT_PACKED *_dst glMapNamedBufferEXT_ARG_EXPAND_TAIL);
typedef GLvoid * (*glMapNamedBufferEXT_PTR)(glMapNamedBufferEXT_ARG_EXPAND);
#endif
#ifndef glMapNamedBufferRangeEXT_RETURN
#define glMapNamedBufferRangeEXT_RETURN GLvoid *
#define glMapNamedBufferRangeEXT_ARG_NAMES buffer, offset, length, access
#define glMapNamedBufferRangeEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access
#define glMapNamedBufferRangeEXT_ARG_NAMES_TAIL , buffer, offset, length, access
#define glMapNamedBufferRangeEXT_ARG_EXPAND_TAIL , GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access
#define forward_glMapNamedBufferRangeEXT(_buffer, _offset, _length, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glMapNamedBufferRangeEXT_PACKED)); \
        GLvoid * ret = (GLvoid *)0; \
        remote_dma_send((packed_call_t *)pack_glMapNamedBufferRangeEXT(dst, _buffer, _offset, _length, _access), &ret); \
        ret; \
    });
#define call_glMapNamedBufferRangeEXT(packed, ret_v) do { \
    glMapNamedBufferRangeEXT_PACKED *unpacked = (glMapNamedBufferRangeEXT_PACKED *)packed; \
    glMapNamedBufferRangeEXT_ARGS *args = (glMapNamedBufferRangeEXT_ARGS *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapNamedBufferRangeEXT(args->buffer, args->offset, args->length, args->access);; \
    } else { \
        glMapNamedBufferRangeEXT(args->buffer, args->offset, args->length, args->access);; \
    } \
} while(0)
GLvoid * glMapNamedBufferRangeEXT(glMapNamedBufferRangeEXT_ARG_EXPAND);
packed_call_t *pack_glMapNamedBufferRangeEXT(glMapNamedBufferRangeEXT_PACKED *_dst glMapNamedBufferRangeEXT_ARG_EXPAND_TAIL);
typedef GLvoid * (*glMapNamedBufferRangeEXT_PTR)(glMapNamedBufferRangeEXT_ARG_EXPAND);
#endif
#ifndef glMapObjectBufferATI_RETURN
#define glMapObjectBufferATI_RETURN GLvoid *
#define glMapObjectBufferATI_ARG_NAMES buffer
#define glMapObjectBufferATI_ARG_EXPAND GLuint buffer
#define glMapObjectBufferATI_ARG_NAMES_TAIL , buffer
#define glMapObjectBufferATI_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glMapObjectBufferATI(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glMapObjectBufferATI_PACKED)); \
        GLvoid * ret = (GLvoid *)0; \
        remote_dma_send((packed_call_t *)pack_glMapObjectBufferATI(dst, _buffer), &ret); \
        ret; \
    });
#define call_glMapObjectBufferATI(packed, ret_v) do { \
    glMapObjectBufferATI_PACKED *unpacked = (glMapObjectBufferATI_PACKED *)packed; \
    glMapObjectBufferATI_ARGS *args = (glMapObjectBufferATI_ARGS *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapObjectBufferATI(args->buffer);; \
    } else { \
        glMapObjectBufferATI(args->buffer);; \
    } \
} while(0)
GLvoid * glMapObjectBufferATI(glMapObjectBufferATI_ARG_EXPAND);
packed_call_t *pack_glMapObjectBufferATI(glMapObjectBufferATI_PACKED *_dst glMapObjectBufferATI_ARG_EXPAND_TAIL);
typedef GLvoid * (*glMapObjectBufferATI_PTR)(glMapObjectBufferATI_ARG_EXPAND);
#endif
#ifndef glMapParameterfvNV_RETURN
#define glMapParameterfvNV_RETURN void
#define glMapParameterfvNV_ARG_NAMES target, pname, params
#define glMapParameterfvNV_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glMapParameterfvNV_ARG_NAMES_TAIL , target, pname, params
#define glMapParameterfvNV_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glMapParameterfvNV(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMapParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapParameterfvNV(dst, _target, _pname, _params), NULL); \
    });
#define call_glMapParameterfvNV(packed, ret_v) do { \
    glMapParameterfvNV_PACKED *unpacked = (glMapParameterfvNV_PACKED *)packed; \
    glMapParameterfvNV_ARGS *args = (glMapParameterfvNV_ARGS *)&unpacked->args; \
    glMapParameterfvNV(args->target, args->pname, args->params);; \
} while(0)
void glMapParameterfvNV(glMapParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glMapParameterfvNV(glMapParameterfvNV_PACKED *_dst glMapParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glMapParameterfvNV_PTR)(glMapParameterfvNV_ARG_EXPAND);
#endif
#ifndef glMapParameterivNV_RETURN
#define glMapParameterivNV_RETURN void
#define glMapParameterivNV_ARG_NAMES target, pname, params
#define glMapParameterivNV_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glMapParameterivNV_ARG_NAMES_TAIL , target, pname, params
#define glMapParameterivNV_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glMapParameterivNV(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMapParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapParameterivNV(dst, _target, _pname, _params), NULL); \
    });
#define call_glMapParameterivNV(packed, ret_v) do { \
    glMapParameterivNV_PACKED *unpacked = (glMapParameterivNV_PACKED *)packed; \
    glMapParameterivNV_ARGS *args = (glMapParameterivNV_ARGS *)&unpacked->args; \
    glMapParameterivNV(args->target, args->pname, args->params);; \
} while(0)
void glMapParameterivNV(glMapParameterivNV_ARG_EXPAND);
packed_call_t *pack_glMapParameterivNV(glMapParameterivNV_PACKED *_dst glMapParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glMapParameterivNV_PTR)(glMapParameterivNV_ARG_EXPAND);
#endif
#ifndef glMapTexture2DINTEL_RETURN
#define glMapTexture2DINTEL_RETURN GLvoid *
#define glMapTexture2DINTEL_ARG_NAMES texture, level, access, stride, layout
#define glMapTexture2DINTEL_ARG_EXPAND GLuint texture, GLint level, GLbitfield access, const GLint * stride, const GLenum * layout
#define glMapTexture2DINTEL_ARG_NAMES_TAIL , texture, level, access, stride, layout
#define glMapTexture2DINTEL_ARG_EXPAND_TAIL , GLuint texture, GLint level, GLbitfield access, const GLint * stride, const GLenum * layout
#define forward_glMapTexture2DINTEL(_texture, _level, _access, _stride, _layout) \
    ({ \
        void *dst = remote_dma(sizeof(glMapTexture2DINTEL_PACKED)); \
        GLvoid * ret = (GLvoid *)0; \
        remote_dma_send((packed_call_t *)pack_glMapTexture2DINTEL(dst, _texture, _level, _access, _stride, _layout), &ret); \
        ret; \
    });
#define call_glMapTexture2DINTEL(packed, ret_v) do { \
    glMapTexture2DINTEL_PACKED *unpacked = (glMapTexture2DINTEL_PACKED *)packed; \
    glMapTexture2DINTEL_ARGS *args = (glMapTexture2DINTEL_ARGS *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapTexture2DINTEL(args->texture, args->level, args->access, args->stride, args->layout);; \
    } else { \
        glMapTexture2DINTEL(args->texture, args->level, args->access, args->stride, args->layout);; \
    } \
} while(0)
GLvoid * glMapTexture2DINTEL(glMapTexture2DINTEL_ARG_EXPAND);
packed_call_t *pack_glMapTexture2DINTEL(glMapTexture2DINTEL_PACKED *_dst glMapTexture2DINTEL_ARG_EXPAND_TAIL);
typedef GLvoid * (*glMapTexture2DINTEL_PTR)(glMapTexture2DINTEL_ARG_EXPAND);
#endif
#ifndef glMapVertexAttrib1dAPPLE_RETURN
#define glMapVertexAttrib1dAPPLE_RETURN void
#define glMapVertexAttrib1dAPPLE_ARG_NAMES index, size, u1, u2, stride, order, points
#define glMapVertexAttrib1dAPPLE_ARG_EXPAND GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points
#define glMapVertexAttrib1dAPPLE_ARG_NAMES_TAIL , index, size, u1, u2, stride, order, points
#define glMapVertexAttrib1dAPPLE_ARG_EXPAND_TAIL , GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points
#define forward_glMapVertexAttrib1dAPPLE(_index, _size, _u1, _u2, _stride, _order, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMapVertexAttrib1dAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapVertexAttrib1dAPPLE(dst, _index, _size, _u1, _u2, _stride, _order, _points), NULL); \
    });
#define call_glMapVertexAttrib1dAPPLE(packed, ret_v) do { \
    glMapVertexAttrib1dAPPLE_PACKED *unpacked = (glMapVertexAttrib1dAPPLE_PACKED *)packed; \
    glMapVertexAttrib1dAPPLE_ARGS *args = (glMapVertexAttrib1dAPPLE_ARGS *)&unpacked->args; \
    glMapVertexAttrib1dAPPLE(args->index, args->size, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMapVertexAttrib1dAPPLE(glMapVertexAttrib1dAPPLE_ARG_EXPAND);
packed_call_t *pack_glMapVertexAttrib1dAPPLE(glMapVertexAttrib1dAPPLE_PACKED *_dst glMapVertexAttrib1dAPPLE_ARG_EXPAND_TAIL);
typedef void (*glMapVertexAttrib1dAPPLE_PTR)(glMapVertexAttrib1dAPPLE_ARG_EXPAND);
#endif
#ifndef glMapVertexAttrib1fAPPLE_RETURN
#define glMapVertexAttrib1fAPPLE_RETURN void
#define glMapVertexAttrib1fAPPLE_ARG_NAMES index, size, u1, u2, stride, order, points
#define glMapVertexAttrib1fAPPLE_ARG_EXPAND GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points
#define glMapVertexAttrib1fAPPLE_ARG_NAMES_TAIL , index, size, u1, u2, stride, order, points
#define glMapVertexAttrib1fAPPLE_ARG_EXPAND_TAIL , GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points
#define forward_glMapVertexAttrib1fAPPLE(_index, _size, _u1, _u2, _stride, _order, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMapVertexAttrib1fAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapVertexAttrib1fAPPLE(dst, _index, _size, _u1, _u2, _stride, _order, _points), NULL); \
    });
#define call_glMapVertexAttrib1fAPPLE(packed, ret_v) do { \
    glMapVertexAttrib1fAPPLE_PACKED *unpacked = (glMapVertexAttrib1fAPPLE_PACKED *)packed; \
    glMapVertexAttrib1fAPPLE_ARGS *args = (glMapVertexAttrib1fAPPLE_ARGS *)&unpacked->args; \
    glMapVertexAttrib1fAPPLE(args->index, args->size, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMapVertexAttrib1fAPPLE(glMapVertexAttrib1fAPPLE_ARG_EXPAND);
packed_call_t *pack_glMapVertexAttrib1fAPPLE(glMapVertexAttrib1fAPPLE_PACKED *_dst glMapVertexAttrib1fAPPLE_ARG_EXPAND_TAIL);
typedef void (*glMapVertexAttrib1fAPPLE_PTR)(glMapVertexAttrib1fAPPLE_ARG_EXPAND);
#endif
#ifndef glMapVertexAttrib2dAPPLE_RETURN
#define glMapVertexAttrib2dAPPLE_RETURN void
#define glMapVertexAttrib2dAPPLE_ARG_NAMES index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMapVertexAttrib2dAPPLE_ARG_EXPAND GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points
#define glMapVertexAttrib2dAPPLE_ARG_NAMES_TAIL , index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMapVertexAttrib2dAPPLE_ARG_EXPAND_TAIL , GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points
#define forward_glMapVertexAttrib2dAPPLE(_index, _size, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMapVertexAttrib2dAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapVertexAttrib2dAPPLE(dst, _index, _size, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points), NULL); \
    });
#define call_glMapVertexAttrib2dAPPLE(packed, ret_v) do { \
    glMapVertexAttrib2dAPPLE_PACKED *unpacked = (glMapVertexAttrib2dAPPLE_PACKED *)packed; \
    glMapVertexAttrib2dAPPLE_ARGS *args = (glMapVertexAttrib2dAPPLE_ARGS *)&unpacked->args; \
    glMapVertexAttrib2dAPPLE(args->index, args->size, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMapVertexAttrib2dAPPLE(glMapVertexAttrib2dAPPLE_ARG_EXPAND);
packed_call_t *pack_glMapVertexAttrib2dAPPLE(glMapVertexAttrib2dAPPLE_PACKED *_dst glMapVertexAttrib2dAPPLE_ARG_EXPAND_TAIL);
typedef void (*glMapVertexAttrib2dAPPLE_PTR)(glMapVertexAttrib2dAPPLE_ARG_EXPAND);
#endif
#ifndef glMapVertexAttrib2fAPPLE_RETURN
#define glMapVertexAttrib2fAPPLE_RETURN void
#define glMapVertexAttrib2fAPPLE_ARG_NAMES index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMapVertexAttrib2fAPPLE_ARG_EXPAND GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points
#define glMapVertexAttrib2fAPPLE_ARG_NAMES_TAIL , index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMapVertexAttrib2fAPPLE_ARG_EXPAND_TAIL , GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points
#define forward_glMapVertexAttrib2fAPPLE(_index, _size, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glMapVertexAttrib2fAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMapVertexAttrib2fAPPLE(dst, _index, _size, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points), NULL); \
    });
#define call_glMapVertexAttrib2fAPPLE(packed, ret_v) do { \
    glMapVertexAttrib2fAPPLE_PACKED *unpacked = (glMapVertexAttrib2fAPPLE_PACKED *)packed; \
    glMapVertexAttrib2fAPPLE_ARGS *args = (glMapVertexAttrib2fAPPLE_ARGS *)&unpacked->args; \
    glMapVertexAttrib2fAPPLE(args->index, args->size, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMapVertexAttrib2fAPPLE(glMapVertexAttrib2fAPPLE_ARG_EXPAND);
packed_call_t *pack_glMapVertexAttrib2fAPPLE(glMapVertexAttrib2fAPPLE_PACKED *_dst glMapVertexAttrib2fAPPLE_ARG_EXPAND_TAIL);
typedef void (*glMapVertexAttrib2fAPPLE_PTR)(glMapVertexAttrib2fAPPLE_ARG_EXPAND);
#endif
#ifndef glMaterialf_RETURN
#define glMaterialf_RETURN void
#define glMaterialf_ARG_NAMES face, pname, param
#define glMaterialf_ARG_EXPAND GLenum face, GLenum pname, GLfloat param
#define glMaterialf_ARG_NAMES_TAIL , face, pname, param
#define glMaterialf_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLfloat param
#define forward_glMaterialf(_face, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMaterialf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMaterialf(dst, _face, _pname, _param), NULL); \
    });
#define call_glMaterialf(packed, ret_v) do { \
    glMaterialf_PACKED *unpacked = (glMaterialf_PACKED *)packed; \
    glMaterialf_ARGS *args = (glMaterialf_ARGS *)&unpacked->args; \
    glMaterialf(args->face, args->pname, args->param);; \
} while(0)
void glMaterialf(glMaterialf_ARG_EXPAND);
packed_call_t *pack_glMaterialf(glMaterialf_PACKED *_dst glMaterialf_ARG_EXPAND_TAIL);
typedef void (*glMaterialf_PTR)(glMaterialf_ARG_EXPAND);
#endif
#ifndef glMaterialfv_RETURN
#define glMaterialfv_RETURN void
#define glMaterialfv_ARG_NAMES face, pname, params
#define glMaterialfv_ARG_EXPAND GLenum face, GLenum pname, const GLfloat * params
#define glMaterialfv_ARG_NAMES_TAIL , face, pname, params
#define glMaterialfv_ARG_EXPAND_TAIL , GLenum face, GLenum pname, const GLfloat * params
#define forward_glMaterialfv(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMaterialfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMaterialfv(dst, _face, _pname, _params), NULL); \
    });
#define call_glMaterialfv(packed, ret_v) do { \
    glMaterialfv_PACKED *unpacked = (glMaterialfv_PACKED *)packed; \
    glMaterialfv_ARGS *args = (glMaterialfv_ARGS *)&unpacked->args; \
    glMaterialfv(args->face, args->pname, args->params);; \
} while(0)
void glMaterialfv(glMaterialfv_ARG_EXPAND);
packed_call_t *pack_glMaterialfv(glMaterialfv_PACKED *_dst glMaterialfv_ARG_EXPAND_TAIL);
typedef void (*glMaterialfv_PTR)(glMaterialfv_ARG_EXPAND);
#endif
#ifndef glMateriali_RETURN
#define glMateriali_RETURN void
#define glMateriali_ARG_NAMES face, pname, param
#define glMateriali_ARG_EXPAND GLenum face, GLenum pname, GLint param
#define glMateriali_ARG_NAMES_TAIL , face, pname, param
#define glMateriali_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLint param
#define forward_glMateriali(_face, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMateriali_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMateriali(dst, _face, _pname, _param), NULL); \
    });
#define call_glMateriali(packed, ret_v) do { \
    glMateriali_PACKED *unpacked = (glMateriali_PACKED *)packed; \
    glMateriali_ARGS *args = (glMateriali_ARGS *)&unpacked->args; \
    glMateriali(args->face, args->pname, args->param);; \
} while(0)
void glMateriali(glMateriali_ARG_EXPAND);
packed_call_t *pack_glMateriali(glMateriali_PACKED *_dst glMateriali_ARG_EXPAND_TAIL);
typedef void (*glMateriali_PTR)(glMateriali_ARG_EXPAND);
#endif
#ifndef glMaterialiv_RETURN
#define glMaterialiv_RETURN void
#define glMaterialiv_ARG_NAMES face, pname, params
#define glMaterialiv_ARG_EXPAND GLenum face, GLenum pname, const GLint * params
#define glMaterialiv_ARG_NAMES_TAIL , face, pname, params
#define glMaterialiv_ARG_EXPAND_TAIL , GLenum face, GLenum pname, const GLint * params
#define forward_glMaterialiv(_face, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMaterialiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMaterialiv(dst, _face, _pname, _params), NULL); \
    });
#define call_glMaterialiv(packed, ret_v) do { \
    glMaterialiv_PACKED *unpacked = (glMaterialiv_PACKED *)packed; \
    glMaterialiv_ARGS *args = (glMaterialiv_ARGS *)&unpacked->args; \
    glMaterialiv(args->face, args->pname, args->params);; \
} while(0)
void glMaterialiv(glMaterialiv_ARG_EXPAND);
packed_call_t *pack_glMaterialiv(glMaterialiv_PACKED *_dst glMaterialiv_ARG_EXPAND_TAIL);
typedef void (*glMaterialiv_PTR)(glMaterialiv_ARG_EXPAND);
#endif
#ifndef glMaterialxOES_RETURN
#define glMaterialxOES_RETURN void
#define glMaterialxOES_ARG_NAMES face, pname, param
#define glMaterialxOES_ARG_EXPAND GLenum face, GLenum pname, GLfixed param
#define glMaterialxOES_ARG_NAMES_TAIL , face, pname, param
#define glMaterialxOES_ARG_EXPAND_TAIL , GLenum face, GLenum pname, GLfixed param
#define forward_glMaterialxOES(_face, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMaterialxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMaterialxOES(dst, _face, _pname, _param), NULL); \
    });
#define call_glMaterialxOES(packed, ret_v) do { \
    glMaterialxOES_PACKED *unpacked = (glMaterialxOES_PACKED *)packed; \
    glMaterialxOES_ARGS *args = (glMaterialxOES_ARGS *)&unpacked->args; \
    glMaterialxOES(args->face, args->pname, args->param);; \
} while(0)
void glMaterialxOES(glMaterialxOES_ARG_EXPAND);
packed_call_t *pack_glMaterialxOES(glMaterialxOES_PACKED *_dst glMaterialxOES_ARG_EXPAND_TAIL);
typedef void (*glMaterialxOES_PTR)(glMaterialxOES_ARG_EXPAND);
#endif
#ifndef glMaterialxvOES_RETURN
#define glMaterialxvOES_RETURN void
#define glMaterialxvOES_ARG_NAMES face, pname, param
#define glMaterialxvOES_ARG_EXPAND GLenum face, GLenum pname, const GLfixed * param
#define glMaterialxvOES_ARG_NAMES_TAIL , face, pname, param
#define glMaterialxvOES_ARG_EXPAND_TAIL , GLenum face, GLenum pname, const GLfixed * param
#define forward_glMaterialxvOES(_face, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMaterialxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMaterialxvOES(dst, _face, _pname, _param), NULL); \
    });
#define call_glMaterialxvOES(packed, ret_v) do { \
    glMaterialxvOES_PACKED *unpacked = (glMaterialxvOES_PACKED *)packed; \
    glMaterialxvOES_ARGS *args = (glMaterialxvOES_ARGS *)&unpacked->args; \
    glMaterialxvOES(args->face, args->pname, args->param);; \
} while(0)
void glMaterialxvOES(glMaterialxvOES_ARG_EXPAND);
packed_call_t *pack_glMaterialxvOES(glMaterialxvOES_PACKED *_dst glMaterialxvOES_ARG_EXPAND_TAIL);
typedef void (*glMaterialxvOES_PTR)(glMaterialxvOES_ARG_EXPAND);
#endif
#ifndef glMatrixFrustumEXT_RETURN
#define glMatrixFrustumEXT_RETURN void
#define glMatrixFrustumEXT_ARG_NAMES mode, left, right, bottom, top, zNear, zFar
#define glMatrixFrustumEXT_ARG_EXPAND GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glMatrixFrustumEXT_ARG_NAMES_TAIL , mode, left, right, bottom, top, zNear, zFar
#define glMatrixFrustumEXT_ARG_EXPAND_TAIL , GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define forward_glMatrixFrustumEXT(_mode, _left, _right, _bottom, _top, _zNear, _zFar) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixFrustumEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixFrustumEXT(dst, _mode, _left, _right, _bottom, _top, _zNear, _zFar), NULL); \
    });
#define call_glMatrixFrustumEXT(packed, ret_v) do { \
    glMatrixFrustumEXT_PACKED *unpacked = (glMatrixFrustumEXT_PACKED *)packed; \
    glMatrixFrustumEXT_ARGS *args = (glMatrixFrustumEXT_ARGS *)&unpacked->args; \
    glMatrixFrustumEXT(args->mode, args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glMatrixFrustumEXT(glMatrixFrustumEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixFrustumEXT(glMatrixFrustumEXT_PACKED *_dst glMatrixFrustumEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixFrustumEXT_PTR)(glMatrixFrustumEXT_ARG_EXPAND);
#endif
#ifndef glMatrixIndexPointerARB_RETURN
#define glMatrixIndexPointerARB_RETURN void
#define glMatrixIndexPointerARB_ARG_NAMES size, type, stride, pointer
#define glMatrixIndexPointerARB_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glMatrixIndexPointerARB_ARG_NAMES_TAIL , size, type, stride, pointer
#define glMatrixIndexPointerARB_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glMatrixIndexPointerARB(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixIndexPointerARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixIndexPointerARB(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glMatrixIndexPointerARB(packed, ret_v) do { \
    glMatrixIndexPointerARB_PACKED *unpacked = (glMatrixIndexPointerARB_PACKED *)packed; \
    glMatrixIndexPointerARB_ARGS *args = (glMatrixIndexPointerARB_ARGS *)&unpacked->args; \
    glMatrixIndexPointerARB(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glMatrixIndexPointerARB(glMatrixIndexPointerARB_ARG_EXPAND);
packed_call_t *pack_glMatrixIndexPointerARB(glMatrixIndexPointerARB_PACKED *_dst glMatrixIndexPointerARB_ARG_EXPAND_TAIL);
typedef void (*glMatrixIndexPointerARB_PTR)(glMatrixIndexPointerARB_ARG_EXPAND);
#endif
#ifndef glMatrixIndexubvARB_RETURN
#define glMatrixIndexubvARB_RETURN void
#define glMatrixIndexubvARB_ARG_NAMES size, indices
#define glMatrixIndexubvARB_ARG_EXPAND GLint size, const GLubyte * indices
#define glMatrixIndexubvARB_ARG_NAMES_TAIL , size, indices
#define glMatrixIndexubvARB_ARG_EXPAND_TAIL , GLint size, const GLubyte * indices
#define forward_glMatrixIndexubvARB(_size, _indices) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixIndexubvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixIndexubvARB(dst, _size, _indices), NULL); \
    });
#define call_glMatrixIndexubvARB(packed, ret_v) do { \
    glMatrixIndexubvARB_PACKED *unpacked = (glMatrixIndexubvARB_PACKED *)packed; \
    glMatrixIndexubvARB_ARGS *args = (glMatrixIndexubvARB_ARGS *)&unpacked->args; \
    glMatrixIndexubvARB(args->size, args->indices);; \
} while(0)
void glMatrixIndexubvARB(glMatrixIndexubvARB_ARG_EXPAND);
packed_call_t *pack_glMatrixIndexubvARB(glMatrixIndexubvARB_PACKED *_dst glMatrixIndexubvARB_ARG_EXPAND_TAIL);
typedef void (*glMatrixIndexubvARB_PTR)(glMatrixIndexubvARB_ARG_EXPAND);
#endif
#ifndef glMatrixIndexuivARB_RETURN
#define glMatrixIndexuivARB_RETURN void
#define glMatrixIndexuivARB_ARG_NAMES size, indices
#define glMatrixIndexuivARB_ARG_EXPAND GLint size, const GLuint * indices
#define glMatrixIndexuivARB_ARG_NAMES_TAIL , size, indices
#define glMatrixIndexuivARB_ARG_EXPAND_TAIL , GLint size, const GLuint * indices
#define forward_glMatrixIndexuivARB(_size, _indices) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixIndexuivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixIndexuivARB(dst, _size, _indices), NULL); \
    });
#define call_glMatrixIndexuivARB(packed, ret_v) do { \
    glMatrixIndexuivARB_PACKED *unpacked = (glMatrixIndexuivARB_PACKED *)packed; \
    glMatrixIndexuivARB_ARGS *args = (glMatrixIndexuivARB_ARGS *)&unpacked->args; \
    glMatrixIndexuivARB(args->size, args->indices);; \
} while(0)
void glMatrixIndexuivARB(glMatrixIndexuivARB_ARG_EXPAND);
packed_call_t *pack_glMatrixIndexuivARB(glMatrixIndexuivARB_PACKED *_dst glMatrixIndexuivARB_ARG_EXPAND_TAIL);
typedef void (*glMatrixIndexuivARB_PTR)(glMatrixIndexuivARB_ARG_EXPAND);
#endif
#ifndef glMatrixIndexusvARB_RETURN
#define glMatrixIndexusvARB_RETURN void
#define glMatrixIndexusvARB_ARG_NAMES size, indices
#define glMatrixIndexusvARB_ARG_EXPAND GLint size, const GLushort * indices
#define glMatrixIndexusvARB_ARG_NAMES_TAIL , size, indices
#define glMatrixIndexusvARB_ARG_EXPAND_TAIL , GLint size, const GLushort * indices
#define forward_glMatrixIndexusvARB(_size, _indices) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixIndexusvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixIndexusvARB(dst, _size, _indices), NULL); \
    });
#define call_glMatrixIndexusvARB(packed, ret_v) do { \
    glMatrixIndexusvARB_PACKED *unpacked = (glMatrixIndexusvARB_PACKED *)packed; \
    glMatrixIndexusvARB_ARGS *args = (glMatrixIndexusvARB_ARGS *)&unpacked->args; \
    glMatrixIndexusvARB(args->size, args->indices);; \
} while(0)
void glMatrixIndexusvARB(glMatrixIndexusvARB_ARG_EXPAND);
packed_call_t *pack_glMatrixIndexusvARB(glMatrixIndexusvARB_PACKED *_dst glMatrixIndexusvARB_ARG_EXPAND_TAIL);
typedef void (*glMatrixIndexusvARB_PTR)(glMatrixIndexusvARB_ARG_EXPAND);
#endif
#ifndef glMatrixLoadIdentityEXT_RETURN
#define glMatrixLoadIdentityEXT_RETURN void
#define glMatrixLoadIdentityEXT_ARG_NAMES mode
#define glMatrixLoadIdentityEXT_ARG_EXPAND GLenum mode
#define glMatrixLoadIdentityEXT_ARG_NAMES_TAIL , mode
#define glMatrixLoadIdentityEXT_ARG_EXPAND_TAIL , GLenum mode
#define forward_glMatrixLoadIdentityEXT(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixLoadIdentityEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixLoadIdentityEXT(dst, _mode), NULL); \
    });
#define call_glMatrixLoadIdentityEXT(packed, ret_v) do { \
    glMatrixLoadIdentityEXT_PACKED *unpacked = (glMatrixLoadIdentityEXT_PACKED *)packed; \
    glMatrixLoadIdentityEXT_ARGS *args = (glMatrixLoadIdentityEXT_ARGS *)&unpacked->args; \
    glMatrixLoadIdentityEXT(args->mode);; \
} while(0)
void glMatrixLoadIdentityEXT(glMatrixLoadIdentityEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixLoadIdentityEXT(glMatrixLoadIdentityEXT_PACKED *_dst glMatrixLoadIdentityEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixLoadIdentityEXT_PTR)(glMatrixLoadIdentityEXT_ARG_EXPAND);
#endif
#ifndef glMatrixLoadTransposedEXT_RETURN
#define glMatrixLoadTransposedEXT_RETURN void
#define glMatrixLoadTransposedEXT_ARG_NAMES mode, m
#define glMatrixLoadTransposedEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixLoadTransposedEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixLoadTransposedEXT_ARG_EXPAND_TAIL , GLenum mode, const GLdouble * m
#define forward_glMatrixLoadTransposedEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixLoadTransposedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixLoadTransposedEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixLoadTransposedEXT(packed, ret_v) do { \
    glMatrixLoadTransposedEXT_PACKED *unpacked = (glMatrixLoadTransposedEXT_PACKED *)packed; \
    glMatrixLoadTransposedEXT_ARGS *args = (glMatrixLoadTransposedEXT_ARGS *)&unpacked->args; \
    glMatrixLoadTransposedEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoadTransposedEXT(glMatrixLoadTransposedEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixLoadTransposedEXT(glMatrixLoadTransposedEXT_PACKED *_dst glMatrixLoadTransposedEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixLoadTransposedEXT_PTR)(glMatrixLoadTransposedEXT_ARG_EXPAND);
#endif
#ifndef glMatrixLoadTransposefEXT_RETURN
#define glMatrixLoadTransposefEXT_RETURN void
#define glMatrixLoadTransposefEXT_ARG_NAMES mode, m
#define glMatrixLoadTransposefEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixLoadTransposefEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixLoadTransposefEXT_ARG_EXPAND_TAIL , GLenum mode, const GLfloat * m
#define forward_glMatrixLoadTransposefEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixLoadTransposefEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixLoadTransposefEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixLoadTransposefEXT(packed, ret_v) do { \
    glMatrixLoadTransposefEXT_PACKED *unpacked = (glMatrixLoadTransposefEXT_PACKED *)packed; \
    glMatrixLoadTransposefEXT_ARGS *args = (glMatrixLoadTransposefEXT_ARGS *)&unpacked->args; \
    glMatrixLoadTransposefEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoadTransposefEXT(glMatrixLoadTransposefEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixLoadTransposefEXT(glMatrixLoadTransposefEXT_PACKED *_dst glMatrixLoadTransposefEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixLoadTransposefEXT_PTR)(glMatrixLoadTransposefEXT_ARG_EXPAND);
#endif
#ifndef glMatrixLoaddEXT_RETURN
#define glMatrixLoaddEXT_RETURN void
#define glMatrixLoaddEXT_ARG_NAMES mode, m
#define glMatrixLoaddEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixLoaddEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixLoaddEXT_ARG_EXPAND_TAIL , GLenum mode, const GLdouble * m
#define forward_glMatrixLoaddEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixLoaddEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixLoaddEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixLoaddEXT(packed, ret_v) do { \
    glMatrixLoaddEXT_PACKED *unpacked = (glMatrixLoaddEXT_PACKED *)packed; \
    glMatrixLoaddEXT_ARGS *args = (glMatrixLoaddEXT_ARGS *)&unpacked->args; \
    glMatrixLoaddEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoaddEXT(glMatrixLoaddEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixLoaddEXT(glMatrixLoaddEXT_PACKED *_dst glMatrixLoaddEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixLoaddEXT_PTR)(glMatrixLoaddEXT_ARG_EXPAND);
#endif
#ifndef glMatrixLoadfEXT_RETURN
#define glMatrixLoadfEXT_RETURN void
#define glMatrixLoadfEXT_ARG_NAMES mode, m
#define glMatrixLoadfEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixLoadfEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixLoadfEXT_ARG_EXPAND_TAIL , GLenum mode, const GLfloat * m
#define forward_glMatrixLoadfEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixLoadfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixLoadfEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixLoadfEXT(packed, ret_v) do { \
    glMatrixLoadfEXT_PACKED *unpacked = (glMatrixLoadfEXT_PACKED *)packed; \
    glMatrixLoadfEXT_ARGS *args = (glMatrixLoadfEXT_ARGS *)&unpacked->args; \
    glMatrixLoadfEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoadfEXT(glMatrixLoadfEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixLoadfEXT(glMatrixLoadfEXT_PACKED *_dst glMatrixLoadfEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixLoadfEXT_PTR)(glMatrixLoadfEXT_ARG_EXPAND);
#endif
#ifndef glMatrixMode_RETURN
#define glMatrixMode_RETURN void
#define glMatrixMode_ARG_NAMES mode
#define glMatrixMode_ARG_EXPAND GLenum mode
#define glMatrixMode_ARG_NAMES_TAIL , mode
#define glMatrixMode_ARG_EXPAND_TAIL , GLenum mode
#define forward_glMatrixMode(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixMode_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixMode(dst, _mode), NULL); \
    });
#define call_glMatrixMode(packed, ret_v) do { \
    glMatrixMode_PACKED *unpacked = (glMatrixMode_PACKED *)packed; \
    glMatrixMode_ARGS *args = (glMatrixMode_ARGS *)&unpacked->args; \
    glMatrixMode(args->mode);; \
} while(0)
void glMatrixMode(glMatrixMode_ARG_EXPAND);
packed_call_t *pack_glMatrixMode(glMatrixMode_PACKED *_dst glMatrixMode_ARG_EXPAND_TAIL);
typedef void (*glMatrixMode_PTR)(glMatrixMode_ARG_EXPAND);
#endif
#ifndef glMatrixMultTransposedEXT_RETURN
#define glMatrixMultTransposedEXT_RETURN void
#define glMatrixMultTransposedEXT_ARG_NAMES mode, m
#define glMatrixMultTransposedEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixMultTransposedEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixMultTransposedEXT_ARG_EXPAND_TAIL , GLenum mode, const GLdouble * m
#define forward_glMatrixMultTransposedEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixMultTransposedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixMultTransposedEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixMultTransposedEXT(packed, ret_v) do { \
    glMatrixMultTransposedEXT_PACKED *unpacked = (glMatrixMultTransposedEXT_PACKED *)packed; \
    glMatrixMultTransposedEXT_ARGS *args = (glMatrixMultTransposedEXT_ARGS *)&unpacked->args; \
    glMatrixMultTransposedEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultTransposedEXT(glMatrixMultTransposedEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixMultTransposedEXT(glMatrixMultTransposedEXT_PACKED *_dst glMatrixMultTransposedEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixMultTransposedEXT_PTR)(glMatrixMultTransposedEXT_ARG_EXPAND);
#endif
#ifndef glMatrixMultTransposefEXT_RETURN
#define glMatrixMultTransposefEXT_RETURN void
#define glMatrixMultTransposefEXT_ARG_NAMES mode, m
#define glMatrixMultTransposefEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixMultTransposefEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixMultTransposefEXT_ARG_EXPAND_TAIL , GLenum mode, const GLfloat * m
#define forward_glMatrixMultTransposefEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixMultTransposefEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixMultTransposefEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixMultTransposefEXT(packed, ret_v) do { \
    glMatrixMultTransposefEXT_PACKED *unpacked = (glMatrixMultTransposefEXT_PACKED *)packed; \
    glMatrixMultTransposefEXT_ARGS *args = (glMatrixMultTransposefEXT_ARGS *)&unpacked->args; \
    glMatrixMultTransposefEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultTransposefEXT(glMatrixMultTransposefEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixMultTransposefEXT(glMatrixMultTransposefEXT_PACKED *_dst glMatrixMultTransposefEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixMultTransposefEXT_PTR)(glMatrixMultTransposefEXT_ARG_EXPAND);
#endif
#ifndef glMatrixMultdEXT_RETURN
#define glMatrixMultdEXT_RETURN void
#define glMatrixMultdEXT_ARG_NAMES mode, m
#define glMatrixMultdEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixMultdEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixMultdEXT_ARG_EXPAND_TAIL , GLenum mode, const GLdouble * m
#define forward_glMatrixMultdEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixMultdEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixMultdEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixMultdEXT(packed, ret_v) do { \
    glMatrixMultdEXT_PACKED *unpacked = (glMatrixMultdEXT_PACKED *)packed; \
    glMatrixMultdEXT_ARGS *args = (glMatrixMultdEXT_ARGS *)&unpacked->args; \
    glMatrixMultdEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultdEXT(glMatrixMultdEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixMultdEXT(glMatrixMultdEXT_PACKED *_dst glMatrixMultdEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixMultdEXT_PTR)(glMatrixMultdEXT_ARG_EXPAND);
#endif
#ifndef glMatrixMultfEXT_RETURN
#define glMatrixMultfEXT_RETURN void
#define glMatrixMultfEXT_ARG_NAMES mode, m
#define glMatrixMultfEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixMultfEXT_ARG_NAMES_TAIL , mode, m
#define glMatrixMultfEXT_ARG_EXPAND_TAIL , GLenum mode, const GLfloat * m
#define forward_glMatrixMultfEXT(_mode, _m) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixMultfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixMultfEXT(dst, _mode, _m), NULL); \
    });
#define call_glMatrixMultfEXT(packed, ret_v) do { \
    glMatrixMultfEXT_PACKED *unpacked = (glMatrixMultfEXT_PACKED *)packed; \
    glMatrixMultfEXT_ARGS *args = (glMatrixMultfEXT_ARGS *)&unpacked->args; \
    glMatrixMultfEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultfEXT(glMatrixMultfEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixMultfEXT(glMatrixMultfEXT_PACKED *_dst glMatrixMultfEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixMultfEXT_PTR)(glMatrixMultfEXT_ARG_EXPAND);
#endif
#ifndef glMatrixOrthoEXT_RETURN
#define glMatrixOrthoEXT_RETURN void
#define glMatrixOrthoEXT_ARG_NAMES mode, left, right, bottom, top, zNear, zFar
#define glMatrixOrthoEXT_ARG_EXPAND GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glMatrixOrthoEXT_ARG_NAMES_TAIL , mode, left, right, bottom, top, zNear, zFar
#define glMatrixOrthoEXT_ARG_EXPAND_TAIL , GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define forward_glMatrixOrthoEXT(_mode, _left, _right, _bottom, _top, _zNear, _zFar) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixOrthoEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixOrthoEXT(dst, _mode, _left, _right, _bottom, _top, _zNear, _zFar), NULL); \
    });
#define call_glMatrixOrthoEXT(packed, ret_v) do { \
    glMatrixOrthoEXT_PACKED *unpacked = (glMatrixOrthoEXT_PACKED *)packed; \
    glMatrixOrthoEXT_ARGS *args = (glMatrixOrthoEXT_ARGS *)&unpacked->args; \
    glMatrixOrthoEXT(args->mode, args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glMatrixOrthoEXT(glMatrixOrthoEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixOrthoEXT(glMatrixOrthoEXT_PACKED *_dst glMatrixOrthoEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixOrthoEXT_PTR)(glMatrixOrthoEXT_ARG_EXPAND);
#endif
#ifndef glMatrixPopEXT_RETURN
#define glMatrixPopEXT_RETURN void
#define glMatrixPopEXT_ARG_NAMES mode
#define glMatrixPopEXT_ARG_EXPAND GLenum mode
#define glMatrixPopEXT_ARG_NAMES_TAIL , mode
#define glMatrixPopEXT_ARG_EXPAND_TAIL , GLenum mode
#define forward_glMatrixPopEXT(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixPopEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixPopEXT(dst, _mode), NULL); \
    });
#define call_glMatrixPopEXT(packed, ret_v) do { \
    glMatrixPopEXT_PACKED *unpacked = (glMatrixPopEXT_PACKED *)packed; \
    glMatrixPopEXT_ARGS *args = (glMatrixPopEXT_ARGS *)&unpacked->args; \
    glMatrixPopEXT(args->mode);; \
} while(0)
void glMatrixPopEXT(glMatrixPopEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixPopEXT(glMatrixPopEXT_PACKED *_dst glMatrixPopEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixPopEXT_PTR)(glMatrixPopEXT_ARG_EXPAND);
#endif
#ifndef glMatrixPushEXT_RETURN
#define glMatrixPushEXT_RETURN void
#define glMatrixPushEXT_ARG_NAMES mode
#define glMatrixPushEXT_ARG_EXPAND GLenum mode
#define glMatrixPushEXT_ARG_NAMES_TAIL , mode
#define glMatrixPushEXT_ARG_EXPAND_TAIL , GLenum mode
#define forward_glMatrixPushEXT(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixPushEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixPushEXT(dst, _mode), NULL); \
    });
#define call_glMatrixPushEXT(packed, ret_v) do { \
    glMatrixPushEXT_PACKED *unpacked = (glMatrixPushEXT_PACKED *)packed; \
    glMatrixPushEXT_ARGS *args = (glMatrixPushEXT_ARGS *)&unpacked->args; \
    glMatrixPushEXT(args->mode);; \
} while(0)
void glMatrixPushEXT(glMatrixPushEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixPushEXT(glMatrixPushEXT_PACKED *_dst glMatrixPushEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixPushEXT_PTR)(glMatrixPushEXT_ARG_EXPAND);
#endif
#ifndef glMatrixRotatedEXT_RETURN
#define glMatrixRotatedEXT_RETURN void
#define glMatrixRotatedEXT_ARG_NAMES mode, angle, x, y, z
#define glMatrixRotatedEXT_ARG_EXPAND GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z
#define glMatrixRotatedEXT_ARG_NAMES_TAIL , mode, angle, x, y, z
#define glMatrixRotatedEXT_ARG_EXPAND_TAIL , GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z
#define forward_glMatrixRotatedEXT(_mode, _angle, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixRotatedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixRotatedEXT(dst, _mode, _angle, _x, _y, _z), NULL); \
    });
#define call_glMatrixRotatedEXT(packed, ret_v) do { \
    glMatrixRotatedEXT_PACKED *unpacked = (glMatrixRotatedEXT_PACKED *)packed; \
    glMatrixRotatedEXT_ARGS *args = (glMatrixRotatedEXT_ARGS *)&unpacked->args; \
    glMatrixRotatedEXT(args->mode, args->angle, args->x, args->y, args->z);; \
} while(0)
void glMatrixRotatedEXT(glMatrixRotatedEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixRotatedEXT(glMatrixRotatedEXT_PACKED *_dst glMatrixRotatedEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixRotatedEXT_PTR)(glMatrixRotatedEXT_ARG_EXPAND);
#endif
#ifndef glMatrixRotatefEXT_RETURN
#define glMatrixRotatefEXT_RETURN void
#define glMatrixRotatefEXT_ARG_NAMES mode, angle, x, y, z
#define glMatrixRotatefEXT_ARG_EXPAND GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z
#define glMatrixRotatefEXT_ARG_NAMES_TAIL , mode, angle, x, y, z
#define glMatrixRotatefEXT_ARG_EXPAND_TAIL , GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z
#define forward_glMatrixRotatefEXT(_mode, _angle, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixRotatefEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixRotatefEXT(dst, _mode, _angle, _x, _y, _z), NULL); \
    });
#define call_glMatrixRotatefEXT(packed, ret_v) do { \
    glMatrixRotatefEXT_PACKED *unpacked = (glMatrixRotatefEXT_PACKED *)packed; \
    glMatrixRotatefEXT_ARGS *args = (glMatrixRotatefEXT_ARGS *)&unpacked->args; \
    glMatrixRotatefEXT(args->mode, args->angle, args->x, args->y, args->z);; \
} while(0)
void glMatrixRotatefEXT(glMatrixRotatefEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixRotatefEXT(glMatrixRotatefEXT_PACKED *_dst glMatrixRotatefEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixRotatefEXT_PTR)(glMatrixRotatefEXT_ARG_EXPAND);
#endif
#ifndef glMatrixScaledEXT_RETURN
#define glMatrixScaledEXT_RETURN void
#define glMatrixScaledEXT_ARG_NAMES mode, x, y, z
#define glMatrixScaledEXT_ARG_EXPAND GLenum mode, GLdouble x, GLdouble y, GLdouble z
#define glMatrixScaledEXT_ARG_NAMES_TAIL , mode, x, y, z
#define glMatrixScaledEXT_ARG_EXPAND_TAIL , GLenum mode, GLdouble x, GLdouble y, GLdouble z
#define forward_glMatrixScaledEXT(_mode, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixScaledEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixScaledEXT(dst, _mode, _x, _y, _z), NULL); \
    });
#define call_glMatrixScaledEXT(packed, ret_v) do { \
    glMatrixScaledEXT_PACKED *unpacked = (glMatrixScaledEXT_PACKED *)packed; \
    glMatrixScaledEXT_ARGS *args = (glMatrixScaledEXT_ARGS *)&unpacked->args; \
    glMatrixScaledEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixScaledEXT(glMatrixScaledEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixScaledEXT(glMatrixScaledEXT_PACKED *_dst glMatrixScaledEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixScaledEXT_PTR)(glMatrixScaledEXT_ARG_EXPAND);
#endif
#ifndef glMatrixScalefEXT_RETURN
#define glMatrixScalefEXT_RETURN void
#define glMatrixScalefEXT_ARG_NAMES mode, x, y, z
#define glMatrixScalefEXT_ARG_EXPAND GLenum mode, GLfloat x, GLfloat y, GLfloat z
#define glMatrixScalefEXT_ARG_NAMES_TAIL , mode, x, y, z
#define glMatrixScalefEXT_ARG_EXPAND_TAIL , GLenum mode, GLfloat x, GLfloat y, GLfloat z
#define forward_glMatrixScalefEXT(_mode, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixScalefEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixScalefEXT(dst, _mode, _x, _y, _z), NULL); \
    });
#define call_glMatrixScalefEXT(packed, ret_v) do { \
    glMatrixScalefEXT_PACKED *unpacked = (glMatrixScalefEXT_PACKED *)packed; \
    glMatrixScalefEXT_ARGS *args = (glMatrixScalefEXT_ARGS *)&unpacked->args; \
    glMatrixScalefEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixScalefEXT(glMatrixScalefEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixScalefEXT(glMatrixScalefEXT_PACKED *_dst glMatrixScalefEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixScalefEXT_PTR)(glMatrixScalefEXT_ARG_EXPAND);
#endif
#ifndef glMatrixTranslatedEXT_RETURN
#define glMatrixTranslatedEXT_RETURN void
#define glMatrixTranslatedEXT_ARG_NAMES mode, x, y, z
#define glMatrixTranslatedEXT_ARG_EXPAND GLenum mode, GLdouble x, GLdouble y, GLdouble z
#define glMatrixTranslatedEXT_ARG_NAMES_TAIL , mode, x, y, z
#define glMatrixTranslatedEXT_ARG_EXPAND_TAIL , GLenum mode, GLdouble x, GLdouble y, GLdouble z
#define forward_glMatrixTranslatedEXT(_mode, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixTranslatedEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixTranslatedEXT(dst, _mode, _x, _y, _z), NULL); \
    });
#define call_glMatrixTranslatedEXT(packed, ret_v) do { \
    glMatrixTranslatedEXT_PACKED *unpacked = (glMatrixTranslatedEXT_PACKED *)packed; \
    glMatrixTranslatedEXT_ARGS *args = (glMatrixTranslatedEXT_ARGS *)&unpacked->args; \
    glMatrixTranslatedEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixTranslatedEXT(glMatrixTranslatedEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixTranslatedEXT(glMatrixTranslatedEXT_PACKED *_dst glMatrixTranslatedEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixTranslatedEXT_PTR)(glMatrixTranslatedEXT_ARG_EXPAND);
#endif
#ifndef glMatrixTranslatefEXT_RETURN
#define glMatrixTranslatefEXT_RETURN void
#define glMatrixTranslatefEXT_ARG_NAMES mode, x, y, z
#define glMatrixTranslatefEXT_ARG_EXPAND GLenum mode, GLfloat x, GLfloat y, GLfloat z
#define glMatrixTranslatefEXT_ARG_NAMES_TAIL , mode, x, y, z
#define glMatrixTranslatefEXT_ARG_EXPAND_TAIL , GLenum mode, GLfloat x, GLfloat y, GLfloat z
#define forward_glMatrixTranslatefEXT(_mode, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glMatrixTranslatefEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMatrixTranslatefEXT(dst, _mode, _x, _y, _z), NULL); \
    });
#define call_glMatrixTranslatefEXT(packed, ret_v) do { \
    glMatrixTranslatefEXT_PACKED *unpacked = (glMatrixTranslatefEXT_PACKED *)packed; \
    glMatrixTranslatefEXT_ARGS *args = (glMatrixTranslatefEXT_ARGS *)&unpacked->args; \
    glMatrixTranslatefEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixTranslatefEXT(glMatrixTranslatefEXT_ARG_EXPAND);
packed_call_t *pack_glMatrixTranslatefEXT(glMatrixTranslatefEXT_PACKED *_dst glMatrixTranslatefEXT_ARG_EXPAND_TAIL);
typedef void (*glMatrixTranslatefEXT_PTR)(glMatrixTranslatefEXT_ARG_EXPAND);
#endif
#ifndef glMemoryBarrier_RETURN
#define glMemoryBarrier_RETURN void
#define glMemoryBarrier_ARG_NAMES barriers
#define glMemoryBarrier_ARG_EXPAND GLbitfield barriers
#define glMemoryBarrier_ARG_NAMES_TAIL , barriers
#define glMemoryBarrier_ARG_EXPAND_TAIL , GLbitfield barriers
#define forward_glMemoryBarrier(_barriers) \
    ({ \
        void *dst = remote_dma(sizeof(glMemoryBarrier_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMemoryBarrier(dst, _barriers), NULL); \
    });
#define call_glMemoryBarrier(packed, ret_v) do { \
    glMemoryBarrier_PACKED *unpacked = (glMemoryBarrier_PACKED *)packed; \
    glMemoryBarrier_ARGS *args = (glMemoryBarrier_ARGS *)&unpacked->args; \
    glMemoryBarrier(args->barriers);; \
} while(0)
void glMemoryBarrier(glMemoryBarrier_ARG_EXPAND);
packed_call_t *pack_glMemoryBarrier(glMemoryBarrier_PACKED *_dst glMemoryBarrier_ARG_EXPAND_TAIL);
typedef void (*glMemoryBarrier_PTR)(glMemoryBarrier_ARG_EXPAND);
#endif
#ifndef glMemoryBarrierEXT_RETURN
#define glMemoryBarrierEXT_RETURN void
#define glMemoryBarrierEXT_ARG_NAMES barriers
#define glMemoryBarrierEXT_ARG_EXPAND GLbitfield barriers
#define glMemoryBarrierEXT_ARG_NAMES_TAIL , barriers
#define glMemoryBarrierEXT_ARG_EXPAND_TAIL , GLbitfield barriers
#define forward_glMemoryBarrierEXT(_barriers) \
    ({ \
        void *dst = remote_dma(sizeof(glMemoryBarrierEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMemoryBarrierEXT(dst, _barriers), NULL); \
    });
#define call_glMemoryBarrierEXT(packed, ret_v) do { \
    glMemoryBarrierEXT_PACKED *unpacked = (glMemoryBarrierEXT_PACKED *)packed; \
    glMemoryBarrierEXT_ARGS *args = (glMemoryBarrierEXT_ARGS *)&unpacked->args; \
    glMemoryBarrierEXT(args->barriers);; \
} while(0)
void glMemoryBarrierEXT(glMemoryBarrierEXT_ARG_EXPAND);
packed_call_t *pack_glMemoryBarrierEXT(glMemoryBarrierEXT_PACKED *_dst glMemoryBarrierEXT_ARG_EXPAND_TAIL);
typedef void (*glMemoryBarrierEXT_PTR)(glMemoryBarrierEXT_ARG_EXPAND);
#endif
#ifndef glMinSampleShading_RETURN
#define glMinSampleShading_RETURN void
#define glMinSampleShading_ARG_NAMES value
#define glMinSampleShading_ARG_EXPAND GLfloat value
#define glMinSampleShading_ARG_NAMES_TAIL , value
#define glMinSampleShading_ARG_EXPAND_TAIL , GLfloat value
#define forward_glMinSampleShading(_value) \
    ({ \
        void *dst = remote_dma(sizeof(glMinSampleShading_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMinSampleShading(dst, _value), NULL); \
    });
#define call_glMinSampleShading(packed, ret_v) do { \
    glMinSampleShading_PACKED *unpacked = (glMinSampleShading_PACKED *)packed; \
    glMinSampleShading_ARGS *args = (glMinSampleShading_ARGS *)&unpacked->args; \
    glMinSampleShading(args->value);; \
} while(0)
void glMinSampleShading(glMinSampleShading_ARG_EXPAND);
packed_call_t *pack_glMinSampleShading(glMinSampleShading_PACKED *_dst glMinSampleShading_ARG_EXPAND_TAIL);
typedef void (*glMinSampleShading_PTR)(glMinSampleShading_ARG_EXPAND);
#endif
#ifndef glMinSampleShadingARB_RETURN
#define glMinSampleShadingARB_RETURN void
#define glMinSampleShadingARB_ARG_NAMES value
#define glMinSampleShadingARB_ARG_EXPAND GLfloat value
#define glMinSampleShadingARB_ARG_NAMES_TAIL , value
#define glMinSampleShadingARB_ARG_EXPAND_TAIL , GLfloat value
#define forward_glMinSampleShadingARB(_value) \
    ({ \
        void *dst = remote_dma(sizeof(glMinSampleShadingARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMinSampleShadingARB(dst, _value), NULL); \
    });
#define call_glMinSampleShadingARB(packed, ret_v) do { \
    glMinSampleShadingARB_PACKED *unpacked = (glMinSampleShadingARB_PACKED *)packed; \
    glMinSampleShadingARB_ARGS *args = (glMinSampleShadingARB_ARGS *)&unpacked->args; \
    glMinSampleShadingARB(args->value);; \
} while(0)
void glMinSampleShadingARB(glMinSampleShadingARB_ARG_EXPAND);
packed_call_t *pack_glMinSampleShadingARB(glMinSampleShadingARB_PACKED *_dst glMinSampleShadingARB_ARG_EXPAND_TAIL);
typedef void (*glMinSampleShadingARB_PTR)(glMinSampleShadingARB_ARG_EXPAND);
#endif
#ifndef glMinmax_RETURN
#define glMinmax_RETURN void
#define glMinmax_ARG_NAMES target, internalformat, sink
#define glMinmax_ARG_EXPAND GLenum target, GLenum internalformat, GLboolean sink
#define glMinmax_ARG_NAMES_TAIL , target, internalformat, sink
#define glMinmax_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLboolean sink
#define forward_glMinmax(_target, _internalformat, _sink) \
    ({ \
        void *dst = remote_dma(sizeof(glMinmax_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMinmax(dst, _target, _internalformat, _sink), NULL); \
    });
#define call_glMinmax(packed, ret_v) do { \
    glMinmax_PACKED *unpacked = (glMinmax_PACKED *)packed; \
    glMinmax_ARGS *args = (glMinmax_ARGS *)&unpacked->args; \
    glMinmax(args->target, args->internalformat, args->sink);; \
} while(0)
void glMinmax(glMinmax_ARG_EXPAND);
packed_call_t *pack_glMinmax(glMinmax_PACKED *_dst glMinmax_ARG_EXPAND_TAIL);
typedef void (*glMinmax_PTR)(glMinmax_ARG_EXPAND);
#endif
#ifndef glMinmaxEXT_RETURN
#define glMinmaxEXT_RETURN void
#define glMinmaxEXT_ARG_NAMES target, internalformat, sink
#define glMinmaxEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLboolean sink
#define glMinmaxEXT_ARG_NAMES_TAIL , target, internalformat, sink
#define glMinmaxEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLboolean sink
#define forward_glMinmaxEXT(_target, _internalformat, _sink) \
    ({ \
        void *dst = remote_dma(sizeof(glMinmaxEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMinmaxEXT(dst, _target, _internalformat, _sink), NULL); \
    });
#define call_glMinmaxEXT(packed, ret_v) do { \
    glMinmaxEXT_PACKED *unpacked = (glMinmaxEXT_PACKED *)packed; \
    glMinmaxEXT_ARGS *args = (glMinmaxEXT_ARGS *)&unpacked->args; \
    glMinmaxEXT(args->target, args->internalformat, args->sink);; \
} while(0)
void glMinmaxEXT(glMinmaxEXT_ARG_EXPAND);
packed_call_t *pack_glMinmaxEXT(glMinmaxEXT_PACKED *_dst glMinmaxEXT_ARG_EXPAND_TAIL);
typedef void (*glMinmaxEXT_PTR)(glMinmaxEXT_ARG_EXPAND);
#endif
#ifndef glMultMatrixd_RETURN
#define glMultMatrixd_RETURN void
#define glMultMatrixd_ARG_NAMES m
#define glMultMatrixd_ARG_EXPAND const GLdouble * m
#define glMultMatrixd_ARG_NAMES_TAIL , m
#define glMultMatrixd_ARG_EXPAND_TAIL , const GLdouble * m
#define forward_glMultMatrixd(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultMatrixd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultMatrixd(dst, _m), NULL); \
    });
#define call_glMultMatrixd(packed, ret_v) do { \
    glMultMatrixd_PACKED *unpacked = (glMultMatrixd_PACKED *)packed; \
    glMultMatrixd_ARGS *args = (glMultMatrixd_ARGS *)&unpacked->args; \
    glMultMatrixd(args->m);; \
} while(0)
void glMultMatrixd(glMultMatrixd_ARG_EXPAND);
packed_call_t *pack_glMultMatrixd(glMultMatrixd_PACKED *_dst glMultMatrixd_ARG_EXPAND_TAIL);
typedef void (*glMultMatrixd_PTR)(glMultMatrixd_ARG_EXPAND);
#endif
#ifndef glMultMatrixf_RETURN
#define glMultMatrixf_RETURN void
#define glMultMatrixf_ARG_NAMES m
#define glMultMatrixf_ARG_EXPAND const GLfloat * m
#define glMultMatrixf_ARG_NAMES_TAIL , m
#define glMultMatrixf_ARG_EXPAND_TAIL , const GLfloat * m
#define forward_glMultMatrixf(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultMatrixf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultMatrixf(dst, _m), NULL); \
    });
#define call_glMultMatrixf(packed, ret_v) do { \
    glMultMatrixf_PACKED *unpacked = (glMultMatrixf_PACKED *)packed; \
    glMultMatrixf_ARGS *args = (glMultMatrixf_ARGS *)&unpacked->args; \
    glMultMatrixf(args->m);; \
} while(0)
void glMultMatrixf(glMultMatrixf_ARG_EXPAND);
packed_call_t *pack_glMultMatrixf(glMultMatrixf_PACKED *_dst glMultMatrixf_ARG_EXPAND_TAIL);
typedef void (*glMultMatrixf_PTR)(glMultMatrixf_ARG_EXPAND);
#endif
#ifndef glMultMatrixxOES_RETURN
#define glMultMatrixxOES_RETURN void
#define glMultMatrixxOES_ARG_NAMES m
#define glMultMatrixxOES_ARG_EXPAND const GLfixed * m
#define glMultMatrixxOES_ARG_NAMES_TAIL , m
#define glMultMatrixxOES_ARG_EXPAND_TAIL , const GLfixed * m
#define forward_glMultMatrixxOES(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultMatrixxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultMatrixxOES(dst, _m), NULL); \
    });
#define call_glMultMatrixxOES(packed, ret_v) do { \
    glMultMatrixxOES_PACKED *unpacked = (glMultMatrixxOES_PACKED *)packed; \
    glMultMatrixxOES_ARGS *args = (glMultMatrixxOES_ARGS *)&unpacked->args; \
    glMultMatrixxOES(args->m);; \
} while(0)
void glMultMatrixxOES(glMultMatrixxOES_ARG_EXPAND);
packed_call_t *pack_glMultMatrixxOES(glMultMatrixxOES_PACKED *_dst glMultMatrixxOES_ARG_EXPAND_TAIL);
typedef void (*glMultMatrixxOES_PTR)(glMultMatrixxOES_ARG_EXPAND);
#endif
#ifndef glMultTransposeMatrixd_RETURN
#define glMultTransposeMatrixd_RETURN void
#define glMultTransposeMatrixd_ARG_NAMES m
#define glMultTransposeMatrixd_ARG_EXPAND const GLdouble * m
#define glMultTransposeMatrixd_ARG_NAMES_TAIL , m
#define glMultTransposeMatrixd_ARG_EXPAND_TAIL , const GLdouble * m
#define forward_glMultTransposeMatrixd(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultTransposeMatrixd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultTransposeMatrixd(dst, _m), NULL); \
    });
#define call_glMultTransposeMatrixd(packed, ret_v) do { \
    glMultTransposeMatrixd_PACKED *unpacked = (glMultTransposeMatrixd_PACKED *)packed; \
    glMultTransposeMatrixd_ARGS *args = (glMultTransposeMatrixd_ARGS *)&unpacked->args; \
    glMultTransposeMatrixd(args->m);; \
} while(0)
void glMultTransposeMatrixd(glMultTransposeMatrixd_ARG_EXPAND);
packed_call_t *pack_glMultTransposeMatrixd(glMultTransposeMatrixd_PACKED *_dst glMultTransposeMatrixd_ARG_EXPAND_TAIL);
typedef void (*glMultTransposeMatrixd_PTR)(glMultTransposeMatrixd_ARG_EXPAND);
#endif
#ifndef glMultTransposeMatrixdARB_RETURN
#define glMultTransposeMatrixdARB_RETURN void
#define glMultTransposeMatrixdARB_ARG_NAMES m
#define glMultTransposeMatrixdARB_ARG_EXPAND const GLdouble * m
#define glMultTransposeMatrixdARB_ARG_NAMES_TAIL , m
#define glMultTransposeMatrixdARB_ARG_EXPAND_TAIL , const GLdouble * m
#define forward_glMultTransposeMatrixdARB(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultTransposeMatrixdARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultTransposeMatrixdARB(dst, _m), NULL); \
    });
#define call_glMultTransposeMatrixdARB(packed, ret_v) do { \
    glMultTransposeMatrixdARB_PACKED *unpacked = (glMultTransposeMatrixdARB_PACKED *)packed; \
    glMultTransposeMatrixdARB_ARGS *args = (glMultTransposeMatrixdARB_ARGS *)&unpacked->args; \
    glMultTransposeMatrixdARB(args->m);; \
} while(0)
void glMultTransposeMatrixdARB(glMultTransposeMatrixdARB_ARG_EXPAND);
packed_call_t *pack_glMultTransposeMatrixdARB(glMultTransposeMatrixdARB_PACKED *_dst glMultTransposeMatrixdARB_ARG_EXPAND_TAIL);
typedef void (*glMultTransposeMatrixdARB_PTR)(glMultTransposeMatrixdARB_ARG_EXPAND);
#endif
#ifndef glMultTransposeMatrixf_RETURN
#define glMultTransposeMatrixf_RETURN void
#define glMultTransposeMatrixf_ARG_NAMES m
#define glMultTransposeMatrixf_ARG_EXPAND const GLfloat * m
#define glMultTransposeMatrixf_ARG_NAMES_TAIL , m
#define glMultTransposeMatrixf_ARG_EXPAND_TAIL , const GLfloat * m
#define forward_glMultTransposeMatrixf(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultTransposeMatrixf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultTransposeMatrixf(dst, _m), NULL); \
    });
#define call_glMultTransposeMatrixf(packed, ret_v) do { \
    glMultTransposeMatrixf_PACKED *unpacked = (glMultTransposeMatrixf_PACKED *)packed; \
    glMultTransposeMatrixf_ARGS *args = (glMultTransposeMatrixf_ARGS *)&unpacked->args; \
    glMultTransposeMatrixf(args->m);; \
} while(0)
void glMultTransposeMatrixf(glMultTransposeMatrixf_ARG_EXPAND);
packed_call_t *pack_glMultTransposeMatrixf(glMultTransposeMatrixf_PACKED *_dst glMultTransposeMatrixf_ARG_EXPAND_TAIL);
typedef void (*glMultTransposeMatrixf_PTR)(glMultTransposeMatrixf_ARG_EXPAND);
#endif
#ifndef glMultTransposeMatrixfARB_RETURN
#define glMultTransposeMatrixfARB_RETURN void
#define glMultTransposeMatrixfARB_ARG_NAMES m
#define glMultTransposeMatrixfARB_ARG_EXPAND const GLfloat * m
#define glMultTransposeMatrixfARB_ARG_NAMES_TAIL , m
#define glMultTransposeMatrixfARB_ARG_EXPAND_TAIL , const GLfloat * m
#define forward_glMultTransposeMatrixfARB(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultTransposeMatrixfARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultTransposeMatrixfARB(dst, _m), NULL); \
    });
#define call_glMultTransposeMatrixfARB(packed, ret_v) do { \
    glMultTransposeMatrixfARB_PACKED *unpacked = (glMultTransposeMatrixfARB_PACKED *)packed; \
    glMultTransposeMatrixfARB_ARGS *args = (glMultTransposeMatrixfARB_ARGS *)&unpacked->args; \
    glMultTransposeMatrixfARB(args->m);; \
} while(0)
void glMultTransposeMatrixfARB(glMultTransposeMatrixfARB_ARG_EXPAND);
packed_call_t *pack_glMultTransposeMatrixfARB(glMultTransposeMatrixfARB_PACKED *_dst glMultTransposeMatrixfARB_ARG_EXPAND_TAIL);
typedef void (*glMultTransposeMatrixfARB_PTR)(glMultTransposeMatrixfARB_ARG_EXPAND);
#endif
#ifndef glMultTransposeMatrixxOES_RETURN
#define glMultTransposeMatrixxOES_RETURN void
#define glMultTransposeMatrixxOES_ARG_NAMES m
#define glMultTransposeMatrixxOES_ARG_EXPAND const GLfixed * m
#define glMultTransposeMatrixxOES_ARG_NAMES_TAIL , m
#define glMultTransposeMatrixxOES_ARG_EXPAND_TAIL , const GLfixed * m
#define forward_glMultTransposeMatrixxOES(_m) \
    ({ \
        void *dst = remote_dma(sizeof(glMultTransposeMatrixxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultTransposeMatrixxOES(dst, _m), NULL); \
    });
#define call_glMultTransposeMatrixxOES(packed, ret_v) do { \
    glMultTransposeMatrixxOES_PACKED *unpacked = (glMultTransposeMatrixxOES_PACKED *)packed; \
    glMultTransposeMatrixxOES_ARGS *args = (glMultTransposeMatrixxOES_ARGS *)&unpacked->args; \
    glMultTransposeMatrixxOES(args->m);; \
} while(0)
void glMultTransposeMatrixxOES(glMultTransposeMatrixxOES_ARG_EXPAND);
packed_call_t *pack_glMultTransposeMatrixxOES(glMultTransposeMatrixxOES_PACKED *_dst glMultTransposeMatrixxOES_ARG_EXPAND_TAIL);
typedef void (*glMultTransposeMatrixxOES_PTR)(glMultTransposeMatrixxOES_ARG_EXPAND);
#endif
#ifndef glMultiDrawArrays_RETURN
#define glMultiDrawArrays_RETURN void
#define glMultiDrawArrays_ARG_NAMES mode, first, count, drawcount
#define glMultiDrawArrays_ARG_EXPAND GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount
#define glMultiDrawArrays_ARG_NAMES_TAIL , mode, first, count, drawcount
#define glMultiDrawArrays_ARG_EXPAND_TAIL , GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount
#define forward_glMultiDrawArrays(_mode, _first, _count, _drawcount) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawArrays_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawArrays(dst, _mode, _first, _count, _drawcount), NULL); \
    });
#define call_glMultiDrawArrays(packed, ret_v) do { \
    glMultiDrawArrays_PACKED *unpacked = (glMultiDrawArrays_PACKED *)packed; \
    glMultiDrawArrays_ARGS *args = (glMultiDrawArrays_ARGS *)&unpacked->args; \
    glMultiDrawArrays(args->mode, args->first, args->count, args->drawcount);; \
} while(0)
void glMultiDrawArrays(glMultiDrawArrays_ARG_EXPAND);
packed_call_t *pack_glMultiDrawArrays(glMultiDrawArrays_PACKED *_dst glMultiDrawArrays_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawArrays_PTR)(glMultiDrawArrays_ARG_EXPAND);
#endif
#ifndef glMultiDrawArraysEXT_RETURN
#define glMultiDrawArraysEXT_RETURN void
#define glMultiDrawArraysEXT_ARG_NAMES mode, first, count, primcount
#define glMultiDrawArraysEXT_ARG_EXPAND GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount
#define glMultiDrawArraysEXT_ARG_NAMES_TAIL , mode, first, count, primcount
#define glMultiDrawArraysEXT_ARG_EXPAND_TAIL , GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount
#define forward_glMultiDrawArraysEXT(_mode, _first, _count, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawArraysEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawArraysEXT(dst, _mode, _first, _count, _primcount), NULL); \
    });
#define call_glMultiDrawArraysEXT(packed, ret_v) do { \
    glMultiDrawArraysEXT_PACKED *unpacked = (glMultiDrawArraysEXT_PACKED *)packed; \
    glMultiDrawArraysEXT_ARGS *args = (glMultiDrawArraysEXT_ARGS *)&unpacked->args; \
    glMultiDrawArraysEXT(args->mode, args->first, args->count, args->primcount);; \
} while(0)
void glMultiDrawArraysEXT(glMultiDrawArraysEXT_ARG_EXPAND);
packed_call_t *pack_glMultiDrawArraysEXT(glMultiDrawArraysEXT_PACKED *_dst glMultiDrawArraysEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawArraysEXT_PTR)(glMultiDrawArraysEXT_ARG_EXPAND);
#endif
#ifndef glMultiDrawArraysIndirect_RETURN
#define glMultiDrawArraysIndirect_RETURN void
#define glMultiDrawArraysIndirect_ARG_NAMES mode, indirect, drawcount, stride
#define glMultiDrawArraysIndirect_ARG_EXPAND GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride
#define glMultiDrawArraysIndirect_ARG_NAMES_TAIL , mode, indirect, drawcount, stride
#define glMultiDrawArraysIndirect_ARG_EXPAND_TAIL , GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride
#define forward_glMultiDrawArraysIndirect(_mode, _indirect, _drawcount, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawArraysIndirect_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawArraysIndirect(dst, _mode, _indirect, _drawcount, _stride), NULL); \
    });
#define call_glMultiDrawArraysIndirect(packed, ret_v) do { \
    glMultiDrawArraysIndirect_PACKED *unpacked = (glMultiDrawArraysIndirect_PACKED *)packed; \
    glMultiDrawArraysIndirect_ARGS *args = (glMultiDrawArraysIndirect_ARGS *)&unpacked->args; \
    glMultiDrawArraysIndirect(args->mode, args->indirect, args->drawcount, args->stride);; \
} while(0)
void glMultiDrawArraysIndirect(glMultiDrawArraysIndirect_ARG_EXPAND);
packed_call_t *pack_glMultiDrawArraysIndirect(glMultiDrawArraysIndirect_PACKED *_dst glMultiDrawArraysIndirect_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawArraysIndirect_PTR)(glMultiDrawArraysIndirect_ARG_EXPAND);
#endif
#ifndef glMultiDrawArraysIndirectAMD_RETURN
#define glMultiDrawArraysIndirectAMD_RETURN void
#define glMultiDrawArraysIndirectAMD_ARG_NAMES mode, indirect, primcount, stride
#define glMultiDrawArraysIndirectAMD_ARG_EXPAND GLenum mode, const GLvoid * indirect, GLsizei primcount, GLsizei stride
#define glMultiDrawArraysIndirectAMD_ARG_NAMES_TAIL , mode, indirect, primcount, stride
#define glMultiDrawArraysIndirectAMD_ARG_EXPAND_TAIL , GLenum mode, const GLvoid * indirect, GLsizei primcount, GLsizei stride
#define forward_glMultiDrawArraysIndirectAMD(_mode, _indirect, _primcount, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawArraysIndirectAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawArraysIndirectAMD(dst, _mode, _indirect, _primcount, _stride), NULL); \
    });
#define call_glMultiDrawArraysIndirectAMD(packed, ret_v) do { \
    glMultiDrawArraysIndirectAMD_PACKED *unpacked = (glMultiDrawArraysIndirectAMD_PACKED *)packed; \
    glMultiDrawArraysIndirectAMD_ARGS *args = (glMultiDrawArraysIndirectAMD_ARGS *)&unpacked->args; \
    glMultiDrawArraysIndirectAMD(args->mode, args->indirect, args->primcount, args->stride);; \
} while(0)
void glMultiDrawArraysIndirectAMD(glMultiDrawArraysIndirectAMD_ARG_EXPAND);
packed_call_t *pack_glMultiDrawArraysIndirectAMD(glMultiDrawArraysIndirectAMD_PACKED *_dst glMultiDrawArraysIndirectAMD_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawArraysIndirectAMD_PTR)(glMultiDrawArraysIndirectAMD_ARG_EXPAND);
#endif
#ifndef glMultiDrawElementArrayAPPLE_RETURN
#define glMultiDrawElementArrayAPPLE_RETURN void
#define glMultiDrawElementArrayAPPLE_ARG_NAMES mode, first, count, primcount
#define glMultiDrawElementArrayAPPLE_ARG_EXPAND GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount
#define glMultiDrawElementArrayAPPLE_ARG_NAMES_TAIL , mode, first, count, primcount
#define glMultiDrawElementArrayAPPLE_ARG_EXPAND_TAIL , GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount
#define forward_glMultiDrawElementArrayAPPLE(_mode, _first, _count, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawElementArrayAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawElementArrayAPPLE(dst, _mode, _first, _count, _primcount), NULL); \
    });
#define call_glMultiDrawElementArrayAPPLE(packed, ret_v) do { \
    glMultiDrawElementArrayAPPLE_PACKED *unpacked = (glMultiDrawElementArrayAPPLE_PACKED *)packed; \
    glMultiDrawElementArrayAPPLE_ARGS *args = (glMultiDrawElementArrayAPPLE_ARGS *)&unpacked->args; \
    glMultiDrawElementArrayAPPLE(args->mode, args->first, args->count, args->primcount);; \
} while(0)
void glMultiDrawElementArrayAPPLE(glMultiDrawElementArrayAPPLE_ARG_EXPAND);
packed_call_t *pack_glMultiDrawElementArrayAPPLE(glMultiDrawElementArrayAPPLE_PACKED *_dst glMultiDrawElementArrayAPPLE_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawElementArrayAPPLE_PTR)(glMultiDrawElementArrayAPPLE_ARG_EXPAND);
#endif
#ifndef glMultiDrawElements_RETURN
#define glMultiDrawElements_RETURN void
#define glMultiDrawElements_ARG_NAMES mode, count, type, indices, drawcount
#define glMultiDrawElements_ARG_EXPAND GLenum mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei drawcount
#define glMultiDrawElements_ARG_NAMES_TAIL , mode, count, type, indices, drawcount
#define glMultiDrawElements_ARG_EXPAND_TAIL , GLenum mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei drawcount
#define forward_glMultiDrawElements(_mode, _count, _type, _indices, _drawcount) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawElements_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawElements(dst, _mode, _count, _type, _indices, _drawcount), NULL); \
    });
#define call_glMultiDrawElements(packed, ret_v) do { \
    glMultiDrawElements_PACKED *unpacked = (glMultiDrawElements_PACKED *)packed; \
    glMultiDrawElements_ARGS *args = (glMultiDrawElements_ARGS *)&unpacked->args; \
    glMultiDrawElements(args->mode, args->count, args->type, args->indices, args->drawcount);; \
} while(0)
void glMultiDrawElements(glMultiDrawElements_ARG_EXPAND);
packed_call_t *pack_glMultiDrawElements(glMultiDrawElements_PACKED *_dst glMultiDrawElements_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawElements_PTR)(glMultiDrawElements_ARG_EXPAND);
#endif
#ifndef glMultiDrawElementsBaseVertex_RETURN
#define glMultiDrawElementsBaseVertex_RETURN void
#define glMultiDrawElementsBaseVertex_ARG_NAMES mode, count, type, indices, drawcount, basevertex
#define glMultiDrawElementsBaseVertex_ARG_EXPAND GLenum mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei drawcount, const GLint * basevertex
#define glMultiDrawElementsBaseVertex_ARG_NAMES_TAIL , mode, count, type, indices, drawcount, basevertex
#define glMultiDrawElementsBaseVertex_ARG_EXPAND_TAIL , GLenum mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei drawcount, const GLint * basevertex
#define forward_glMultiDrawElementsBaseVertex(_mode, _count, _type, _indices, _drawcount, _basevertex) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawElementsBaseVertex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawElementsBaseVertex(dst, _mode, _count, _type, _indices, _drawcount, _basevertex), NULL); \
    });
#define call_glMultiDrawElementsBaseVertex(packed, ret_v) do { \
    glMultiDrawElementsBaseVertex_PACKED *unpacked = (glMultiDrawElementsBaseVertex_PACKED *)packed; \
    glMultiDrawElementsBaseVertex_ARGS *args = (glMultiDrawElementsBaseVertex_ARGS *)&unpacked->args; \
    glMultiDrawElementsBaseVertex(args->mode, args->count, args->type, args->indices, args->drawcount, args->basevertex);; \
} while(0)
void glMultiDrawElementsBaseVertex(glMultiDrawElementsBaseVertex_ARG_EXPAND);
packed_call_t *pack_glMultiDrawElementsBaseVertex(glMultiDrawElementsBaseVertex_PACKED *_dst glMultiDrawElementsBaseVertex_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawElementsBaseVertex_PTR)(glMultiDrawElementsBaseVertex_ARG_EXPAND);
#endif
#ifndef glMultiDrawElementsEXT_RETURN
#define glMultiDrawElementsEXT_RETURN void
#define glMultiDrawElementsEXT_ARG_NAMES mode, count, type, indices, primcount
#define glMultiDrawElementsEXT_ARG_EXPAND GLenum mode, const GLsizei * count, GLenum type, const GLvoid * indices, GLsizei primcount
#define glMultiDrawElementsEXT_ARG_NAMES_TAIL , mode, count, type, indices, primcount
#define glMultiDrawElementsEXT_ARG_EXPAND_TAIL , GLenum mode, const GLsizei * count, GLenum type, const GLvoid * indices, GLsizei primcount
#define forward_glMultiDrawElementsEXT(_mode, _count, _type, _indices, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawElementsEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawElementsEXT(dst, _mode, _count, _type, _indices, _primcount), NULL); \
    });
#define call_glMultiDrawElementsEXT(packed, ret_v) do { \
    glMultiDrawElementsEXT_PACKED *unpacked = (glMultiDrawElementsEXT_PACKED *)packed; \
    glMultiDrawElementsEXT_ARGS *args = (glMultiDrawElementsEXT_ARGS *)&unpacked->args; \
    glMultiDrawElementsEXT(args->mode, args->count, args->type, args->indices, args->primcount);; \
} while(0)
void glMultiDrawElementsEXT(glMultiDrawElementsEXT_ARG_EXPAND);
packed_call_t *pack_glMultiDrawElementsEXT(glMultiDrawElementsEXT_PACKED *_dst glMultiDrawElementsEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawElementsEXT_PTR)(glMultiDrawElementsEXT_ARG_EXPAND);
#endif
#ifndef glMultiDrawElementsIndirect_RETURN
#define glMultiDrawElementsIndirect_RETURN void
#define glMultiDrawElementsIndirect_ARG_NAMES mode, type, indirect, drawcount, stride
#define glMultiDrawElementsIndirect_ARG_EXPAND GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride
#define glMultiDrawElementsIndirect_ARG_NAMES_TAIL , mode, type, indirect, drawcount, stride
#define glMultiDrawElementsIndirect_ARG_EXPAND_TAIL , GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride
#define forward_glMultiDrawElementsIndirect(_mode, _type, _indirect, _drawcount, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawElementsIndirect_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawElementsIndirect(dst, _mode, _type, _indirect, _drawcount, _stride), NULL); \
    });
#define call_glMultiDrawElementsIndirect(packed, ret_v) do { \
    glMultiDrawElementsIndirect_PACKED *unpacked = (glMultiDrawElementsIndirect_PACKED *)packed; \
    glMultiDrawElementsIndirect_ARGS *args = (glMultiDrawElementsIndirect_ARGS *)&unpacked->args; \
    glMultiDrawElementsIndirect(args->mode, args->type, args->indirect, args->drawcount, args->stride);; \
} while(0)
void glMultiDrawElementsIndirect(glMultiDrawElementsIndirect_ARG_EXPAND);
packed_call_t *pack_glMultiDrawElementsIndirect(glMultiDrawElementsIndirect_PACKED *_dst glMultiDrawElementsIndirect_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawElementsIndirect_PTR)(glMultiDrawElementsIndirect_ARG_EXPAND);
#endif
#ifndef glMultiDrawElementsIndirectAMD_RETURN
#define glMultiDrawElementsIndirectAMD_RETURN void
#define glMultiDrawElementsIndirectAMD_ARG_NAMES mode, type, indirect, primcount, stride
#define glMultiDrawElementsIndirectAMD_ARG_EXPAND GLenum mode, GLenum type, const GLvoid * indirect, GLsizei primcount, GLsizei stride
#define glMultiDrawElementsIndirectAMD_ARG_NAMES_TAIL , mode, type, indirect, primcount, stride
#define glMultiDrawElementsIndirectAMD_ARG_EXPAND_TAIL , GLenum mode, GLenum type, const GLvoid * indirect, GLsizei primcount, GLsizei stride
#define forward_glMultiDrawElementsIndirectAMD(_mode, _type, _indirect, _primcount, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawElementsIndirectAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawElementsIndirectAMD(dst, _mode, _type, _indirect, _primcount, _stride), NULL); \
    });
#define call_glMultiDrawElementsIndirectAMD(packed, ret_v) do { \
    glMultiDrawElementsIndirectAMD_PACKED *unpacked = (glMultiDrawElementsIndirectAMD_PACKED *)packed; \
    glMultiDrawElementsIndirectAMD_ARGS *args = (glMultiDrawElementsIndirectAMD_ARGS *)&unpacked->args; \
    glMultiDrawElementsIndirectAMD(args->mode, args->type, args->indirect, args->primcount, args->stride);; \
} while(0)
void glMultiDrawElementsIndirectAMD(glMultiDrawElementsIndirectAMD_ARG_EXPAND);
packed_call_t *pack_glMultiDrawElementsIndirectAMD(glMultiDrawElementsIndirectAMD_PACKED *_dst glMultiDrawElementsIndirectAMD_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawElementsIndirectAMD_PTR)(glMultiDrawElementsIndirectAMD_ARG_EXPAND);
#endif
#ifndef glMultiDrawRangeElementArrayAPPLE_RETURN
#define glMultiDrawRangeElementArrayAPPLE_RETURN void
#define glMultiDrawRangeElementArrayAPPLE_ARG_NAMES mode, start, end, first, count, primcount
#define glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount
#define glMultiDrawRangeElementArrayAPPLE_ARG_NAMES_TAIL , mode, start, end, first, count, primcount
#define glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND_TAIL , GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount
#define forward_glMultiDrawRangeElementArrayAPPLE(_mode, _start, _end, _first, _count, _primcount) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiDrawRangeElementArrayAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiDrawRangeElementArrayAPPLE(dst, _mode, _start, _end, _first, _count, _primcount), NULL); \
    });
#define call_glMultiDrawRangeElementArrayAPPLE(packed, ret_v) do { \
    glMultiDrawRangeElementArrayAPPLE_PACKED *unpacked = (glMultiDrawRangeElementArrayAPPLE_PACKED *)packed; \
    glMultiDrawRangeElementArrayAPPLE_ARGS *args = (glMultiDrawRangeElementArrayAPPLE_ARGS *)&unpacked->args; \
    glMultiDrawRangeElementArrayAPPLE(args->mode, args->start, args->end, args->first, args->count, args->primcount);; \
} while(0)
void glMultiDrawRangeElementArrayAPPLE(glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND);
packed_call_t *pack_glMultiDrawRangeElementArrayAPPLE(glMultiDrawRangeElementArrayAPPLE_PACKED *_dst glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND_TAIL);
typedef void (*glMultiDrawRangeElementArrayAPPLE_PTR)(glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND);
#endif
#ifndef glMultiModeDrawArraysIBM_RETURN
#define glMultiModeDrawArraysIBM_RETURN void
#define glMultiModeDrawArraysIBM_ARG_NAMES mode, first, count, primcount, modestride
#define glMultiModeDrawArraysIBM_ARG_EXPAND const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride
#define glMultiModeDrawArraysIBM_ARG_NAMES_TAIL , mode, first, count, primcount, modestride
#define glMultiModeDrawArraysIBM_ARG_EXPAND_TAIL , const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride
#define forward_glMultiModeDrawArraysIBM(_mode, _first, _count, _primcount, _modestride) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiModeDrawArraysIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiModeDrawArraysIBM(dst, _mode, _first, _count, _primcount, _modestride), NULL); \
    });
#define call_glMultiModeDrawArraysIBM(packed, ret_v) do { \
    glMultiModeDrawArraysIBM_PACKED *unpacked = (glMultiModeDrawArraysIBM_PACKED *)packed; \
    glMultiModeDrawArraysIBM_ARGS *args = (glMultiModeDrawArraysIBM_ARGS *)&unpacked->args; \
    glMultiModeDrawArraysIBM(args->mode, args->first, args->count, args->primcount, args->modestride);; \
} while(0)
void glMultiModeDrawArraysIBM(glMultiModeDrawArraysIBM_ARG_EXPAND);
packed_call_t *pack_glMultiModeDrawArraysIBM(glMultiModeDrawArraysIBM_PACKED *_dst glMultiModeDrawArraysIBM_ARG_EXPAND_TAIL);
typedef void (*glMultiModeDrawArraysIBM_PTR)(glMultiModeDrawArraysIBM_ARG_EXPAND);
#endif
#ifndef glMultiModeDrawElementsIBM_RETURN
#define glMultiModeDrawElementsIBM_RETURN void
#define glMultiModeDrawElementsIBM_ARG_NAMES mode, count, type, indices, primcount, modestride
#define glMultiModeDrawElementsIBM_ARG_EXPAND const GLenum * mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei primcount, GLint modestride
#define glMultiModeDrawElementsIBM_ARG_NAMES_TAIL , mode, count, type, indices, primcount, modestride
#define glMultiModeDrawElementsIBM_ARG_EXPAND_TAIL , const GLenum * mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei primcount, GLint modestride
#define forward_glMultiModeDrawElementsIBM(_mode, _count, _type, _indices, _primcount, _modestride) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiModeDrawElementsIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiModeDrawElementsIBM(dst, _mode, _count, _type, _indices, _primcount, _modestride), NULL); \
    });
#define call_glMultiModeDrawElementsIBM(packed, ret_v) do { \
    glMultiModeDrawElementsIBM_PACKED *unpacked = (glMultiModeDrawElementsIBM_PACKED *)packed; \
    glMultiModeDrawElementsIBM_ARGS *args = (glMultiModeDrawElementsIBM_ARGS *)&unpacked->args; \
    glMultiModeDrawElementsIBM(args->mode, args->count, args->type, args->indices, args->primcount, args->modestride);; \
} while(0)
void glMultiModeDrawElementsIBM(glMultiModeDrawElementsIBM_ARG_EXPAND);
packed_call_t *pack_glMultiModeDrawElementsIBM(glMultiModeDrawElementsIBM_PACKED *_dst glMultiModeDrawElementsIBM_ARG_EXPAND_TAIL);
typedef void (*glMultiModeDrawElementsIBM_PTR)(glMultiModeDrawElementsIBM_ARG_EXPAND);
#endif
#ifndef glMultiTexBufferEXT_RETURN
#define glMultiTexBufferEXT_RETURN void
#define glMultiTexBufferEXT_ARG_NAMES texunit, target, internalformat, buffer
#define glMultiTexBufferEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer
#define glMultiTexBufferEXT_ARG_NAMES_TAIL , texunit, target, internalformat, buffer
#define glMultiTexBufferEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer
#define forward_glMultiTexBufferEXT(_texunit, _target, _internalformat, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexBufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexBufferEXT(dst, _texunit, _target, _internalformat, _buffer), NULL); \
    });
#define call_glMultiTexBufferEXT(packed, ret_v) do { \
    glMultiTexBufferEXT_PACKED *unpacked = (glMultiTexBufferEXT_PACKED *)packed; \
    glMultiTexBufferEXT_ARGS *args = (glMultiTexBufferEXT_ARGS *)&unpacked->args; \
    glMultiTexBufferEXT(args->texunit, args->target, args->internalformat, args->buffer);; \
} while(0)
void glMultiTexBufferEXT(glMultiTexBufferEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexBufferEXT(glMultiTexBufferEXT_PACKED *_dst glMultiTexBufferEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexBufferEXT_PTR)(glMultiTexBufferEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1bOES_RETURN
#define glMultiTexCoord1bOES_RETURN void
#define glMultiTexCoord1bOES_ARG_NAMES texture, s
#define glMultiTexCoord1bOES_ARG_EXPAND GLenum texture, GLbyte s
#define glMultiTexCoord1bOES_ARG_NAMES_TAIL , texture, s
#define glMultiTexCoord1bOES_ARG_EXPAND_TAIL , GLenum texture, GLbyte s
#define forward_glMultiTexCoord1bOES(_texture, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1bOES(dst, _texture, _s), NULL); \
    });
#define call_glMultiTexCoord1bOES(packed, ret_v) do { \
    glMultiTexCoord1bOES_PACKED *unpacked = (glMultiTexCoord1bOES_PACKED *)packed; \
    glMultiTexCoord1bOES_ARGS *args = (glMultiTexCoord1bOES_ARGS *)&unpacked->args; \
    glMultiTexCoord1bOES(args->texture, args->s);; \
} while(0)
void glMultiTexCoord1bOES(glMultiTexCoord1bOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1bOES(glMultiTexCoord1bOES_PACKED *_dst glMultiTexCoord1bOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1bOES_PTR)(glMultiTexCoord1bOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1bvOES_RETURN
#define glMultiTexCoord1bvOES_RETURN void
#define glMultiTexCoord1bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord1bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord1bvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord1bvOES_ARG_EXPAND_TAIL , GLenum texture, const GLbyte * coords
#define forward_glMultiTexCoord1bvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1bvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord1bvOES(packed, ret_v) do { \
    glMultiTexCoord1bvOES_PACKED *unpacked = (glMultiTexCoord1bvOES_PACKED *)packed; \
    glMultiTexCoord1bvOES_ARGS *args = (glMultiTexCoord1bvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord1bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord1bvOES(glMultiTexCoord1bvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1bvOES(glMultiTexCoord1bvOES_PACKED *_dst glMultiTexCoord1bvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1bvOES_PTR)(glMultiTexCoord1bvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1d_RETURN
#define glMultiTexCoord1d_RETURN void
#define glMultiTexCoord1d_ARG_NAMES target, s
#define glMultiTexCoord1d_ARG_EXPAND GLenum target, GLdouble s
#define glMultiTexCoord1d_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1d_ARG_EXPAND_TAIL , GLenum target, GLdouble s
#define forward_glMultiTexCoord1d(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1d(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1d(packed, ret_v) do { \
    glMultiTexCoord1d_PACKED *unpacked = (glMultiTexCoord1d_PACKED *)packed; \
    glMultiTexCoord1d_ARGS *args = (glMultiTexCoord1d_ARGS *)&unpacked->args; \
    glMultiTexCoord1d(args->target, args->s);; \
} while(0)
void glMultiTexCoord1d(glMultiTexCoord1d_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1d(glMultiTexCoord1d_PACKED *_dst glMultiTexCoord1d_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1d_PTR)(glMultiTexCoord1d_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1dARB_RETURN
#define glMultiTexCoord1dARB_RETURN void
#define glMultiTexCoord1dARB_ARG_NAMES target, s
#define glMultiTexCoord1dARB_ARG_EXPAND GLenum target, GLdouble s
#define glMultiTexCoord1dARB_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1dARB_ARG_EXPAND_TAIL , GLenum target, GLdouble s
#define forward_glMultiTexCoord1dARB(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1dARB(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1dARB(packed, ret_v) do { \
    glMultiTexCoord1dARB_PACKED *unpacked = (glMultiTexCoord1dARB_PACKED *)packed; \
    glMultiTexCoord1dARB_ARGS *args = (glMultiTexCoord1dARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1dARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1dARB(glMultiTexCoord1dARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1dARB(glMultiTexCoord1dARB_PACKED *_dst glMultiTexCoord1dARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1dARB_PTR)(glMultiTexCoord1dARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1dv_RETURN
#define glMultiTexCoord1dv_RETURN void
#define glMultiTexCoord1dv_ARG_NAMES target, v
#define glMultiTexCoord1dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord1dv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1dv_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord1dv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1dv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1dv(packed, ret_v) do { \
    glMultiTexCoord1dv_PACKED *unpacked = (glMultiTexCoord1dv_PACKED *)packed; \
    glMultiTexCoord1dv_ARGS *args = (glMultiTexCoord1dv_ARGS *)&unpacked->args; \
    glMultiTexCoord1dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1dv(glMultiTexCoord1dv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1dv(glMultiTexCoord1dv_PACKED *_dst glMultiTexCoord1dv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1dv_PTR)(glMultiTexCoord1dv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1dvARB_RETURN
#define glMultiTexCoord1dvARB_RETURN void
#define glMultiTexCoord1dvARB_ARG_NAMES target, v
#define glMultiTexCoord1dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord1dvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1dvARB_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord1dvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1dvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1dvARB(packed, ret_v) do { \
    glMultiTexCoord1dvARB_PACKED *unpacked = (glMultiTexCoord1dvARB_PACKED *)packed; \
    glMultiTexCoord1dvARB_ARGS *args = (glMultiTexCoord1dvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1dvARB(glMultiTexCoord1dvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1dvARB(glMultiTexCoord1dvARB_PACKED *_dst glMultiTexCoord1dvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1dvARB_PTR)(glMultiTexCoord1dvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1f_RETURN
#define glMultiTexCoord1f_RETURN void
#define glMultiTexCoord1f_ARG_NAMES target, s
#define glMultiTexCoord1f_ARG_EXPAND GLenum target, GLfloat s
#define glMultiTexCoord1f_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1f_ARG_EXPAND_TAIL , GLenum target, GLfloat s
#define forward_glMultiTexCoord1f(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1f(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1f(packed, ret_v) do { \
    glMultiTexCoord1f_PACKED *unpacked = (glMultiTexCoord1f_PACKED *)packed; \
    glMultiTexCoord1f_ARGS *args = (glMultiTexCoord1f_ARGS *)&unpacked->args; \
    glMultiTexCoord1f(args->target, args->s);; \
} while(0)
void glMultiTexCoord1f(glMultiTexCoord1f_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1f(glMultiTexCoord1f_PACKED *_dst glMultiTexCoord1f_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1f_PTR)(glMultiTexCoord1f_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1fARB_RETURN
#define glMultiTexCoord1fARB_RETURN void
#define glMultiTexCoord1fARB_ARG_NAMES target, s
#define glMultiTexCoord1fARB_ARG_EXPAND GLenum target, GLfloat s
#define glMultiTexCoord1fARB_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1fARB_ARG_EXPAND_TAIL , GLenum target, GLfloat s
#define forward_glMultiTexCoord1fARB(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1fARB(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1fARB(packed, ret_v) do { \
    glMultiTexCoord1fARB_PACKED *unpacked = (glMultiTexCoord1fARB_PACKED *)packed; \
    glMultiTexCoord1fARB_ARGS *args = (glMultiTexCoord1fARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1fARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1fARB(glMultiTexCoord1fARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1fARB(glMultiTexCoord1fARB_PACKED *_dst glMultiTexCoord1fARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1fARB_PTR)(glMultiTexCoord1fARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1fv_RETURN
#define glMultiTexCoord1fv_RETURN void
#define glMultiTexCoord1fv_ARG_NAMES target, v
#define glMultiTexCoord1fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord1fv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1fv_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord1fv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1fv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1fv(packed, ret_v) do { \
    glMultiTexCoord1fv_PACKED *unpacked = (glMultiTexCoord1fv_PACKED *)packed; \
    glMultiTexCoord1fv_ARGS *args = (glMultiTexCoord1fv_ARGS *)&unpacked->args; \
    glMultiTexCoord1fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1fv(glMultiTexCoord1fv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1fv(glMultiTexCoord1fv_PACKED *_dst glMultiTexCoord1fv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1fv_PTR)(glMultiTexCoord1fv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1fvARB_RETURN
#define glMultiTexCoord1fvARB_RETURN void
#define glMultiTexCoord1fvARB_ARG_NAMES target, v
#define glMultiTexCoord1fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord1fvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1fvARB_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord1fvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1fvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1fvARB(packed, ret_v) do { \
    glMultiTexCoord1fvARB_PACKED *unpacked = (glMultiTexCoord1fvARB_PACKED *)packed; \
    glMultiTexCoord1fvARB_ARGS *args = (glMultiTexCoord1fvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1fvARB(glMultiTexCoord1fvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1fvARB(glMultiTexCoord1fvARB_PACKED *_dst glMultiTexCoord1fvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1fvARB_PTR)(glMultiTexCoord1fvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1hNV_RETURN
#define glMultiTexCoord1hNV_RETURN void
#define glMultiTexCoord1hNV_ARG_NAMES target, s
#define glMultiTexCoord1hNV_ARG_EXPAND GLenum target, GLhalfNV s
#define glMultiTexCoord1hNV_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1hNV_ARG_EXPAND_TAIL , GLenum target, GLhalfNV s
#define forward_glMultiTexCoord1hNV(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1hNV(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1hNV(packed, ret_v) do { \
    glMultiTexCoord1hNV_PACKED *unpacked = (glMultiTexCoord1hNV_PACKED *)packed; \
    glMultiTexCoord1hNV_ARGS *args = (glMultiTexCoord1hNV_ARGS *)&unpacked->args; \
    glMultiTexCoord1hNV(args->target, args->s);; \
} while(0)
void glMultiTexCoord1hNV(glMultiTexCoord1hNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1hNV(glMultiTexCoord1hNV_PACKED *_dst glMultiTexCoord1hNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1hNV_PTR)(glMultiTexCoord1hNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1hvNV_RETURN
#define glMultiTexCoord1hvNV_RETURN void
#define glMultiTexCoord1hvNV_ARG_NAMES target, v
#define glMultiTexCoord1hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord1hvNV_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1hvNV_ARG_EXPAND_TAIL , GLenum target, const GLhalfNV * v
#define forward_glMultiTexCoord1hvNV(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1hvNV(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1hvNV(packed, ret_v) do { \
    glMultiTexCoord1hvNV_PACKED *unpacked = (glMultiTexCoord1hvNV_PACKED *)packed; \
    glMultiTexCoord1hvNV_ARGS *args = (glMultiTexCoord1hvNV_ARGS *)&unpacked->args; \
    glMultiTexCoord1hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord1hvNV(glMultiTexCoord1hvNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1hvNV(glMultiTexCoord1hvNV_PACKED *_dst glMultiTexCoord1hvNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1hvNV_PTR)(glMultiTexCoord1hvNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1i_RETURN
#define glMultiTexCoord1i_RETURN void
#define glMultiTexCoord1i_ARG_NAMES target, s
#define glMultiTexCoord1i_ARG_EXPAND GLenum target, GLint s
#define glMultiTexCoord1i_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1i_ARG_EXPAND_TAIL , GLenum target, GLint s
#define forward_glMultiTexCoord1i(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1i(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1i(packed, ret_v) do { \
    glMultiTexCoord1i_PACKED *unpacked = (glMultiTexCoord1i_PACKED *)packed; \
    glMultiTexCoord1i_ARGS *args = (glMultiTexCoord1i_ARGS *)&unpacked->args; \
    glMultiTexCoord1i(args->target, args->s);; \
} while(0)
void glMultiTexCoord1i(glMultiTexCoord1i_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1i(glMultiTexCoord1i_PACKED *_dst glMultiTexCoord1i_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1i_PTR)(glMultiTexCoord1i_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1iARB_RETURN
#define glMultiTexCoord1iARB_RETURN void
#define glMultiTexCoord1iARB_ARG_NAMES target, s
#define glMultiTexCoord1iARB_ARG_EXPAND GLenum target, GLint s
#define glMultiTexCoord1iARB_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1iARB_ARG_EXPAND_TAIL , GLenum target, GLint s
#define forward_glMultiTexCoord1iARB(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1iARB(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1iARB(packed, ret_v) do { \
    glMultiTexCoord1iARB_PACKED *unpacked = (glMultiTexCoord1iARB_PACKED *)packed; \
    glMultiTexCoord1iARB_ARGS *args = (glMultiTexCoord1iARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1iARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1iARB(glMultiTexCoord1iARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1iARB(glMultiTexCoord1iARB_PACKED *_dst glMultiTexCoord1iARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1iARB_PTR)(glMultiTexCoord1iARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1iv_RETURN
#define glMultiTexCoord1iv_RETURN void
#define glMultiTexCoord1iv_ARG_NAMES target, v
#define glMultiTexCoord1iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord1iv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1iv_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord1iv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1iv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1iv(packed, ret_v) do { \
    glMultiTexCoord1iv_PACKED *unpacked = (glMultiTexCoord1iv_PACKED *)packed; \
    glMultiTexCoord1iv_ARGS *args = (glMultiTexCoord1iv_ARGS *)&unpacked->args; \
    glMultiTexCoord1iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1iv(glMultiTexCoord1iv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1iv(glMultiTexCoord1iv_PACKED *_dst glMultiTexCoord1iv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1iv_PTR)(glMultiTexCoord1iv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1ivARB_RETURN
#define glMultiTexCoord1ivARB_RETURN void
#define glMultiTexCoord1ivARB_ARG_NAMES target, v
#define glMultiTexCoord1ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord1ivARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1ivARB_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord1ivARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1ivARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1ivARB(packed, ret_v) do { \
    glMultiTexCoord1ivARB_PACKED *unpacked = (glMultiTexCoord1ivARB_PACKED *)packed; \
    glMultiTexCoord1ivARB_ARGS *args = (glMultiTexCoord1ivARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1ivARB(glMultiTexCoord1ivARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1ivARB(glMultiTexCoord1ivARB_PACKED *_dst glMultiTexCoord1ivARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1ivARB_PTR)(glMultiTexCoord1ivARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1s_RETURN
#define glMultiTexCoord1s_RETURN void
#define glMultiTexCoord1s_ARG_NAMES target, s
#define glMultiTexCoord1s_ARG_EXPAND GLenum target, GLshort s
#define glMultiTexCoord1s_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1s_ARG_EXPAND_TAIL , GLenum target, GLshort s
#define forward_glMultiTexCoord1s(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1s(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1s(packed, ret_v) do { \
    glMultiTexCoord1s_PACKED *unpacked = (glMultiTexCoord1s_PACKED *)packed; \
    glMultiTexCoord1s_ARGS *args = (glMultiTexCoord1s_ARGS *)&unpacked->args; \
    glMultiTexCoord1s(args->target, args->s);; \
} while(0)
void glMultiTexCoord1s(glMultiTexCoord1s_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1s(glMultiTexCoord1s_PACKED *_dst glMultiTexCoord1s_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1s_PTR)(glMultiTexCoord1s_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1sARB_RETURN
#define glMultiTexCoord1sARB_RETURN void
#define glMultiTexCoord1sARB_ARG_NAMES target, s
#define glMultiTexCoord1sARB_ARG_EXPAND GLenum target, GLshort s
#define glMultiTexCoord1sARB_ARG_NAMES_TAIL , target, s
#define glMultiTexCoord1sARB_ARG_EXPAND_TAIL , GLenum target, GLshort s
#define forward_glMultiTexCoord1sARB(_target, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1sARB(dst, _target, _s), NULL); \
    });
#define call_glMultiTexCoord1sARB(packed, ret_v) do { \
    glMultiTexCoord1sARB_PACKED *unpacked = (glMultiTexCoord1sARB_PACKED *)packed; \
    glMultiTexCoord1sARB_ARGS *args = (glMultiTexCoord1sARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1sARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1sARB(glMultiTexCoord1sARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1sARB(glMultiTexCoord1sARB_PACKED *_dst glMultiTexCoord1sARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1sARB_PTR)(glMultiTexCoord1sARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1sv_RETURN
#define glMultiTexCoord1sv_RETURN void
#define glMultiTexCoord1sv_ARG_NAMES target, v
#define glMultiTexCoord1sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord1sv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1sv_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord1sv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1sv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1sv(packed, ret_v) do { \
    glMultiTexCoord1sv_PACKED *unpacked = (glMultiTexCoord1sv_PACKED *)packed; \
    glMultiTexCoord1sv_ARGS *args = (glMultiTexCoord1sv_ARGS *)&unpacked->args; \
    glMultiTexCoord1sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1sv(glMultiTexCoord1sv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1sv(glMultiTexCoord1sv_PACKED *_dst glMultiTexCoord1sv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1sv_PTR)(glMultiTexCoord1sv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1svARB_RETURN
#define glMultiTexCoord1svARB_RETURN void
#define glMultiTexCoord1svARB_ARG_NAMES target, v
#define glMultiTexCoord1svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord1svARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord1svARB_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord1svARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1svARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord1svARB(packed, ret_v) do { \
    glMultiTexCoord1svARB_PACKED *unpacked = (glMultiTexCoord1svARB_PACKED *)packed; \
    glMultiTexCoord1svARB_ARGS *args = (glMultiTexCoord1svARB_ARGS *)&unpacked->args; \
    glMultiTexCoord1svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1svARB(glMultiTexCoord1svARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1svARB(glMultiTexCoord1svARB_PACKED *_dst glMultiTexCoord1svARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1svARB_PTR)(glMultiTexCoord1svARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1xOES_RETURN
#define glMultiTexCoord1xOES_RETURN void
#define glMultiTexCoord1xOES_ARG_NAMES texture, s
#define glMultiTexCoord1xOES_ARG_EXPAND GLenum texture, GLfixed s
#define glMultiTexCoord1xOES_ARG_NAMES_TAIL , texture, s
#define glMultiTexCoord1xOES_ARG_EXPAND_TAIL , GLenum texture, GLfixed s
#define forward_glMultiTexCoord1xOES(_texture, _s) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1xOES(dst, _texture, _s), NULL); \
    });
#define call_glMultiTexCoord1xOES(packed, ret_v) do { \
    glMultiTexCoord1xOES_PACKED *unpacked = (glMultiTexCoord1xOES_PACKED *)packed; \
    glMultiTexCoord1xOES_ARGS *args = (glMultiTexCoord1xOES_ARGS *)&unpacked->args; \
    glMultiTexCoord1xOES(args->texture, args->s);; \
} while(0)
void glMultiTexCoord1xOES(glMultiTexCoord1xOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1xOES(glMultiTexCoord1xOES_PACKED *_dst glMultiTexCoord1xOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1xOES_PTR)(glMultiTexCoord1xOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord1xvOES_RETURN
#define glMultiTexCoord1xvOES_RETURN void
#define glMultiTexCoord1xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord1xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord1xvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord1xvOES_ARG_EXPAND_TAIL , GLenum texture, const GLfixed * coords
#define forward_glMultiTexCoord1xvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord1xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord1xvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord1xvOES(packed, ret_v) do { \
    glMultiTexCoord1xvOES_PACKED *unpacked = (glMultiTexCoord1xvOES_PACKED *)packed; \
    glMultiTexCoord1xvOES_ARGS *args = (glMultiTexCoord1xvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord1xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord1xvOES(glMultiTexCoord1xvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord1xvOES(glMultiTexCoord1xvOES_PACKED *_dst glMultiTexCoord1xvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord1xvOES_PTR)(glMultiTexCoord1xvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2bOES_RETURN
#define glMultiTexCoord2bOES_RETURN void
#define glMultiTexCoord2bOES_ARG_NAMES texture, s, t
#define glMultiTexCoord2bOES_ARG_EXPAND GLenum texture, GLbyte s, GLbyte t
#define glMultiTexCoord2bOES_ARG_NAMES_TAIL , texture, s, t
#define glMultiTexCoord2bOES_ARG_EXPAND_TAIL , GLenum texture, GLbyte s, GLbyte t
#define forward_glMultiTexCoord2bOES(_texture, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2bOES(dst, _texture, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2bOES(packed, ret_v) do { \
    glMultiTexCoord2bOES_PACKED *unpacked = (glMultiTexCoord2bOES_PACKED *)packed; \
    glMultiTexCoord2bOES_ARGS *args = (glMultiTexCoord2bOES_ARGS *)&unpacked->args; \
    glMultiTexCoord2bOES(args->texture, args->s, args->t);; \
} while(0)
void glMultiTexCoord2bOES(glMultiTexCoord2bOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2bOES(glMultiTexCoord2bOES_PACKED *_dst glMultiTexCoord2bOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2bOES_PTR)(glMultiTexCoord2bOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2bvOES_RETURN
#define glMultiTexCoord2bvOES_RETURN void
#define glMultiTexCoord2bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord2bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord2bvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord2bvOES_ARG_EXPAND_TAIL , GLenum texture, const GLbyte * coords
#define forward_glMultiTexCoord2bvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2bvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord2bvOES(packed, ret_v) do { \
    glMultiTexCoord2bvOES_PACKED *unpacked = (glMultiTexCoord2bvOES_PACKED *)packed; \
    glMultiTexCoord2bvOES_ARGS *args = (glMultiTexCoord2bvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord2bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord2bvOES(glMultiTexCoord2bvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2bvOES(glMultiTexCoord2bvOES_PACKED *_dst glMultiTexCoord2bvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2bvOES_PTR)(glMultiTexCoord2bvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2d_RETURN
#define glMultiTexCoord2d_RETURN void
#define glMultiTexCoord2d_ARG_NAMES target, s, t
#define glMultiTexCoord2d_ARG_EXPAND GLenum target, GLdouble s, GLdouble t
#define glMultiTexCoord2d_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2d_ARG_EXPAND_TAIL , GLenum target, GLdouble s, GLdouble t
#define forward_glMultiTexCoord2d(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2d(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2d(packed, ret_v) do { \
    glMultiTexCoord2d_PACKED *unpacked = (glMultiTexCoord2d_PACKED *)packed; \
    glMultiTexCoord2d_ARGS *args = (glMultiTexCoord2d_ARGS *)&unpacked->args; \
    glMultiTexCoord2d(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2d(glMultiTexCoord2d_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2d(glMultiTexCoord2d_PACKED *_dst glMultiTexCoord2d_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2d_PTR)(glMultiTexCoord2d_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2dARB_RETURN
#define glMultiTexCoord2dARB_RETURN void
#define glMultiTexCoord2dARB_ARG_NAMES target, s, t
#define glMultiTexCoord2dARB_ARG_EXPAND GLenum target, GLdouble s, GLdouble t
#define glMultiTexCoord2dARB_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2dARB_ARG_EXPAND_TAIL , GLenum target, GLdouble s, GLdouble t
#define forward_glMultiTexCoord2dARB(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2dARB(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2dARB(packed, ret_v) do { \
    glMultiTexCoord2dARB_PACKED *unpacked = (glMultiTexCoord2dARB_PACKED *)packed; \
    glMultiTexCoord2dARB_ARGS *args = (glMultiTexCoord2dARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2dARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2dARB(glMultiTexCoord2dARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2dARB(glMultiTexCoord2dARB_PACKED *_dst glMultiTexCoord2dARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2dARB_PTR)(glMultiTexCoord2dARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2dv_RETURN
#define glMultiTexCoord2dv_RETURN void
#define glMultiTexCoord2dv_ARG_NAMES target, v
#define glMultiTexCoord2dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord2dv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2dv_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord2dv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2dv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2dv(packed, ret_v) do { \
    glMultiTexCoord2dv_PACKED *unpacked = (glMultiTexCoord2dv_PACKED *)packed; \
    glMultiTexCoord2dv_ARGS *args = (glMultiTexCoord2dv_ARGS *)&unpacked->args; \
    glMultiTexCoord2dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2dv(glMultiTexCoord2dv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2dv(glMultiTexCoord2dv_PACKED *_dst glMultiTexCoord2dv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2dv_PTR)(glMultiTexCoord2dv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2dvARB_RETURN
#define glMultiTexCoord2dvARB_RETURN void
#define glMultiTexCoord2dvARB_ARG_NAMES target, v
#define glMultiTexCoord2dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord2dvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2dvARB_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord2dvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2dvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2dvARB(packed, ret_v) do { \
    glMultiTexCoord2dvARB_PACKED *unpacked = (glMultiTexCoord2dvARB_PACKED *)packed; \
    glMultiTexCoord2dvARB_ARGS *args = (glMultiTexCoord2dvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2dvARB(glMultiTexCoord2dvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2dvARB(glMultiTexCoord2dvARB_PACKED *_dst glMultiTexCoord2dvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2dvARB_PTR)(glMultiTexCoord2dvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2f_RETURN
#define glMultiTexCoord2f_RETURN void
#define glMultiTexCoord2f_ARG_NAMES target, s, t
#define glMultiTexCoord2f_ARG_EXPAND GLenum target, GLfloat s, GLfloat t
#define glMultiTexCoord2f_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2f_ARG_EXPAND_TAIL , GLenum target, GLfloat s, GLfloat t
#define forward_glMultiTexCoord2f(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2f(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2f(packed, ret_v) do { \
    glMultiTexCoord2f_PACKED *unpacked = (glMultiTexCoord2f_PACKED *)packed; \
    glMultiTexCoord2f_ARGS *args = (glMultiTexCoord2f_ARGS *)&unpacked->args; \
    glMultiTexCoord2f(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2f(glMultiTexCoord2f_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2f(glMultiTexCoord2f_PACKED *_dst glMultiTexCoord2f_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2f_PTR)(glMultiTexCoord2f_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2fARB_RETURN
#define glMultiTexCoord2fARB_RETURN void
#define glMultiTexCoord2fARB_ARG_NAMES target, s, t
#define glMultiTexCoord2fARB_ARG_EXPAND GLenum target, GLfloat s, GLfloat t
#define glMultiTexCoord2fARB_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2fARB_ARG_EXPAND_TAIL , GLenum target, GLfloat s, GLfloat t
#define forward_glMultiTexCoord2fARB(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2fARB(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2fARB(packed, ret_v) do { \
    glMultiTexCoord2fARB_PACKED *unpacked = (glMultiTexCoord2fARB_PACKED *)packed; \
    glMultiTexCoord2fARB_ARGS *args = (glMultiTexCoord2fARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2fARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2fARB(glMultiTexCoord2fARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2fARB(glMultiTexCoord2fARB_PACKED *_dst glMultiTexCoord2fARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2fARB_PTR)(glMultiTexCoord2fARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2fv_RETURN
#define glMultiTexCoord2fv_RETURN void
#define glMultiTexCoord2fv_ARG_NAMES target, v
#define glMultiTexCoord2fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord2fv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2fv_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord2fv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2fv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2fv(packed, ret_v) do { \
    glMultiTexCoord2fv_PACKED *unpacked = (glMultiTexCoord2fv_PACKED *)packed; \
    glMultiTexCoord2fv_ARGS *args = (glMultiTexCoord2fv_ARGS *)&unpacked->args; \
    glMultiTexCoord2fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2fv(glMultiTexCoord2fv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2fv(glMultiTexCoord2fv_PACKED *_dst glMultiTexCoord2fv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2fv_PTR)(glMultiTexCoord2fv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2fvARB_RETURN
#define glMultiTexCoord2fvARB_RETURN void
#define glMultiTexCoord2fvARB_ARG_NAMES target, v
#define glMultiTexCoord2fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord2fvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2fvARB_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord2fvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2fvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2fvARB(packed, ret_v) do { \
    glMultiTexCoord2fvARB_PACKED *unpacked = (glMultiTexCoord2fvARB_PACKED *)packed; \
    glMultiTexCoord2fvARB_ARGS *args = (glMultiTexCoord2fvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2fvARB(glMultiTexCoord2fvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2fvARB(glMultiTexCoord2fvARB_PACKED *_dst glMultiTexCoord2fvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2fvARB_PTR)(glMultiTexCoord2fvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2hNV_RETURN
#define glMultiTexCoord2hNV_RETURN void
#define glMultiTexCoord2hNV_ARG_NAMES target, s, t
#define glMultiTexCoord2hNV_ARG_EXPAND GLenum target, GLhalfNV s, GLhalfNV t
#define glMultiTexCoord2hNV_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2hNV_ARG_EXPAND_TAIL , GLenum target, GLhalfNV s, GLhalfNV t
#define forward_glMultiTexCoord2hNV(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2hNV(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2hNV(packed, ret_v) do { \
    glMultiTexCoord2hNV_PACKED *unpacked = (glMultiTexCoord2hNV_PACKED *)packed; \
    glMultiTexCoord2hNV_ARGS *args = (glMultiTexCoord2hNV_ARGS *)&unpacked->args; \
    glMultiTexCoord2hNV(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2hNV(glMultiTexCoord2hNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2hNV(glMultiTexCoord2hNV_PACKED *_dst glMultiTexCoord2hNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2hNV_PTR)(glMultiTexCoord2hNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2hvNV_RETURN
#define glMultiTexCoord2hvNV_RETURN void
#define glMultiTexCoord2hvNV_ARG_NAMES target, v
#define glMultiTexCoord2hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord2hvNV_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2hvNV_ARG_EXPAND_TAIL , GLenum target, const GLhalfNV * v
#define forward_glMultiTexCoord2hvNV(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2hvNV(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2hvNV(packed, ret_v) do { \
    glMultiTexCoord2hvNV_PACKED *unpacked = (glMultiTexCoord2hvNV_PACKED *)packed; \
    glMultiTexCoord2hvNV_ARGS *args = (glMultiTexCoord2hvNV_ARGS *)&unpacked->args; \
    glMultiTexCoord2hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord2hvNV(glMultiTexCoord2hvNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2hvNV(glMultiTexCoord2hvNV_PACKED *_dst glMultiTexCoord2hvNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2hvNV_PTR)(glMultiTexCoord2hvNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2i_RETURN
#define glMultiTexCoord2i_RETURN void
#define glMultiTexCoord2i_ARG_NAMES target, s, t
#define glMultiTexCoord2i_ARG_EXPAND GLenum target, GLint s, GLint t
#define glMultiTexCoord2i_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2i_ARG_EXPAND_TAIL , GLenum target, GLint s, GLint t
#define forward_glMultiTexCoord2i(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2i(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2i(packed, ret_v) do { \
    glMultiTexCoord2i_PACKED *unpacked = (glMultiTexCoord2i_PACKED *)packed; \
    glMultiTexCoord2i_ARGS *args = (glMultiTexCoord2i_ARGS *)&unpacked->args; \
    glMultiTexCoord2i(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2i(glMultiTexCoord2i_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2i(glMultiTexCoord2i_PACKED *_dst glMultiTexCoord2i_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2i_PTR)(glMultiTexCoord2i_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2iARB_RETURN
#define glMultiTexCoord2iARB_RETURN void
#define glMultiTexCoord2iARB_ARG_NAMES target, s, t
#define glMultiTexCoord2iARB_ARG_EXPAND GLenum target, GLint s, GLint t
#define glMultiTexCoord2iARB_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2iARB_ARG_EXPAND_TAIL , GLenum target, GLint s, GLint t
#define forward_glMultiTexCoord2iARB(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2iARB(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2iARB(packed, ret_v) do { \
    glMultiTexCoord2iARB_PACKED *unpacked = (glMultiTexCoord2iARB_PACKED *)packed; \
    glMultiTexCoord2iARB_ARGS *args = (glMultiTexCoord2iARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2iARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2iARB(glMultiTexCoord2iARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2iARB(glMultiTexCoord2iARB_PACKED *_dst glMultiTexCoord2iARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2iARB_PTR)(glMultiTexCoord2iARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2iv_RETURN
#define glMultiTexCoord2iv_RETURN void
#define glMultiTexCoord2iv_ARG_NAMES target, v
#define glMultiTexCoord2iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord2iv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2iv_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord2iv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2iv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2iv(packed, ret_v) do { \
    glMultiTexCoord2iv_PACKED *unpacked = (glMultiTexCoord2iv_PACKED *)packed; \
    glMultiTexCoord2iv_ARGS *args = (glMultiTexCoord2iv_ARGS *)&unpacked->args; \
    glMultiTexCoord2iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2iv(glMultiTexCoord2iv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2iv(glMultiTexCoord2iv_PACKED *_dst glMultiTexCoord2iv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2iv_PTR)(glMultiTexCoord2iv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2ivARB_RETURN
#define glMultiTexCoord2ivARB_RETURN void
#define glMultiTexCoord2ivARB_ARG_NAMES target, v
#define glMultiTexCoord2ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord2ivARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2ivARB_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord2ivARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2ivARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2ivARB(packed, ret_v) do { \
    glMultiTexCoord2ivARB_PACKED *unpacked = (glMultiTexCoord2ivARB_PACKED *)packed; \
    glMultiTexCoord2ivARB_ARGS *args = (glMultiTexCoord2ivARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2ivARB(glMultiTexCoord2ivARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2ivARB(glMultiTexCoord2ivARB_PACKED *_dst glMultiTexCoord2ivARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2ivARB_PTR)(glMultiTexCoord2ivARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2s_RETURN
#define glMultiTexCoord2s_RETURN void
#define glMultiTexCoord2s_ARG_NAMES target, s, t
#define glMultiTexCoord2s_ARG_EXPAND GLenum target, GLshort s, GLshort t
#define glMultiTexCoord2s_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2s_ARG_EXPAND_TAIL , GLenum target, GLshort s, GLshort t
#define forward_glMultiTexCoord2s(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2s(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2s(packed, ret_v) do { \
    glMultiTexCoord2s_PACKED *unpacked = (glMultiTexCoord2s_PACKED *)packed; \
    glMultiTexCoord2s_ARGS *args = (glMultiTexCoord2s_ARGS *)&unpacked->args; \
    glMultiTexCoord2s(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2s(glMultiTexCoord2s_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2s(glMultiTexCoord2s_PACKED *_dst glMultiTexCoord2s_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2s_PTR)(glMultiTexCoord2s_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2sARB_RETURN
#define glMultiTexCoord2sARB_RETURN void
#define glMultiTexCoord2sARB_ARG_NAMES target, s, t
#define glMultiTexCoord2sARB_ARG_EXPAND GLenum target, GLshort s, GLshort t
#define glMultiTexCoord2sARB_ARG_NAMES_TAIL , target, s, t
#define glMultiTexCoord2sARB_ARG_EXPAND_TAIL , GLenum target, GLshort s, GLshort t
#define forward_glMultiTexCoord2sARB(_target, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2sARB(dst, _target, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2sARB(packed, ret_v) do { \
    glMultiTexCoord2sARB_PACKED *unpacked = (glMultiTexCoord2sARB_PACKED *)packed; \
    glMultiTexCoord2sARB_ARGS *args = (glMultiTexCoord2sARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2sARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2sARB(glMultiTexCoord2sARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2sARB(glMultiTexCoord2sARB_PACKED *_dst glMultiTexCoord2sARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2sARB_PTR)(glMultiTexCoord2sARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2sv_RETURN
#define glMultiTexCoord2sv_RETURN void
#define glMultiTexCoord2sv_ARG_NAMES target, v
#define glMultiTexCoord2sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord2sv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2sv_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord2sv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2sv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2sv(packed, ret_v) do { \
    glMultiTexCoord2sv_PACKED *unpacked = (glMultiTexCoord2sv_PACKED *)packed; \
    glMultiTexCoord2sv_ARGS *args = (glMultiTexCoord2sv_ARGS *)&unpacked->args; \
    glMultiTexCoord2sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2sv(glMultiTexCoord2sv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2sv(glMultiTexCoord2sv_PACKED *_dst glMultiTexCoord2sv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2sv_PTR)(glMultiTexCoord2sv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2svARB_RETURN
#define glMultiTexCoord2svARB_RETURN void
#define glMultiTexCoord2svARB_ARG_NAMES target, v
#define glMultiTexCoord2svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord2svARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord2svARB_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord2svARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2svARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord2svARB(packed, ret_v) do { \
    glMultiTexCoord2svARB_PACKED *unpacked = (glMultiTexCoord2svARB_PACKED *)packed; \
    glMultiTexCoord2svARB_ARGS *args = (glMultiTexCoord2svARB_ARGS *)&unpacked->args; \
    glMultiTexCoord2svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2svARB(glMultiTexCoord2svARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2svARB(glMultiTexCoord2svARB_PACKED *_dst glMultiTexCoord2svARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2svARB_PTR)(glMultiTexCoord2svARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2xOES_RETURN
#define glMultiTexCoord2xOES_RETURN void
#define glMultiTexCoord2xOES_ARG_NAMES texture, s, t
#define glMultiTexCoord2xOES_ARG_EXPAND GLenum texture, GLfixed s, GLfixed t
#define glMultiTexCoord2xOES_ARG_NAMES_TAIL , texture, s, t
#define glMultiTexCoord2xOES_ARG_EXPAND_TAIL , GLenum texture, GLfixed s, GLfixed t
#define forward_glMultiTexCoord2xOES(_texture, _s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2xOES(dst, _texture, _s, _t), NULL); \
    });
#define call_glMultiTexCoord2xOES(packed, ret_v) do { \
    glMultiTexCoord2xOES_PACKED *unpacked = (glMultiTexCoord2xOES_PACKED *)packed; \
    glMultiTexCoord2xOES_ARGS *args = (glMultiTexCoord2xOES_ARGS *)&unpacked->args; \
    glMultiTexCoord2xOES(args->texture, args->s, args->t);; \
} while(0)
void glMultiTexCoord2xOES(glMultiTexCoord2xOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2xOES(glMultiTexCoord2xOES_PACKED *_dst glMultiTexCoord2xOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2xOES_PTR)(glMultiTexCoord2xOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord2xvOES_RETURN
#define glMultiTexCoord2xvOES_RETURN void
#define glMultiTexCoord2xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord2xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord2xvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord2xvOES_ARG_EXPAND_TAIL , GLenum texture, const GLfixed * coords
#define forward_glMultiTexCoord2xvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord2xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord2xvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord2xvOES(packed, ret_v) do { \
    glMultiTexCoord2xvOES_PACKED *unpacked = (glMultiTexCoord2xvOES_PACKED *)packed; \
    glMultiTexCoord2xvOES_ARGS *args = (glMultiTexCoord2xvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord2xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord2xvOES(glMultiTexCoord2xvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord2xvOES(glMultiTexCoord2xvOES_PACKED *_dst glMultiTexCoord2xvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord2xvOES_PTR)(glMultiTexCoord2xvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3bOES_RETURN
#define glMultiTexCoord3bOES_RETURN void
#define glMultiTexCoord3bOES_ARG_NAMES texture, s, t, r
#define glMultiTexCoord3bOES_ARG_EXPAND GLenum texture, GLbyte s, GLbyte t, GLbyte r
#define glMultiTexCoord3bOES_ARG_NAMES_TAIL , texture, s, t, r
#define glMultiTexCoord3bOES_ARG_EXPAND_TAIL , GLenum texture, GLbyte s, GLbyte t, GLbyte r
#define forward_glMultiTexCoord3bOES(_texture, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3bOES(dst, _texture, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3bOES(packed, ret_v) do { \
    glMultiTexCoord3bOES_PACKED *unpacked = (glMultiTexCoord3bOES_PACKED *)packed; \
    glMultiTexCoord3bOES_ARGS *args = (glMultiTexCoord3bOES_ARGS *)&unpacked->args; \
    glMultiTexCoord3bOES(args->texture, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3bOES(glMultiTexCoord3bOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3bOES(glMultiTexCoord3bOES_PACKED *_dst glMultiTexCoord3bOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3bOES_PTR)(glMultiTexCoord3bOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3bvOES_RETURN
#define glMultiTexCoord3bvOES_RETURN void
#define glMultiTexCoord3bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord3bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord3bvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord3bvOES_ARG_EXPAND_TAIL , GLenum texture, const GLbyte * coords
#define forward_glMultiTexCoord3bvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3bvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord3bvOES(packed, ret_v) do { \
    glMultiTexCoord3bvOES_PACKED *unpacked = (glMultiTexCoord3bvOES_PACKED *)packed; \
    glMultiTexCoord3bvOES_ARGS *args = (glMultiTexCoord3bvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord3bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord3bvOES(glMultiTexCoord3bvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3bvOES(glMultiTexCoord3bvOES_PACKED *_dst glMultiTexCoord3bvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3bvOES_PTR)(glMultiTexCoord3bvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3d_RETURN
#define glMultiTexCoord3d_RETURN void
#define glMultiTexCoord3d_ARG_NAMES target, s, t, r
#define glMultiTexCoord3d_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r
#define glMultiTexCoord3d_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3d_ARG_EXPAND_TAIL , GLenum target, GLdouble s, GLdouble t, GLdouble r
#define forward_glMultiTexCoord3d(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3d(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3d(packed, ret_v) do { \
    glMultiTexCoord3d_PACKED *unpacked = (glMultiTexCoord3d_PACKED *)packed; \
    glMultiTexCoord3d_ARGS *args = (glMultiTexCoord3d_ARGS *)&unpacked->args; \
    glMultiTexCoord3d(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3d(glMultiTexCoord3d_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3d(glMultiTexCoord3d_PACKED *_dst glMultiTexCoord3d_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3d_PTR)(glMultiTexCoord3d_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3dARB_RETURN
#define glMultiTexCoord3dARB_RETURN void
#define glMultiTexCoord3dARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3dARB_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r
#define glMultiTexCoord3dARB_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3dARB_ARG_EXPAND_TAIL , GLenum target, GLdouble s, GLdouble t, GLdouble r
#define forward_glMultiTexCoord3dARB(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3dARB(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3dARB(packed, ret_v) do { \
    glMultiTexCoord3dARB_PACKED *unpacked = (glMultiTexCoord3dARB_PACKED *)packed; \
    glMultiTexCoord3dARB_ARGS *args = (glMultiTexCoord3dARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3dARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3dARB(glMultiTexCoord3dARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3dARB(glMultiTexCoord3dARB_PACKED *_dst glMultiTexCoord3dARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3dARB_PTR)(glMultiTexCoord3dARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3dv_RETURN
#define glMultiTexCoord3dv_RETURN void
#define glMultiTexCoord3dv_ARG_NAMES target, v
#define glMultiTexCoord3dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord3dv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3dv_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord3dv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3dv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3dv(packed, ret_v) do { \
    glMultiTexCoord3dv_PACKED *unpacked = (glMultiTexCoord3dv_PACKED *)packed; \
    glMultiTexCoord3dv_ARGS *args = (glMultiTexCoord3dv_ARGS *)&unpacked->args; \
    glMultiTexCoord3dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3dv(glMultiTexCoord3dv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3dv(glMultiTexCoord3dv_PACKED *_dst glMultiTexCoord3dv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3dv_PTR)(glMultiTexCoord3dv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3dvARB_RETURN
#define glMultiTexCoord3dvARB_RETURN void
#define glMultiTexCoord3dvARB_ARG_NAMES target, v
#define glMultiTexCoord3dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord3dvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3dvARB_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord3dvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3dvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3dvARB(packed, ret_v) do { \
    glMultiTexCoord3dvARB_PACKED *unpacked = (glMultiTexCoord3dvARB_PACKED *)packed; \
    glMultiTexCoord3dvARB_ARGS *args = (glMultiTexCoord3dvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3dvARB(glMultiTexCoord3dvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3dvARB(glMultiTexCoord3dvARB_PACKED *_dst glMultiTexCoord3dvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3dvARB_PTR)(glMultiTexCoord3dvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3f_RETURN
#define glMultiTexCoord3f_RETURN void
#define glMultiTexCoord3f_ARG_NAMES target, s, t, r
#define glMultiTexCoord3f_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r
#define glMultiTexCoord3f_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3f_ARG_EXPAND_TAIL , GLenum target, GLfloat s, GLfloat t, GLfloat r
#define forward_glMultiTexCoord3f(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3f(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3f(packed, ret_v) do { \
    glMultiTexCoord3f_PACKED *unpacked = (glMultiTexCoord3f_PACKED *)packed; \
    glMultiTexCoord3f_ARGS *args = (glMultiTexCoord3f_ARGS *)&unpacked->args; \
    glMultiTexCoord3f(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3f(glMultiTexCoord3f_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3f(glMultiTexCoord3f_PACKED *_dst glMultiTexCoord3f_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3f_PTR)(glMultiTexCoord3f_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3fARB_RETURN
#define glMultiTexCoord3fARB_RETURN void
#define glMultiTexCoord3fARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3fARB_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r
#define glMultiTexCoord3fARB_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3fARB_ARG_EXPAND_TAIL , GLenum target, GLfloat s, GLfloat t, GLfloat r
#define forward_glMultiTexCoord3fARB(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3fARB(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3fARB(packed, ret_v) do { \
    glMultiTexCoord3fARB_PACKED *unpacked = (glMultiTexCoord3fARB_PACKED *)packed; \
    glMultiTexCoord3fARB_ARGS *args = (glMultiTexCoord3fARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3fARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3fARB(glMultiTexCoord3fARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3fARB(glMultiTexCoord3fARB_PACKED *_dst glMultiTexCoord3fARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3fARB_PTR)(glMultiTexCoord3fARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3fv_RETURN
#define glMultiTexCoord3fv_RETURN void
#define glMultiTexCoord3fv_ARG_NAMES target, v
#define glMultiTexCoord3fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord3fv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3fv_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord3fv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3fv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3fv(packed, ret_v) do { \
    glMultiTexCoord3fv_PACKED *unpacked = (glMultiTexCoord3fv_PACKED *)packed; \
    glMultiTexCoord3fv_ARGS *args = (glMultiTexCoord3fv_ARGS *)&unpacked->args; \
    glMultiTexCoord3fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3fv(glMultiTexCoord3fv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3fv(glMultiTexCoord3fv_PACKED *_dst glMultiTexCoord3fv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3fv_PTR)(glMultiTexCoord3fv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3fvARB_RETURN
#define glMultiTexCoord3fvARB_RETURN void
#define glMultiTexCoord3fvARB_ARG_NAMES target, v
#define glMultiTexCoord3fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord3fvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3fvARB_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord3fvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3fvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3fvARB(packed, ret_v) do { \
    glMultiTexCoord3fvARB_PACKED *unpacked = (glMultiTexCoord3fvARB_PACKED *)packed; \
    glMultiTexCoord3fvARB_ARGS *args = (glMultiTexCoord3fvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3fvARB(glMultiTexCoord3fvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3fvARB(glMultiTexCoord3fvARB_PACKED *_dst glMultiTexCoord3fvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3fvARB_PTR)(glMultiTexCoord3fvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3hNV_RETURN
#define glMultiTexCoord3hNV_RETURN void
#define glMultiTexCoord3hNV_ARG_NAMES target, s, t, r
#define glMultiTexCoord3hNV_ARG_EXPAND GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r
#define glMultiTexCoord3hNV_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3hNV_ARG_EXPAND_TAIL , GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r
#define forward_glMultiTexCoord3hNV(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3hNV(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3hNV(packed, ret_v) do { \
    glMultiTexCoord3hNV_PACKED *unpacked = (glMultiTexCoord3hNV_PACKED *)packed; \
    glMultiTexCoord3hNV_ARGS *args = (glMultiTexCoord3hNV_ARGS *)&unpacked->args; \
    glMultiTexCoord3hNV(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3hNV(glMultiTexCoord3hNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3hNV(glMultiTexCoord3hNV_PACKED *_dst glMultiTexCoord3hNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3hNV_PTR)(glMultiTexCoord3hNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3hvNV_RETURN
#define glMultiTexCoord3hvNV_RETURN void
#define glMultiTexCoord3hvNV_ARG_NAMES target, v
#define glMultiTexCoord3hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord3hvNV_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3hvNV_ARG_EXPAND_TAIL , GLenum target, const GLhalfNV * v
#define forward_glMultiTexCoord3hvNV(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3hvNV(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3hvNV(packed, ret_v) do { \
    glMultiTexCoord3hvNV_PACKED *unpacked = (glMultiTexCoord3hvNV_PACKED *)packed; \
    glMultiTexCoord3hvNV_ARGS *args = (glMultiTexCoord3hvNV_ARGS *)&unpacked->args; \
    glMultiTexCoord3hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord3hvNV(glMultiTexCoord3hvNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3hvNV(glMultiTexCoord3hvNV_PACKED *_dst glMultiTexCoord3hvNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3hvNV_PTR)(glMultiTexCoord3hvNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3i_RETURN
#define glMultiTexCoord3i_RETURN void
#define glMultiTexCoord3i_ARG_NAMES target, s, t, r
#define glMultiTexCoord3i_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r
#define glMultiTexCoord3i_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3i_ARG_EXPAND_TAIL , GLenum target, GLint s, GLint t, GLint r
#define forward_glMultiTexCoord3i(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3i(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3i(packed, ret_v) do { \
    glMultiTexCoord3i_PACKED *unpacked = (glMultiTexCoord3i_PACKED *)packed; \
    glMultiTexCoord3i_ARGS *args = (glMultiTexCoord3i_ARGS *)&unpacked->args; \
    glMultiTexCoord3i(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3i(glMultiTexCoord3i_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3i(glMultiTexCoord3i_PACKED *_dst glMultiTexCoord3i_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3i_PTR)(glMultiTexCoord3i_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3iARB_RETURN
#define glMultiTexCoord3iARB_RETURN void
#define glMultiTexCoord3iARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3iARB_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r
#define glMultiTexCoord3iARB_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3iARB_ARG_EXPAND_TAIL , GLenum target, GLint s, GLint t, GLint r
#define forward_glMultiTexCoord3iARB(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3iARB(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3iARB(packed, ret_v) do { \
    glMultiTexCoord3iARB_PACKED *unpacked = (glMultiTexCoord3iARB_PACKED *)packed; \
    glMultiTexCoord3iARB_ARGS *args = (glMultiTexCoord3iARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3iARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3iARB(glMultiTexCoord3iARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3iARB(glMultiTexCoord3iARB_PACKED *_dst glMultiTexCoord3iARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3iARB_PTR)(glMultiTexCoord3iARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3iv_RETURN
#define glMultiTexCoord3iv_RETURN void
#define glMultiTexCoord3iv_ARG_NAMES target, v
#define glMultiTexCoord3iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord3iv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3iv_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord3iv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3iv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3iv(packed, ret_v) do { \
    glMultiTexCoord3iv_PACKED *unpacked = (glMultiTexCoord3iv_PACKED *)packed; \
    glMultiTexCoord3iv_ARGS *args = (glMultiTexCoord3iv_ARGS *)&unpacked->args; \
    glMultiTexCoord3iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3iv(glMultiTexCoord3iv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3iv(glMultiTexCoord3iv_PACKED *_dst glMultiTexCoord3iv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3iv_PTR)(glMultiTexCoord3iv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3ivARB_RETURN
#define glMultiTexCoord3ivARB_RETURN void
#define glMultiTexCoord3ivARB_ARG_NAMES target, v
#define glMultiTexCoord3ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord3ivARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3ivARB_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord3ivARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3ivARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3ivARB(packed, ret_v) do { \
    glMultiTexCoord3ivARB_PACKED *unpacked = (glMultiTexCoord3ivARB_PACKED *)packed; \
    glMultiTexCoord3ivARB_ARGS *args = (glMultiTexCoord3ivARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3ivARB(glMultiTexCoord3ivARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3ivARB(glMultiTexCoord3ivARB_PACKED *_dst glMultiTexCoord3ivARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3ivARB_PTR)(glMultiTexCoord3ivARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3s_RETURN
#define glMultiTexCoord3s_RETURN void
#define glMultiTexCoord3s_ARG_NAMES target, s, t, r
#define glMultiTexCoord3s_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r
#define glMultiTexCoord3s_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3s_ARG_EXPAND_TAIL , GLenum target, GLshort s, GLshort t, GLshort r
#define forward_glMultiTexCoord3s(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3s(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3s(packed, ret_v) do { \
    glMultiTexCoord3s_PACKED *unpacked = (glMultiTexCoord3s_PACKED *)packed; \
    glMultiTexCoord3s_ARGS *args = (glMultiTexCoord3s_ARGS *)&unpacked->args; \
    glMultiTexCoord3s(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3s(glMultiTexCoord3s_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3s(glMultiTexCoord3s_PACKED *_dst glMultiTexCoord3s_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3s_PTR)(glMultiTexCoord3s_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3sARB_RETURN
#define glMultiTexCoord3sARB_RETURN void
#define glMultiTexCoord3sARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3sARB_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r
#define glMultiTexCoord3sARB_ARG_NAMES_TAIL , target, s, t, r
#define glMultiTexCoord3sARB_ARG_EXPAND_TAIL , GLenum target, GLshort s, GLshort t, GLshort r
#define forward_glMultiTexCoord3sARB(_target, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3sARB(dst, _target, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3sARB(packed, ret_v) do { \
    glMultiTexCoord3sARB_PACKED *unpacked = (glMultiTexCoord3sARB_PACKED *)packed; \
    glMultiTexCoord3sARB_ARGS *args = (glMultiTexCoord3sARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3sARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3sARB(glMultiTexCoord3sARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3sARB(glMultiTexCoord3sARB_PACKED *_dst glMultiTexCoord3sARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3sARB_PTR)(glMultiTexCoord3sARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3sv_RETURN
#define glMultiTexCoord3sv_RETURN void
#define glMultiTexCoord3sv_ARG_NAMES target, v
#define glMultiTexCoord3sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord3sv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3sv_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord3sv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3sv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3sv(packed, ret_v) do { \
    glMultiTexCoord3sv_PACKED *unpacked = (glMultiTexCoord3sv_PACKED *)packed; \
    glMultiTexCoord3sv_ARGS *args = (glMultiTexCoord3sv_ARGS *)&unpacked->args; \
    glMultiTexCoord3sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3sv(glMultiTexCoord3sv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3sv(glMultiTexCoord3sv_PACKED *_dst glMultiTexCoord3sv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3sv_PTR)(glMultiTexCoord3sv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3svARB_RETURN
#define glMultiTexCoord3svARB_RETURN void
#define glMultiTexCoord3svARB_ARG_NAMES target, v
#define glMultiTexCoord3svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord3svARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord3svARB_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord3svARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3svARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord3svARB(packed, ret_v) do { \
    glMultiTexCoord3svARB_PACKED *unpacked = (glMultiTexCoord3svARB_PACKED *)packed; \
    glMultiTexCoord3svARB_ARGS *args = (glMultiTexCoord3svARB_ARGS *)&unpacked->args; \
    glMultiTexCoord3svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3svARB(glMultiTexCoord3svARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3svARB(glMultiTexCoord3svARB_PACKED *_dst glMultiTexCoord3svARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3svARB_PTR)(glMultiTexCoord3svARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3xOES_RETURN
#define glMultiTexCoord3xOES_RETURN void
#define glMultiTexCoord3xOES_ARG_NAMES texture, s, t, r
#define glMultiTexCoord3xOES_ARG_EXPAND GLenum texture, GLfixed s, GLfixed t, GLfixed r
#define glMultiTexCoord3xOES_ARG_NAMES_TAIL , texture, s, t, r
#define glMultiTexCoord3xOES_ARG_EXPAND_TAIL , GLenum texture, GLfixed s, GLfixed t, GLfixed r
#define forward_glMultiTexCoord3xOES(_texture, _s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3xOES(dst, _texture, _s, _t, _r), NULL); \
    });
#define call_glMultiTexCoord3xOES(packed, ret_v) do { \
    glMultiTexCoord3xOES_PACKED *unpacked = (glMultiTexCoord3xOES_PACKED *)packed; \
    glMultiTexCoord3xOES_ARGS *args = (glMultiTexCoord3xOES_ARGS *)&unpacked->args; \
    glMultiTexCoord3xOES(args->texture, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3xOES(glMultiTexCoord3xOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3xOES(glMultiTexCoord3xOES_PACKED *_dst glMultiTexCoord3xOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3xOES_PTR)(glMultiTexCoord3xOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord3xvOES_RETURN
#define glMultiTexCoord3xvOES_RETURN void
#define glMultiTexCoord3xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord3xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord3xvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord3xvOES_ARG_EXPAND_TAIL , GLenum texture, const GLfixed * coords
#define forward_glMultiTexCoord3xvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord3xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord3xvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord3xvOES(packed, ret_v) do { \
    glMultiTexCoord3xvOES_PACKED *unpacked = (glMultiTexCoord3xvOES_PACKED *)packed; \
    glMultiTexCoord3xvOES_ARGS *args = (glMultiTexCoord3xvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord3xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord3xvOES(glMultiTexCoord3xvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord3xvOES(glMultiTexCoord3xvOES_PACKED *_dst glMultiTexCoord3xvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord3xvOES_PTR)(glMultiTexCoord3xvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4bOES_RETURN
#define glMultiTexCoord4bOES_RETURN void
#define glMultiTexCoord4bOES_ARG_NAMES texture, s, t, r, q
#define glMultiTexCoord4bOES_ARG_EXPAND GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q
#define glMultiTexCoord4bOES_ARG_NAMES_TAIL , texture, s, t, r, q
#define glMultiTexCoord4bOES_ARG_EXPAND_TAIL , GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q
#define forward_glMultiTexCoord4bOES(_texture, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4bOES(dst, _texture, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4bOES(packed, ret_v) do { \
    glMultiTexCoord4bOES_PACKED *unpacked = (glMultiTexCoord4bOES_PACKED *)packed; \
    glMultiTexCoord4bOES_ARGS *args = (glMultiTexCoord4bOES_ARGS *)&unpacked->args; \
    glMultiTexCoord4bOES(args->texture, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4bOES(glMultiTexCoord4bOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4bOES(glMultiTexCoord4bOES_PACKED *_dst glMultiTexCoord4bOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4bOES_PTR)(glMultiTexCoord4bOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4bvOES_RETURN
#define glMultiTexCoord4bvOES_RETURN void
#define glMultiTexCoord4bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord4bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord4bvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord4bvOES_ARG_EXPAND_TAIL , GLenum texture, const GLbyte * coords
#define forward_glMultiTexCoord4bvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4bvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord4bvOES(packed, ret_v) do { \
    glMultiTexCoord4bvOES_PACKED *unpacked = (glMultiTexCoord4bvOES_PACKED *)packed; \
    glMultiTexCoord4bvOES_ARGS *args = (glMultiTexCoord4bvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord4bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord4bvOES(glMultiTexCoord4bvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4bvOES(glMultiTexCoord4bvOES_PACKED *_dst glMultiTexCoord4bvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4bvOES_PTR)(glMultiTexCoord4bvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4d_RETURN
#define glMultiTexCoord4d_RETURN void
#define glMultiTexCoord4d_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4d_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define glMultiTexCoord4d_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4d_ARG_EXPAND_TAIL , GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define forward_glMultiTexCoord4d(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4d(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4d(packed, ret_v) do { \
    glMultiTexCoord4d_PACKED *unpacked = (glMultiTexCoord4d_PACKED *)packed; \
    glMultiTexCoord4d_ARGS *args = (glMultiTexCoord4d_ARGS *)&unpacked->args; \
    glMultiTexCoord4d(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4d(glMultiTexCoord4d_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4d(glMultiTexCoord4d_PACKED *_dst glMultiTexCoord4d_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4d_PTR)(glMultiTexCoord4d_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4dARB_RETURN
#define glMultiTexCoord4dARB_RETURN void
#define glMultiTexCoord4dARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4dARB_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define glMultiTexCoord4dARB_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4dARB_ARG_EXPAND_TAIL , GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define forward_glMultiTexCoord4dARB(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4dARB(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4dARB(packed, ret_v) do { \
    glMultiTexCoord4dARB_PACKED *unpacked = (glMultiTexCoord4dARB_PACKED *)packed; \
    glMultiTexCoord4dARB_ARGS *args = (glMultiTexCoord4dARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4dARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4dARB(glMultiTexCoord4dARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4dARB(glMultiTexCoord4dARB_PACKED *_dst glMultiTexCoord4dARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4dARB_PTR)(glMultiTexCoord4dARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4dv_RETURN
#define glMultiTexCoord4dv_RETURN void
#define glMultiTexCoord4dv_ARG_NAMES target, v
#define glMultiTexCoord4dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord4dv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4dv_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord4dv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4dv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4dv(packed, ret_v) do { \
    glMultiTexCoord4dv_PACKED *unpacked = (glMultiTexCoord4dv_PACKED *)packed; \
    glMultiTexCoord4dv_ARGS *args = (glMultiTexCoord4dv_ARGS *)&unpacked->args; \
    glMultiTexCoord4dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4dv(glMultiTexCoord4dv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4dv(glMultiTexCoord4dv_PACKED *_dst glMultiTexCoord4dv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4dv_PTR)(glMultiTexCoord4dv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4dvARB_RETURN
#define glMultiTexCoord4dvARB_RETURN void
#define glMultiTexCoord4dvARB_ARG_NAMES target, v
#define glMultiTexCoord4dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord4dvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4dvARB_ARG_EXPAND_TAIL , GLenum target, const GLdouble * v
#define forward_glMultiTexCoord4dvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4dvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4dvARB(packed, ret_v) do { \
    glMultiTexCoord4dvARB_PACKED *unpacked = (glMultiTexCoord4dvARB_PACKED *)packed; \
    glMultiTexCoord4dvARB_ARGS *args = (glMultiTexCoord4dvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4dvARB(glMultiTexCoord4dvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4dvARB(glMultiTexCoord4dvARB_PACKED *_dst glMultiTexCoord4dvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4dvARB_PTR)(glMultiTexCoord4dvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4f_RETURN
#define glMultiTexCoord4f_RETURN void
#define glMultiTexCoord4f_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4f_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define glMultiTexCoord4f_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4f_ARG_EXPAND_TAIL , GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define forward_glMultiTexCoord4f(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4f(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4f(packed, ret_v) do { \
    glMultiTexCoord4f_PACKED *unpacked = (glMultiTexCoord4f_PACKED *)packed; \
    glMultiTexCoord4f_ARGS *args = (glMultiTexCoord4f_ARGS *)&unpacked->args; \
    glMultiTexCoord4f(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4f(glMultiTexCoord4f_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4f(glMultiTexCoord4f_PACKED *_dst glMultiTexCoord4f_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4f_PTR)(glMultiTexCoord4f_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4fARB_RETURN
#define glMultiTexCoord4fARB_RETURN void
#define glMultiTexCoord4fARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4fARB_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define glMultiTexCoord4fARB_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4fARB_ARG_EXPAND_TAIL , GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define forward_glMultiTexCoord4fARB(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4fARB(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4fARB(packed, ret_v) do { \
    glMultiTexCoord4fARB_PACKED *unpacked = (glMultiTexCoord4fARB_PACKED *)packed; \
    glMultiTexCoord4fARB_ARGS *args = (glMultiTexCoord4fARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4fARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4fARB(glMultiTexCoord4fARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4fARB(glMultiTexCoord4fARB_PACKED *_dst glMultiTexCoord4fARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4fARB_PTR)(glMultiTexCoord4fARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4fv_RETURN
#define glMultiTexCoord4fv_RETURN void
#define glMultiTexCoord4fv_ARG_NAMES target, v
#define glMultiTexCoord4fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord4fv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4fv_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord4fv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4fv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4fv(packed, ret_v) do { \
    glMultiTexCoord4fv_PACKED *unpacked = (glMultiTexCoord4fv_PACKED *)packed; \
    glMultiTexCoord4fv_ARGS *args = (glMultiTexCoord4fv_ARGS *)&unpacked->args; \
    glMultiTexCoord4fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4fv(glMultiTexCoord4fv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4fv(glMultiTexCoord4fv_PACKED *_dst glMultiTexCoord4fv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4fv_PTR)(glMultiTexCoord4fv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4fvARB_RETURN
#define glMultiTexCoord4fvARB_RETURN void
#define glMultiTexCoord4fvARB_ARG_NAMES target, v
#define glMultiTexCoord4fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord4fvARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4fvARB_ARG_EXPAND_TAIL , GLenum target, const GLfloat * v
#define forward_glMultiTexCoord4fvARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4fvARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4fvARB(packed, ret_v) do { \
    glMultiTexCoord4fvARB_PACKED *unpacked = (glMultiTexCoord4fvARB_PACKED *)packed; \
    glMultiTexCoord4fvARB_ARGS *args = (glMultiTexCoord4fvARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4fvARB(glMultiTexCoord4fvARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4fvARB(glMultiTexCoord4fvARB_PACKED *_dst glMultiTexCoord4fvARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4fvARB_PTR)(glMultiTexCoord4fvARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4hNV_RETURN
#define glMultiTexCoord4hNV_RETURN void
#define glMultiTexCoord4hNV_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4hNV_ARG_EXPAND GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q
#define glMultiTexCoord4hNV_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4hNV_ARG_EXPAND_TAIL , GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q
#define forward_glMultiTexCoord4hNV(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4hNV(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4hNV(packed, ret_v) do { \
    glMultiTexCoord4hNV_PACKED *unpacked = (glMultiTexCoord4hNV_PACKED *)packed; \
    glMultiTexCoord4hNV_ARGS *args = (glMultiTexCoord4hNV_ARGS *)&unpacked->args; \
    glMultiTexCoord4hNV(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4hNV(glMultiTexCoord4hNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4hNV(glMultiTexCoord4hNV_PACKED *_dst glMultiTexCoord4hNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4hNV_PTR)(glMultiTexCoord4hNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4hvNV_RETURN
#define glMultiTexCoord4hvNV_RETURN void
#define glMultiTexCoord4hvNV_ARG_NAMES target, v
#define glMultiTexCoord4hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord4hvNV_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4hvNV_ARG_EXPAND_TAIL , GLenum target, const GLhalfNV * v
#define forward_glMultiTexCoord4hvNV(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4hvNV(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4hvNV(packed, ret_v) do { \
    glMultiTexCoord4hvNV_PACKED *unpacked = (glMultiTexCoord4hvNV_PACKED *)packed; \
    glMultiTexCoord4hvNV_ARGS *args = (glMultiTexCoord4hvNV_ARGS *)&unpacked->args; \
    glMultiTexCoord4hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord4hvNV(glMultiTexCoord4hvNV_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4hvNV(glMultiTexCoord4hvNV_PACKED *_dst glMultiTexCoord4hvNV_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4hvNV_PTR)(glMultiTexCoord4hvNV_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4i_RETURN
#define glMultiTexCoord4i_RETURN void
#define glMultiTexCoord4i_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4i_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r, GLint q
#define glMultiTexCoord4i_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4i_ARG_EXPAND_TAIL , GLenum target, GLint s, GLint t, GLint r, GLint q
#define forward_glMultiTexCoord4i(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4i(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4i(packed, ret_v) do { \
    glMultiTexCoord4i_PACKED *unpacked = (glMultiTexCoord4i_PACKED *)packed; \
    glMultiTexCoord4i_ARGS *args = (glMultiTexCoord4i_ARGS *)&unpacked->args; \
    glMultiTexCoord4i(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4i(glMultiTexCoord4i_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4i(glMultiTexCoord4i_PACKED *_dst glMultiTexCoord4i_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4i_PTR)(glMultiTexCoord4i_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4iARB_RETURN
#define glMultiTexCoord4iARB_RETURN void
#define glMultiTexCoord4iARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4iARB_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r, GLint q
#define glMultiTexCoord4iARB_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4iARB_ARG_EXPAND_TAIL , GLenum target, GLint s, GLint t, GLint r, GLint q
#define forward_glMultiTexCoord4iARB(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4iARB(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4iARB(packed, ret_v) do { \
    glMultiTexCoord4iARB_PACKED *unpacked = (glMultiTexCoord4iARB_PACKED *)packed; \
    glMultiTexCoord4iARB_ARGS *args = (glMultiTexCoord4iARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4iARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4iARB(glMultiTexCoord4iARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4iARB(glMultiTexCoord4iARB_PACKED *_dst glMultiTexCoord4iARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4iARB_PTR)(glMultiTexCoord4iARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4iv_RETURN
#define glMultiTexCoord4iv_RETURN void
#define glMultiTexCoord4iv_ARG_NAMES target, v
#define glMultiTexCoord4iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord4iv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4iv_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord4iv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4iv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4iv(packed, ret_v) do { \
    glMultiTexCoord4iv_PACKED *unpacked = (glMultiTexCoord4iv_PACKED *)packed; \
    glMultiTexCoord4iv_ARGS *args = (glMultiTexCoord4iv_ARGS *)&unpacked->args; \
    glMultiTexCoord4iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4iv(glMultiTexCoord4iv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4iv(glMultiTexCoord4iv_PACKED *_dst glMultiTexCoord4iv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4iv_PTR)(glMultiTexCoord4iv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4ivARB_RETURN
#define glMultiTexCoord4ivARB_RETURN void
#define glMultiTexCoord4ivARB_ARG_NAMES target, v
#define glMultiTexCoord4ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord4ivARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4ivARB_ARG_EXPAND_TAIL , GLenum target, const GLint * v
#define forward_glMultiTexCoord4ivARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4ivARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4ivARB(packed, ret_v) do { \
    glMultiTexCoord4ivARB_PACKED *unpacked = (glMultiTexCoord4ivARB_PACKED *)packed; \
    glMultiTexCoord4ivARB_ARGS *args = (glMultiTexCoord4ivARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4ivARB(glMultiTexCoord4ivARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4ivARB(glMultiTexCoord4ivARB_PACKED *_dst glMultiTexCoord4ivARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4ivARB_PTR)(glMultiTexCoord4ivARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4s_RETURN
#define glMultiTexCoord4s_RETURN void
#define glMultiTexCoord4s_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4s_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r, GLshort q
#define glMultiTexCoord4s_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4s_ARG_EXPAND_TAIL , GLenum target, GLshort s, GLshort t, GLshort r, GLshort q
#define forward_glMultiTexCoord4s(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4s(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4s(packed, ret_v) do { \
    glMultiTexCoord4s_PACKED *unpacked = (glMultiTexCoord4s_PACKED *)packed; \
    glMultiTexCoord4s_ARGS *args = (glMultiTexCoord4s_ARGS *)&unpacked->args; \
    glMultiTexCoord4s(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4s(glMultiTexCoord4s_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4s(glMultiTexCoord4s_PACKED *_dst glMultiTexCoord4s_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4s_PTR)(glMultiTexCoord4s_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4sARB_RETURN
#define glMultiTexCoord4sARB_RETURN void
#define glMultiTexCoord4sARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4sARB_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r, GLshort q
#define glMultiTexCoord4sARB_ARG_NAMES_TAIL , target, s, t, r, q
#define glMultiTexCoord4sARB_ARG_EXPAND_TAIL , GLenum target, GLshort s, GLshort t, GLshort r, GLshort q
#define forward_glMultiTexCoord4sARB(_target, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4sARB(dst, _target, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4sARB(packed, ret_v) do { \
    glMultiTexCoord4sARB_PACKED *unpacked = (glMultiTexCoord4sARB_PACKED *)packed; \
    glMultiTexCoord4sARB_ARGS *args = (glMultiTexCoord4sARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4sARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4sARB(glMultiTexCoord4sARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4sARB(glMultiTexCoord4sARB_PACKED *_dst glMultiTexCoord4sARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4sARB_PTR)(glMultiTexCoord4sARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4sv_RETURN
#define glMultiTexCoord4sv_RETURN void
#define glMultiTexCoord4sv_ARG_NAMES target, v
#define glMultiTexCoord4sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord4sv_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4sv_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord4sv(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4sv(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4sv(packed, ret_v) do { \
    glMultiTexCoord4sv_PACKED *unpacked = (glMultiTexCoord4sv_PACKED *)packed; \
    glMultiTexCoord4sv_ARGS *args = (glMultiTexCoord4sv_ARGS *)&unpacked->args; \
    glMultiTexCoord4sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4sv(glMultiTexCoord4sv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4sv(glMultiTexCoord4sv_PACKED *_dst glMultiTexCoord4sv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4sv_PTR)(glMultiTexCoord4sv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4svARB_RETURN
#define glMultiTexCoord4svARB_RETURN void
#define glMultiTexCoord4svARB_ARG_NAMES target, v
#define glMultiTexCoord4svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord4svARB_ARG_NAMES_TAIL , target, v
#define glMultiTexCoord4svARB_ARG_EXPAND_TAIL , GLenum target, const GLshort * v
#define forward_glMultiTexCoord4svARB(_target, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4svARB(dst, _target, _v), NULL); \
    });
#define call_glMultiTexCoord4svARB(packed, ret_v) do { \
    glMultiTexCoord4svARB_PACKED *unpacked = (glMultiTexCoord4svARB_PACKED *)packed; \
    glMultiTexCoord4svARB_ARGS *args = (glMultiTexCoord4svARB_ARGS *)&unpacked->args; \
    glMultiTexCoord4svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4svARB(glMultiTexCoord4svARB_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4svARB(glMultiTexCoord4svARB_PACKED *_dst glMultiTexCoord4svARB_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4svARB_PTR)(glMultiTexCoord4svARB_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4xOES_RETURN
#define glMultiTexCoord4xOES_RETURN void
#define glMultiTexCoord4xOES_ARG_NAMES texture, s, t, r, q
#define glMultiTexCoord4xOES_ARG_EXPAND GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q
#define glMultiTexCoord4xOES_ARG_NAMES_TAIL , texture, s, t, r, q
#define glMultiTexCoord4xOES_ARG_EXPAND_TAIL , GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q
#define forward_glMultiTexCoord4xOES(_texture, _s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4xOES(dst, _texture, _s, _t, _r, _q), NULL); \
    });
#define call_glMultiTexCoord4xOES(packed, ret_v) do { \
    glMultiTexCoord4xOES_PACKED *unpacked = (glMultiTexCoord4xOES_PACKED *)packed; \
    glMultiTexCoord4xOES_ARGS *args = (glMultiTexCoord4xOES_ARGS *)&unpacked->args; \
    glMultiTexCoord4xOES(args->texture, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4xOES(glMultiTexCoord4xOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4xOES(glMultiTexCoord4xOES_PACKED *_dst glMultiTexCoord4xOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4xOES_PTR)(glMultiTexCoord4xOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoord4xvOES_RETURN
#define glMultiTexCoord4xvOES_RETURN void
#define glMultiTexCoord4xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord4xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord4xvOES_ARG_NAMES_TAIL , texture, coords
#define glMultiTexCoord4xvOES_ARG_EXPAND_TAIL , GLenum texture, const GLfixed * coords
#define forward_glMultiTexCoord4xvOES(_texture, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoord4xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoord4xvOES(dst, _texture, _coords), NULL); \
    });
#define call_glMultiTexCoord4xvOES(packed, ret_v) do { \
    glMultiTexCoord4xvOES_PACKED *unpacked = (glMultiTexCoord4xvOES_PACKED *)packed; \
    glMultiTexCoord4xvOES_ARGS *args = (glMultiTexCoord4xvOES_ARGS *)&unpacked->args; \
    glMultiTexCoord4xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord4xvOES(glMultiTexCoord4xvOES_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoord4xvOES(glMultiTexCoord4xvOES_PACKED *_dst glMultiTexCoord4xvOES_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoord4xvOES_PTR)(glMultiTexCoord4xvOES_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP1ui_RETURN
#define glMultiTexCoordP1ui_RETURN void
#define glMultiTexCoordP1ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP1ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP1ui_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP1ui_ARG_EXPAND_TAIL , GLenum texture, GLenum type, GLuint coords
#define forward_glMultiTexCoordP1ui(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP1ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP1ui(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP1ui(packed, ret_v) do { \
    glMultiTexCoordP1ui_PACKED *unpacked = (glMultiTexCoordP1ui_PACKED *)packed; \
    glMultiTexCoordP1ui_ARGS *args = (glMultiTexCoordP1ui_ARGS *)&unpacked->args; \
    glMultiTexCoordP1ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP1ui(glMultiTexCoordP1ui_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP1ui(glMultiTexCoordP1ui_PACKED *_dst glMultiTexCoordP1ui_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP1ui_PTR)(glMultiTexCoordP1ui_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP1uiv_RETURN
#define glMultiTexCoordP1uiv_RETURN void
#define glMultiTexCoordP1uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP1uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP1uiv_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP1uiv_ARG_EXPAND_TAIL , GLenum texture, GLenum type, const GLuint * coords
#define forward_glMultiTexCoordP1uiv(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP1uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP1uiv(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP1uiv(packed, ret_v) do { \
    glMultiTexCoordP1uiv_PACKED *unpacked = (glMultiTexCoordP1uiv_PACKED *)packed; \
    glMultiTexCoordP1uiv_ARGS *args = (glMultiTexCoordP1uiv_ARGS *)&unpacked->args; \
    glMultiTexCoordP1uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP1uiv(glMultiTexCoordP1uiv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP1uiv(glMultiTexCoordP1uiv_PACKED *_dst glMultiTexCoordP1uiv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP1uiv_PTR)(glMultiTexCoordP1uiv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP2ui_RETURN
#define glMultiTexCoordP2ui_RETURN void
#define glMultiTexCoordP2ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP2ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP2ui_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP2ui_ARG_EXPAND_TAIL , GLenum texture, GLenum type, GLuint coords
#define forward_glMultiTexCoordP2ui(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP2ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP2ui(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP2ui(packed, ret_v) do { \
    glMultiTexCoordP2ui_PACKED *unpacked = (glMultiTexCoordP2ui_PACKED *)packed; \
    glMultiTexCoordP2ui_ARGS *args = (glMultiTexCoordP2ui_ARGS *)&unpacked->args; \
    glMultiTexCoordP2ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP2ui(glMultiTexCoordP2ui_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP2ui(glMultiTexCoordP2ui_PACKED *_dst glMultiTexCoordP2ui_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP2ui_PTR)(glMultiTexCoordP2ui_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP2uiv_RETURN
#define glMultiTexCoordP2uiv_RETURN void
#define glMultiTexCoordP2uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP2uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP2uiv_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP2uiv_ARG_EXPAND_TAIL , GLenum texture, GLenum type, const GLuint * coords
#define forward_glMultiTexCoordP2uiv(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP2uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP2uiv(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP2uiv(packed, ret_v) do { \
    glMultiTexCoordP2uiv_PACKED *unpacked = (glMultiTexCoordP2uiv_PACKED *)packed; \
    glMultiTexCoordP2uiv_ARGS *args = (glMultiTexCoordP2uiv_ARGS *)&unpacked->args; \
    glMultiTexCoordP2uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP2uiv(glMultiTexCoordP2uiv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP2uiv(glMultiTexCoordP2uiv_PACKED *_dst glMultiTexCoordP2uiv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP2uiv_PTR)(glMultiTexCoordP2uiv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP3ui_RETURN
#define glMultiTexCoordP3ui_RETURN void
#define glMultiTexCoordP3ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP3ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP3ui_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP3ui_ARG_EXPAND_TAIL , GLenum texture, GLenum type, GLuint coords
#define forward_glMultiTexCoordP3ui(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP3ui(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP3ui(packed, ret_v) do { \
    glMultiTexCoordP3ui_PACKED *unpacked = (glMultiTexCoordP3ui_PACKED *)packed; \
    glMultiTexCoordP3ui_ARGS *args = (glMultiTexCoordP3ui_ARGS *)&unpacked->args; \
    glMultiTexCoordP3ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP3ui(glMultiTexCoordP3ui_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP3ui(glMultiTexCoordP3ui_PACKED *_dst glMultiTexCoordP3ui_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP3ui_PTR)(glMultiTexCoordP3ui_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP3uiv_RETURN
#define glMultiTexCoordP3uiv_RETURN void
#define glMultiTexCoordP3uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP3uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP3uiv_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP3uiv_ARG_EXPAND_TAIL , GLenum texture, GLenum type, const GLuint * coords
#define forward_glMultiTexCoordP3uiv(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP3uiv(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP3uiv(packed, ret_v) do { \
    glMultiTexCoordP3uiv_PACKED *unpacked = (glMultiTexCoordP3uiv_PACKED *)packed; \
    glMultiTexCoordP3uiv_ARGS *args = (glMultiTexCoordP3uiv_ARGS *)&unpacked->args; \
    glMultiTexCoordP3uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP3uiv(glMultiTexCoordP3uiv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP3uiv(glMultiTexCoordP3uiv_PACKED *_dst glMultiTexCoordP3uiv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP3uiv_PTR)(glMultiTexCoordP3uiv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP4ui_RETURN
#define glMultiTexCoordP4ui_RETURN void
#define glMultiTexCoordP4ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP4ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP4ui_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP4ui_ARG_EXPAND_TAIL , GLenum texture, GLenum type, GLuint coords
#define forward_glMultiTexCoordP4ui(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP4ui(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP4ui(packed, ret_v) do { \
    glMultiTexCoordP4ui_PACKED *unpacked = (glMultiTexCoordP4ui_PACKED *)packed; \
    glMultiTexCoordP4ui_ARGS *args = (glMultiTexCoordP4ui_ARGS *)&unpacked->args; \
    glMultiTexCoordP4ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP4ui(glMultiTexCoordP4ui_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP4ui(glMultiTexCoordP4ui_PACKED *_dst glMultiTexCoordP4ui_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP4ui_PTR)(glMultiTexCoordP4ui_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordP4uiv_RETURN
#define glMultiTexCoordP4uiv_RETURN void
#define glMultiTexCoordP4uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP4uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP4uiv_ARG_NAMES_TAIL , texture, type, coords
#define glMultiTexCoordP4uiv_ARG_EXPAND_TAIL , GLenum texture, GLenum type, const GLuint * coords
#define forward_glMultiTexCoordP4uiv(_texture, _type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordP4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordP4uiv(dst, _texture, _type, _coords), NULL); \
    });
#define call_glMultiTexCoordP4uiv(packed, ret_v) do { \
    glMultiTexCoordP4uiv_PACKED *unpacked = (glMultiTexCoordP4uiv_PACKED *)packed; \
    glMultiTexCoordP4uiv_ARGS *args = (glMultiTexCoordP4uiv_ARGS *)&unpacked->args; \
    glMultiTexCoordP4uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP4uiv(glMultiTexCoordP4uiv_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordP4uiv(glMultiTexCoordP4uiv_PACKED *_dst glMultiTexCoordP4uiv_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordP4uiv_PTR)(glMultiTexCoordP4uiv_ARG_EXPAND);
#endif
#ifndef glMultiTexCoordPointerEXT_RETURN
#define glMultiTexCoordPointerEXT_RETURN void
#define glMultiTexCoordPointerEXT_ARG_NAMES texunit, size, type, stride, pointer
#define glMultiTexCoordPointerEXT_ARG_EXPAND GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glMultiTexCoordPointerEXT_ARG_NAMES_TAIL , texunit, size, type, stride, pointer
#define glMultiTexCoordPointerEXT_ARG_EXPAND_TAIL , GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glMultiTexCoordPointerEXT(_texunit, _size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexCoordPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexCoordPointerEXT(dst, _texunit, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glMultiTexCoordPointerEXT(packed, ret_v) do { \
    glMultiTexCoordPointerEXT_PACKED *unpacked = (glMultiTexCoordPointerEXT_PACKED *)packed; \
    glMultiTexCoordPointerEXT_ARGS *args = (glMultiTexCoordPointerEXT_ARGS *)&unpacked->args; \
    glMultiTexCoordPointerEXT(args->texunit, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glMultiTexCoordPointerEXT(glMultiTexCoordPointerEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexCoordPointerEXT(glMultiTexCoordPointerEXT_PACKED *_dst glMultiTexCoordPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexCoordPointerEXT_PTR)(glMultiTexCoordPointerEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexEnvfEXT_RETURN
#define glMultiTexEnvfEXT_RETURN void
#define glMultiTexEnvfEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexEnvfEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat param
#define glMultiTexEnvfEXT_ARG_NAMES_TAIL , texunit, target, pname, param
#define glMultiTexEnvfEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLfloat param
#define forward_glMultiTexEnvfEXT(_texunit, _target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexEnvfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexEnvfEXT(dst, _texunit, _target, _pname, _param), NULL); \
    });
#define call_glMultiTexEnvfEXT(packed, ret_v) do { \
    glMultiTexEnvfEXT_PACKED *unpacked = (glMultiTexEnvfEXT_PACKED *)packed; \
    glMultiTexEnvfEXT_ARGS *args = (glMultiTexEnvfEXT_ARGS *)&unpacked->args; \
    glMultiTexEnvfEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexEnvfEXT(glMultiTexEnvfEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexEnvfEXT(glMultiTexEnvfEXT_PACKED *_dst glMultiTexEnvfEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexEnvfEXT_PTR)(glMultiTexEnvfEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexEnvfvEXT_RETURN
#define glMultiTexEnvfvEXT_RETURN void
#define glMultiTexEnvfvEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexEnvfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLfloat * params
#define glMultiTexEnvfvEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glMultiTexEnvfvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, const GLfloat * params
#define forward_glMultiTexEnvfvEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexEnvfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexEnvfvEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glMultiTexEnvfvEXT(packed, ret_v) do { \
    glMultiTexEnvfvEXT_PACKED *unpacked = (glMultiTexEnvfvEXT_PACKED *)packed; \
    glMultiTexEnvfvEXT_ARGS *args = (glMultiTexEnvfvEXT_ARGS *)&unpacked->args; \
    glMultiTexEnvfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexEnvfvEXT(glMultiTexEnvfvEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexEnvfvEXT(glMultiTexEnvfvEXT_PACKED *_dst glMultiTexEnvfvEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexEnvfvEXT_PTR)(glMultiTexEnvfvEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexEnviEXT_RETURN
#define glMultiTexEnviEXT_RETURN void
#define glMultiTexEnviEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexEnviEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint param
#define glMultiTexEnviEXT_ARG_NAMES_TAIL , texunit, target, pname, param
#define glMultiTexEnviEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLint param
#define forward_glMultiTexEnviEXT(_texunit, _target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexEnviEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexEnviEXT(dst, _texunit, _target, _pname, _param), NULL); \
    });
#define call_glMultiTexEnviEXT(packed, ret_v) do { \
    glMultiTexEnviEXT_PACKED *unpacked = (glMultiTexEnviEXT_PACKED *)packed; \
    glMultiTexEnviEXT_ARGS *args = (glMultiTexEnviEXT_ARGS *)&unpacked->args; \
    glMultiTexEnviEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexEnviEXT(glMultiTexEnviEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexEnviEXT(glMultiTexEnviEXT_PACKED *_dst glMultiTexEnviEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexEnviEXT_PTR)(glMultiTexEnviEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexEnvivEXT_RETURN
#define glMultiTexEnvivEXT_RETURN void
#define glMultiTexEnvivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexEnvivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define glMultiTexEnvivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glMultiTexEnvivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define forward_glMultiTexEnvivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexEnvivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexEnvivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glMultiTexEnvivEXT(packed, ret_v) do { \
    glMultiTexEnvivEXT_PACKED *unpacked = (glMultiTexEnvivEXT_PACKED *)packed; \
    glMultiTexEnvivEXT_ARGS *args = (glMultiTexEnvivEXT_ARGS *)&unpacked->args; \
    glMultiTexEnvivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexEnvivEXT(glMultiTexEnvivEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexEnvivEXT(glMultiTexEnvivEXT_PACKED *_dst glMultiTexEnvivEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexEnvivEXT_PTR)(glMultiTexEnvivEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexGendEXT_RETURN
#define glMultiTexGendEXT_RETURN void
#define glMultiTexGendEXT_ARG_NAMES texunit, coord, pname, param
#define glMultiTexGendEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLdouble param
#define glMultiTexGendEXT_ARG_NAMES_TAIL , texunit, coord, pname, param
#define glMultiTexGendEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, GLdouble param
#define forward_glMultiTexGendEXT(_texunit, _coord, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexGendEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexGendEXT(dst, _texunit, _coord, _pname, _param), NULL); \
    });
#define call_glMultiTexGendEXT(packed, ret_v) do { \
    glMultiTexGendEXT_PACKED *unpacked = (glMultiTexGendEXT_PACKED *)packed; \
    glMultiTexGendEXT_ARGS *args = (glMultiTexGendEXT_ARGS *)&unpacked->args; \
    glMultiTexGendEXT(args->texunit, args->coord, args->pname, args->param);; \
} while(0)
void glMultiTexGendEXT(glMultiTexGendEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexGendEXT(glMultiTexGendEXT_PACKED *_dst glMultiTexGendEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexGendEXT_PTR)(glMultiTexGendEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexGendvEXT_RETURN
#define glMultiTexGendvEXT_RETURN void
#define glMultiTexGendvEXT_ARG_NAMES texunit, coord, pname, params
#define glMultiTexGendvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params
#define glMultiTexGendvEXT_ARG_NAMES_TAIL , texunit, coord, pname, params
#define glMultiTexGendvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params
#define forward_glMultiTexGendvEXT(_texunit, _coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexGendvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexGendvEXT(dst, _texunit, _coord, _pname, _params), NULL); \
    });
#define call_glMultiTexGendvEXT(packed, ret_v) do { \
    glMultiTexGendvEXT_PACKED *unpacked = (glMultiTexGendvEXT_PACKED *)packed; \
    glMultiTexGendvEXT_ARGS *args = (glMultiTexGendvEXT_ARGS *)&unpacked->args; \
    glMultiTexGendvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glMultiTexGendvEXT(glMultiTexGendvEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexGendvEXT(glMultiTexGendvEXT_PACKED *_dst glMultiTexGendvEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexGendvEXT_PTR)(glMultiTexGendvEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexGenfEXT_RETURN
#define glMultiTexGenfEXT_RETURN void
#define glMultiTexGenfEXT_ARG_NAMES texunit, coord, pname, param
#define glMultiTexGenfEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLfloat param
#define glMultiTexGenfEXT_ARG_NAMES_TAIL , texunit, coord, pname, param
#define glMultiTexGenfEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, GLfloat param
#define forward_glMultiTexGenfEXT(_texunit, _coord, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexGenfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexGenfEXT(dst, _texunit, _coord, _pname, _param), NULL); \
    });
#define call_glMultiTexGenfEXT(packed, ret_v) do { \
    glMultiTexGenfEXT_PACKED *unpacked = (glMultiTexGenfEXT_PACKED *)packed; \
    glMultiTexGenfEXT_ARGS *args = (glMultiTexGenfEXT_ARGS *)&unpacked->args; \
    glMultiTexGenfEXT(args->texunit, args->coord, args->pname, args->param);; \
} while(0)
void glMultiTexGenfEXT(glMultiTexGenfEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexGenfEXT(glMultiTexGenfEXT_PACKED *_dst glMultiTexGenfEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexGenfEXT_PTR)(glMultiTexGenfEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexGenfvEXT_RETURN
#define glMultiTexGenfvEXT_RETURN void
#define glMultiTexGenfvEXT_ARG_NAMES texunit, coord, pname, params
#define glMultiTexGenfvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params
#define glMultiTexGenfvEXT_ARG_NAMES_TAIL , texunit, coord, pname, params
#define glMultiTexGenfvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params
#define forward_glMultiTexGenfvEXT(_texunit, _coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexGenfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexGenfvEXT(dst, _texunit, _coord, _pname, _params), NULL); \
    });
#define call_glMultiTexGenfvEXT(packed, ret_v) do { \
    glMultiTexGenfvEXT_PACKED *unpacked = (glMultiTexGenfvEXT_PACKED *)packed; \
    glMultiTexGenfvEXT_ARGS *args = (glMultiTexGenfvEXT_ARGS *)&unpacked->args; \
    glMultiTexGenfvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glMultiTexGenfvEXT(glMultiTexGenfvEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexGenfvEXT(glMultiTexGenfvEXT_PACKED *_dst glMultiTexGenfvEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexGenfvEXT_PTR)(glMultiTexGenfvEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexGeniEXT_RETURN
#define glMultiTexGeniEXT_RETURN void
#define glMultiTexGeniEXT_ARG_NAMES texunit, coord, pname, param
#define glMultiTexGeniEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLint param
#define glMultiTexGeniEXT_ARG_NAMES_TAIL , texunit, coord, pname, param
#define glMultiTexGeniEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, GLint param
#define forward_glMultiTexGeniEXT(_texunit, _coord, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexGeniEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexGeniEXT(dst, _texunit, _coord, _pname, _param), NULL); \
    });
#define call_glMultiTexGeniEXT(packed, ret_v) do { \
    glMultiTexGeniEXT_PACKED *unpacked = (glMultiTexGeniEXT_PACKED *)packed; \
    glMultiTexGeniEXT_ARGS *args = (glMultiTexGeniEXT_ARGS *)&unpacked->args; \
    glMultiTexGeniEXT(args->texunit, args->coord, args->pname, args->param);; \
} while(0)
void glMultiTexGeniEXT(glMultiTexGeniEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexGeniEXT(glMultiTexGeniEXT_PACKED *_dst glMultiTexGeniEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexGeniEXT_PTR)(glMultiTexGeniEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexGenivEXT_RETURN
#define glMultiTexGenivEXT_RETURN void
#define glMultiTexGenivEXT_ARG_NAMES texunit, coord, pname, params
#define glMultiTexGenivEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, const GLint * params
#define glMultiTexGenivEXT_ARG_NAMES_TAIL , texunit, coord, pname, params
#define glMultiTexGenivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum coord, GLenum pname, const GLint * params
#define forward_glMultiTexGenivEXT(_texunit, _coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexGenivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexGenivEXT(dst, _texunit, _coord, _pname, _params), NULL); \
    });
#define call_glMultiTexGenivEXT(packed, ret_v) do { \
    glMultiTexGenivEXT_PACKED *unpacked = (glMultiTexGenivEXT_PACKED *)packed; \
    glMultiTexGenivEXT_ARGS *args = (glMultiTexGenivEXT_ARGS *)&unpacked->args; \
    glMultiTexGenivEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glMultiTexGenivEXT(glMultiTexGenivEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexGenivEXT(glMultiTexGenivEXT_PACKED *_dst glMultiTexGenivEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexGenivEXT_PTR)(glMultiTexGenivEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexImage1DEXT_RETURN
#define glMultiTexImage1DEXT_RETURN void
#define glMultiTexImage1DEXT_ARG_NAMES texunit, target, level, internalformat, width, border, format, type, pixels
#define glMultiTexImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexImage1DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, width, border, format, type, pixels
#define glMultiTexImage1DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glMultiTexImage1DEXT(_texunit, _target, _level, _internalformat, _width, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexImage1DEXT(dst, _texunit, _target, _level, _internalformat, _width, _border, _format, _type, _pixels), NULL); \
    });
#define call_glMultiTexImage1DEXT(packed, ret_v) do { \
    glMultiTexImage1DEXT_PACKED *unpacked = (glMultiTexImage1DEXT_PACKED *)packed; \
    glMultiTexImage1DEXT_ARGS *args = (glMultiTexImage1DEXT_ARGS *)&unpacked->args; \
    glMultiTexImage1DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexImage1DEXT(glMultiTexImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexImage1DEXT(glMultiTexImage1DEXT_PACKED *_dst glMultiTexImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexImage1DEXT_PTR)(glMultiTexImage1DEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexImage2DEXT_RETURN
#define glMultiTexImage2DEXT_RETURN void
#define glMultiTexImage2DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, border, format, type, pixels
#define glMultiTexImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexImage2DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, width, height, border, format, type, pixels
#define glMultiTexImage2DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glMultiTexImage2DEXT(_texunit, _target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexImage2DEXT(dst, _texunit, _target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels), NULL); \
    });
#define call_glMultiTexImage2DEXT(packed, ret_v) do { \
    glMultiTexImage2DEXT_PACKED *unpacked = (glMultiTexImage2DEXT_PACKED *)packed; \
    glMultiTexImage2DEXT_ARGS *args = (glMultiTexImage2DEXT_ARGS *)&unpacked->args; \
    glMultiTexImage2DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexImage2DEXT(glMultiTexImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexImage2DEXT(glMultiTexImage2DEXT_PACKED *_dst glMultiTexImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexImage2DEXT_PTR)(glMultiTexImage2DEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexImage3DEXT_RETURN
#define glMultiTexImage3DEXT_RETURN void
#define glMultiTexImage3DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, depth, border, format, type, pixels
#define glMultiTexImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexImage3DEXT_ARG_NAMES_TAIL , texunit, target, level, internalformat, width, height, depth, border, format, type, pixels
#define glMultiTexImage3DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glMultiTexImage3DEXT(_texunit, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexImage3DEXT(dst, _texunit, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels), NULL); \
    });
#define call_glMultiTexImage3DEXT(packed, ret_v) do { \
    glMultiTexImage3DEXT_PACKED *unpacked = (glMultiTexImage3DEXT_PACKED *)packed; \
    glMultiTexImage3DEXT_ARGS *args = (glMultiTexImage3DEXT_ARGS *)&unpacked->args; \
    glMultiTexImage3DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexImage3DEXT(glMultiTexImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexImage3DEXT(glMultiTexImage3DEXT_PACKED *_dst glMultiTexImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexImage3DEXT_PTR)(glMultiTexImage3DEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexParameterIivEXT_RETURN
#define glMultiTexParameterIivEXT_RETURN void
#define glMultiTexParameterIivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterIivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define glMultiTexParameterIivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glMultiTexParameterIivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define forward_glMultiTexParameterIivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexParameterIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexParameterIivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glMultiTexParameterIivEXT(packed, ret_v) do { \
    glMultiTexParameterIivEXT_PACKED *unpacked = (glMultiTexParameterIivEXT_PACKED *)packed; \
    glMultiTexParameterIivEXT_ARGS *args = (glMultiTexParameterIivEXT_ARGS *)&unpacked->args; \
    glMultiTexParameterIivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterIivEXT(glMultiTexParameterIivEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexParameterIivEXT(glMultiTexParameterIivEXT_PACKED *_dst glMultiTexParameterIivEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexParameterIivEXT_PTR)(glMultiTexParameterIivEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexParameterIuivEXT_RETURN
#define glMultiTexParameterIuivEXT_RETURN void
#define glMultiTexParameterIuivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterIuivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLuint * params
#define glMultiTexParameterIuivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glMultiTexParameterIuivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, const GLuint * params
#define forward_glMultiTexParameterIuivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexParameterIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexParameterIuivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glMultiTexParameterIuivEXT(packed, ret_v) do { \
    glMultiTexParameterIuivEXT_PACKED *unpacked = (glMultiTexParameterIuivEXT_PACKED *)packed; \
    glMultiTexParameterIuivEXT_ARGS *args = (glMultiTexParameterIuivEXT_ARGS *)&unpacked->args; \
    glMultiTexParameterIuivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterIuivEXT(glMultiTexParameterIuivEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexParameterIuivEXT(glMultiTexParameterIuivEXT_PACKED *_dst glMultiTexParameterIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexParameterIuivEXT_PTR)(glMultiTexParameterIuivEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexParameterfEXT_RETURN
#define glMultiTexParameterfEXT_RETURN void
#define glMultiTexParameterfEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexParameterfEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat param
#define glMultiTexParameterfEXT_ARG_NAMES_TAIL , texunit, target, pname, param
#define glMultiTexParameterfEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLfloat param
#define forward_glMultiTexParameterfEXT(_texunit, _target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexParameterfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexParameterfEXT(dst, _texunit, _target, _pname, _param), NULL); \
    });
#define call_glMultiTexParameterfEXT(packed, ret_v) do { \
    glMultiTexParameterfEXT_PACKED *unpacked = (glMultiTexParameterfEXT_PACKED *)packed; \
    glMultiTexParameterfEXT_ARGS *args = (glMultiTexParameterfEXT_ARGS *)&unpacked->args; \
    glMultiTexParameterfEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexParameterfEXT(glMultiTexParameterfEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexParameterfEXT(glMultiTexParameterfEXT_PACKED *_dst glMultiTexParameterfEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexParameterfEXT_PTR)(glMultiTexParameterfEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexParameterfvEXT_RETURN
#define glMultiTexParameterfvEXT_RETURN void
#define glMultiTexParameterfvEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLfloat * params
#define glMultiTexParameterfvEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glMultiTexParameterfvEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, const GLfloat * params
#define forward_glMultiTexParameterfvEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexParameterfvEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glMultiTexParameterfvEXT(packed, ret_v) do { \
    glMultiTexParameterfvEXT_PACKED *unpacked = (glMultiTexParameterfvEXT_PACKED *)packed; \
    glMultiTexParameterfvEXT_ARGS *args = (glMultiTexParameterfvEXT_ARGS *)&unpacked->args; \
    glMultiTexParameterfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterfvEXT(glMultiTexParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexParameterfvEXT(glMultiTexParameterfvEXT_PACKED *_dst glMultiTexParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexParameterfvEXT_PTR)(glMultiTexParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexParameteriEXT_RETURN
#define glMultiTexParameteriEXT_RETURN void
#define glMultiTexParameteriEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexParameteriEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint param
#define glMultiTexParameteriEXT_ARG_NAMES_TAIL , texunit, target, pname, param
#define glMultiTexParameteriEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, GLint param
#define forward_glMultiTexParameteriEXT(_texunit, _target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexParameteriEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexParameteriEXT(dst, _texunit, _target, _pname, _param), NULL); \
    });
#define call_glMultiTexParameteriEXT(packed, ret_v) do { \
    glMultiTexParameteriEXT_PACKED *unpacked = (glMultiTexParameteriEXT_PACKED *)packed; \
    glMultiTexParameteriEXT_ARGS *args = (glMultiTexParameteriEXT_ARGS *)&unpacked->args; \
    glMultiTexParameteriEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexParameteriEXT(glMultiTexParameteriEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexParameteriEXT(glMultiTexParameteriEXT_PACKED *_dst glMultiTexParameteriEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexParameteriEXT_PTR)(glMultiTexParameteriEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexParameterivEXT_RETURN
#define glMultiTexParameterivEXT_RETURN void
#define glMultiTexParameterivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define glMultiTexParameterivEXT_ARG_NAMES_TAIL , texunit, target, pname, params
#define glMultiTexParameterivEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define forward_glMultiTexParameterivEXT(_texunit, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexParameterivEXT(dst, _texunit, _target, _pname, _params), NULL); \
    });
#define call_glMultiTexParameterivEXT(packed, ret_v) do { \
    glMultiTexParameterivEXT_PACKED *unpacked = (glMultiTexParameterivEXT_PACKED *)packed; \
    glMultiTexParameterivEXT_ARGS *args = (glMultiTexParameterivEXT_ARGS *)&unpacked->args; \
    glMultiTexParameterivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterivEXT(glMultiTexParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexParameterivEXT(glMultiTexParameterivEXT_PACKED *_dst glMultiTexParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexParameterivEXT_PTR)(glMultiTexParameterivEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexRenderbufferEXT_RETURN
#define glMultiTexRenderbufferEXT_RETURN void
#define glMultiTexRenderbufferEXT_ARG_NAMES texunit, target, renderbuffer
#define glMultiTexRenderbufferEXT_ARG_EXPAND GLenum texunit, GLenum target, GLuint renderbuffer
#define glMultiTexRenderbufferEXT_ARG_NAMES_TAIL , texunit, target, renderbuffer
#define glMultiTexRenderbufferEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLuint renderbuffer
#define forward_glMultiTexRenderbufferEXT(_texunit, _target, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexRenderbufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexRenderbufferEXT(dst, _texunit, _target, _renderbuffer), NULL); \
    });
#define call_glMultiTexRenderbufferEXT(packed, ret_v) do { \
    glMultiTexRenderbufferEXT_PACKED *unpacked = (glMultiTexRenderbufferEXT_PACKED *)packed; \
    glMultiTexRenderbufferEXT_ARGS *args = (glMultiTexRenderbufferEXT_ARGS *)&unpacked->args; \
    glMultiTexRenderbufferEXT(args->texunit, args->target, args->renderbuffer);; \
} while(0)
void glMultiTexRenderbufferEXT(glMultiTexRenderbufferEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexRenderbufferEXT(glMultiTexRenderbufferEXT_PACKED *_dst glMultiTexRenderbufferEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexRenderbufferEXT_PTR)(glMultiTexRenderbufferEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexSubImage1DEXT_RETURN
#define glMultiTexSubImage1DEXT_RETURN void
#define glMultiTexSubImage1DEXT_ARG_NAMES texunit, target, level, xoffset, width, format, type, pixels
#define glMultiTexSubImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexSubImage1DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, width, format, type, pixels
#define glMultiTexSubImage1DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glMultiTexSubImage1DEXT(_texunit, _target, _level, _xoffset, _width, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexSubImage1DEXT(dst, _texunit, _target, _level, _xoffset, _width, _format, _type, _pixels), NULL); \
    });
#define call_glMultiTexSubImage1DEXT(packed, ret_v) do { \
    glMultiTexSubImage1DEXT_PACKED *unpacked = (glMultiTexSubImage1DEXT_PACKED *)packed; \
    glMultiTexSubImage1DEXT_ARGS *args = (glMultiTexSubImage1DEXT_ARGS *)&unpacked->args; \
    glMultiTexSubImage1DEXT(args->texunit, args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexSubImage1DEXT(glMultiTexSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexSubImage1DEXT(glMultiTexSubImage1DEXT_PACKED *_dst glMultiTexSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexSubImage1DEXT_PTR)(glMultiTexSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexSubImage2DEXT_RETURN
#define glMultiTexSubImage2DEXT_RETURN void
#define glMultiTexSubImage2DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, width, height, format, type, pixels
#define glMultiTexSubImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexSubImage2DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, yoffset, width, height, format, type, pixels
#define glMultiTexSubImage2DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glMultiTexSubImage2DEXT(_texunit, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexSubImage2DEXT(dst, _texunit, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels), NULL); \
    });
#define call_glMultiTexSubImage2DEXT(packed, ret_v) do { \
    glMultiTexSubImage2DEXT_PACKED *unpacked = (glMultiTexSubImage2DEXT_PACKED *)packed; \
    glMultiTexSubImage2DEXT_ARGS *args = (glMultiTexSubImage2DEXT_ARGS *)&unpacked->args; \
    glMultiTexSubImage2DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexSubImage2DEXT(glMultiTexSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexSubImage2DEXT(glMultiTexSubImage2DEXT_PACKED *_dst glMultiTexSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexSubImage2DEXT_PTR)(glMultiTexSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glMultiTexSubImage3DEXT_RETURN
#define glMultiTexSubImage3DEXT_RETURN void
#define glMultiTexSubImage3DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glMultiTexSubImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexSubImage3DEXT_ARG_NAMES_TAIL , texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glMultiTexSubImage3DEXT_ARG_EXPAND_TAIL , GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glMultiTexSubImage3DEXT(_texunit, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glMultiTexSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glMultiTexSubImage3DEXT(dst, _texunit, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels), NULL); \
    });
#define call_glMultiTexSubImage3DEXT(packed, ret_v) do { \
    glMultiTexSubImage3DEXT_PACKED *unpacked = (glMultiTexSubImage3DEXT_PACKED *)packed; \
    glMultiTexSubImage3DEXT_ARGS *args = (glMultiTexSubImage3DEXT_ARGS *)&unpacked->args; \
    glMultiTexSubImage3DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexSubImage3DEXT(glMultiTexSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glMultiTexSubImage3DEXT(glMultiTexSubImage3DEXT_PACKED *_dst glMultiTexSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glMultiTexSubImage3DEXT_PTR)(glMultiTexSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glNamedBufferDataEXT_RETURN
#define glNamedBufferDataEXT_RETURN void
#define glNamedBufferDataEXT_ARG_NAMES buffer, size, data, usage
#define glNamedBufferDataEXT_ARG_EXPAND GLuint buffer, GLsizeiptr size, const GLvoid * data, GLenum usage
#define glNamedBufferDataEXT_ARG_NAMES_TAIL , buffer, size, data, usage
#define glNamedBufferDataEXT_ARG_EXPAND_TAIL , GLuint buffer, GLsizeiptr size, const GLvoid * data, GLenum usage
#define forward_glNamedBufferDataEXT(_buffer, _size, _data, _usage) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedBufferDataEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedBufferDataEXT(dst, _buffer, _size, _data, _usage), NULL); \
    });
#define call_glNamedBufferDataEXT(packed, ret_v) do { \
    glNamedBufferDataEXT_PACKED *unpacked = (glNamedBufferDataEXT_PACKED *)packed; \
    glNamedBufferDataEXT_ARGS *args = (glNamedBufferDataEXT_ARGS *)&unpacked->args; \
    glNamedBufferDataEXT(args->buffer, args->size, args->data, args->usage);; \
} while(0)
void glNamedBufferDataEXT(glNamedBufferDataEXT_ARG_EXPAND);
packed_call_t *pack_glNamedBufferDataEXT(glNamedBufferDataEXT_PACKED *_dst glNamedBufferDataEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedBufferDataEXT_PTR)(glNamedBufferDataEXT_ARG_EXPAND);
#endif
#ifndef glNamedBufferSubDataEXT_RETURN
#define glNamedBufferSubDataEXT_RETURN void
#define glNamedBufferSubDataEXT_ARG_NAMES buffer, offset, size, data
#define glNamedBufferSubDataEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid * data
#define glNamedBufferSubDataEXT_ARG_NAMES_TAIL , buffer, offset, size, data
#define glNamedBufferSubDataEXT_ARG_EXPAND_TAIL , GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid * data
#define forward_glNamedBufferSubDataEXT(_buffer, _offset, _size, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedBufferSubDataEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedBufferSubDataEXT(dst, _buffer, _offset, _size, _data), NULL); \
    });
#define call_glNamedBufferSubDataEXT(packed, ret_v) do { \
    glNamedBufferSubDataEXT_PACKED *unpacked = (glNamedBufferSubDataEXT_PACKED *)packed; \
    glNamedBufferSubDataEXT_ARGS *args = (glNamedBufferSubDataEXT_ARGS *)&unpacked->args; \
    glNamedBufferSubDataEXT(args->buffer, args->offset, args->size, args->data);; \
} while(0)
void glNamedBufferSubDataEXT(glNamedBufferSubDataEXT_ARG_EXPAND);
packed_call_t *pack_glNamedBufferSubDataEXT(glNamedBufferSubDataEXT_PACKED *_dst glNamedBufferSubDataEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedBufferSubDataEXT_PTR)(glNamedBufferSubDataEXT_ARG_EXPAND);
#endif
#ifndef glNamedCopyBufferSubDataEXT_RETURN
#define glNamedCopyBufferSubDataEXT_RETURN void
#define glNamedCopyBufferSubDataEXT_ARG_NAMES readBuffer, writeBuffer, readOffset, writeOffset, size
#define glNamedCopyBufferSubDataEXT_ARG_EXPAND GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size
#define glNamedCopyBufferSubDataEXT_ARG_NAMES_TAIL , readBuffer, writeBuffer, readOffset, writeOffset, size
#define glNamedCopyBufferSubDataEXT_ARG_EXPAND_TAIL , GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size
#define forward_glNamedCopyBufferSubDataEXT(_readBuffer, _writeBuffer, _readOffset, _writeOffset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedCopyBufferSubDataEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedCopyBufferSubDataEXT(dst, _readBuffer, _writeBuffer, _readOffset, _writeOffset, _size), NULL); \
    });
#define call_glNamedCopyBufferSubDataEXT(packed, ret_v) do { \
    glNamedCopyBufferSubDataEXT_PACKED *unpacked = (glNamedCopyBufferSubDataEXT_PACKED *)packed; \
    glNamedCopyBufferSubDataEXT_ARGS *args = (glNamedCopyBufferSubDataEXT_ARGS *)&unpacked->args; \
    glNamedCopyBufferSubDataEXT(args->readBuffer, args->writeBuffer, args->readOffset, args->writeOffset, args->size);; \
} while(0)
void glNamedCopyBufferSubDataEXT(glNamedCopyBufferSubDataEXT_ARG_EXPAND);
packed_call_t *pack_glNamedCopyBufferSubDataEXT(glNamedCopyBufferSubDataEXT_PACKED *_dst glNamedCopyBufferSubDataEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedCopyBufferSubDataEXT_PTR)(glNamedCopyBufferSubDataEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferParameteriEXT_RETURN
#define glNamedFramebufferParameteriEXT_RETURN void
#define glNamedFramebufferParameteriEXT_ARG_NAMES framebuffer, pname, param
#define glNamedFramebufferParameteriEXT_ARG_EXPAND GLuint framebuffer, GLenum pname, GLint param
#define glNamedFramebufferParameteriEXT_ARG_NAMES_TAIL , framebuffer, pname, param
#define glNamedFramebufferParameteriEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum pname, GLint param
#define forward_glNamedFramebufferParameteriEXT(_framebuffer, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferParameteriEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferParameteriEXT(dst, _framebuffer, _pname, _param), NULL); \
    });
#define call_glNamedFramebufferParameteriEXT(packed, ret_v) do { \
    glNamedFramebufferParameteriEXT_PACKED *unpacked = (glNamedFramebufferParameteriEXT_PACKED *)packed; \
    glNamedFramebufferParameteriEXT_ARGS *args = (glNamedFramebufferParameteriEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferParameteriEXT(args->framebuffer, args->pname, args->param);; \
} while(0)
void glNamedFramebufferParameteriEXT(glNamedFramebufferParameteriEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferParameteriEXT(glNamedFramebufferParameteriEXT_PACKED *_dst glNamedFramebufferParameteriEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferParameteriEXT_PTR)(glNamedFramebufferParameteriEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferRenderbufferEXT_RETURN
#define glNamedFramebufferRenderbufferEXT_RETURN void
#define glNamedFramebufferRenderbufferEXT_ARG_NAMES framebuffer, attachment, renderbuffertarget, renderbuffer
#define glNamedFramebufferRenderbufferEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define glNamedFramebufferRenderbufferEXT_ARG_NAMES_TAIL , framebuffer, attachment, renderbuffertarget, renderbuffer
#define glNamedFramebufferRenderbufferEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define forward_glNamedFramebufferRenderbufferEXT(_framebuffer, _attachment, _renderbuffertarget, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferRenderbufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferRenderbufferEXT(dst, _framebuffer, _attachment, _renderbuffertarget, _renderbuffer), NULL); \
    });
#define call_glNamedFramebufferRenderbufferEXT(packed, ret_v) do { \
    glNamedFramebufferRenderbufferEXT_PACKED *unpacked = (glNamedFramebufferRenderbufferEXT_PACKED *)packed; \
    glNamedFramebufferRenderbufferEXT_ARGS *args = (glNamedFramebufferRenderbufferEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferRenderbufferEXT(args->framebuffer, args->attachment, args->renderbuffertarget, args->renderbuffer);; \
} while(0)
void glNamedFramebufferRenderbufferEXT(glNamedFramebufferRenderbufferEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferRenderbufferEXT(glNamedFramebufferRenderbufferEXT_PACKED *_dst glNamedFramebufferRenderbufferEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferRenderbufferEXT_PTR)(glNamedFramebufferRenderbufferEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferTexture1DEXT_RETURN
#define glNamedFramebufferTexture1DEXT_RETURN void
#define glNamedFramebufferTexture1DEXT_ARG_NAMES framebuffer, attachment, textarget, texture, level
#define glNamedFramebufferTexture1DEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glNamedFramebufferTexture1DEXT_ARG_NAMES_TAIL , framebuffer, attachment, textarget, texture, level
#define glNamedFramebufferTexture1DEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define forward_glNamedFramebufferTexture1DEXT(_framebuffer, _attachment, _textarget, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferTexture1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferTexture1DEXT(dst, _framebuffer, _attachment, _textarget, _texture, _level), NULL); \
    });
#define call_glNamedFramebufferTexture1DEXT(packed, ret_v) do { \
    glNamedFramebufferTexture1DEXT_PACKED *unpacked = (glNamedFramebufferTexture1DEXT_PACKED *)packed; \
    glNamedFramebufferTexture1DEXT_ARGS *args = (glNamedFramebufferTexture1DEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferTexture1DEXT(args->framebuffer, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glNamedFramebufferTexture1DEXT(glNamedFramebufferTexture1DEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferTexture1DEXT(glNamedFramebufferTexture1DEXT_PACKED *_dst glNamedFramebufferTexture1DEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferTexture1DEXT_PTR)(glNamedFramebufferTexture1DEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferTexture2DEXT_RETURN
#define glNamedFramebufferTexture2DEXT_RETURN void
#define glNamedFramebufferTexture2DEXT_ARG_NAMES framebuffer, attachment, textarget, texture, level
#define glNamedFramebufferTexture2DEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glNamedFramebufferTexture2DEXT_ARG_NAMES_TAIL , framebuffer, attachment, textarget, texture, level
#define glNamedFramebufferTexture2DEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define forward_glNamedFramebufferTexture2DEXT(_framebuffer, _attachment, _textarget, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferTexture2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferTexture2DEXT(dst, _framebuffer, _attachment, _textarget, _texture, _level), NULL); \
    });
#define call_glNamedFramebufferTexture2DEXT(packed, ret_v) do { \
    glNamedFramebufferTexture2DEXT_PACKED *unpacked = (glNamedFramebufferTexture2DEXT_PACKED *)packed; \
    glNamedFramebufferTexture2DEXT_ARGS *args = (glNamedFramebufferTexture2DEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferTexture2DEXT(args->framebuffer, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glNamedFramebufferTexture2DEXT(glNamedFramebufferTexture2DEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferTexture2DEXT(glNamedFramebufferTexture2DEXT_PACKED *_dst glNamedFramebufferTexture2DEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferTexture2DEXT_PTR)(glNamedFramebufferTexture2DEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferTexture3DEXT_RETURN
#define glNamedFramebufferTexture3DEXT_RETURN void
#define glNamedFramebufferTexture3DEXT_ARG_NAMES framebuffer, attachment, textarget, texture, level, zoffset
#define glNamedFramebufferTexture3DEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define glNamedFramebufferTexture3DEXT_ARG_NAMES_TAIL , framebuffer, attachment, textarget, texture, level, zoffset
#define glNamedFramebufferTexture3DEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define forward_glNamedFramebufferTexture3DEXT(_framebuffer, _attachment, _textarget, _texture, _level, _zoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferTexture3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferTexture3DEXT(dst, _framebuffer, _attachment, _textarget, _texture, _level, _zoffset), NULL); \
    });
#define call_glNamedFramebufferTexture3DEXT(packed, ret_v) do { \
    glNamedFramebufferTexture3DEXT_PACKED *unpacked = (glNamedFramebufferTexture3DEXT_PACKED *)packed; \
    glNamedFramebufferTexture3DEXT_ARGS *args = (glNamedFramebufferTexture3DEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferTexture3DEXT(args->framebuffer, args->attachment, args->textarget, args->texture, args->level, args->zoffset);; \
} while(0)
void glNamedFramebufferTexture3DEXT(glNamedFramebufferTexture3DEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferTexture3DEXT(glNamedFramebufferTexture3DEXT_PACKED *_dst glNamedFramebufferTexture3DEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferTexture3DEXT_PTR)(glNamedFramebufferTexture3DEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferTextureEXT_RETURN
#define glNamedFramebufferTextureEXT_RETURN void
#define glNamedFramebufferTextureEXT_ARG_NAMES framebuffer, attachment, texture, level
#define glNamedFramebufferTextureEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLuint texture, GLint level
#define glNamedFramebufferTextureEXT_ARG_NAMES_TAIL , framebuffer, attachment, texture, level
#define glNamedFramebufferTextureEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLuint texture, GLint level
#define forward_glNamedFramebufferTextureEXT(_framebuffer, _attachment, _texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferTextureEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferTextureEXT(dst, _framebuffer, _attachment, _texture, _level), NULL); \
    });
#define call_glNamedFramebufferTextureEXT(packed, ret_v) do { \
    glNamedFramebufferTextureEXT_PACKED *unpacked = (glNamedFramebufferTextureEXT_PACKED *)packed; \
    glNamedFramebufferTextureEXT_ARGS *args = (glNamedFramebufferTextureEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferTextureEXT(args->framebuffer, args->attachment, args->texture, args->level);; \
} while(0)
void glNamedFramebufferTextureEXT(glNamedFramebufferTextureEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferTextureEXT(glNamedFramebufferTextureEXT_PACKED *_dst glNamedFramebufferTextureEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferTextureEXT_PTR)(glNamedFramebufferTextureEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferTextureFaceEXT_RETURN
#define glNamedFramebufferTextureFaceEXT_RETURN void
#define glNamedFramebufferTextureFaceEXT_ARG_NAMES framebuffer, attachment, texture, level, face
#define glNamedFramebufferTextureFaceEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face
#define glNamedFramebufferTextureFaceEXT_ARG_NAMES_TAIL , framebuffer, attachment, texture, level, face
#define glNamedFramebufferTextureFaceEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face
#define forward_glNamedFramebufferTextureFaceEXT(_framebuffer, _attachment, _texture, _level, _face) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferTextureFaceEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferTextureFaceEXT(dst, _framebuffer, _attachment, _texture, _level, _face), NULL); \
    });
#define call_glNamedFramebufferTextureFaceEXT(packed, ret_v) do { \
    glNamedFramebufferTextureFaceEXT_PACKED *unpacked = (glNamedFramebufferTextureFaceEXT_PACKED *)packed; \
    glNamedFramebufferTextureFaceEXT_ARGS *args = (glNamedFramebufferTextureFaceEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferTextureFaceEXT(args->framebuffer, args->attachment, args->texture, args->level, args->face);; \
} while(0)
void glNamedFramebufferTextureFaceEXT(glNamedFramebufferTextureFaceEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferTextureFaceEXT(glNamedFramebufferTextureFaceEXT_PACKED *_dst glNamedFramebufferTextureFaceEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferTextureFaceEXT_PTR)(glNamedFramebufferTextureFaceEXT_ARG_EXPAND);
#endif
#ifndef glNamedFramebufferTextureLayerEXT_RETURN
#define glNamedFramebufferTextureLayerEXT_RETURN void
#define glNamedFramebufferTextureLayerEXT_ARG_NAMES framebuffer, attachment, texture, level, layer
#define glNamedFramebufferTextureLayerEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glNamedFramebufferTextureLayerEXT_ARG_NAMES_TAIL , framebuffer, attachment, texture, level, layer
#define glNamedFramebufferTextureLayerEXT_ARG_EXPAND_TAIL , GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer
#define forward_glNamedFramebufferTextureLayerEXT(_framebuffer, _attachment, _texture, _level, _layer) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedFramebufferTextureLayerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedFramebufferTextureLayerEXT(dst, _framebuffer, _attachment, _texture, _level, _layer), NULL); \
    });
#define call_glNamedFramebufferTextureLayerEXT(packed, ret_v) do { \
    glNamedFramebufferTextureLayerEXT_PACKED *unpacked = (glNamedFramebufferTextureLayerEXT_PACKED *)packed; \
    glNamedFramebufferTextureLayerEXT_ARGS *args = (glNamedFramebufferTextureLayerEXT_ARGS *)&unpacked->args; \
    glNamedFramebufferTextureLayerEXT(args->framebuffer, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glNamedFramebufferTextureLayerEXT(glNamedFramebufferTextureLayerEXT_ARG_EXPAND);
packed_call_t *pack_glNamedFramebufferTextureLayerEXT(glNamedFramebufferTextureLayerEXT_PACKED *_dst glNamedFramebufferTextureLayerEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedFramebufferTextureLayerEXT_PTR)(glNamedFramebufferTextureLayerEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameter4dEXT_RETURN
#define glNamedProgramLocalParameter4dEXT_RETURN void
#define glNamedProgramLocalParameter4dEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameter4dEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glNamedProgramLocalParameter4dEXT_ARG_NAMES_TAIL , program, target, index, x, y, z, w
#define glNamedProgramLocalParameter4dEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glNamedProgramLocalParameter4dEXT(_program, _target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameter4dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameter4dEXT(dst, _program, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glNamedProgramLocalParameter4dEXT(packed, ret_v) do { \
    glNamedProgramLocalParameter4dEXT_PACKED *unpacked = (glNamedProgramLocalParameter4dEXT_PACKED *)packed; \
    glNamedProgramLocalParameter4dEXT_ARGS *args = (glNamedProgramLocalParameter4dEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameter4dEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameter4dEXT(glNamedProgramLocalParameter4dEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameter4dEXT(glNamedProgramLocalParameter4dEXT_PACKED *_dst glNamedProgramLocalParameter4dEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameter4dEXT_PTR)(glNamedProgramLocalParameter4dEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameter4dvEXT_RETURN
#define glNamedProgramLocalParameter4dvEXT_RETURN void
#define glNamedProgramLocalParameter4dvEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameter4dvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLdouble * params
#define glNamedProgramLocalParameter4dvEXT_ARG_NAMES_TAIL , program, target, index, params
#define glNamedProgramLocalParameter4dvEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, const GLdouble * params
#define forward_glNamedProgramLocalParameter4dvEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameter4dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameter4dvEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glNamedProgramLocalParameter4dvEXT(packed, ret_v) do { \
    glNamedProgramLocalParameter4dvEXT_PACKED *unpacked = (glNamedProgramLocalParameter4dvEXT_PACKED *)packed; \
    glNamedProgramLocalParameter4dvEXT_ARGS *args = (glNamedProgramLocalParameter4dvEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameter4dvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameter4dvEXT(glNamedProgramLocalParameter4dvEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameter4dvEXT(glNamedProgramLocalParameter4dvEXT_PACKED *_dst glNamedProgramLocalParameter4dvEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameter4dvEXT_PTR)(glNamedProgramLocalParameter4dvEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameter4fEXT_RETURN
#define glNamedProgramLocalParameter4fEXT_RETURN void
#define glNamedProgramLocalParameter4fEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameter4fEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glNamedProgramLocalParameter4fEXT_ARG_NAMES_TAIL , program, target, index, x, y, z, w
#define glNamedProgramLocalParameter4fEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glNamedProgramLocalParameter4fEXT(_program, _target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameter4fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameter4fEXT(dst, _program, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glNamedProgramLocalParameter4fEXT(packed, ret_v) do { \
    glNamedProgramLocalParameter4fEXT_PACKED *unpacked = (glNamedProgramLocalParameter4fEXT_PACKED *)packed; \
    glNamedProgramLocalParameter4fEXT_ARGS *args = (glNamedProgramLocalParameter4fEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameter4fEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameter4fEXT(glNamedProgramLocalParameter4fEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameter4fEXT(glNamedProgramLocalParameter4fEXT_PACKED *_dst glNamedProgramLocalParameter4fEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameter4fEXT_PTR)(glNamedProgramLocalParameter4fEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameter4fvEXT_RETURN
#define glNamedProgramLocalParameter4fvEXT_RETURN void
#define glNamedProgramLocalParameter4fvEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameter4fvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLfloat * params
#define glNamedProgramLocalParameter4fvEXT_ARG_NAMES_TAIL , program, target, index, params
#define glNamedProgramLocalParameter4fvEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, const GLfloat * params
#define forward_glNamedProgramLocalParameter4fvEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameter4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameter4fvEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glNamedProgramLocalParameter4fvEXT(packed, ret_v) do { \
    glNamedProgramLocalParameter4fvEXT_PACKED *unpacked = (glNamedProgramLocalParameter4fvEXT_PACKED *)packed; \
    glNamedProgramLocalParameter4fvEXT_ARGS *args = (glNamedProgramLocalParameter4fvEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameter4fvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameter4fvEXT(glNamedProgramLocalParameter4fvEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameter4fvEXT(glNamedProgramLocalParameter4fvEXT_PACKED *_dst glNamedProgramLocalParameter4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameter4fvEXT_PTR)(glNamedProgramLocalParameter4fvEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameterI4iEXT_RETURN
#define glNamedProgramLocalParameterI4iEXT_RETURN void
#define glNamedProgramLocalParameterI4iEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameterI4iEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define glNamedProgramLocalParameterI4iEXT_ARG_NAMES_TAIL , program, target, index, x, y, z, w
#define glNamedProgramLocalParameterI4iEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define forward_glNamedProgramLocalParameterI4iEXT(_program, _target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameterI4iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameterI4iEXT(dst, _program, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glNamedProgramLocalParameterI4iEXT(packed, ret_v) do { \
    glNamedProgramLocalParameterI4iEXT_PACKED *unpacked = (glNamedProgramLocalParameterI4iEXT_PACKED *)packed; \
    glNamedProgramLocalParameterI4iEXT_ARGS *args = (glNamedProgramLocalParameterI4iEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameterI4iEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameterI4iEXT(glNamedProgramLocalParameterI4iEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameterI4iEXT(glNamedProgramLocalParameterI4iEXT_PACKED *_dst glNamedProgramLocalParameterI4iEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameterI4iEXT_PTR)(glNamedProgramLocalParameterI4iEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameterI4ivEXT_RETURN
#define glNamedProgramLocalParameterI4ivEXT_RETURN void
#define glNamedProgramLocalParameterI4ivEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLint * params
#define glNamedProgramLocalParameterI4ivEXT_ARG_NAMES_TAIL , program, target, index, params
#define glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, const GLint * params
#define forward_glNamedProgramLocalParameterI4ivEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameterI4ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameterI4ivEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glNamedProgramLocalParameterI4ivEXT(packed, ret_v) do { \
    glNamedProgramLocalParameterI4ivEXT_PACKED *unpacked = (glNamedProgramLocalParameterI4ivEXT_PACKED *)packed; \
    glNamedProgramLocalParameterI4ivEXT_ARGS *args = (glNamedProgramLocalParameterI4ivEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameterI4ivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameterI4ivEXT(glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameterI4ivEXT(glNamedProgramLocalParameterI4ivEXT_PACKED *_dst glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameterI4ivEXT_PTR)(glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameterI4uiEXT_RETURN
#define glNamedProgramLocalParameterI4uiEXT_RETURN void
#define glNamedProgramLocalParameterI4uiEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glNamedProgramLocalParameterI4uiEXT_ARG_NAMES_TAIL , program, target, index, x, y, z, w
#define glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define forward_glNamedProgramLocalParameterI4uiEXT(_program, _target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameterI4uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameterI4uiEXT(dst, _program, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glNamedProgramLocalParameterI4uiEXT(packed, ret_v) do { \
    glNamedProgramLocalParameterI4uiEXT_PACKED *unpacked = (glNamedProgramLocalParameterI4uiEXT_PACKED *)packed; \
    glNamedProgramLocalParameterI4uiEXT_ARGS *args = (glNamedProgramLocalParameterI4uiEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameterI4uiEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameterI4uiEXT(glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameterI4uiEXT(glNamedProgramLocalParameterI4uiEXT_PACKED *_dst glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameterI4uiEXT_PTR)(glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameterI4uivEXT_RETURN
#define glNamedProgramLocalParameterI4uivEXT_RETURN void
#define glNamedProgramLocalParameterI4uivEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLuint * params
#define glNamedProgramLocalParameterI4uivEXT_ARG_NAMES_TAIL , program, target, index, params
#define glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, const GLuint * params
#define forward_glNamedProgramLocalParameterI4uivEXT(_program, _target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameterI4uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameterI4uivEXT(dst, _program, _target, _index, _params), NULL); \
    });
#define call_glNamedProgramLocalParameterI4uivEXT(packed, ret_v) do { \
    glNamedProgramLocalParameterI4uivEXT_PACKED *unpacked = (glNamedProgramLocalParameterI4uivEXT_PACKED *)packed; \
    glNamedProgramLocalParameterI4uivEXT_ARGS *args = (glNamedProgramLocalParameterI4uivEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameterI4uivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameterI4uivEXT(glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameterI4uivEXT(glNamedProgramLocalParameterI4uivEXT_PACKED *_dst glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameterI4uivEXT_PTR)(glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParameters4fvEXT_RETURN
#define glNamedProgramLocalParameters4fvEXT_RETURN void
#define glNamedProgramLocalParameters4fvEXT_ARG_NAMES program, target, index, count, params
#define glNamedProgramLocalParameters4fvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define glNamedProgramLocalParameters4fvEXT_ARG_NAMES_TAIL , program, target, index, count, params
#define glNamedProgramLocalParameters4fvEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define forward_glNamedProgramLocalParameters4fvEXT(_program, _target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParameters4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParameters4fvEXT(dst, _program, _target, _index, _count, _params), NULL); \
    });
#define call_glNamedProgramLocalParameters4fvEXT(packed, ret_v) do { \
    glNamedProgramLocalParameters4fvEXT_PACKED *unpacked = (glNamedProgramLocalParameters4fvEXT_PACKED *)packed; \
    glNamedProgramLocalParameters4fvEXT_ARGS *args = (glNamedProgramLocalParameters4fvEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParameters4fvEXT(args->program, args->target, args->index, args->count, args->params);; \
} while(0)
void glNamedProgramLocalParameters4fvEXT(glNamedProgramLocalParameters4fvEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParameters4fvEXT(glNamedProgramLocalParameters4fvEXT_PACKED *_dst glNamedProgramLocalParameters4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParameters4fvEXT_PTR)(glNamedProgramLocalParameters4fvEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParametersI4ivEXT_RETURN
#define glNamedProgramLocalParametersI4ivEXT_RETURN void
#define glNamedProgramLocalParametersI4ivEXT_ARG_NAMES program, target, index, count, params
#define glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params
#define glNamedProgramLocalParametersI4ivEXT_ARG_NAMES_TAIL , program, target, index, count, params
#define glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params
#define forward_glNamedProgramLocalParametersI4ivEXT(_program, _target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParametersI4ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParametersI4ivEXT(dst, _program, _target, _index, _count, _params), NULL); \
    });
#define call_glNamedProgramLocalParametersI4ivEXT(packed, ret_v) do { \
    glNamedProgramLocalParametersI4ivEXT_PACKED *unpacked = (glNamedProgramLocalParametersI4ivEXT_PACKED *)packed; \
    glNamedProgramLocalParametersI4ivEXT_ARGS *args = (glNamedProgramLocalParametersI4ivEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParametersI4ivEXT(args->program, args->target, args->index, args->count, args->params);; \
} while(0)
void glNamedProgramLocalParametersI4ivEXT(glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParametersI4ivEXT(glNamedProgramLocalParametersI4ivEXT_PACKED *_dst glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParametersI4ivEXT_PTR)(glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramLocalParametersI4uivEXT_RETURN
#define glNamedProgramLocalParametersI4uivEXT_RETURN void
#define glNamedProgramLocalParametersI4uivEXT_ARG_NAMES program, target, index, count, params
#define glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params
#define glNamedProgramLocalParametersI4uivEXT_ARG_NAMES_TAIL , program, target, index, count, params
#define glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params
#define forward_glNamedProgramLocalParametersI4uivEXT(_program, _target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramLocalParametersI4uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramLocalParametersI4uivEXT(dst, _program, _target, _index, _count, _params), NULL); \
    });
#define call_glNamedProgramLocalParametersI4uivEXT(packed, ret_v) do { \
    glNamedProgramLocalParametersI4uivEXT_PACKED *unpacked = (glNamedProgramLocalParametersI4uivEXT_PACKED *)packed; \
    glNamedProgramLocalParametersI4uivEXT_ARGS *args = (glNamedProgramLocalParametersI4uivEXT_ARGS *)&unpacked->args; \
    glNamedProgramLocalParametersI4uivEXT(args->program, args->target, args->index, args->count, args->params);; \
} while(0)
void glNamedProgramLocalParametersI4uivEXT(glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramLocalParametersI4uivEXT(glNamedProgramLocalParametersI4uivEXT_PACKED *_dst glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramLocalParametersI4uivEXT_PTR)(glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND);
#endif
#ifndef glNamedProgramStringEXT_RETURN
#define glNamedProgramStringEXT_RETURN void
#define glNamedProgramStringEXT_ARG_NAMES program, target, format, len, string
#define glNamedProgramStringEXT_ARG_EXPAND GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid * string
#define glNamedProgramStringEXT_ARG_NAMES_TAIL , program, target, format, len, string
#define glNamedProgramStringEXT_ARG_EXPAND_TAIL , GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid * string
#define forward_glNamedProgramStringEXT(_program, _target, _format, _len, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedProgramStringEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedProgramStringEXT(dst, _program, _target, _format, _len, _string), NULL); \
    });
#define call_glNamedProgramStringEXT(packed, ret_v) do { \
    glNamedProgramStringEXT_PACKED *unpacked = (glNamedProgramStringEXT_PACKED *)packed; \
    glNamedProgramStringEXT_ARGS *args = (glNamedProgramStringEXT_ARGS *)&unpacked->args; \
    glNamedProgramStringEXT(args->program, args->target, args->format, args->len, args->string);; \
} while(0)
void glNamedProgramStringEXT(glNamedProgramStringEXT_ARG_EXPAND);
packed_call_t *pack_glNamedProgramStringEXT(glNamedProgramStringEXT_PACKED *_dst glNamedProgramStringEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedProgramStringEXT_PTR)(glNamedProgramStringEXT_ARG_EXPAND);
#endif
#ifndef glNamedRenderbufferStorageEXT_RETURN
#define glNamedRenderbufferStorageEXT_RETURN void
#define glNamedRenderbufferStorageEXT_ARG_NAMES renderbuffer, internalformat, width, height
#define glNamedRenderbufferStorageEXT_ARG_EXPAND GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height
#define glNamedRenderbufferStorageEXT_ARG_NAMES_TAIL , renderbuffer, internalformat, width, height
#define glNamedRenderbufferStorageEXT_ARG_EXPAND_TAIL , GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glNamedRenderbufferStorageEXT(_renderbuffer, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedRenderbufferStorageEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedRenderbufferStorageEXT(dst, _renderbuffer, _internalformat, _width, _height), NULL); \
    });
#define call_glNamedRenderbufferStorageEXT(packed, ret_v) do { \
    glNamedRenderbufferStorageEXT_PACKED *unpacked = (glNamedRenderbufferStorageEXT_PACKED *)packed; \
    glNamedRenderbufferStorageEXT_ARGS *args = (glNamedRenderbufferStorageEXT_ARGS *)&unpacked->args; \
    glNamedRenderbufferStorageEXT(args->renderbuffer, args->internalformat, args->width, args->height);; \
} while(0)
void glNamedRenderbufferStorageEXT(glNamedRenderbufferStorageEXT_ARG_EXPAND);
packed_call_t *pack_glNamedRenderbufferStorageEXT(glNamedRenderbufferStorageEXT_PACKED *_dst glNamedRenderbufferStorageEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedRenderbufferStorageEXT_PTR)(glNamedRenderbufferStorageEXT_ARG_EXPAND);
#endif
#ifndef glNamedRenderbufferStorageMultisampleCoverageEXT_RETURN
#define glNamedRenderbufferStorageMultisampleCoverageEXT_RETURN void
#define glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_NAMES renderbuffer, coverageSamples, colorSamples, internalformat, width, height
#define glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height
#define glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_NAMES_TAIL , renderbuffer, coverageSamples, colorSamples, internalformat, width, height
#define glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND_TAIL , GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glNamedRenderbufferStorageMultisampleCoverageEXT(_renderbuffer, _coverageSamples, _colorSamples, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedRenderbufferStorageMultisampleCoverageEXT(dst, _renderbuffer, _coverageSamples, _colorSamples, _internalformat, _width, _height), NULL); \
    });
#define call_glNamedRenderbufferStorageMultisampleCoverageEXT(packed, ret_v) do { \
    glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED *unpacked = (glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED *)packed; \
    glNamedRenderbufferStorageMultisampleCoverageEXT_ARGS *args = (glNamedRenderbufferStorageMultisampleCoverageEXT_ARGS *)&unpacked->args; \
    glNamedRenderbufferStorageMultisampleCoverageEXT(args->renderbuffer, args->coverageSamples, args->colorSamples, args->internalformat, args->width, args->height);; \
} while(0)
void glNamedRenderbufferStorageMultisampleCoverageEXT(glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND);
packed_call_t *pack_glNamedRenderbufferStorageMultisampleCoverageEXT(glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED *_dst glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedRenderbufferStorageMultisampleCoverageEXT_PTR)(glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND);
#endif
#ifndef glNamedRenderbufferStorageMultisampleEXT_RETURN
#define glNamedRenderbufferStorageMultisampleEXT_RETURN void
#define glNamedRenderbufferStorageMultisampleEXT_ARG_NAMES renderbuffer, samples, internalformat, width, height
#define glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define glNamedRenderbufferStorageMultisampleEXT_ARG_NAMES_TAIL , renderbuffer, samples, internalformat, width, height
#define glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND_TAIL , GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glNamedRenderbufferStorageMultisampleEXT(_renderbuffer, _samples, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedRenderbufferStorageMultisampleEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedRenderbufferStorageMultisampleEXT(dst, _renderbuffer, _samples, _internalformat, _width, _height), NULL); \
    });
#define call_glNamedRenderbufferStorageMultisampleEXT(packed, ret_v) do { \
    glNamedRenderbufferStorageMultisampleEXT_PACKED *unpacked = (glNamedRenderbufferStorageMultisampleEXT_PACKED *)packed; \
    glNamedRenderbufferStorageMultisampleEXT_ARGS *args = (glNamedRenderbufferStorageMultisampleEXT_ARGS *)&unpacked->args; \
    glNamedRenderbufferStorageMultisampleEXT(args->renderbuffer, args->samples, args->internalformat, args->width, args->height);; \
} while(0)
void glNamedRenderbufferStorageMultisampleEXT(glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND);
packed_call_t *pack_glNamedRenderbufferStorageMultisampleEXT(glNamedRenderbufferStorageMultisampleEXT_PACKED *_dst glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND_TAIL);
typedef void (*glNamedRenderbufferStorageMultisampleEXT_PTR)(glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND);
#endif
#ifndef glNamedStringARB_RETURN
#define glNamedStringARB_RETURN void
#define glNamedStringARB_ARG_NAMES type, namelen, name, stringlen, string
#define glNamedStringARB_ARG_EXPAND GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string
#define glNamedStringARB_ARG_NAMES_TAIL , type, namelen, name, stringlen, string
#define glNamedStringARB_ARG_EXPAND_TAIL , GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string
#define forward_glNamedStringARB(_type, _namelen, _name, _stringlen, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glNamedStringARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNamedStringARB(dst, _type, _namelen, _name, _stringlen, _string), NULL); \
    });
#define call_glNamedStringARB(packed, ret_v) do { \
    glNamedStringARB_PACKED *unpacked = (glNamedStringARB_PACKED *)packed; \
    glNamedStringARB_ARGS *args = (glNamedStringARB_ARGS *)&unpacked->args; \
    glNamedStringARB(args->type, args->namelen, args->name, args->stringlen, args->string);; \
} while(0)
void glNamedStringARB(glNamedStringARB_ARG_EXPAND);
packed_call_t *pack_glNamedStringARB(glNamedStringARB_PACKED *_dst glNamedStringARB_ARG_EXPAND_TAIL);
typedef void (*glNamedStringARB_PTR)(glNamedStringARB_ARG_EXPAND);
#endif
#ifndef glNewList_RETURN
#define glNewList_RETURN void
#define glNewList_ARG_NAMES list, mode
#define glNewList_ARG_EXPAND GLuint list, GLenum mode
#define glNewList_ARG_NAMES_TAIL , list, mode
#define glNewList_ARG_EXPAND_TAIL , GLuint list, GLenum mode
#define forward_glNewList(_list, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glNewList_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNewList(dst, _list, _mode), NULL); \
    });
#define call_glNewList(packed, ret_v) do { \
    glNewList_PACKED *unpacked = (glNewList_PACKED *)packed; \
    glNewList_ARGS *args = (glNewList_ARGS *)&unpacked->args; \
    glNewList(args->list, args->mode);; \
} while(0)
void glNewList(glNewList_ARG_EXPAND);
packed_call_t *pack_glNewList(glNewList_PACKED *_dst glNewList_ARG_EXPAND_TAIL);
typedef void (*glNewList_PTR)(glNewList_ARG_EXPAND);
#endif
#ifndef glNewObjectBufferATI_RETURN
#define glNewObjectBufferATI_RETURN GLuint
#define glNewObjectBufferATI_ARG_NAMES size, pointer, usage
#define glNewObjectBufferATI_ARG_EXPAND GLsizei size, const GLvoid * pointer, GLenum usage
#define glNewObjectBufferATI_ARG_NAMES_TAIL , size, pointer, usage
#define glNewObjectBufferATI_ARG_EXPAND_TAIL , GLsizei size, const GLvoid * pointer, GLenum usage
#define forward_glNewObjectBufferATI(_size, _pointer, _usage) \
    ({ \
        void *dst = remote_dma(sizeof(glNewObjectBufferATI_PACKED)); \
        GLuint ret = (GLuint)0; \
        remote_dma_send((packed_call_t *)pack_glNewObjectBufferATI(dst, _size, _pointer, _usage), &ret); \
        ret; \
    });
#define call_glNewObjectBufferATI(packed, ret_v) do { \
    glNewObjectBufferATI_PACKED *unpacked = (glNewObjectBufferATI_PACKED *)packed; \
    glNewObjectBufferATI_ARGS *args = (glNewObjectBufferATI_ARGS *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glNewObjectBufferATI(args->size, args->pointer, args->usage);; \
    } else { \
        glNewObjectBufferATI(args->size, args->pointer, args->usage);; \
    } \
} while(0)
GLuint glNewObjectBufferATI(glNewObjectBufferATI_ARG_EXPAND);
packed_call_t *pack_glNewObjectBufferATI(glNewObjectBufferATI_PACKED *_dst glNewObjectBufferATI_ARG_EXPAND_TAIL);
typedef GLuint (*glNewObjectBufferATI_PTR)(glNewObjectBufferATI_ARG_EXPAND);
#endif
#ifndef glNormal3b_RETURN
#define glNormal3b_RETURN void
#define glNormal3b_ARG_NAMES nx, ny, nz
#define glNormal3b_ARG_EXPAND GLbyte nx, GLbyte ny, GLbyte nz
#define glNormal3b_ARG_NAMES_TAIL , nx, ny, nz
#define glNormal3b_ARG_EXPAND_TAIL , GLbyte nx, GLbyte ny, GLbyte nz
#define forward_glNormal3b(_nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3b_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3b(dst, _nx, _ny, _nz), NULL); \
    });
#define call_glNormal3b(packed, ret_v) do { \
    glNormal3b_PACKED *unpacked = (glNormal3b_PACKED *)packed; \
    glNormal3b_ARGS *args = (glNormal3b_ARGS *)&unpacked->args; \
    glNormal3b(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3b(glNormal3b_ARG_EXPAND);
packed_call_t *pack_glNormal3b(glNormal3b_PACKED *_dst glNormal3b_ARG_EXPAND_TAIL);
typedef void (*glNormal3b_PTR)(glNormal3b_ARG_EXPAND);
#endif
#ifndef glNormal3bv_RETURN
#define glNormal3bv_RETURN void
#define glNormal3bv_ARG_NAMES v
#define glNormal3bv_ARG_EXPAND const GLbyte * v
#define glNormal3bv_ARG_NAMES_TAIL , v
#define glNormal3bv_ARG_EXPAND_TAIL , const GLbyte * v
#define forward_glNormal3bv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3bv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3bv(dst, _v), NULL); \
    });
#define call_glNormal3bv(packed, ret_v) do { \
    glNormal3bv_PACKED *unpacked = (glNormal3bv_PACKED *)packed; \
    glNormal3bv_ARGS *args = (glNormal3bv_ARGS *)&unpacked->args; \
    glNormal3bv(args->v);; \
} while(0)
void glNormal3bv(glNormal3bv_ARG_EXPAND);
packed_call_t *pack_glNormal3bv(glNormal3bv_PACKED *_dst glNormal3bv_ARG_EXPAND_TAIL);
typedef void (*glNormal3bv_PTR)(glNormal3bv_ARG_EXPAND);
#endif
#ifndef glNormal3d_RETURN
#define glNormal3d_RETURN void
#define glNormal3d_ARG_NAMES nx, ny, nz
#define glNormal3d_ARG_EXPAND GLdouble nx, GLdouble ny, GLdouble nz
#define glNormal3d_ARG_NAMES_TAIL , nx, ny, nz
#define glNormal3d_ARG_EXPAND_TAIL , GLdouble nx, GLdouble ny, GLdouble nz
#define forward_glNormal3d(_nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3d(dst, _nx, _ny, _nz), NULL); \
    });
#define call_glNormal3d(packed, ret_v) do { \
    glNormal3d_PACKED *unpacked = (glNormal3d_PACKED *)packed; \
    glNormal3d_ARGS *args = (glNormal3d_ARGS *)&unpacked->args; \
    glNormal3d(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3d(glNormal3d_ARG_EXPAND);
packed_call_t *pack_glNormal3d(glNormal3d_PACKED *_dst glNormal3d_ARG_EXPAND_TAIL);
typedef void (*glNormal3d_PTR)(glNormal3d_ARG_EXPAND);
#endif
#ifndef glNormal3dv_RETURN
#define glNormal3dv_RETURN void
#define glNormal3dv_ARG_NAMES v
#define glNormal3dv_ARG_EXPAND const GLdouble * v
#define glNormal3dv_ARG_NAMES_TAIL , v
#define glNormal3dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glNormal3dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3dv(dst, _v), NULL); \
    });
#define call_glNormal3dv(packed, ret_v) do { \
    glNormal3dv_PACKED *unpacked = (glNormal3dv_PACKED *)packed; \
    glNormal3dv_ARGS *args = (glNormal3dv_ARGS *)&unpacked->args; \
    glNormal3dv(args->v);; \
} while(0)
void glNormal3dv(glNormal3dv_ARG_EXPAND);
packed_call_t *pack_glNormal3dv(glNormal3dv_PACKED *_dst glNormal3dv_ARG_EXPAND_TAIL);
typedef void (*glNormal3dv_PTR)(glNormal3dv_ARG_EXPAND);
#endif
#ifndef glNormal3f_RETURN
#define glNormal3f_RETURN void
#define glNormal3f_ARG_NAMES nx, ny, nz
#define glNormal3f_ARG_EXPAND GLfloat nx, GLfloat ny, GLfloat nz
#define glNormal3f_ARG_NAMES_TAIL , nx, ny, nz
#define glNormal3f_ARG_EXPAND_TAIL , GLfloat nx, GLfloat ny, GLfloat nz
#define forward_glNormal3f(_nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3f(dst, _nx, _ny, _nz), NULL); \
    });
#define call_glNormal3f(packed, ret_v) do { \
    glNormal3f_PACKED *unpacked = (glNormal3f_PACKED *)packed; \
    glNormal3f_ARGS *args = (glNormal3f_ARGS *)&unpacked->args; \
    glNormal3f(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3f(glNormal3f_ARG_EXPAND);
packed_call_t *pack_glNormal3f(glNormal3f_PACKED *_dst glNormal3f_ARG_EXPAND_TAIL);
typedef void (*glNormal3f_PTR)(glNormal3f_ARG_EXPAND);
#endif
#ifndef glNormal3fVertex3fSUN_RETURN
#define glNormal3fVertex3fSUN_RETURN void
#define glNormal3fVertex3fSUN_ARG_NAMES nx, ny, nz, x, y, z
#define glNormal3fVertex3fSUN_ARG_EXPAND GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glNormal3fVertex3fSUN_ARG_NAMES_TAIL , nx, ny, nz, x, y, z
#define glNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glNormal3fVertex3fSUN(_nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3fVertex3fSUN(dst, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glNormal3fVertex3fSUN(packed, ret_v) do { \
    glNormal3fVertex3fSUN_PACKED *unpacked = (glNormal3fVertex3fSUN_PACKED *)packed; \
    glNormal3fVertex3fSUN_ARGS *args = (glNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glNormal3fVertex3fSUN(args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glNormal3fVertex3fSUN(glNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glNormal3fVertex3fSUN(glNormal3fVertex3fSUN_PACKED *_dst glNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glNormal3fVertex3fSUN_PTR)(glNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glNormal3fVertex3fvSUN_RETURN
#define glNormal3fVertex3fvSUN_RETURN void
#define glNormal3fVertex3fvSUN_ARG_NAMES n, v
#define glNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * n, const GLfloat * v
#define glNormal3fVertex3fvSUN_ARG_NAMES_TAIL , n, v
#define glNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * n, const GLfloat * v
#define forward_glNormal3fVertex3fvSUN(_n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3fVertex3fvSUN(dst, _n, _v), NULL); \
    });
#define call_glNormal3fVertex3fvSUN(packed, ret_v) do { \
    glNormal3fVertex3fvSUN_PACKED *unpacked = (glNormal3fVertex3fvSUN_PACKED *)packed; \
    glNormal3fVertex3fvSUN_ARGS *args = (glNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glNormal3fVertex3fvSUN(args->n, args->v);; \
} while(0)
void glNormal3fVertex3fvSUN(glNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glNormal3fVertex3fvSUN(glNormal3fVertex3fvSUN_PACKED *_dst glNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glNormal3fVertex3fvSUN_PTR)(glNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glNormal3fv_RETURN
#define glNormal3fv_RETURN void
#define glNormal3fv_ARG_NAMES v
#define glNormal3fv_ARG_EXPAND const GLfloat * v
#define glNormal3fv_ARG_NAMES_TAIL , v
#define glNormal3fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glNormal3fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3fv(dst, _v), NULL); \
    });
#define call_glNormal3fv(packed, ret_v) do { \
    glNormal3fv_PACKED *unpacked = (glNormal3fv_PACKED *)packed; \
    glNormal3fv_ARGS *args = (glNormal3fv_ARGS *)&unpacked->args; \
    glNormal3fv(args->v);; \
} while(0)
void glNormal3fv(glNormal3fv_ARG_EXPAND);
packed_call_t *pack_glNormal3fv(glNormal3fv_PACKED *_dst glNormal3fv_ARG_EXPAND_TAIL);
typedef void (*glNormal3fv_PTR)(glNormal3fv_ARG_EXPAND);
#endif
#ifndef glNormal3hNV_RETURN
#define glNormal3hNV_RETURN void
#define glNormal3hNV_ARG_NAMES nx, ny, nz
#define glNormal3hNV_ARG_EXPAND GLhalfNV nx, GLhalfNV ny, GLhalfNV nz
#define glNormal3hNV_ARG_NAMES_TAIL , nx, ny, nz
#define glNormal3hNV_ARG_EXPAND_TAIL , GLhalfNV nx, GLhalfNV ny, GLhalfNV nz
#define forward_glNormal3hNV(_nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3hNV(dst, _nx, _ny, _nz), NULL); \
    });
#define call_glNormal3hNV(packed, ret_v) do { \
    glNormal3hNV_PACKED *unpacked = (glNormal3hNV_PACKED *)packed; \
    glNormal3hNV_ARGS *args = (glNormal3hNV_ARGS *)&unpacked->args; \
    glNormal3hNV(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3hNV(glNormal3hNV_ARG_EXPAND);
packed_call_t *pack_glNormal3hNV(glNormal3hNV_PACKED *_dst glNormal3hNV_ARG_EXPAND_TAIL);
typedef void (*glNormal3hNV_PTR)(glNormal3hNV_ARG_EXPAND);
#endif
#ifndef glNormal3hvNV_RETURN
#define glNormal3hvNV_RETURN void
#define glNormal3hvNV_ARG_NAMES v
#define glNormal3hvNV_ARG_EXPAND const GLhalfNV * v
#define glNormal3hvNV_ARG_NAMES_TAIL , v
#define glNormal3hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glNormal3hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3hvNV(dst, _v), NULL); \
    });
#define call_glNormal3hvNV(packed, ret_v) do { \
    glNormal3hvNV_PACKED *unpacked = (glNormal3hvNV_PACKED *)packed; \
    glNormal3hvNV_ARGS *args = (glNormal3hvNV_ARGS *)&unpacked->args; \
    glNormal3hvNV(args->v);; \
} while(0)
void glNormal3hvNV(glNormal3hvNV_ARG_EXPAND);
packed_call_t *pack_glNormal3hvNV(glNormal3hvNV_PACKED *_dst glNormal3hvNV_ARG_EXPAND_TAIL);
typedef void (*glNormal3hvNV_PTR)(glNormal3hvNV_ARG_EXPAND);
#endif
#ifndef glNormal3i_RETURN
#define glNormal3i_RETURN void
#define glNormal3i_ARG_NAMES nx, ny, nz
#define glNormal3i_ARG_EXPAND GLint nx, GLint ny, GLint nz
#define glNormal3i_ARG_NAMES_TAIL , nx, ny, nz
#define glNormal3i_ARG_EXPAND_TAIL , GLint nx, GLint ny, GLint nz
#define forward_glNormal3i(_nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3i(dst, _nx, _ny, _nz), NULL); \
    });
#define call_glNormal3i(packed, ret_v) do { \
    glNormal3i_PACKED *unpacked = (glNormal3i_PACKED *)packed; \
    glNormal3i_ARGS *args = (glNormal3i_ARGS *)&unpacked->args; \
    glNormal3i(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3i(glNormal3i_ARG_EXPAND);
packed_call_t *pack_glNormal3i(glNormal3i_PACKED *_dst glNormal3i_ARG_EXPAND_TAIL);
typedef void (*glNormal3i_PTR)(glNormal3i_ARG_EXPAND);
#endif
#ifndef glNormal3iv_RETURN
#define glNormal3iv_RETURN void
#define glNormal3iv_ARG_NAMES v
#define glNormal3iv_ARG_EXPAND const GLint * v
#define glNormal3iv_ARG_NAMES_TAIL , v
#define glNormal3iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glNormal3iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3iv(dst, _v), NULL); \
    });
#define call_glNormal3iv(packed, ret_v) do { \
    glNormal3iv_PACKED *unpacked = (glNormal3iv_PACKED *)packed; \
    glNormal3iv_ARGS *args = (glNormal3iv_ARGS *)&unpacked->args; \
    glNormal3iv(args->v);; \
} while(0)
void glNormal3iv(glNormal3iv_ARG_EXPAND);
packed_call_t *pack_glNormal3iv(glNormal3iv_PACKED *_dst glNormal3iv_ARG_EXPAND_TAIL);
typedef void (*glNormal3iv_PTR)(glNormal3iv_ARG_EXPAND);
#endif
#ifndef glNormal3s_RETURN
#define glNormal3s_RETURN void
#define glNormal3s_ARG_NAMES nx, ny, nz
#define glNormal3s_ARG_EXPAND GLshort nx, GLshort ny, GLshort nz
#define glNormal3s_ARG_NAMES_TAIL , nx, ny, nz
#define glNormal3s_ARG_EXPAND_TAIL , GLshort nx, GLshort ny, GLshort nz
#define forward_glNormal3s(_nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3s(dst, _nx, _ny, _nz), NULL); \
    });
#define call_glNormal3s(packed, ret_v) do { \
    glNormal3s_PACKED *unpacked = (glNormal3s_PACKED *)packed; \
    glNormal3s_ARGS *args = (glNormal3s_ARGS *)&unpacked->args; \
    glNormal3s(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3s(glNormal3s_ARG_EXPAND);
packed_call_t *pack_glNormal3s(glNormal3s_PACKED *_dst glNormal3s_ARG_EXPAND_TAIL);
typedef void (*glNormal3s_PTR)(glNormal3s_ARG_EXPAND);
#endif
#ifndef glNormal3sv_RETURN
#define glNormal3sv_RETURN void
#define glNormal3sv_ARG_NAMES v
#define glNormal3sv_ARG_EXPAND const GLshort * v
#define glNormal3sv_ARG_NAMES_TAIL , v
#define glNormal3sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glNormal3sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3sv(dst, _v), NULL); \
    });
#define call_glNormal3sv(packed, ret_v) do { \
    glNormal3sv_PACKED *unpacked = (glNormal3sv_PACKED *)packed; \
    glNormal3sv_ARGS *args = (glNormal3sv_ARGS *)&unpacked->args; \
    glNormal3sv(args->v);; \
} while(0)
void glNormal3sv(glNormal3sv_ARG_EXPAND);
packed_call_t *pack_glNormal3sv(glNormal3sv_PACKED *_dst glNormal3sv_ARG_EXPAND_TAIL);
typedef void (*glNormal3sv_PTR)(glNormal3sv_ARG_EXPAND);
#endif
#ifndef glNormal3xOES_RETURN
#define glNormal3xOES_RETURN void
#define glNormal3xOES_ARG_NAMES nx, ny, nz
#define glNormal3xOES_ARG_EXPAND GLfixed nx, GLfixed ny, GLfixed nz
#define glNormal3xOES_ARG_NAMES_TAIL , nx, ny, nz
#define glNormal3xOES_ARG_EXPAND_TAIL , GLfixed nx, GLfixed ny, GLfixed nz
#define forward_glNormal3xOES(_nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3xOES(dst, _nx, _ny, _nz), NULL); \
    });
#define call_glNormal3xOES(packed, ret_v) do { \
    glNormal3xOES_PACKED *unpacked = (glNormal3xOES_PACKED *)packed; \
    glNormal3xOES_ARGS *args = (glNormal3xOES_ARGS *)&unpacked->args; \
    glNormal3xOES(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3xOES(glNormal3xOES_ARG_EXPAND);
packed_call_t *pack_glNormal3xOES(glNormal3xOES_PACKED *_dst glNormal3xOES_ARG_EXPAND_TAIL);
typedef void (*glNormal3xOES_PTR)(glNormal3xOES_ARG_EXPAND);
#endif
#ifndef glNormal3xvOES_RETURN
#define glNormal3xvOES_RETURN void
#define glNormal3xvOES_ARG_NAMES coords
#define glNormal3xvOES_ARG_EXPAND const GLfixed * coords
#define glNormal3xvOES_ARG_NAMES_TAIL , coords
#define glNormal3xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glNormal3xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormal3xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormal3xvOES(dst, _coords), NULL); \
    });
#define call_glNormal3xvOES(packed, ret_v) do { \
    glNormal3xvOES_PACKED *unpacked = (glNormal3xvOES_PACKED *)packed; \
    glNormal3xvOES_ARGS *args = (glNormal3xvOES_ARGS *)&unpacked->args; \
    glNormal3xvOES(args->coords);; \
} while(0)
void glNormal3xvOES(glNormal3xvOES_ARG_EXPAND);
packed_call_t *pack_glNormal3xvOES(glNormal3xvOES_PACKED *_dst glNormal3xvOES_ARG_EXPAND_TAIL);
typedef void (*glNormal3xvOES_PTR)(glNormal3xvOES_ARG_EXPAND);
#endif
#ifndef glNormalFormatNV_RETURN
#define glNormalFormatNV_RETURN void
#define glNormalFormatNV_ARG_NAMES type, stride
#define glNormalFormatNV_ARG_EXPAND GLenum type, GLsizei stride
#define glNormalFormatNV_ARG_NAMES_TAIL , type, stride
#define glNormalFormatNV_ARG_EXPAND_TAIL , GLenum type, GLsizei stride
#define forward_glNormalFormatNV(_type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalFormatNV(dst, _type, _stride), NULL); \
    });
#define call_glNormalFormatNV(packed, ret_v) do { \
    glNormalFormatNV_PACKED *unpacked = (glNormalFormatNV_PACKED *)packed; \
    glNormalFormatNV_ARGS *args = (glNormalFormatNV_ARGS *)&unpacked->args; \
    glNormalFormatNV(args->type, args->stride);; \
} while(0)
void glNormalFormatNV(glNormalFormatNV_ARG_EXPAND);
packed_call_t *pack_glNormalFormatNV(glNormalFormatNV_PACKED *_dst glNormalFormatNV_ARG_EXPAND_TAIL);
typedef void (*glNormalFormatNV_PTR)(glNormalFormatNV_ARG_EXPAND);
#endif
#ifndef glNormalP3ui_RETURN
#define glNormalP3ui_RETURN void
#define glNormalP3ui_ARG_NAMES type, coords
#define glNormalP3ui_ARG_EXPAND GLenum type, GLuint coords
#define glNormalP3ui_ARG_NAMES_TAIL , type, coords
#define glNormalP3ui_ARG_EXPAND_TAIL , GLenum type, GLuint coords
#define forward_glNormalP3ui(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalP3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalP3ui(dst, _type, _coords), NULL); \
    });
#define call_glNormalP3ui(packed, ret_v) do { \
    glNormalP3ui_PACKED *unpacked = (glNormalP3ui_PACKED *)packed; \
    glNormalP3ui_ARGS *args = (glNormalP3ui_ARGS *)&unpacked->args; \
    glNormalP3ui(args->type, args->coords);; \
} while(0)
void glNormalP3ui(glNormalP3ui_ARG_EXPAND);
packed_call_t *pack_glNormalP3ui(glNormalP3ui_PACKED *_dst glNormalP3ui_ARG_EXPAND_TAIL);
typedef void (*glNormalP3ui_PTR)(glNormalP3ui_ARG_EXPAND);
#endif
#ifndef glNormalP3uiv_RETURN
#define glNormalP3uiv_RETURN void
#define glNormalP3uiv_ARG_NAMES type, coords
#define glNormalP3uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glNormalP3uiv_ARG_NAMES_TAIL , type, coords
#define glNormalP3uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * coords
#define forward_glNormalP3uiv(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalP3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalP3uiv(dst, _type, _coords), NULL); \
    });
#define call_glNormalP3uiv(packed, ret_v) do { \
    glNormalP3uiv_PACKED *unpacked = (glNormalP3uiv_PACKED *)packed; \
    glNormalP3uiv_ARGS *args = (glNormalP3uiv_ARGS *)&unpacked->args; \
    glNormalP3uiv(args->type, args->coords);; \
} while(0)
void glNormalP3uiv(glNormalP3uiv_ARG_EXPAND);
packed_call_t *pack_glNormalP3uiv(glNormalP3uiv_PACKED *_dst glNormalP3uiv_ARG_EXPAND_TAIL);
typedef void (*glNormalP3uiv_PTR)(glNormalP3uiv_ARG_EXPAND);
#endif
#ifndef glNormalPointer_RETURN
#define glNormalPointer_RETURN void
#define glNormalPointer_ARG_NAMES type, stride, pointer
#define glNormalPointer_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glNormalPointer_ARG_NAMES_TAIL , type, stride, pointer
#define glNormalPointer_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glNormalPointer(_type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalPointer(dst, _type, _stride, _pointer), NULL); \
    });
#define call_glNormalPointer(packed, ret_v) do { \
    glNormalPointer_PACKED *unpacked = (glNormalPointer_PACKED *)packed; \
    glNormalPointer_ARGS *args = (glNormalPointer_ARGS *)&unpacked->args; \
    glNormalPointer(args->type, args->stride, args->pointer);; \
} while(0)
void glNormalPointer(glNormalPointer_ARG_EXPAND);
packed_call_t *pack_glNormalPointer(glNormalPointer_PACKED *_dst glNormalPointer_ARG_EXPAND_TAIL);
typedef void (*glNormalPointer_PTR)(glNormalPointer_ARG_EXPAND);
#endif
#ifndef glNormalPointerEXT_RETURN
#define glNormalPointerEXT_RETURN void
#define glNormalPointerEXT_ARG_NAMES type, stride, count, pointer
#define glNormalPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glNormalPointerEXT_ARG_NAMES_TAIL , type, stride, count, pointer
#define glNormalPointerEXT_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define forward_glNormalPointerEXT(_type, _stride, _count, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalPointerEXT(dst, _type, _stride, _count, _pointer), NULL); \
    });
#define call_glNormalPointerEXT(packed, ret_v) do { \
    glNormalPointerEXT_PACKED *unpacked = (glNormalPointerEXT_PACKED *)packed; \
    glNormalPointerEXT_ARGS *args = (glNormalPointerEXT_ARGS *)&unpacked->args; \
    glNormalPointerEXT(args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glNormalPointerEXT(glNormalPointerEXT_ARG_EXPAND);
packed_call_t *pack_glNormalPointerEXT(glNormalPointerEXT_PACKED *_dst glNormalPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glNormalPointerEXT_PTR)(glNormalPointerEXT_ARG_EXPAND);
#endif
#ifndef glNormalPointerListIBM_RETURN
#define glNormalPointerListIBM_RETURN void
#define glNormalPointerListIBM_ARG_NAMES type, stride, pointer, ptrstride
#define glNormalPointerListIBM_ARG_EXPAND GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glNormalPointerListIBM_ARG_NAMES_TAIL , type, stride, pointer, ptrstride
#define glNormalPointerListIBM_ARG_EXPAND_TAIL , GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define forward_glNormalPointerListIBM(_type, _stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalPointerListIBM(dst, _type, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glNormalPointerListIBM(packed, ret_v) do { \
    glNormalPointerListIBM_PACKED *unpacked = (glNormalPointerListIBM_PACKED *)packed; \
    glNormalPointerListIBM_ARGS *args = (glNormalPointerListIBM_ARGS *)&unpacked->args; \
    glNormalPointerListIBM(args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glNormalPointerListIBM(glNormalPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glNormalPointerListIBM(glNormalPointerListIBM_PACKED *_dst glNormalPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glNormalPointerListIBM_PTR)(glNormalPointerListIBM_ARG_EXPAND);
#endif
#ifndef glNormalPointervINTEL_RETURN
#define glNormalPointervINTEL_RETURN void
#define glNormalPointervINTEL_ARG_NAMES type, pointer
#define glNormalPointervINTEL_ARG_EXPAND GLenum type, const GLvoid * pointer
#define glNormalPointervINTEL_ARG_NAMES_TAIL , type, pointer
#define glNormalPointervINTEL_ARG_EXPAND_TAIL , GLenum type, const GLvoid * pointer
#define forward_glNormalPointervINTEL(_type, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalPointervINTEL_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalPointervINTEL(dst, _type, _pointer), NULL); \
    });
#define call_glNormalPointervINTEL(packed, ret_v) do { \
    glNormalPointervINTEL_PACKED *unpacked = (glNormalPointervINTEL_PACKED *)packed; \
    glNormalPointervINTEL_ARGS *args = (glNormalPointervINTEL_ARGS *)&unpacked->args; \
    glNormalPointervINTEL(args->type, args->pointer);; \
} while(0)
void glNormalPointervINTEL(glNormalPointervINTEL_ARG_EXPAND);
packed_call_t *pack_glNormalPointervINTEL(glNormalPointervINTEL_PACKED *_dst glNormalPointervINTEL_ARG_EXPAND_TAIL);
typedef void (*glNormalPointervINTEL_PTR)(glNormalPointervINTEL_ARG_EXPAND);
#endif
#ifndef glNormalStream3bATI_RETURN
#define glNormalStream3bATI_RETURN void
#define glNormalStream3bATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3bATI_ARG_EXPAND GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz
#define glNormalStream3bATI_ARG_NAMES_TAIL , stream, nx, ny, nz
#define glNormalStream3bATI_ARG_EXPAND_TAIL , GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz
#define forward_glNormalStream3bATI(_stream, _nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3bATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3bATI(dst, _stream, _nx, _ny, _nz), NULL); \
    });
#define call_glNormalStream3bATI(packed, ret_v) do { \
    glNormalStream3bATI_PACKED *unpacked = (glNormalStream3bATI_PACKED *)packed; \
    glNormalStream3bATI_ARGS *args = (glNormalStream3bATI_ARGS *)&unpacked->args; \
    glNormalStream3bATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3bATI(glNormalStream3bATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3bATI(glNormalStream3bATI_PACKED *_dst glNormalStream3bATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3bATI_PTR)(glNormalStream3bATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3bvATI_RETURN
#define glNormalStream3bvATI_RETURN void
#define glNormalStream3bvATI_ARG_NAMES stream, coords
#define glNormalStream3bvATI_ARG_EXPAND GLenum stream, const GLbyte * coords
#define glNormalStream3bvATI_ARG_NAMES_TAIL , stream, coords
#define glNormalStream3bvATI_ARG_EXPAND_TAIL , GLenum stream, const GLbyte * coords
#define forward_glNormalStream3bvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3bvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3bvATI(dst, _stream, _coords), NULL); \
    });
#define call_glNormalStream3bvATI(packed, ret_v) do { \
    glNormalStream3bvATI_PACKED *unpacked = (glNormalStream3bvATI_PACKED *)packed; \
    glNormalStream3bvATI_ARGS *args = (glNormalStream3bvATI_ARGS *)&unpacked->args; \
    glNormalStream3bvATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3bvATI(glNormalStream3bvATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3bvATI(glNormalStream3bvATI_PACKED *_dst glNormalStream3bvATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3bvATI_PTR)(glNormalStream3bvATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3dATI_RETURN
#define glNormalStream3dATI_RETURN void
#define glNormalStream3dATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3dATI_ARG_EXPAND GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz
#define glNormalStream3dATI_ARG_NAMES_TAIL , stream, nx, ny, nz
#define glNormalStream3dATI_ARG_EXPAND_TAIL , GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz
#define forward_glNormalStream3dATI(_stream, _nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3dATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3dATI(dst, _stream, _nx, _ny, _nz), NULL); \
    });
#define call_glNormalStream3dATI(packed, ret_v) do { \
    glNormalStream3dATI_PACKED *unpacked = (glNormalStream3dATI_PACKED *)packed; \
    glNormalStream3dATI_ARGS *args = (glNormalStream3dATI_ARGS *)&unpacked->args; \
    glNormalStream3dATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3dATI(glNormalStream3dATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3dATI(glNormalStream3dATI_PACKED *_dst glNormalStream3dATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3dATI_PTR)(glNormalStream3dATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3dvATI_RETURN
#define glNormalStream3dvATI_RETURN void
#define glNormalStream3dvATI_ARG_NAMES stream, coords
#define glNormalStream3dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glNormalStream3dvATI_ARG_NAMES_TAIL , stream, coords
#define glNormalStream3dvATI_ARG_EXPAND_TAIL , GLenum stream, const GLdouble * coords
#define forward_glNormalStream3dvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3dvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3dvATI(dst, _stream, _coords), NULL); \
    });
#define call_glNormalStream3dvATI(packed, ret_v) do { \
    glNormalStream3dvATI_PACKED *unpacked = (glNormalStream3dvATI_PACKED *)packed; \
    glNormalStream3dvATI_ARGS *args = (glNormalStream3dvATI_ARGS *)&unpacked->args; \
    glNormalStream3dvATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3dvATI(glNormalStream3dvATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3dvATI(glNormalStream3dvATI_PACKED *_dst glNormalStream3dvATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3dvATI_PTR)(glNormalStream3dvATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3fATI_RETURN
#define glNormalStream3fATI_RETURN void
#define glNormalStream3fATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3fATI_ARG_EXPAND GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz
#define glNormalStream3fATI_ARG_NAMES_TAIL , stream, nx, ny, nz
#define glNormalStream3fATI_ARG_EXPAND_TAIL , GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz
#define forward_glNormalStream3fATI(_stream, _nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3fATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3fATI(dst, _stream, _nx, _ny, _nz), NULL); \
    });
#define call_glNormalStream3fATI(packed, ret_v) do { \
    glNormalStream3fATI_PACKED *unpacked = (glNormalStream3fATI_PACKED *)packed; \
    glNormalStream3fATI_ARGS *args = (glNormalStream3fATI_ARGS *)&unpacked->args; \
    glNormalStream3fATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3fATI(glNormalStream3fATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3fATI(glNormalStream3fATI_PACKED *_dst glNormalStream3fATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3fATI_PTR)(glNormalStream3fATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3fvATI_RETURN
#define glNormalStream3fvATI_RETURN void
#define glNormalStream3fvATI_ARG_NAMES stream, coords
#define glNormalStream3fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glNormalStream3fvATI_ARG_NAMES_TAIL , stream, coords
#define glNormalStream3fvATI_ARG_EXPAND_TAIL , GLenum stream, const GLfloat * coords
#define forward_glNormalStream3fvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3fvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3fvATI(dst, _stream, _coords), NULL); \
    });
#define call_glNormalStream3fvATI(packed, ret_v) do { \
    glNormalStream3fvATI_PACKED *unpacked = (glNormalStream3fvATI_PACKED *)packed; \
    glNormalStream3fvATI_ARGS *args = (glNormalStream3fvATI_ARGS *)&unpacked->args; \
    glNormalStream3fvATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3fvATI(glNormalStream3fvATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3fvATI(glNormalStream3fvATI_PACKED *_dst glNormalStream3fvATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3fvATI_PTR)(glNormalStream3fvATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3iATI_RETURN
#define glNormalStream3iATI_RETURN void
#define glNormalStream3iATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3iATI_ARG_EXPAND GLenum stream, GLint nx, GLint ny, GLint nz
#define glNormalStream3iATI_ARG_NAMES_TAIL , stream, nx, ny, nz
#define glNormalStream3iATI_ARG_EXPAND_TAIL , GLenum stream, GLint nx, GLint ny, GLint nz
#define forward_glNormalStream3iATI(_stream, _nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3iATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3iATI(dst, _stream, _nx, _ny, _nz), NULL); \
    });
#define call_glNormalStream3iATI(packed, ret_v) do { \
    glNormalStream3iATI_PACKED *unpacked = (glNormalStream3iATI_PACKED *)packed; \
    glNormalStream3iATI_ARGS *args = (glNormalStream3iATI_ARGS *)&unpacked->args; \
    glNormalStream3iATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3iATI(glNormalStream3iATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3iATI(glNormalStream3iATI_PACKED *_dst glNormalStream3iATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3iATI_PTR)(glNormalStream3iATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3ivATI_RETURN
#define glNormalStream3ivATI_RETURN void
#define glNormalStream3ivATI_ARG_NAMES stream, coords
#define glNormalStream3ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glNormalStream3ivATI_ARG_NAMES_TAIL , stream, coords
#define glNormalStream3ivATI_ARG_EXPAND_TAIL , GLenum stream, const GLint * coords
#define forward_glNormalStream3ivATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3ivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3ivATI(dst, _stream, _coords), NULL); \
    });
#define call_glNormalStream3ivATI(packed, ret_v) do { \
    glNormalStream3ivATI_PACKED *unpacked = (glNormalStream3ivATI_PACKED *)packed; \
    glNormalStream3ivATI_ARGS *args = (glNormalStream3ivATI_ARGS *)&unpacked->args; \
    glNormalStream3ivATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3ivATI(glNormalStream3ivATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3ivATI(glNormalStream3ivATI_PACKED *_dst glNormalStream3ivATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3ivATI_PTR)(glNormalStream3ivATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3sATI_RETURN
#define glNormalStream3sATI_RETURN void
#define glNormalStream3sATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3sATI_ARG_EXPAND GLenum stream, GLshort nx, GLshort ny, GLshort nz
#define glNormalStream3sATI_ARG_NAMES_TAIL , stream, nx, ny, nz
#define glNormalStream3sATI_ARG_EXPAND_TAIL , GLenum stream, GLshort nx, GLshort ny, GLshort nz
#define forward_glNormalStream3sATI(_stream, _nx, _ny, _nz) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3sATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3sATI(dst, _stream, _nx, _ny, _nz), NULL); \
    });
#define call_glNormalStream3sATI(packed, ret_v) do { \
    glNormalStream3sATI_PACKED *unpacked = (glNormalStream3sATI_PACKED *)packed; \
    glNormalStream3sATI_ARGS *args = (glNormalStream3sATI_ARGS *)&unpacked->args; \
    glNormalStream3sATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3sATI(glNormalStream3sATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3sATI(glNormalStream3sATI_PACKED *_dst glNormalStream3sATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3sATI_PTR)(glNormalStream3sATI_ARG_EXPAND);
#endif
#ifndef glNormalStream3svATI_RETURN
#define glNormalStream3svATI_RETURN void
#define glNormalStream3svATI_ARG_NAMES stream, coords
#define glNormalStream3svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glNormalStream3svATI_ARG_NAMES_TAIL , stream, coords
#define glNormalStream3svATI_ARG_EXPAND_TAIL , GLenum stream, const GLshort * coords
#define forward_glNormalStream3svATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glNormalStream3svATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glNormalStream3svATI(dst, _stream, _coords), NULL); \
    });
#define call_glNormalStream3svATI(packed, ret_v) do { \
    glNormalStream3svATI_PACKED *unpacked = (glNormalStream3svATI_PACKED *)packed; \
    glNormalStream3svATI_ARGS *args = (glNormalStream3svATI_ARGS *)&unpacked->args; \
    glNormalStream3svATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3svATI(glNormalStream3svATI_ARG_EXPAND);
packed_call_t *pack_glNormalStream3svATI(glNormalStream3svATI_PACKED *_dst glNormalStream3svATI_ARG_EXPAND_TAIL);
typedef void (*glNormalStream3svATI_PTR)(glNormalStream3svATI_ARG_EXPAND);
#endif
#ifndef glObjectLabel_RETURN
#define glObjectLabel_RETURN void
#define glObjectLabel_ARG_NAMES identifier, name, length, label
#define glObjectLabel_ARG_EXPAND GLenum identifier, GLuint name, GLsizei length, const GLchar * label
#define glObjectLabel_ARG_NAMES_TAIL , identifier, name, length, label
#define glObjectLabel_ARG_EXPAND_TAIL , GLenum identifier, GLuint name, GLsizei length, const GLchar * label
#define forward_glObjectLabel(_identifier, _name, _length, _label) \
    ({ \
        void *dst = remote_dma(sizeof(glObjectLabel_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glObjectLabel(dst, _identifier, _name, _length, _label), NULL); \
    });
#define call_glObjectLabel(packed, ret_v) do { \
    glObjectLabel_PACKED *unpacked = (glObjectLabel_PACKED *)packed; \
    glObjectLabel_ARGS *args = (glObjectLabel_ARGS *)&unpacked->args; \
    glObjectLabel(args->identifier, args->name, args->length, args->label);; \
} while(0)
void glObjectLabel(glObjectLabel_ARG_EXPAND);
packed_call_t *pack_glObjectLabel(glObjectLabel_PACKED *_dst glObjectLabel_ARG_EXPAND_TAIL);
typedef void (*glObjectLabel_PTR)(glObjectLabel_ARG_EXPAND);
#endif
#ifndef glObjectPtrLabel_RETURN
#define glObjectPtrLabel_RETURN void
#define glObjectPtrLabel_ARG_NAMES ptr, length, label
#define glObjectPtrLabel_ARG_EXPAND const void * ptr, GLsizei length, const GLchar * label
#define glObjectPtrLabel_ARG_NAMES_TAIL , ptr, length, label
#define glObjectPtrLabel_ARG_EXPAND_TAIL , const void * ptr, GLsizei length, const GLchar * label
#define forward_glObjectPtrLabel(_ptr, _length, _label) \
    ({ \
        void *dst = remote_dma(sizeof(glObjectPtrLabel_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glObjectPtrLabel(dst, _ptr, _length, _label), NULL); \
    });
#define call_glObjectPtrLabel(packed, ret_v) do { \
    glObjectPtrLabel_PACKED *unpacked = (glObjectPtrLabel_PACKED *)packed; \
    glObjectPtrLabel_ARGS *args = (glObjectPtrLabel_ARGS *)&unpacked->args; \
    glObjectPtrLabel(args->ptr, args->length, args->label);; \
} while(0)
void glObjectPtrLabel(glObjectPtrLabel_ARG_EXPAND);
packed_call_t *pack_glObjectPtrLabel(glObjectPtrLabel_PACKED *_dst glObjectPtrLabel_ARG_EXPAND_TAIL);
typedef void (*glObjectPtrLabel_PTR)(glObjectPtrLabel_ARG_EXPAND);
#endif
#ifndef glObjectPurgeableAPPLE_RETURN
#define glObjectPurgeableAPPLE_RETURN GLenum
#define glObjectPurgeableAPPLE_ARG_NAMES objectType, name, option
#define glObjectPurgeableAPPLE_ARG_EXPAND GLenum objectType, GLuint name, GLenum option
#define glObjectPurgeableAPPLE_ARG_NAMES_TAIL , objectType, name, option
#define glObjectPurgeableAPPLE_ARG_EXPAND_TAIL , GLenum objectType, GLuint name, GLenum option
#define forward_glObjectPurgeableAPPLE(_objectType, _name, _option) \
    ({ \
        void *dst = remote_dma(sizeof(glObjectPurgeableAPPLE_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glObjectPurgeableAPPLE(dst, _objectType, _name, _option), &ret); \
        ret; \
    });
#define call_glObjectPurgeableAPPLE(packed, ret_v) do { \
    glObjectPurgeableAPPLE_PACKED *unpacked = (glObjectPurgeableAPPLE_PACKED *)packed; \
    glObjectPurgeableAPPLE_ARGS *args = (glObjectPurgeableAPPLE_ARGS *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glObjectPurgeableAPPLE(args->objectType, args->name, args->option);; \
    } else { \
        glObjectPurgeableAPPLE(args->objectType, args->name, args->option);; \
    } \
} while(0)
GLenum glObjectPurgeableAPPLE(glObjectPurgeableAPPLE_ARG_EXPAND);
packed_call_t *pack_glObjectPurgeableAPPLE(glObjectPurgeableAPPLE_PACKED *_dst glObjectPurgeableAPPLE_ARG_EXPAND_TAIL);
typedef GLenum (*glObjectPurgeableAPPLE_PTR)(glObjectPurgeableAPPLE_ARG_EXPAND);
#endif
#ifndef glObjectUnpurgeableAPPLE_RETURN
#define glObjectUnpurgeableAPPLE_RETURN GLenum
#define glObjectUnpurgeableAPPLE_ARG_NAMES objectType, name, option
#define glObjectUnpurgeableAPPLE_ARG_EXPAND GLenum objectType, GLuint name, GLenum option
#define glObjectUnpurgeableAPPLE_ARG_NAMES_TAIL , objectType, name, option
#define glObjectUnpurgeableAPPLE_ARG_EXPAND_TAIL , GLenum objectType, GLuint name, GLenum option
#define forward_glObjectUnpurgeableAPPLE(_objectType, _name, _option) \
    ({ \
        void *dst = remote_dma(sizeof(glObjectUnpurgeableAPPLE_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glObjectUnpurgeableAPPLE(dst, _objectType, _name, _option), &ret); \
        ret; \
    });
#define call_glObjectUnpurgeableAPPLE(packed, ret_v) do { \
    glObjectUnpurgeableAPPLE_PACKED *unpacked = (glObjectUnpurgeableAPPLE_PACKED *)packed; \
    glObjectUnpurgeableAPPLE_ARGS *args = (glObjectUnpurgeableAPPLE_ARGS *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glObjectUnpurgeableAPPLE(args->objectType, args->name, args->option);; \
    } else { \
        glObjectUnpurgeableAPPLE(args->objectType, args->name, args->option);; \
    } \
} while(0)
GLenum glObjectUnpurgeableAPPLE(glObjectUnpurgeableAPPLE_ARG_EXPAND);
packed_call_t *pack_glObjectUnpurgeableAPPLE(glObjectUnpurgeableAPPLE_PACKED *_dst glObjectUnpurgeableAPPLE_ARG_EXPAND_TAIL);
typedef GLenum (*glObjectUnpurgeableAPPLE_PTR)(glObjectUnpurgeableAPPLE_ARG_EXPAND);
#endif
#ifndef glOrtho_RETURN
#define glOrtho_RETURN void
#define glOrtho_ARG_NAMES left, right, bottom, top, zNear, zFar
#define glOrtho_ARG_EXPAND GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glOrtho_ARG_NAMES_TAIL , left, right, bottom, top, zNear, zFar
#define glOrtho_ARG_EXPAND_TAIL , GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define forward_glOrtho(_left, _right, _bottom, _top, _zNear, _zFar) \
    ({ \
        void *dst = remote_dma(sizeof(glOrtho_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glOrtho(dst, _left, _right, _bottom, _top, _zNear, _zFar), NULL); \
    });
#define call_glOrtho(packed, ret_v) do { \
    glOrtho_PACKED *unpacked = (glOrtho_PACKED *)packed; \
    glOrtho_ARGS *args = (glOrtho_ARGS *)&unpacked->args; \
    glOrtho(args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glOrtho(glOrtho_ARG_EXPAND);
packed_call_t *pack_glOrtho(glOrtho_PACKED *_dst glOrtho_ARG_EXPAND_TAIL);
typedef void (*glOrtho_PTR)(glOrtho_ARG_EXPAND);
#endif
#ifndef glOrthofOES_RETURN
#define glOrthofOES_RETURN void
#define glOrthofOES_ARG_NAMES l, r, b, t, n, f
#define glOrthofOES_ARG_EXPAND GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f
#define glOrthofOES_ARG_NAMES_TAIL , l, r, b, t, n, f
#define glOrthofOES_ARG_EXPAND_TAIL , GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f
#define forward_glOrthofOES(_l, _r, _b, _t, _n, _f) \
    ({ \
        void *dst = remote_dma(sizeof(glOrthofOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glOrthofOES(dst, _l, _r, _b, _t, _n, _f), NULL); \
    });
#define call_glOrthofOES(packed, ret_v) do { \
    glOrthofOES_PACKED *unpacked = (glOrthofOES_PACKED *)packed; \
    glOrthofOES_ARGS *args = (glOrthofOES_ARGS *)&unpacked->args; \
    glOrthofOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glOrthofOES(glOrthofOES_ARG_EXPAND);
packed_call_t *pack_glOrthofOES(glOrthofOES_PACKED *_dst glOrthofOES_ARG_EXPAND_TAIL);
typedef void (*glOrthofOES_PTR)(glOrthofOES_ARG_EXPAND);
#endif
#ifndef glOrthoxOES_RETURN
#define glOrthoxOES_RETURN void
#define glOrthoxOES_ARG_NAMES l, r, b, t, n, f
#define glOrthoxOES_ARG_EXPAND GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f
#define glOrthoxOES_ARG_NAMES_TAIL , l, r, b, t, n, f
#define glOrthoxOES_ARG_EXPAND_TAIL , GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f
#define forward_glOrthoxOES(_l, _r, _b, _t, _n, _f) \
    ({ \
        void *dst = remote_dma(sizeof(glOrthoxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glOrthoxOES(dst, _l, _r, _b, _t, _n, _f), NULL); \
    });
#define call_glOrthoxOES(packed, ret_v) do { \
    glOrthoxOES_PACKED *unpacked = (glOrthoxOES_PACKED *)packed; \
    glOrthoxOES_ARGS *args = (glOrthoxOES_ARGS *)&unpacked->args; \
    glOrthoxOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glOrthoxOES(glOrthoxOES_ARG_EXPAND);
packed_call_t *pack_glOrthoxOES(glOrthoxOES_PACKED *_dst glOrthoxOES_ARG_EXPAND_TAIL);
typedef void (*glOrthoxOES_PTR)(glOrthoxOES_ARG_EXPAND);
#endif
#ifndef glPNTrianglesfATI_RETURN
#define glPNTrianglesfATI_RETURN void
#define glPNTrianglesfATI_ARG_NAMES pname, param
#define glPNTrianglesfATI_ARG_EXPAND GLenum pname, GLfloat param
#define glPNTrianglesfATI_ARG_NAMES_TAIL , pname, param
#define glPNTrianglesfATI_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPNTrianglesfATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPNTrianglesfATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPNTrianglesfATI(dst, _pname, _param), NULL); \
    });
#define call_glPNTrianglesfATI(packed, ret_v) do { \
    glPNTrianglesfATI_PACKED *unpacked = (glPNTrianglesfATI_PACKED *)packed; \
    glPNTrianglesfATI_ARGS *args = (glPNTrianglesfATI_ARGS *)&unpacked->args; \
    glPNTrianglesfATI(args->pname, args->param);; \
} while(0)
void glPNTrianglesfATI(glPNTrianglesfATI_ARG_EXPAND);
packed_call_t *pack_glPNTrianglesfATI(glPNTrianglesfATI_PACKED *_dst glPNTrianglesfATI_ARG_EXPAND_TAIL);
typedef void (*glPNTrianglesfATI_PTR)(glPNTrianglesfATI_ARG_EXPAND);
#endif
#ifndef glPNTrianglesiATI_RETURN
#define glPNTrianglesiATI_RETURN void
#define glPNTrianglesiATI_ARG_NAMES pname, param
#define glPNTrianglesiATI_ARG_EXPAND GLenum pname, GLint param
#define glPNTrianglesiATI_ARG_NAMES_TAIL , pname, param
#define glPNTrianglesiATI_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glPNTrianglesiATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPNTrianglesiATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPNTrianglesiATI(dst, _pname, _param), NULL); \
    });
#define call_glPNTrianglesiATI(packed, ret_v) do { \
    glPNTrianglesiATI_PACKED *unpacked = (glPNTrianglesiATI_PACKED *)packed; \
    glPNTrianglesiATI_ARGS *args = (glPNTrianglesiATI_ARGS *)&unpacked->args; \
    glPNTrianglesiATI(args->pname, args->param);; \
} while(0)
void glPNTrianglesiATI(glPNTrianglesiATI_ARG_EXPAND);
packed_call_t *pack_glPNTrianglesiATI(glPNTrianglesiATI_PACKED *_dst glPNTrianglesiATI_ARG_EXPAND_TAIL);
typedef void (*glPNTrianglesiATI_PTR)(glPNTrianglesiATI_ARG_EXPAND);
#endif
#ifndef glPassTexCoordATI_RETURN
#define glPassTexCoordATI_RETURN void
#define glPassTexCoordATI_ARG_NAMES dst, coord, swizzle
#define glPassTexCoordATI_ARG_EXPAND GLuint dst, GLuint coord, GLenum swizzle
#define glPassTexCoordATI_ARG_NAMES_TAIL , dst, coord, swizzle
#define glPassTexCoordATI_ARG_EXPAND_TAIL , GLuint dst, GLuint coord, GLenum swizzle
#define forward_glPassTexCoordATI(_dst, _coord, _swizzle) \
    ({ \
        void *dst = remote_dma(sizeof(glPassTexCoordATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPassTexCoordATI(dst, _dst, _coord, _swizzle), NULL); \
    });
#define call_glPassTexCoordATI(packed, ret_v) do { \
    glPassTexCoordATI_PACKED *unpacked = (glPassTexCoordATI_PACKED *)packed; \
    glPassTexCoordATI_ARGS *args = (glPassTexCoordATI_ARGS *)&unpacked->args; \
    glPassTexCoordATI(args->dst, args->coord, args->swizzle);; \
} while(0)
void glPassTexCoordATI(glPassTexCoordATI_ARG_EXPAND);
packed_call_t *pack_glPassTexCoordATI(glPassTexCoordATI_PACKED *_dst glPassTexCoordATI_ARG_EXPAND_TAIL);
typedef void (*glPassTexCoordATI_PTR)(glPassTexCoordATI_ARG_EXPAND);
#endif
#ifndef glPassThrough_RETURN
#define glPassThrough_RETURN void
#define glPassThrough_ARG_NAMES token
#define glPassThrough_ARG_EXPAND GLfloat token
#define glPassThrough_ARG_NAMES_TAIL , token
#define glPassThrough_ARG_EXPAND_TAIL , GLfloat token
#define forward_glPassThrough(_token) \
    ({ \
        void *dst = remote_dma(sizeof(glPassThrough_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPassThrough(dst, _token), NULL); \
    });
#define call_glPassThrough(packed, ret_v) do { \
    glPassThrough_PACKED *unpacked = (glPassThrough_PACKED *)packed; \
    glPassThrough_ARGS *args = (glPassThrough_ARGS *)&unpacked->args; \
    glPassThrough(args->token);; \
} while(0)
void glPassThrough(glPassThrough_ARG_EXPAND);
packed_call_t *pack_glPassThrough(glPassThrough_PACKED *_dst glPassThrough_ARG_EXPAND_TAIL);
typedef void (*glPassThrough_PTR)(glPassThrough_ARG_EXPAND);
#endif
#ifndef glPassThroughxOES_RETURN
#define glPassThroughxOES_RETURN void
#define glPassThroughxOES_ARG_NAMES token
#define glPassThroughxOES_ARG_EXPAND GLfixed token
#define glPassThroughxOES_ARG_NAMES_TAIL , token
#define glPassThroughxOES_ARG_EXPAND_TAIL , GLfixed token
#define forward_glPassThroughxOES(_token) \
    ({ \
        void *dst = remote_dma(sizeof(glPassThroughxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPassThroughxOES(dst, _token), NULL); \
    });
#define call_glPassThroughxOES(packed, ret_v) do { \
    glPassThroughxOES_PACKED *unpacked = (glPassThroughxOES_PACKED *)packed; \
    glPassThroughxOES_ARGS *args = (glPassThroughxOES_ARGS *)&unpacked->args; \
    glPassThroughxOES(args->token);; \
} while(0)
void glPassThroughxOES(glPassThroughxOES_ARG_EXPAND);
packed_call_t *pack_glPassThroughxOES(glPassThroughxOES_PACKED *_dst glPassThroughxOES_ARG_EXPAND_TAIL);
typedef void (*glPassThroughxOES_PTR)(glPassThroughxOES_ARG_EXPAND);
#endif
#ifndef glPatchParameterfv_RETURN
#define glPatchParameterfv_RETURN void
#define glPatchParameterfv_ARG_NAMES pname, values
#define glPatchParameterfv_ARG_EXPAND GLenum pname, const GLfloat * values
#define glPatchParameterfv_ARG_NAMES_TAIL , pname, values
#define glPatchParameterfv_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * values
#define forward_glPatchParameterfv(_pname, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glPatchParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPatchParameterfv(dst, _pname, _values), NULL); \
    });
#define call_glPatchParameterfv(packed, ret_v) do { \
    glPatchParameterfv_PACKED *unpacked = (glPatchParameterfv_PACKED *)packed; \
    glPatchParameterfv_ARGS *args = (glPatchParameterfv_ARGS *)&unpacked->args; \
    glPatchParameterfv(args->pname, args->values);; \
} while(0)
void glPatchParameterfv(glPatchParameterfv_ARG_EXPAND);
packed_call_t *pack_glPatchParameterfv(glPatchParameterfv_PACKED *_dst glPatchParameterfv_ARG_EXPAND_TAIL);
typedef void (*glPatchParameterfv_PTR)(glPatchParameterfv_ARG_EXPAND);
#endif
#ifndef glPatchParameteri_RETURN
#define glPatchParameteri_RETURN void
#define glPatchParameteri_ARG_NAMES pname, value
#define glPatchParameteri_ARG_EXPAND GLenum pname, GLint value
#define glPatchParameteri_ARG_NAMES_TAIL , pname, value
#define glPatchParameteri_ARG_EXPAND_TAIL , GLenum pname, GLint value
#define forward_glPatchParameteri(_pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glPatchParameteri_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPatchParameteri(dst, _pname, _value), NULL); \
    });
#define call_glPatchParameteri(packed, ret_v) do { \
    glPatchParameteri_PACKED *unpacked = (glPatchParameteri_PACKED *)packed; \
    glPatchParameteri_ARGS *args = (glPatchParameteri_ARGS *)&unpacked->args; \
    glPatchParameteri(args->pname, args->value);; \
} while(0)
void glPatchParameteri(glPatchParameteri_ARG_EXPAND);
packed_call_t *pack_glPatchParameteri(glPatchParameteri_PACKED *_dst glPatchParameteri_ARG_EXPAND_TAIL);
typedef void (*glPatchParameteri_PTR)(glPatchParameteri_ARG_EXPAND);
#endif
#ifndef glPathColorGenNV_RETURN
#define glPathColorGenNV_RETURN void
#define glPathColorGenNV_ARG_NAMES color, genMode, colorFormat, coeffs
#define glPathColorGenNV_ARG_EXPAND GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs
#define glPathColorGenNV_ARG_NAMES_TAIL , color, genMode, colorFormat, coeffs
#define glPathColorGenNV_ARG_EXPAND_TAIL , GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs
#define forward_glPathColorGenNV(_color, _genMode, _colorFormat, _coeffs) \
    ({ \
        void *dst = remote_dma(sizeof(glPathColorGenNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathColorGenNV(dst, _color, _genMode, _colorFormat, _coeffs), NULL); \
    });
#define call_glPathColorGenNV(packed, ret_v) do { \
    glPathColorGenNV_PACKED *unpacked = (glPathColorGenNV_PACKED *)packed; \
    glPathColorGenNV_ARGS *args = (glPathColorGenNV_ARGS *)&unpacked->args; \
    glPathColorGenNV(args->color, args->genMode, args->colorFormat, args->coeffs);; \
} while(0)
void glPathColorGenNV(glPathColorGenNV_ARG_EXPAND);
packed_call_t *pack_glPathColorGenNV(glPathColorGenNV_PACKED *_dst glPathColorGenNV_ARG_EXPAND_TAIL);
typedef void (*glPathColorGenNV_PTR)(glPathColorGenNV_ARG_EXPAND);
#endif
#ifndef glPathCommandsNV_RETURN
#define glPathCommandsNV_RETURN void
#define glPathCommandsNV_ARG_NAMES path, numCommands, commands, numCoords, coordType, coords
#define glPathCommandsNV_ARG_EXPAND GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathCommandsNV_ARG_NAMES_TAIL , path, numCommands, commands, numCoords, coordType, coords
#define glPathCommandsNV_ARG_EXPAND_TAIL , GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define forward_glPathCommandsNV(_path, _numCommands, _commands, _numCoords, _coordType, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glPathCommandsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathCommandsNV(dst, _path, _numCommands, _commands, _numCoords, _coordType, _coords), NULL); \
    });
#define call_glPathCommandsNV(packed, ret_v) do { \
    glPathCommandsNV_PACKED *unpacked = (glPathCommandsNV_PACKED *)packed; \
    glPathCommandsNV_ARGS *args = (glPathCommandsNV_ARGS *)&unpacked->args; \
    glPathCommandsNV(args->path, args->numCommands, args->commands, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathCommandsNV(glPathCommandsNV_ARG_EXPAND);
packed_call_t *pack_glPathCommandsNV(glPathCommandsNV_PACKED *_dst glPathCommandsNV_ARG_EXPAND_TAIL);
typedef void (*glPathCommandsNV_PTR)(glPathCommandsNV_ARG_EXPAND);
#endif
#ifndef glPathCoordsNV_RETURN
#define glPathCoordsNV_RETURN void
#define glPathCoordsNV_ARG_NAMES path, numCoords, coordType, coords
#define glPathCoordsNV_ARG_EXPAND GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathCoordsNV_ARG_NAMES_TAIL , path, numCoords, coordType, coords
#define glPathCoordsNV_ARG_EXPAND_TAIL , GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define forward_glPathCoordsNV(_path, _numCoords, _coordType, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glPathCoordsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathCoordsNV(dst, _path, _numCoords, _coordType, _coords), NULL); \
    });
#define call_glPathCoordsNV(packed, ret_v) do { \
    glPathCoordsNV_PACKED *unpacked = (glPathCoordsNV_PACKED *)packed; \
    glPathCoordsNV_ARGS *args = (glPathCoordsNV_ARGS *)&unpacked->args; \
    glPathCoordsNV(args->path, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathCoordsNV(glPathCoordsNV_ARG_EXPAND);
packed_call_t *pack_glPathCoordsNV(glPathCoordsNV_PACKED *_dst glPathCoordsNV_ARG_EXPAND_TAIL);
typedef void (*glPathCoordsNV_PTR)(glPathCoordsNV_ARG_EXPAND);
#endif
#ifndef glPathCoverDepthFuncNV_RETURN
#define glPathCoverDepthFuncNV_RETURN void
#define glPathCoverDepthFuncNV_ARG_NAMES func
#define glPathCoverDepthFuncNV_ARG_EXPAND GLenum func
#define glPathCoverDepthFuncNV_ARG_NAMES_TAIL , func
#define glPathCoverDepthFuncNV_ARG_EXPAND_TAIL , GLenum func
#define forward_glPathCoverDepthFuncNV(_func) \
    ({ \
        void *dst = remote_dma(sizeof(glPathCoverDepthFuncNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathCoverDepthFuncNV(dst, _func), NULL); \
    });
#define call_glPathCoverDepthFuncNV(packed, ret_v) do { \
    glPathCoverDepthFuncNV_PACKED *unpacked = (glPathCoverDepthFuncNV_PACKED *)packed; \
    glPathCoverDepthFuncNV_ARGS *args = (glPathCoverDepthFuncNV_ARGS *)&unpacked->args; \
    glPathCoverDepthFuncNV(args->func);; \
} while(0)
void glPathCoverDepthFuncNV(glPathCoverDepthFuncNV_ARG_EXPAND);
packed_call_t *pack_glPathCoverDepthFuncNV(glPathCoverDepthFuncNV_PACKED *_dst glPathCoverDepthFuncNV_ARG_EXPAND_TAIL);
typedef void (*glPathCoverDepthFuncNV_PTR)(glPathCoverDepthFuncNV_ARG_EXPAND);
#endif
#ifndef glPathDashArrayNV_RETURN
#define glPathDashArrayNV_RETURN void
#define glPathDashArrayNV_ARG_NAMES path, dashCount, dashArray
#define glPathDashArrayNV_ARG_EXPAND GLuint path, GLsizei dashCount, const GLfloat * dashArray
#define glPathDashArrayNV_ARG_NAMES_TAIL , path, dashCount, dashArray
#define glPathDashArrayNV_ARG_EXPAND_TAIL , GLuint path, GLsizei dashCount, const GLfloat * dashArray
#define forward_glPathDashArrayNV(_path, _dashCount, _dashArray) \
    ({ \
        void *dst = remote_dma(sizeof(glPathDashArrayNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathDashArrayNV(dst, _path, _dashCount, _dashArray), NULL); \
    });
#define call_glPathDashArrayNV(packed, ret_v) do { \
    glPathDashArrayNV_PACKED *unpacked = (glPathDashArrayNV_PACKED *)packed; \
    glPathDashArrayNV_ARGS *args = (glPathDashArrayNV_ARGS *)&unpacked->args; \
    glPathDashArrayNV(args->path, args->dashCount, args->dashArray);; \
} while(0)
void glPathDashArrayNV(glPathDashArrayNV_ARG_EXPAND);
packed_call_t *pack_glPathDashArrayNV(glPathDashArrayNV_PACKED *_dst glPathDashArrayNV_ARG_EXPAND_TAIL);
typedef void (*glPathDashArrayNV_PTR)(glPathDashArrayNV_ARG_EXPAND);
#endif
#ifndef glPathFogGenNV_RETURN
#define glPathFogGenNV_RETURN void
#define glPathFogGenNV_ARG_NAMES genMode
#define glPathFogGenNV_ARG_EXPAND GLenum genMode
#define glPathFogGenNV_ARG_NAMES_TAIL , genMode
#define glPathFogGenNV_ARG_EXPAND_TAIL , GLenum genMode
#define forward_glPathFogGenNV(_genMode) \
    ({ \
        void *dst = remote_dma(sizeof(glPathFogGenNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathFogGenNV(dst, _genMode), NULL); \
    });
#define call_glPathFogGenNV(packed, ret_v) do { \
    glPathFogGenNV_PACKED *unpacked = (glPathFogGenNV_PACKED *)packed; \
    glPathFogGenNV_ARGS *args = (glPathFogGenNV_ARGS *)&unpacked->args; \
    glPathFogGenNV(args->genMode);; \
} while(0)
void glPathFogGenNV(glPathFogGenNV_ARG_EXPAND);
packed_call_t *pack_glPathFogGenNV(glPathFogGenNV_PACKED *_dst glPathFogGenNV_ARG_EXPAND_TAIL);
typedef void (*glPathFogGenNV_PTR)(glPathFogGenNV_ARG_EXPAND);
#endif
#ifndef glPathGlyphRangeNV_RETURN
#define glPathGlyphRangeNV_RETURN void
#define glPathGlyphRangeNV_ARG_NAMES firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale
#define glPathGlyphRangeNV_ARG_EXPAND GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale
#define glPathGlyphRangeNV_ARG_NAMES_TAIL , firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale
#define glPathGlyphRangeNV_ARG_EXPAND_TAIL , GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale
#define forward_glPathGlyphRangeNV(_firstPathName, _fontTarget, _fontName, _fontStyle, _firstGlyph, _numGlyphs, _handleMissingGlyphs, _pathParameterTemplate, _emScale) \
    ({ \
        void *dst = remote_dma(sizeof(glPathGlyphRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathGlyphRangeNV(dst, _firstPathName, _fontTarget, _fontName, _fontStyle, _firstGlyph, _numGlyphs, _handleMissingGlyphs, _pathParameterTemplate, _emScale), NULL); \
    });
#define call_glPathGlyphRangeNV(packed, ret_v) do { \
    glPathGlyphRangeNV_PACKED *unpacked = (glPathGlyphRangeNV_PACKED *)packed; \
    glPathGlyphRangeNV_ARGS *args = (glPathGlyphRangeNV_ARGS *)&unpacked->args; \
    glPathGlyphRangeNV(args->firstPathName, args->fontTarget, args->fontName, args->fontStyle, args->firstGlyph, args->numGlyphs, args->handleMissingGlyphs, args->pathParameterTemplate, args->emScale);; \
} while(0)
void glPathGlyphRangeNV(glPathGlyphRangeNV_ARG_EXPAND);
packed_call_t *pack_glPathGlyphRangeNV(glPathGlyphRangeNV_PACKED *_dst glPathGlyphRangeNV_ARG_EXPAND_TAIL);
typedef void (*glPathGlyphRangeNV_PTR)(glPathGlyphRangeNV_ARG_EXPAND);
#endif
#ifndef glPathGlyphsNV_RETURN
#define glPathGlyphsNV_RETURN void
#define glPathGlyphsNV_ARG_NAMES firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale
#define glPathGlyphsNV_ARG_EXPAND GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale
#define glPathGlyphsNV_ARG_NAMES_TAIL , firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale
#define glPathGlyphsNV_ARG_EXPAND_TAIL , GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale
#define forward_glPathGlyphsNV(_firstPathName, _fontTarget, _fontName, _fontStyle, _numGlyphs, _type, _charcodes, _handleMissingGlyphs, _pathParameterTemplate, _emScale) \
    ({ \
        void *dst = remote_dma(sizeof(glPathGlyphsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathGlyphsNV(dst, _firstPathName, _fontTarget, _fontName, _fontStyle, _numGlyphs, _type, _charcodes, _handleMissingGlyphs, _pathParameterTemplate, _emScale), NULL); \
    });
#define call_glPathGlyphsNV(packed, ret_v) do { \
    glPathGlyphsNV_PACKED *unpacked = (glPathGlyphsNV_PACKED *)packed; \
    glPathGlyphsNV_ARGS *args = (glPathGlyphsNV_ARGS *)&unpacked->args; \
    glPathGlyphsNV(args->firstPathName, args->fontTarget, args->fontName, args->fontStyle, args->numGlyphs, args->type, args->charcodes, args->handleMissingGlyphs, args->pathParameterTemplate, args->emScale);; \
} while(0)
void glPathGlyphsNV(glPathGlyphsNV_ARG_EXPAND);
packed_call_t *pack_glPathGlyphsNV(glPathGlyphsNV_PACKED *_dst glPathGlyphsNV_ARG_EXPAND_TAIL);
typedef void (*glPathGlyphsNV_PTR)(glPathGlyphsNV_ARG_EXPAND);
#endif
#ifndef glPathParameterfNV_RETURN
#define glPathParameterfNV_RETURN void
#define glPathParameterfNV_ARG_NAMES path, pname, value
#define glPathParameterfNV_ARG_EXPAND GLuint path, GLenum pname, GLfloat value
#define glPathParameterfNV_ARG_NAMES_TAIL , path, pname, value
#define glPathParameterfNV_ARG_EXPAND_TAIL , GLuint path, GLenum pname, GLfloat value
#define forward_glPathParameterfNV(_path, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glPathParameterfNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathParameterfNV(dst, _path, _pname, _value), NULL); \
    });
#define call_glPathParameterfNV(packed, ret_v) do { \
    glPathParameterfNV_PACKED *unpacked = (glPathParameterfNV_PACKED *)packed; \
    glPathParameterfNV_ARGS *args = (glPathParameterfNV_ARGS *)&unpacked->args; \
    glPathParameterfNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameterfNV(glPathParameterfNV_ARG_EXPAND);
packed_call_t *pack_glPathParameterfNV(glPathParameterfNV_PACKED *_dst glPathParameterfNV_ARG_EXPAND_TAIL);
typedef void (*glPathParameterfNV_PTR)(glPathParameterfNV_ARG_EXPAND);
#endif
#ifndef glPathParameterfvNV_RETURN
#define glPathParameterfvNV_RETURN void
#define glPathParameterfvNV_ARG_NAMES path, pname, value
#define glPathParameterfvNV_ARG_EXPAND GLuint path, GLenum pname, const GLfloat * value
#define glPathParameterfvNV_ARG_NAMES_TAIL , path, pname, value
#define glPathParameterfvNV_ARG_EXPAND_TAIL , GLuint path, GLenum pname, const GLfloat * value
#define forward_glPathParameterfvNV(_path, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glPathParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathParameterfvNV(dst, _path, _pname, _value), NULL); \
    });
#define call_glPathParameterfvNV(packed, ret_v) do { \
    glPathParameterfvNV_PACKED *unpacked = (glPathParameterfvNV_PACKED *)packed; \
    glPathParameterfvNV_ARGS *args = (glPathParameterfvNV_ARGS *)&unpacked->args; \
    glPathParameterfvNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameterfvNV(glPathParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glPathParameterfvNV(glPathParameterfvNV_PACKED *_dst glPathParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glPathParameterfvNV_PTR)(glPathParameterfvNV_ARG_EXPAND);
#endif
#ifndef glPathParameteriNV_RETURN
#define glPathParameteriNV_RETURN void
#define glPathParameteriNV_ARG_NAMES path, pname, value
#define glPathParameteriNV_ARG_EXPAND GLuint path, GLenum pname, GLint value
#define glPathParameteriNV_ARG_NAMES_TAIL , path, pname, value
#define glPathParameteriNV_ARG_EXPAND_TAIL , GLuint path, GLenum pname, GLint value
#define forward_glPathParameteriNV(_path, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glPathParameteriNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathParameteriNV(dst, _path, _pname, _value), NULL); \
    });
#define call_glPathParameteriNV(packed, ret_v) do { \
    glPathParameteriNV_PACKED *unpacked = (glPathParameteriNV_PACKED *)packed; \
    glPathParameteriNV_ARGS *args = (glPathParameteriNV_ARGS *)&unpacked->args; \
    glPathParameteriNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameteriNV(glPathParameteriNV_ARG_EXPAND);
packed_call_t *pack_glPathParameteriNV(glPathParameteriNV_PACKED *_dst glPathParameteriNV_ARG_EXPAND_TAIL);
typedef void (*glPathParameteriNV_PTR)(glPathParameteriNV_ARG_EXPAND);
#endif
#ifndef glPathParameterivNV_RETURN
#define glPathParameterivNV_RETURN void
#define glPathParameterivNV_ARG_NAMES path, pname, value
#define glPathParameterivNV_ARG_EXPAND GLuint path, GLenum pname, const GLint * value
#define glPathParameterivNV_ARG_NAMES_TAIL , path, pname, value
#define glPathParameterivNV_ARG_EXPAND_TAIL , GLuint path, GLenum pname, const GLint * value
#define forward_glPathParameterivNV(_path, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glPathParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathParameterivNV(dst, _path, _pname, _value), NULL); \
    });
#define call_glPathParameterivNV(packed, ret_v) do { \
    glPathParameterivNV_PACKED *unpacked = (glPathParameterivNV_PACKED *)packed; \
    glPathParameterivNV_ARGS *args = (glPathParameterivNV_ARGS *)&unpacked->args; \
    glPathParameterivNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameterivNV(glPathParameterivNV_ARG_EXPAND);
packed_call_t *pack_glPathParameterivNV(glPathParameterivNV_PACKED *_dst glPathParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glPathParameterivNV_PTR)(glPathParameterivNV_ARG_EXPAND);
#endif
#ifndef glPathStencilDepthOffsetNV_RETURN
#define glPathStencilDepthOffsetNV_RETURN void
#define glPathStencilDepthOffsetNV_ARG_NAMES factor, units
#define glPathStencilDepthOffsetNV_ARG_EXPAND GLfloat factor, GLfloat units
#define glPathStencilDepthOffsetNV_ARG_NAMES_TAIL , factor, units
#define glPathStencilDepthOffsetNV_ARG_EXPAND_TAIL , GLfloat factor, GLfloat units
#define forward_glPathStencilDepthOffsetNV(_factor, _units) \
    ({ \
        void *dst = remote_dma(sizeof(glPathStencilDepthOffsetNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathStencilDepthOffsetNV(dst, _factor, _units), NULL); \
    });
#define call_glPathStencilDepthOffsetNV(packed, ret_v) do { \
    glPathStencilDepthOffsetNV_PACKED *unpacked = (glPathStencilDepthOffsetNV_PACKED *)packed; \
    glPathStencilDepthOffsetNV_ARGS *args = (glPathStencilDepthOffsetNV_ARGS *)&unpacked->args; \
    glPathStencilDepthOffsetNV(args->factor, args->units);; \
} while(0)
void glPathStencilDepthOffsetNV(glPathStencilDepthOffsetNV_ARG_EXPAND);
packed_call_t *pack_glPathStencilDepthOffsetNV(glPathStencilDepthOffsetNV_PACKED *_dst glPathStencilDepthOffsetNV_ARG_EXPAND_TAIL);
typedef void (*glPathStencilDepthOffsetNV_PTR)(glPathStencilDepthOffsetNV_ARG_EXPAND);
#endif
#ifndef glPathStencilFuncNV_RETURN
#define glPathStencilFuncNV_RETURN void
#define glPathStencilFuncNV_ARG_NAMES func, ref, mask
#define glPathStencilFuncNV_ARG_EXPAND GLenum func, GLint ref, GLuint mask
#define glPathStencilFuncNV_ARG_NAMES_TAIL , func, ref, mask
#define glPathStencilFuncNV_ARG_EXPAND_TAIL , GLenum func, GLint ref, GLuint mask
#define forward_glPathStencilFuncNV(_func, _ref, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glPathStencilFuncNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathStencilFuncNV(dst, _func, _ref, _mask), NULL); \
    });
#define call_glPathStencilFuncNV(packed, ret_v) do { \
    glPathStencilFuncNV_PACKED *unpacked = (glPathStencilFuncNV_PACKED *)packed; \
    glPathStencilFuncNV_ARGS *args = (glPathStencilFuncNV_ARGS *)&unpacked->args; \
    glPathStencilFuncNV(args->func, args->ref, args->mask);; \
} while(0)
void glPathStencilFuncNV(glPathStencilFuncNV_ARG_EXPAND);
packed_call_t *pack_glPathStencilFuncNV(glPathStencilFuncNV_PACKED *_dst glPathStencilFuncNV_ARG_EXPAND_TAIL);
typedef void (*glPathStencilFuncNV_PTR)(glPathStencilFuncNV_ARG_EXPAND);
#endif
#ifndef glPathStringNV_RETURN
#define glPathStringNV_RETURN void
#define glPathStringNV_ARG_NAMES path, format, length, pathString
#define glPathStringNV_ARG_EXPAND GLuint path, GLenum format, GLsizei length, const GLvoid * pathString
#define glPathStringNV_ARG_NAMES_TAIL , path, format, length, pathString
#define glPathStringNV_ARG_EXPAND_TAIL , GLuint path, GLenum format, GLsizei length, const GLvoid * pathString
#define forward_glPathStringNV(_path, _format, _length, _pathString) \
    ({ \
        void *dst = remote_dma(sizeof(glPathStringNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathStringNV(dst, _path, _format, _length, _pathString), NULL); \
    });
#define call_glPathStringNV(packed, ret_v) do { \
    glPathStringNV_PACKED *unpacked = (glPathStringNV_PACKED *)packed; \
    glPathStringNV_ARGS *args = (glPathStringNV_ARGS *)&unpacked->args; \
    glPathStringNV(args->path, args->format, args->length, args->pathString);; \
} while(0)
void glPathStringNV(glPathStringNV_ARG_EXPAND);
packed_call_t *pack_glPathStringNV(glPathStringNV_PACKED *_dst glPathStringNV_ARG_EXPAND_TAIL);
typedef void (*glPathStringNV_PTR)(glPathStringNV_ARG_EXPAND);
#endif
#ifndef glPathSubCommandsNV_RETURN
#define glPathSubCommandsNV_RETURN void
#define glPathSubCommandsNV_ARG_NAMES path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords
#define glPathSubCommandsNV_ARG_EXPAND GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathSubCommandsNV_ARG_NAMES_TAIL , path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords
#define glPathSubCommandsNV_ARG_EXPAND_TAIL , GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define forward_glPathSubCommandsNV(_path, _commandStart, _commandsToDelete, _numCommands, _commands, _numCoords, _coordType, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glPathSubCommandsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathSubCommandsNV(dst, _path, _commandStart, _commandsToDelete, _numCommands, _commands, _numCoords, _coordType, _coords), NULL); \
    });
#define call_glPathSubCommandsNV(packed, ret_v) do { \
    glPathSubCommandsNV_PACKED *unpacked = (glPathSubCommandsNV_PACKED *)packed; \
    glPathSubCommandsNV_ARGS *args = (glPathSubCommandsNV_ARGS *)&unpacked->args; \
    glPathSubCommandsNV(args->path, args->commandStart, args->commandsToDelete, args->numCommands, args->commands, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathSubCommandsNV(glPathSubCommandsNV_ARG_EXPAND);
packed_call_t *pack_glPathSubCommandsNV(glPathSubCommandsNV_PACKED *_dst glPathSubCommandsNV_ARG_EXPAND_TAIL);
typedef void (*glPathSubCommandsNV_PTR)(glPathSubCommandsNV_ARG_EXPAND);
#endif
#ifndef glPathSubCoordsNV_RETURN
#define glPathSubCoordsNV_RETURN void
#define glPathSubCoordsNV_ARG_NAMES path, coordStart, numCoords, coordType, coords
#define glPathSubCoordsNV_ARG_EXPAND GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathSubCoordsNV_ARG_NAMES_TAIL , path, coordStart, numCoords, coordType, coords
#define glPathSubCoordsNV_ARG_EXPAND_TAIL , GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define forward_glPathSubCoordsNV(_path, _coordStart, _numCoords, _coordType, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glPathSubCoordsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathSubCoordsNV(dst, _path, _coordStart, _numCoords, _coordType, _coords), NULL); \
    });
#define call_glPathSubCoordsNV(packed, ret_v) do { \
    glPathSubCoordsNV_PACKED *unpacked = (glPathSubCoordsNV_PACKED *)packed; \
    glPathSubCoordsNV_ARGS *args = (glPathSubCoordsNV_ARGS *)&unpacked->args; \
    glPathSubCoordsNV(args->path, args->coordStart, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathSubCoordsNV(glPathSubCoordsNV_ARG_EXPAND);
packed_call_t *pack_glPathSubCoordsNV(glPathSubCoordsNV_PACKED *_dst glPathSubCoordsNV_ARG_EXPAND_TAIL);
typedef void (*glPathSubCoordsNV_PTR)(glPathSubCoordsNV_ARG_EXPAND);
#endif
#ifndef glPathTexGenNV_RETURN
#define glPathTexGenNV_RETURN void
#define glPathTexGenNV_ARG_NAMES texCoordSet, genMode, components, coeffs
#define glPathTexGenNV_ARG_EXPAND GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs
#define glPathTexGenNV_ARG_NAMES_TAIL , texCoordSet, genMode, components, coeffs
#define glPathTexGenNV_ARG_EXPAND_TAIL , GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs
#define forward_glPathTexGenNV(_texCoordSet, _genMode, _components, _coeffs) \
    ({ \
        void *dst = remote_dma(sizeof(glPathTexGenNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPathTexGenNV(dst, _texCoordSet, _genMode, _components, _coeffs), NULL); \
    });
#define call_glPathTexGenNV(packed, ret_v) do { \
    glPathTexGenNV_PACKED *unpacked = (glPathTexGenNV_PACKED *)packed; \
    glPathTexGenNV_ARGS *args = (glPathTexGenNV_ARGS *)&unpacked->args; \
    glPathTexGenNV(args->texCoordSet, args->genMode, args->components, args->coeffs);; \
} while(0)
void glPathTexGenNV(glPathTexGenNV_ARG_EXPAND);
packed_call_t *pack_glPathTexGenNV(glPathTexGenNV_PACKED *_dst glPathTexGenNV_ARG_EXPAND_TAIL);
typedef void (*glPathTexGenNV_PTR)(glPathTexGenNV_ARG_EXPAND);
#endif
#ifndef glPauseTransformFeedback_RETURN
#define glPauseTransformFeedback_RETURN void
#define glPauseTransformFeedback_ARG_NAMES 
#define glPauseTransformFeedback_ARG_EXPAND 
#define glPauseTransformFeedback_ARG_NAMES_TAIL 
#define glPauseTransformFeedback_ARG_EXPAND_TAIL 
#define forward_glPauseTransformFeedback() \
    ({ \
        void *dst = remote_dma(sizeof(glPauseTransformFeedback_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPauseTransformFeedback(dst), NULL); \
    });
#define call_glPauseTransformFeedback(packed, ret_v) do { \
    glPauseTransformFeedback();; \
} while(0)
void glPauseTransformFeedback(glPauseTransformFeedback_ARG_EXPAND);
packed_call_t *pack_glPauseTransformFeedback(glPauseTransformFeedback_PACKED *_dst glPauseTransformFeedback_ARG_EXPAND_TAIL);
typedef void (*glPauseTransformFeedback_PTR)(glPauseTransformFeedback_ARG_EXPAND);
#endif
#ifndef glPauseTransformFeedbackNV_RETURN
#define glPauseTransformFeedbackNV_RETURN void
#define glPauseTransformFeedbackNV_ARG_NAMES 
#define glPauseTransformFeedbackNV_ARG_EXPAND 
#define glPauseTransformFeedbackNV_ARG_NAMES_TAIL 
#define glPauseTransformFeedbackNV_ARG_EXPAND_TAIL 
#define forward_glPauseTransformFeedbackNV() \
    ({ \
        void *dst = remote_dma(sizeof(glPauseTransformFeedbackNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPauseTransformFeedbackNV(dst), NULL); \
    });
#define call_glPauseTransformFeedbackNV(packed, ret_v) do { \
    glPauseTransformFeedbackNV();; \
} while(0)
void glPauseTransformFeedbackNV(glPauseTransformFeedbackNV_ARG_EXPAND);
packed_call_t *pack_glPauseTransformFeedbackNV(glPauseTransformFeedbackNV_PACKED *_dst glPauseTransformFeedbackNV_ARG_EXPAND_TAIL);
typedef void (*glPauseTransformFeedbackNV_PTR)(glPauseTransformFeedbackNV_ARG_EXPAND);
#endif
#ifndef glPixelDataRangeNV_RETURN
#define glPixelDataRangeNV_RETURN void
#define glPixelDataRangeNV_ARG_NAMES target, length, pointer
#define glPixelDataRangeNV_ARG_EXPAND GLenum target, GLsizei length, const GLvoid * pointer
#define glPixelDataRangeNV_ARG_NAMES_TAIL , target, length, pointer
#define glPixelDataRangeNV_ARG_EXPAND_TAIL , GLenum target, GLsizei length, const GLvoid * pointer
#define forward_glPixelDataRangeNV(_target, _length, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelDataRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelDataRangeNV(dst, _target, _length, _pointer), NULL); \
    });
#define call_glPixelDataRangeNV(packed, ret_v) do { \
    glPixelDataRangeNV_PACKED *unpacked = (glPixelDataRangeNV_PACKED *)packed; \
    glPixelDataRangeNV_ARGS *args = (glPixelDataRangeNV_ARGS *)&unpacked->args; \
    glPixelDataRangeNV(args->target, args->length, args->pointer);; \
} while(0)
void glPixelDataRangeNV(glPixelDataRangeNV_ARG_EXPAND);
packed_call_t *pack_glPixelDataRangeNV(glPixelDataRangeNV_PACKED *_dst glPixelDataRangeNV_ARG_EXPAND_TAIL);
typedef void (*glPixelDataRangeNV_PTR)(glPixelDataRangeNV_ARG_EXPAND);
#endif
#ifndef glPixelMapfv_RETURN
#define glPixelMapfv_RETURN void
#define glPixelMapfv_ARG_NAMES map, mapsize, values
#define glPixelMapfv_ARG_EXPAND GLenum map, GLsizei mapsize, const GLfloat * values
#define glPixelMapfv_ARG_NAMES_TAIL , map, mapsize, values
#define glPixelMapfv_ARG_EXPAND_TAIL , GLenum map, GLsizei mapsize, const GLfloat * values
#define forward_glPixelMapfv(_map, _mapsize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelMapfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelMapfv(dst, _map, _mapsize, _values), NULL); \
    });
#define call_glPixelMapfv(packed, ret_v) do { \
    glPixelMapfv_PACKED *unpacked = (glPixelMapfv_PACKED *)packed; \
    glPixelMapfv_ARGS *args = (glPixelMapfv_ARGS *)&unpacked->args; \
    glPixelMapfv(args->map, args->mapsize, args->values);; \
} while(0)
void glPixelMapfv(glPixelMapfv_ARG_EXPAND);
packed_call_t *pack_glPixelMapfv(glPixelMapfv_PACKED *_dst glPixelMapfv_ARG_EXPAND_TAIL);
typedef void (*glPixelMapfv_PTR)(glPixelMapfv_ARG_EXPAND);
#endif
#ifndef glPixelMapuiv_RETURN
#define glPixelMapuiv_RETURN void
#define glPixelMapuiv_ARG_NAMES map, mapsize, values
#define glPixelMapuiv_ARG_EXPAND GLenum map, GLsizei mapsize, const GLuint * values
#define glPixelMapuiv_ARG_NAMES_TAIL , map, mapsize, values
#define glPixelMapuiv_ARG_EXPAND_TAIL , GLenum map, GLsizei mapsize, const GLuint * values
#define forward_glPixelMapuiv(_map, _mapsize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelMapuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelMapuiv(dst, _map, _mapsize, _values), NULL); \
    });
#define call_glPixelMapuiv(packed, ret_v) do { \
    glPixelMapuiv_PACKED *unpacked = (glPixelMapuiv_PACKED *)packed; \
    glPixelMapuiv_ARGS *args = (glPixelMapuiv_ARGS *)&unpacked->args; \
    glPixelMapuiv(args->map, args->mapsize, args->values);; \
} while(0)
void glPixelMapuiv(glPixelMapuiv_ARG_EXPAND);
packed_call_t *pack_glPixelMapuiv(glPixelMapuiv_PACKED *_dst glPixelMapuiv_ARG_EXPAND_TAIL);
typedef void (*glPixelMapuiv_PTR)(glPixelMapuiv_ARG_EXPAND);
#endif
#ifndef glPixelMapusv_RETURN
#define glPixelMapusv_RETURN void
#define glPixelMapusv_ARG_NAMES map, mapsize, values
#define glPixelMapusv_ARG_EXPAND GLenum map, GLsizei mapsize, const GLushort * values
#define glPixelMapusv_ARG_NAMES_TAIL , map, mapsize, values
#define glPixelMapusv_ARG_EXPAND_TAIL , GLenum map, GLsizei mapsize, const GLushort * values
#define forward_glPixelMapusv(_map, _mapsize, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelMapusv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelMapusv(dst, _map, _mapsize, _values), NULL); \
    });
#define call_glPixelMapusv(packed, ret_v) do { \
    glPixelMapusv_PACKED *unpacked = (glPixelMapusv_PACKED *)packed; \
    glPixelMapusv_ARGS *args = (glPixelMapusv_ARGS *)&unpacked->args; \
    glPixelMapusv(args->map, args->mapsize, args->values);; \
} while(0)
void glPixelMapusv(glPixelMapusv_ARG_EXPAND);
packed_call_t *pack_glPixelMapusv(glPixelMapusv_PACKED *_dst glPixelMapusv_ARG_EXPAND_TAIL);
typedef void (*glPixelMapusv_PTR)(glPixelMapusv_ARG_EXPAND);
#endif
#ifndef glPixelMapx_RETURN
#define glPixelMapx_RETURN void
#define glPixelMapx_ARG_NAMES map, size, values
#define glPixelMapx_ARG_EXPAND GLenum map, GLint size, const GLfixed * values
#define glPixelMapx_ARG_NAMES_TAIL , map, size, values
#define glPixelMapx_ARG_EXPAND_TAIL , GLenum map, GLint size, const GLfixed * values
#define forward_glPixelMapx(_map, _size, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelMapx_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelMapx(dst, _map, _size, _values), NULL); \
    });
#define call_glPixelMapx(packed, ret_v) do { \
    glPixelMapx_PACKED *unpacked = (glPixelMapx_PACKED *)packed; \
    glPixelMapx_ARGS *args = (glPixelMapx_ARGS *)&unpacked->args; \
    glPixelMapx(args->map, args->size, args->values);; \
} while(0)
void glPixelMapx(glPixelMapx_ARG_EXPAND);
packed_call_t *pack_glPixelMapx(glPixelMapx_PACKED *_dst glPixelMapx_ARG_EXPAND_TAIL);
typedef void (*glPixelMapx_PTR)(glPixelMapx_ARG_EXPAND);
#endif
#ifndef glPixelStoref_RETURN
#define glPixelStoref_RETURN void
#define glPixelStoref_ARG_NAMES pname, param
#define glPixelStoref_ARG_EXPAND GLenum pname, GLfloat param
#define glPixelStoref_ARG_NAMES_TAIL , pname, param
#define glPixelStoref_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPixelStoref(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelStoref_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelStoref(dst, _pname, _param), NULL); \
    });
#define call_glPixelStoref(packed, ret_v) do { \
    glPixelStoref_PACKED *unpacked = (glPixelStoref_PACKED *)packed; \
    glPixelStoref_ARGS *args = (glPixelStoref_ARGS *)&unpacked->args; \
    glPixelStoref(args->pname, args->param);; \
} while(0)
void glPixelStoref(glPixelStoref_ARG_EXPAND);
packed_call_t *pack_glPixelStoref(glPixelStoref_PACKED *_dst glPixelStoref_ARG_EXPAND_TAIL);
typedef void (*glPixelStoref_PTR)(glPixelStoref_ARG_EXPAND);
#endif
#ifndef glPixelStorei_RETURN
#define glPixelStorei_RETURN void
#define glPixelStorei_ARG_NAMES pname, param
#define glPixelStorei_ARG_EXPAND GLenum pname, GLint param
#define glPixelStorei_ARG_NAMES_TAIL , pname, param
#define glPixelStorei_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glPixelStorei(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelStorei_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelStorei(dst, _pname, _param), NULL); \
    });
#define call_glPixelStorei(packed, ret_v) do { \
    glPixelStorei_PACKED *unpacked = (glPixelStorei_PACKED *)packed; \
    glPixelStorei_ARGS *args = (glPixelStorei_ARGS *)&unpacked->args; \
    glPixelStorei(args->pname, args->param);; \
} while(0)
void glPixelStorei(glPixelStorei_ARG_EXPAND);
packed_call_t *pack_glPixelStorei(glPixelStorei_PACKED *_dst glPixelStorei_ARG_EXPAND_TAIL);
typedef void (*glPixelStorei_PTR)(glPixelStorei_ARG_EXPAND);
#endif
#ifndef glPixelStorex_RETURN
#define glPixelStorex_RETURN void
#define glPixelStorex_ARG_NAMES pname, param
#define glPixelStorex_ARG_EXPAND GLenum pname, GLfixed param
#define glPixelStorex_ARG_NAMES_TAIL , pname, param
#define glPixelStorex_ARG_EXPAND_TAIL , GLenum pname, GLfixed param
#define forward_glPixelStorex(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelStorex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelStorex(dst, _pname, _param), NULL); \
    });
#define call_glPixelStorex(packed, ret_v) do { \
    glPixelStorex_PACKED *unpacked = (glPixelStorex_PACKED *)packed; \
    glPixelStorex_ARGS *args = (glPixelStorex_ARGS *)&unpacked->args; \
    glPixelStorex(args->pname, args->param);; \
} while(0)
void glPixelStorex(glPixelStorex_ARG_EXPAND);
packed_call_t *pack_glPixelStorex(glPixelStorex_PACKED *_dst glPixelStorex_ARG_EXPAND_TAIL);
typedef void (*glPixelStorex_PTR)(glPixelStorex_ARG_EXPAND);
#endif
#ifndef glPixelTexGenParameterfSGIS_RETURN
#define glPixelTexGenParameterfSGIS_RETURN void
#define glPixelTexGenParameterfSGIS_ARG_NAMES pname, param
#define glPixelTexGenParameterfSGIS_ARG_EXPAND GLenum pname, GLfloat param
#define glPixelTexGenParameterfSGIS_ARG_NAMES_TAIL , pname, param
#define glPixelTexGenParameterfSGIS_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPixelTexGenParameterfSGIS(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTexGenParameterfSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTexGenParameterfSGIS(dst, _pname, _param), NULL); \
    });
#define call_glPixelTexGenParameterfSGIS(packed, ret_v) do { \
    glPixelTexGenParameterfSGIS_PACKED *unpacked = (glPixelTexGenParameterfSGIS_PACKED *)packed; \
    glPixelTexGenParameterfSGIS_ARGS *args = (glPixelTexGenParameterfSGIS_ARGS *)&unpacked->args; \
    glPixelTexGenParameterfSGIS(args->pname, args->param);; \
} while(0)
void glPixelTexGenParameterfSGIS(glPixelTexGenParameterfSGIS_ARG_EXPAND);
packed_call_t *pack_glPixelTexGenParameterfSGIS(glPixelTexGenParameterfSGIS_PACKED *_dst glPixelTexGenParameterfSGIS_ARG_EXPAND_TAIL);
typedef void (*glPixelTexGenParameterfSGIS_PTR)(glPixelTexGenParameterfSGIS_ARG_EXPAND);
#endif
#ifndef glPixelTexGenParameterfvSGIS_RETURN
#define glPixelTexGenParameterfvSGIS_RETURN void
#define glPixelTexGenParameterfvSGIS_ARG_NAMES pname, params
#define glPixelTexGenParameterfvSGIS_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPixelTexGenParameterfvSGIS_ARG_NAMES_TAIL , pname, params
#define glPixelTexGenParameterfvSGIS_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glPixelTexGenParameterfvSGIS(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTexGenParameterfvSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTexGenParameterfvSGIS(dst, _pname, _params), NULL); \
    });
#define call_glPixelTexGenParameterfvSGIS(packed, ret_v) do { \
    glPixelTexGenParameterfvSGIS_PACKED *unpacked = (glPixelTexGenParameterfvSGIS_PACKED *)packed; \
    glPixelTexGenParameterfvSGIS_ARGS *args = (glPixelTexGenParameterfvSGIS_ARGS *)&unpacked->args; \
    glPixelTexGenParameterfvSGIS(args->pname, args->params);; \
} while(0)
void glPixelTexGenParameterfvSGIS(glPixelTexGenParameterfvSGIS_ARG_EXPAND);
packed_call_t *pack_glPixelTexGenParameterfvSGIS(glPixelTexGenParameterfvSGIS_PACKED *_dst glPixelTexGenParameterfvSGIS_ARG_EXPAND_TAIL);
typedef void (*glPixelTexGenParameterfvSGIS_PTR)(glPixelTexGenParameterfvSGIS_ARG_EXPAND);
#endif
#ifndef glPixelTexGenParameteriSGIS_RETURN
#define glPixelTexGenParameteriSGIS_RETURN void
#define glPixelTexGenParameteriSGIS_ARG_NAMES pname, param
#define glPixelTexGenParameteriSGIS_ARG_EXPAND GLenum pname, GLint param
#define glPixelTexGenParameteriSGIS_ARG_NAMES_TAIL , pname, param
#define glPixelTexGenParameteriSGIS_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glPixelTexGenParameteriSGIS(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTexGenParameteriSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTexGenParameteriSGIS(dst, _pname, _param), NULL); \
    });
#define call_glPixelTexGenParameteriSGIS(packed, ret_v) do { \
    glPixelTexGenParameteriSGIS_PACKED *unpacked = (glPixelTexGenParameteriSGIS_PACKED *)packed; \
    glPixelTexGenParameteriSGIS_ARGS *args = (glPixelTexGenParameteriSGIS_ARGS *)&unpacked->args; \
    glPixelTexGenParameteriSGIS(args->pname, args->param);; \
} while(0)
void glPixelTexGenParameteriSGIS(glPixelTexGenParameteriSGIS_ARG_EXPAND);
packed_call_t *pack_glPixelTexGenParameteriSGIS(glPixelTexGenParameteriSGIS_PACKED *_dst glPixelTexGenParameteriSGIS_ARG_EXPAND_TAIL);
typedef void (*glPixelTexGenParameteriSGIS_PTR)(glPixelTexGenParameteriSGIS_ARG_EXPAND);
#endif
#ifndef glPixelTexGenParameterivSGIS_RETURN
#define glPixelTexGenParameterivSGIS_RETURN void
#define glPixelTexGenParameterivSGIS_ARG_NAMES pname, params
#define glPixelTexGenParameterivSGIS_ARG_EXPAND GLenum pname, const GLint * params
#define glPixelTexGenParameterivSGIS_ARG_NAMES_TAIL , pname, params
#define glPixelTexGenParameterivSGIS_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glPixelTexGenParameterivSGIS(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTexGenParameterivSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTexGenParameterivSGIS(dst, _pname, _params), NULL); \
    });
#define call_glPixelTexGenParameterivSGIS(packed, ret_v) do { \
    glPixelTexGenParameterivSGIS_PACKED *unpacked = (glPixelTexGenParameterivSGIS_PACKED *)packed; \
    glPixelTexGenParameterivSGIS_ARGS *args = (glPixelTexGenParameterivSGIS_ARGS *)&unpacked->args; \
    glPixelTexGenParameterivSGIS(args->pname, args->params);; \
} while(0)
void glPixelTexGenParameterivSGIS(glPixelTexGenParameterivSGIS_ARG_EXPAND);
packed_call_t *pack_glPixelTexGenParameterivSGIS(glPixelTexGenParameterivSGIS_PACKED *_dst glPixelTexGenParameterivSGIS_ARG_EXPAND_TAIL);
typedef void (*glPixelTexGenParameterivSGIS_PTR)(glPixelTexGenParameterivSGIS_ARG_EXPAND);
#endif
#ifndef glPixelTexGenSGIX_RETURN
#define glPixelTexGenSGIX_RETURN void
#define glPixelTexGenSGIX_ARG_NAMES mode
#define glPixelTexGenSGIX_ARG_EXPAND GLenum mode
#define glPixelTexGenSGIX_ARG_NAMES_TAIL , mode
#define glPixelTexGenSGIX_ARG_EXPAND_TAIL , GLenum mode
#define forward_glPixelTexGenSGIX(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTexGenSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTexGenSGIX(dst, _mode), NULL); \
    });
#define call_glPixelTexGenSGIX(packed, ret_v) do { \
    glPixelTexGenSGIX_PACKED *unpacked = (glPixelTexGenSGIX_PACKED *)packed; \
    glPixelTexGenSGIX_ARGS *args = (glPixelTexGenSGIX_ARGS *)&unpacked->args; \
    glPixelTexGenSGIX(args->mode);; \
} while(0)
void glPixelTexGenSGIX(glPixelTexGenSGIX_ARG_EXPAND);
packed_call_t *pack_glPixelTexGenSGIX(glPixelTexGenSGIX_PACKED *_dst glPixelTexGenSGIX_ARG_EXPAND_TAIL);
typedef void (*glPixelTexGenSGIX_PTR)(glPixelTexGenSGIX_ARG_EXPAND);
#endif
#ifndef glPixelTransferf_RETURN
#define glPixelTransferf_RETURN void
#define glPixelTransferf_ARG_NAMES pname, param
#define glPixelTransferf_ARG_EXPAND GLenum pname, GLfloat param
#define glPixelTransferf_ARG_NAMES_TAIL , pname, param
#define glPixelTransferf_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPixelTransferf(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTransferf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTransferf(dst, _pname, _param), NULL); \
    });
#define call_glPixelTransferf(packed, ret_v) do { \
    glPixelTransferf_PACKED *unpacked = (glPixelTransferf_PACKED *)packed; \
    glPixelTransferf_ARGS *args = (glPixelTransferf_ARGS *)&unpacked->args; \
    glPixelTransferf(args->pname, args->param);; \
} while(0)
void glPixelTransferf(glPixelTransferf_ARG_EXPAND);
packed_call_t *pack_glPixelTransferf(glPixelTransferf_PACKED *_dst glPixelTransferf_ARG_EXPAND_TAIL);
typedef void (*glPixelTransferf_PTR)(glPixelTransferf_ARG_EXPAND);
#endif
#ifndef glPixelTransferi_RETURN
#define glPixelTransferi_RETURN void
#define glPixelTransferi_ARG_NAMES pname, param
#define glPixelTransferi_ARG_EXPAND GLenum pname, GLint param
#define glPixelTransferi_ARG_NAMES_TAIL , pname, param
#define glPixelTransferi_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glPixelTransferi(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTransferi_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTransferi(dst, _pname, _param), NULL); \
    });
#define call_glPixelTransferi(packed, ret_v) do { \
    glPixelTransferi_PACKED *unpacked = (glPixelTransferi_PACKED *)packed; \
    glPixelTransferi_ARGS *args = (glPixelTransferi_ARGS *)&unpacked->args; \
    glPixelTransferi(args->pname, args->param);; \
} while(0)
void glPixelTransferi(glPixelTransferi_ARG_EXPAND);
packed_call_t *pack_glPixelTransferi(glPixelTransferi_PACKED *_dst glPixelTransferi_ARG_EXPAND_TAIL);
typedef void (*glPixelTransferi_PTR)(glPixelTransferi_ARG_EXPAND);
#endif
#ifndef glPixelTransferxOES_RETURN
#define glPixelTransferxOES_RETURN void
#define glPixelTransferxOES_ARG_NAMES pname, param
#define glPixelTransferxOES_ARG_EXPAND GLenum pname, GLfixed param
#define glPixelTransferxOES_ARG_NAMES_TAIL , pname, param
#define glPixelTransferxOES_ARG_EXPAND_TAIL , GLenum pname, GLfixed param
#define forward_glPixelTransferxOES(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTransferxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTransferxOES(dst, _pname, _param), NULL); \
    });
#define call_glPixelTransferxOES(packed, ret_v) do { \
    glPixelTransferxOES_PACKED *unpacked = (glPixelTransferxOES_PACKED *)packed; \
    glPixelTransferxOES_ARGS *args = (glPixelTransferxOES_ARGS *)&unpacked->args; \
    glPixelTransferxOES(args->pname, args->param);; \
} while(0)
void glPixelTransferxOES(glPixelTransferxOES_ARG_EXPAND);
packed_call_t *pack_glPixelTransferxOES(glPixelTransferxOES_PACKED *_dst glPixelTransferxOES_ARG_EXPAND_TAIL);
typedef void (*glPixelTransferxOES_PTR)(glPixelTransferxOES_ARG_EXPAND);
#endif
#ifndef glPixelTransformParameterfEXT_RETURN
#define glPixelTransformParameterfEXT_RETURN void
#define glPixelTransformParameterfEXT_ARG_NAMES target, pname, param
#define glPixelTransformParameterfEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glPixelTransformParameterfEXT_ARG_NAMES_TAIL , target, pname, param
#define glPixelTransformParameterfEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat param
#define forward_glPixelTransformParameterfEXT(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTransformParameterfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTransformParameterfEXT(dst, _target, _pname, _param), NULL); \
    });
#define call_glPixelTransformParameterfEXT(packed, ret_v) do { \
    glPixelTransformParameterfEXT_PACKED *unpacked = (glPixelTransformParameterfEXT_PACKED *)packed; \
    glPixelTransformParameterfEXT_ARGS *args = (glPixelTransformParameterfEXT_ARGS *)&unpacked->args; \
    glPixelTransformParameterfEXT(args->target, args->pname, args->param);; \
} while(0)
void glPixelTransformParameterfEXT(glPixelTransformParameterfEXT_ARG_EXPAND);
packed_call_t *pack_glPixelTransformParameterfEXT(glPixelTransformParameterfEXT_PACKED *_dst glPixelTransformParameterfEXT_ARG_EXPAND_TAIL);
typedef void (*glPixelTransformParameterfEXT_PTR)(glPixelTransformParameterfEXT_ARG_EXPAND);
#endif
#ifndef glPixelTransformParameterfvEXT_RETURN
#define glPixelTransformParameterfvEXT_RETURN void
#define glPixelTransformParameterfvEXT_ARG_NAMES target, pname, params
#define glPixelTransformParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glPixelTransformParameterfvEXT_ARG_NAMES_TAIL , target, pname, params
#define glPixelTransformParameterfvEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glPixelTransformParameterfvEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTransformParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTransformParameterfvEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glPixelTransformParameterfvEXT(packed, ret_v) do { \
    glPixelTransformParameterfvEXT_PACKED *unpacked = (glPixelTransformParameterfvEXT_PACKED *)packed; \
    glPixelTransformParameterfvEXT_ARGS *args = (glPixelTransformParameterfvEXT_ARGS *)&unpacked->args; \
    glPixelTransformParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glPixelTransformParameterfvEXT(glPixelTransformParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glPixelTransformParameterfvEXT(glPixelTransformParameterfvEXT_PACKED *_dst glPixelTransformParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glPixelTransformParameterfvEXT_PTR)(glPixelTransformParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glPixelTransformParameteriEXT_RETURN
#define glPixelTransformParameteriEXT_RETURN void
#define glPixelTransformParameteriEXT_ARG_NAMES target, pname, param
#define glPixelTransformParameteriEXT_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glPixelTransformParameteriEXT_ARG_NAMES_TAIL , target, pname, param
#define glPixelTransformParameteriEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint param
#define forward_glPixelTransformParameteriEXT(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTransformParameteriEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTransformParameteriEXT(dst, _target, _pname, _param), NULL); \
    });
#define call_glPixelTransformParameteriEXT(packed, ret_v) do { \
    glPixelTransformParameteriEXT_PACKED *unpacked = (glPixelTransformParameteriEXT_PACKED *)packed; \
    glPixelTransformParameteriEXT_ARGS *args = (glPixelTransformParameteriEXT_ARGS *)&unpacked->args; \
    glPixelTransformParameteriEXT(args->target, args->pname, args->param);; \
} while(0)
void glPixelTransformParameteriEXT(glPixelTransformParameteriEXT_ARG_EXPAND);
packed_call_t *pack_glPixelTransformParameteriEXT(glPixelTransformParameteriEXT_PACKED *_dst glPixelTransformParameteriEXT_ARG_EXPAND_TAIL);
typedef void (*glPixelTransformParameteriEXT_PTR)(glPixelTransformParameteriEXT_ARG_EXPAND);
#endif
#ifndef glPixelTransformParameterivEXT_RETURN
#define glPixelTransformParameterivEXT_RETURN void
#define glPixelTransformParameterivEXT_ARG_NAMES target, pname, params
#define glPixelTransformParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glPixelTransformParameterivEXT_ARG_NAMES_TAIL , target, pname, params
#define glPixelTransformParameterivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glPixelTransformParameterivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelTransformParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelTransformParameterivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glPixelTransformParameterivEXT(packed, ret_v) do { \
    glPixelTransformParameterivEXT_PACKED *unpacked = (glPixelTransformParameterivEXT_PACKED *)packed; \
    glPixelTransformParameterivEXT_ARGS *args = (glPixelTransformParameterivEXT_ARGS *)&unpacked->args; \
    glPixelTransformParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glPixelTransformParameterivEXT(glPixelTransformParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glPixelTransformParameterivEXT(glPixelTransformParameterivEXT_PACKED *_dst glPixelTransformParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glPixelTransformParameterivEXT_PTR)(glPixelTransformParameterivEXT_ARG_EXPAND);
#endif
#ifndef glPixelZoom_RETURN
#define glPixelZoom_RETURN void
#define glPixelZoom_ARG_NAMES xfactor, yfactor
#define glPixelZoom_ARG_EXPAND GLfloat xfactor, GLfloat yfactor
#define glPixelZoom_ARG_NAMES_TAIL , xfactor, yfactor
#define glPixelZoom_ARG_EXPAND_TAIL , GLfloat xfactor, GLfloat yfactor
#define forward_glPixelZoom(_xfactor, _yfactor) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelZoom_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelZoom(dst, _xfactor, _yfactor), NULL); \
    });
#define call_glPixelZoom(packed, ret_v) do { \
    glPixelZoom_PACKED *unpacked = (glPixelZoom_PACKED *)packed; \
    glPixelZoom_ARGS *args = (glPixelZoom_ARGS *)&unpacked->args; \
    glPixelZoom(args->xfactor, args->yfactor);; \
} while(0)
void glPixelZoom(glPixelZoom_ARG_EXPAND);
packed_call_t *pack_glPixelZoom(glPixelZoom_PACKED *_dst glPixelZoom_ARG_EXPAND_TAIL);
typedef void (*glPixelZoom_PTR)(glPixelZoom_ARG_EXPAND);
#endif
#ifndef glPixelZoomxOES_RETURN
#define glPixelZoomxOES_RETURN void
#define glPixelZoomxOES_ARG_NAMES xfactor, yfactor
#define glPixelZoomxOES_ARG_EXPAND GLfixed xfactor, GLfixed yfactor
#define glPixelZoomxOES_ARG_NAMES_TAIL , xfactor, yfactor
#define glPixelZoomxOES_ARG_EXPAND_TAIL , GLfixed xfactor, GLfixed yfactor
#define forward_glPixelZoomxOES(_xfactor, _yfactor) \
    ({ \
        void *dst = remote_dma(sizeof(glPixelZoomxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPixelZoomxOES(dst, _xfactor, _yfactor), NULL); \
    });
#define call_glPixelZoomxOES(packed, ret_v) do { \
    glPixelZoomxOES_PACKED *unpacked = (glPixelZoomxOES_PACKED *)packed; \
    glPixelZoomxOES_ARGS *args = (glPixelZoomxOES_ARGS *)&unpacked->args; \
    glPixelZoomxOES(args->xfactor, args->yfactor);; \
} while(0)
void glPixelZoomxOES(glPixelZoomxOES_ARG_EXPAND);
packed_call_t *pack_glPixelZoomxOES(glPixelZoomxOES_PACKED *_dst glPixelZoomxOES_ARG_EXPAND_TAIL);
typedef void (*glPixelZoomxOES_PTR)(glPixelZoomxOES_ARG_EXPAND);
#endif
#ifndef glPointAlongPathNV_RETURN
#define glPointAlongPathNV_RETURN GLboolean
#define glPointAlongPathNV_ARG_NAMES path, startSegment, numSegments, distance, x, y, tangentX, tangentY
#define glPointAlongPathNV_ARG_EXPAND GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY
#define glPointAlongPathNV_ARG_NAMES_TAIL , path, startSegment, numSegments, distance, x, y, tangentX, tangentY
#define glPointAlongPathNV_ARG_EXPAND_TAIL , GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY
#define forward_glPointAlongPathNV(_path, _startSegment, _numSegments, _distance, _x, _y, _tangentX, _tangentY) \
    ({ \
        void *dst = remote_dma(sizeof(glPointAlongPathNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glPointAlongPathNV(dst, _path, _startSegment, _numSegments, _distance, _x, _y, _tangentX, _tangentY), &ret); \
        ret; \
    });
#define call_glPointAlongPathNV(packed, ret_v) do { \
    glPointAlongPathNV_PACKED *unpacked = (glPointAlongPathNV_PACKED *)packed; \
    glPointAlongPathNV_ARGS *args = (glPointAlongPathNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glPointAlongPathNV(args->path, args->startSegment, args->numSegments, args->distance, args->x, args->y, args->tangentX, args->tangentY);; \
    } else { \
        glPointAlongPathNV(args->path, args->startSegment, args->numSegments, args->distance, args->x, args->y, args->tangentX, args->tangentY);; \
    } \
} while(0)
GLboolean glPointAlongPathNV(glPointAlongPathNV_ARG_EXPAND);
packed_call_t *pack_glPointAlongPathNV(glPointAlongPathNV_PACKED *_dst glPointAlongPathNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glPointAlongPathNV_PTR)(glPointAlongPathNV_ARG_EXPAND);
#endif
#ifndef glPointParameterf_RETURN
#define glPointParameterf_RETURN void
#define glPointParameterf_ARG_NAMES pname, param
#define glPointParameterf_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterf_ARG_NAMES_TAIL , pname, param
#define glPointParameterf_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPointParameterf(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterf(dst, _pname, _param), NULL); \
    });
#define call_glPointParameterf(packed, ret_v) do { \
    glPointParameterf_PACKED *unpacked = (glPointParameterf_PACKED *)packed; \
    glPointParameterf_ARGS *args = (glPointParameterf_ARGS *)&unpacked->args; \
    glPointParameterf(args->pname, args->param);; \
} while(0)
void glPointParameterf(glPointParameterf_ARG_EXPAND);
packed_call_t *pack_glPointParameterf(glPointParameterf_PACKED *_dst glPointParameterf_ARG_EXPAND_TAIL);
typedef void (*glPointParameterf_PTR)(glPointParameterf_ARG_EXPAND);
#endif
#ifndef glPointParameterfARB_RETURN
#define glPointParameterfARB_RETURN void
#define glPointParameterfARB_ARG_NAMES pname, param
#define glPointParameterfARB_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterfARB_ARG_NAMES_TAIL , pname, param
#define glPointParameterfARB_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPointParameterfARB(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterfARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterfARB(dst, _pname, _param), NULL); \
    });
#define call_glPointParameterfARB(packed, ret_v) do { \
    glPointParameterfARB_PACKED *unpacked = (glPointParameterfARB_PACKED *)packed; \
    glPointParameterfARB_ARGS *args = (glPointParameterfARB_ARGS *)&unpacked->args; \
    glPointParameterfARB(args->pname, args->param);; \
} while(0)
void glPointParameterfARB(glPointParameterfARB_ARG_EXPAND);
packed_call_t *pack_glPointParameterfARB(glPointParameterfARB_PACKED *_dst glPointParameterfARB_ARG_EXPAND_TAIL);
typedef void (*glPointParameterfARB_PTR)(glPointParameterfARB_ARG_EXPAND);
#endif
#ifndef glPointParameterfEXT_RETURN
#define glPointParameterfEXT_RETURN void
#define glPointParameterfEXT_ARG_NAMES pname, param
#define glPointParameterfEXT_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterfEXT_ARG_NAMES_TAIL , pname, param
#define glPointParameterfEXT_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPointParameterfEXT(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterfEXT(dst, _pname, _param), NULL); \
    });
#define call_glPointParameterfEXT(packed, ret_v) do { \
    glPointParameterfEXT_PACKED *unpacked = (glPointParameterfEXT_PACKED *)packed; \
    glPointParameterfEXT_ARGS *args = (glPointParameterfEXT_ARGS *)&unpacked->args; \
    glPointParameterfEXT(args->pname, args->param);; \
} while(0)
void glPointParameterfEXT(glPointParameterfEXT_ARG_EXPAND);
packed_call_t *pack_glPointParameterfEXT(glPointParameterfEXT_PACKED *_dst glPointParameterfEXT_ARG_EXPAND_TAIL);
typedef void (*glPointParameterfEXT_PTR)(glPointParameterfEXT_ARG_EXPAND);
#endif
#ifndef glPointParameterfSGIS_RETURN
#define glPointParameterfSGIS_RETURN void
#define glPointParameterfSGIS_ARG_NAMES pname, param
#define glPointParameterfSGIS_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterfSGIS_ARG_NAMES_TAIL , pname, param
#define glPointParameterfSGIS_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glPointParameterfSGIS(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterfSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterfSGIS(dst, _pname, _param), NULL); \
    });
#define call_glPointParameterfSGIS(packed, ret_v) do { \
    glPointParameterfSGIS_PACKED *unpacked = (glPointParameterfSGIS_PACKED *)packed; \
    glPointParameterfSGIS_ARGS *args = (glPointParameterfSGIS_ARGS *)&unpacked->args; \
    glPointParameterfSGIS(args->pname, args->param);; \
} while(0)
void glPointParameterfSGIS(glPointParameterfSGIS_ARG_EXPAND);
packed_call_t *pack_glPointParameterfSGIS(glPointParameterfSGIS_PACKED *_dst glPointParameterfSGIS_ARG_EXPAND_TAIL);
typedef void (*glPointParameterfSGIS_PTR)(glPointParameterfSGIS_ARG_EXPAND);
#endif
#ifndef glPointParameterfv_RETURN
#define glPointParameterfv_RETURN void
#define glPointParameterfv_ARG_NAMES pname, params
#define glPointParameterfv_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfv_ARG_NAMES_TAIL , pname, params
#define glPointParameterfv_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glPointParameterfv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterfv(dst, _pname, _params), NULL); \
    });
#define call_glPointParameterfv(packed, ret_v) do { \
    glPointParameterfv_PACKED *unpacked = (glPointParameterfv_PACKED *)packed; \
    glPointParameterfv_ARGS *args = (glPointParameterfv_ARGS *)&unpacked->args; \
    glPointParameterfv(args->pname, args->params);; \
} while(0)
void glPointParameterfv(glPointParameterfv_ARG_EXPAND);
packed_call_t *pack_glPointParameterfv(glPointParameterfv_PACKED *_dst glPointParameterfv_ARG_EXPAND_TAIL);
typedef void (*glPointParameterfv_PTR)(glPointParameterfv_ARG_EXPAND);
#endif
#ifndef glPointParameterfvARB_RETURN
#define glPointParameterfvARB_RETURN void
#define glPointParameterfvARB_ARG_NAMES pname, params
#define glPointParameterfvARB_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfvARB_ARG_NAMES_TAIL , pname, params
#define glPointParameterfvARB_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glPointParameterfvARB(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterfvARB(dst, _pname, _params), NULL); \
    });
#define call_glPointParameterfvARB(packed, ret_v) do { \
    glPointParameterfvARB_PACKED *unpacked = (glPointParameterfvARB_PACKED *)packed; \
    glPointParameterfvARB_ARGS *args = (glPointParameterfvARB_ARGS *)&unpacked->args; \
    glPointParameterfvARB(args->pname, args->params);; \
} while(0)
void glPointParameterfvARB(glPointParameterfvARB_ARG_EXPAND);
packed_call_t *pack_glPointParameterfvARB(glPointParameterfvARB_PACKED *_dst glPointParameterfvARB_ARG_EXPAND_TAIL);
typedef void (*glPointParameterfvARB_PTR)(glPointParameterfvARB_ARG_EXPAND);
#endif
#ifndef glPointParameterfvEXT_RETURN
#define glPointParameterfvEXT_RETURN void
#define glPointParameterfvEXT_ARG_NAMES pname, params
#define glPointParameterfvEXT_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfvEXT_ARG_NAMES_TAIL , pname, params
#define glPointParameterfvEXT_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glPointParameterfvEXT(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterfvEXT(dst, _pname, _params), NULL); \
    });
#define call_glPointParameterfvEXT(packed, ret_v) do { \
    glPointParameterfvEXT_PACKED *unpacked = (glPointParameterfvEXT_PACKED *)packed; \
    glPointParameterfvEXT_ARGS *args = (glPointParameterfvEXT_ARGS *)&unpacked->args; \
    glPointParameterfvEXT(args->pname, args->params);; \
} while(0)
void glPointParameterfvEXT(glPointParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glPointParameterfvEXT(glPointParameterfvEXT_PACKED *_dst glPointParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glPointParameterfvEXT_PTR)(glPointParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glPointParameterfvSGIS_RETURN
#define glPointParameterfvSGIS_RETURN void
#define glPointParameterfvSGIS_ARG_NAMES pname, params
#define glPointParameterfvSGIS_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfvSGIS_ARG_NAMES_TAIL , pname, params
#define glPointParameterfvSGIS_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glPointParameterfvSGIS(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterfvSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterfvSGIS(dst, _pname, _params), NULL); \
    });
#define call_glPointParameterfvSGIS(packed, ret_v) do { \
    glPointParameterfvSGIS_PACKED *unpacked = (glPointParameterfvSGIS_PACKED *)packed; \
    glPointParameterfvSGIS_ARGS *args = (glPointParameterfvSGIS_ARGS *)&unpacked->args; \
    glPointParameterfvSGIS(args->pname, args->params);; \
} while(0)
void glPointParameterfvSGIS(glPointParameterfvSGIS_ARG_EXPAND);
packed_call_t *pack_glPointParameterfvSGIS(glPointParameterfvSGIS_PACKED *_dst glPointParameterfvSGIS_ARG_EXPAND_TAIL);
typedef void (*glPointParameterfvSGIS_PTR)(glPointParameterfvSGIS_ARG_EXPAND);
#endif
#ifndef glPointParameteri_RETURN
#define glPointParameteri_RETURN void
#define glPointParameteri_ARG_NAMES pname, param
#define glPointParameteri_ARG_EXPAND GLenum pname, GLint param
#define glPointParameteri_ARG_NAMES_TAIL , pname, param
#define glPointParameteri_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glPointParameteri(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameteri_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameteri(dst, _pname, _param), NULL); \
    });
#define call_glPointParameteri(packed, ret_v) do { \
    glPointParameteri_PACKED *unpacked = (glPointParameteri_PACKED *)packed; \
    glPointParameteri_ARGS *args = (glPointParameteri_ARGS *)&unpacked->args; \
    glPointParameteri(args->pname, args->param);; \
} while(0)
void glPointParameteri(glPointParameteri_ARG_EXPAND);
packed_call_t *pack_glPointParameteri(glPointParameteri_PACKED *_dst glPointParameteri_ARG_EXPAND_TAIL);
typedef void (*glPointParameteri_PTR)(glPointParameteri_ARG_EXPAND);
#endif
#ifndef glPointParameteriNV_RETURN
#define glPointParameteriNV_RETURN void
#define glPointParameteriNV_ARG_NAMES pname, param
#define glPointParameteriNV_ARG_EXPAND GLenum pname, GLint param
#define glPointParameteriNV_ARG_NAMES_TAIL , pname, param
#define glPointParameteriNV_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glPointParameteriNV(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameteriNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameteriNV(dst, _pname, _param), NULL); \
    });
#define call_glPointParameteriNV(packed, ret_v) do { \
    glPointParameteriNV_PACKED *unpacked = (glPointParameteriNV_PACKED *)packed; \
    glPointParameteriNV_ARGS *args = (glPointParameteriNV_ARGS *)&unpacked->args; \
    glPointParameteriNV(args->pname, args->param);; \
} while(0)
void glPointParameteriNV(glPointParameteriNV_ARG_EXPAND);
packed_call_t *pack_glPointParameteriNV(glPointParameteriNV_PACKED *_dst glPointParameteriNV_ARG_EXPAND_TAIL);
typedef void (*glPointParameteriNV_PTR)(glPointParameteriNV_ARG_EXPAND);
#endif
#ifndef glPointParameteriv_RETURN
#define glPointParameteriv_RETURN void
#define glPointParameteriv_ARG_NAMES pname, params
#define glPointParameteriv_ARG_EXPAND GLenum pname, const GLint * params
#define glPointParameteriv_ARG_NAMES_TAIL , pname, params
#define glPointParameteriv_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glPointParameteriv(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameteriv(dst, _pname, _params), NULL); \
    });
#define call_glPointParameteriv(packed, ret_v) do { \
    glPointParameteriv_PACKED *unpacked = (glPointParameteriv_PACKED *)packed; \
    glPointParameteriv_ARGS *args = (glPointParameteriv_ARGS *)&unpacked->args; \
    glPointParameteriv(args->pname, args->params);; \
} while(0)
void glPointParameteriv(glPointParameteriv_ARG_EXPAND);
packed_call_t *pack_glPointParameteriv(glPointParameteriv_PACKED *_dst glPointParameteriv_ARG_EXPAND_TAIL);
typedef void (*glPointParameteriv_PTR)(glPointParameteriv_ARG_EXPAND);
#endif
#ifndef glPointParameterivNV_RETURN
#define glPointParameterivNV_RETURN void
#define glPointParameterivNV_ARG_NAMES pname, params
#define glPointParameterivNV_ARG_EXPAND GLenum pname, const GLint * params
#define glPointParameterivNV_ARG_NAMES_TAIL , pname, params
#define glPointParameterivNV_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glPointParameterivNV(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterivNV(dst, _pname, _params), NULL); \
    });
#define call_glPointParameterivNV(packed, ret_v) do { \
    glPointParameterivNV_PACKED *unpacked = (glPointParameterivNV_PACKED *)packed; \
    glPointParameterivNV_ARGS *args = (glPointParameterivNV_ARGS *)&unpacked->args; \
    glPointParameterivNV(args->pname, args->params);; \
} while(0)
void glPointParameterivNV(glPointParameterivNV_ARG_EXPAND);
packed_call_t *pack_glPointParameterivNV(glPointParameterivNV_PACKED *_dst glPointParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glPointParameterivNV_PTR)(glPointParameterivNV_ARG_EXPAND);
#endif
#ifndef glPointParameterxvOES_RETURN
#define glPointParameterxvOES_RETURN void
#define glPointParameterxvOES_ARG_NAMES pname, params
#define glPointParameterxvOES_ARG_EXPAND GLenum pname, const GLfixed * params
#define glPointParameterxvOES_ARG_NAMES_TAIL , pname, params
#define glPointParameterxvOES_ARG_EXPAND_TAIL , GLenum pname, const GLfixed * params
#define forward_glPointParameterxvOES(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glPointParameterxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointParameterxvOES(dst, _pname, _params), NULL); \
    });
#define call_glPointParameterxvOES(packed, ret_v) do { \
    glPointParameterxvOES_PACKED *unpacked = (glPointParameterxvOES_PACKED *)packed; \
    glPointParameterxvOES_ARGS *args = (glPointParameterxvOES_ARGS *)&unpacked->args; \
    glPointParameterxvOES(args->pname, args->params);; \
} while(0)
void glPointParameterxvOES(glPointParameterxvOES_ARG_EXPAND);
packed_call_t *pack_glPointParameterxvOES(glPointParameterxvOES_PACKED *_dst glPointParameterxvOES_ARG_EXPAND_TAIL);
typedef void (*glPointParameterxvOES_PTR)(glPointParameterxvOES_ARG_EXPAND);
#endif
#ifndef glPointSize_RETURN
#define glPointSize_RETURN void
#define glPointSize_ARG_NAMES size
#define glPointSize_ARG_EXPAND GLfloat size
#define glPointSize_ARG_NAMES_TAIL , size
#define glPointSize_ARG_EXPAND_TAIL , GLfloat size
#define forward_glPointSize(_size) \
    ({ \
        void *dst = remote_dma(sizeof(glPointSize_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointSize(dst, _size), NULL); \
    });
#define call_glPointSize(packed, ret_v) do { \
    glPointSize_PACKED *unpacked = (glPointSize_PACKED *)packed; \
    glPointSize_ARGS *args = (glPointSize_ARGS *)&unpacked->args; \
    glPointSize(args->size);; \
} while(0)
void glPointSize(glPointSize_ARG_EXPAND);
packed_call_t *pack_glPointSize(glPointSize_PACKED *_dst glPointSize_ARG_EXPAND_TAIL);
typedef void (*glPointSize_PTR)(glPointSize_ARG_EXPAND);
#endif
#ifndef glPointSizexOES_RETURN
#define glPointSizexOES_RETURN void
#define glPointSizexOES_ARG_NAMES size
#define glPointSizexOES_ARG_EXPAND GLfixed size
#define glPointSizexOES_ARG_NAMES_TAIL , size
#define glPointSizexOES_ARG_EXPAND_TAIL , GLfixed size
#define forward_glPointSizexOES(_size) \
    ({ \
        void *dst = remote_dma(sizeof(glPointSizexOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPointSizexOES(dst, _size), NULL); \
    });
#define call_glPointSizexOES(packed, ret_v) do { \
    glPointSizexOES_PACKED *unpacked = (glPointSizexOES_PACKED *)packed; \
    glPointSizexOES_ARGS *args = (glPointSizexOES_ARGS *)&unpacked->args; \
    glPointSizexOES(args->size);; \
} while(0)
void glPointSizexOES(glPointSizexOES_ARG_EXPAND);
packed_call_t *pack_glPointSizexOES(glPointSizexOES_PACKED *_dst glPointSizexOES_ARG_EXPAND_TAIL);
typedef void (*glPointSizexOES_PTR)(glPointSizexOES_ARG_EXPAND);
#endif
#ifndef glPollAsyncSGIX_RETURN
#define glPollAsyncSGIX_RETURN GLint
#define glPollAsyncSGIX_ARG_NAMES markerp
#define glPollAsyncSGIX_ARG_EXPAND GLuint * markerp
#define glPollAsyncSGIX_ARG_NAMES_TAIL , markerp
#define glPollAsyncSGIX_ARG_EXPAND_TAIL , GLuint * markerp
#define forward_glPollAsyncSGIX(_markerp) \
    ({ \
        void *dst = remote_dma(sizeof(glPollAsyncSGIX_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glPollAsyncSGIX(dst, _markerp), &ret); \
        ret; \
    });
#define call_glPollAsyncSGIX(packed, ret_v) do { \
    glPollAsyncSGIX_PACKED *unpacked = (glPollAsyncSGIX_PACKED *)packed; \
    glPollAsyncSGIX_ARGS *args = (glPollAsyncSGIX_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glPollAsyncSGIX(args->markerp);; \
    } else { \
        glPollAsyncSGIX(args->markerp);; \
    } \
} while(0)
GLint glPollAsyncSGIX(glPollAsyncSGIX_ARG_EXPAND);
packed_call_t *pack_glPollAsyncSGIX(glPollAsyncSGIX_PACKED *_dst glPollAsyncSGIX_ARG_EXPAND_TAIL);
typedef GLint (*glPollAsyncSGIX_PTR)(glPollAsyncSGIX_ARG_EXPAND);
#endif
#ifndef glPollInstrumentsSGIX_RETURN
#define glPollInstrumentsSGIX_RETURN GLint
#define glPollInstrumentsSGIX_ARG_NAMES marker_p
#define glPollInstrumentsSGIX_ARG_EXPAND GLint * marker_p
#define glPollInstrumentsSGIX_ARG_NAMES_TAIL , marker_p
#define glPollInstrumentsSGIX_ARG_EXPAND_TAIL , GLint * marker_p
#define forward_glPollInstrumentsSGIX(_marker_p) \
    ({ \
        void *dst = remote_dma(sizeof(glPollInstrumentsSGIX_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glPollInstrumentsSGIX(dst, _marker_p), &ret); \
        ret; \
    });
#define call_glPollInstrumentsSGIX(packed, ret_v) do { \
    glPollInstrumentsSGIX_PACKED *unpacked = (glPollInstrumentsSGIX_PACKED *)packed; \
    glPollInstrumentsSGIX_ARGS *args = (glPollInstrumentsSGIX_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glPollInstrumentsSGIX(args->marker_p);; \
    } else { \
        glPollInstrumentsSGIX(args->marker_p);; \
    } \
} while(0)
GLint glPollInstrumentsSGIX(glPollInstrumentsSGIX_ARG_EXPAND);
packed_call_t *pack_glPollInstrumentsSGIX(glPollInstrumentsSGIX_PACKED *_dst glPollInstrumentsSGIX_ARG_EXPAND_TAIL);
typedef GLint (*glPollInstrumentsSGIX_PTR)(glPollInstrumentsSGIX_ARG_EXPAND);
#endif
#ifndef glPolygonMode_RETURN
#define glPolygonMode_RETURN void
#define glPolygonMode_ARG_NAMES face, mode
#define glPolygonMode_ARG_EXPAND GLenum face, GLenum mode
#define glPolygonMode_ARG_NAMES_TAIL , face, mode
#define glPolygonMode_ARG_EXPAND_TAIL , GLenum face, GLenum mode
#define forward_glPolygonMode(_face, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glPolygonMode_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPolygonMode(dst, _face, _mode), NULL); \
    });
#define call_glPolygonMode(packed, ret_v) do { \
    glPolygonMode_PACKED *unpacked = (glPolygonMode_PACKED *)packed; \
    glPolygonMode_ARGS *args = (glPolygonMode_ARGS *)&unpacked->args; \
    glPolygonMode(args->face, args->mode);; \
} while(0)
void glPolygonMode(glPolygonMode_ARG_EXPAND);
packed_call_t *pack_glPolygonMode(glPolygonMode_PACKED *_dst glPolygonMode_ARG_EXPAND_TAIL);
typedef void (*glPolygonMode_PTR)(glPolygonMode_ARG_EXPAND);
#endif
#ifndef glPolygonOffset_RETURN
#define glPolygonOffset_RETURN void
#define glPolygonOffset_ARG_NAMES factor, units
#define glPolygonOffset_ARG_EXPAND GLfloat factor, GLfloat units
#define glPolygonOffset_ARG_NAMES_TAIL , factor, units
#define glPolygonOffset_ARG_EXPAND_TAIL , GLfloat factor, GLfloat units
#define forward_glPolygonOffset(_factor, _units) \
    ({ \
        void *dst = remote_dma(sizeof(glPolygonOffset_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPolygonOffset(dst, _factor, _units), NULL); \
    });
#define call_glPolygonOffset(packed, ret_v) do { \
    glPolygonOffset_PACKED *unpacked = (glPolygonOffset_PACKED *)packed; \
    glPolygonOffset_ARGS *args = (glPolygonOffset_ARGS *)&unpacked->args; \
    glPolygonOffset(args->factor, args->units);; \
} while(0)
void glPolygonOffset(glPolygonOffset_ARG_EXPAND);
packed_call_t *pack_glPolygonOffset(glPolygonOffset_PACKED *_dst glPolygonOffset_ARG_EXPAND_TAIL);
typedef void (*glPolygonOffset_PTR)(glPolygonOffset_ARG_EXPAND);
#endif
#ifndef glPolygonOffsetEXT_RETURN
#define glPolygonOffsetEXT_RETURN void
#define glPolygonOffsetEXT_ARG_NAMES factor, bias
#define glPolygonOffsetEXT_ARG_EXPAND GLfloat factor, GLfloat bias
#define glPolygonOffsetEXT_ARG_NAMES_TAIL , factor, bias
#define glPolygonOffsetEXT_ARG_EXPAND_TAIL , GLfloat factor, GLfloat bias
#define forward_glPolygonOffsetEXT(_factor, _bias) \
    ({ \
        void *dst = remote_dma(sizeof(glPolygonOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPolygonOffsetEXT(dst, _factor, _bias), NULL); \
    });
#define call_glPolygonOffsetEXT(packed, ret_v) do { \
    glPolygonOffsetEXT_PACKED *unpacked = (glPolygonOffsetEXT_PACKED *)packed; \
    glPolygonOffsetEXT_ARGS *args = (glPolygonOffsetEXT_ARGS *)&unpacked->args; \
    glPolygonOffsetEXT(args->factor, args->bias);; \
} while(0)
void glPolygonOffsetEXT(glPolygonOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glPolygonOffsetEXT(glPolygonOffsetEXT_PACKED *_dst glPolygonOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glPolygonOffsetEXT_PTR)(glPolygonOffsetEXT_ARG_EXPAND);
#endif
#ifndef glPolygonOffsetxOES_RETURN
#define glPolygonOffsetxOES_RETURN void
#define glPolygonOffsetxOES_ARG_NAMES factor, units
#define glPolygonOffsetxOES_ARG_EXPAND GLfixed factor, GLfixed units
#define glPolygonOffsetxOES_ARG_NAMES_TAIL , factor, units
#define glPolygonOffsetxOES_ARG_EXPAND_TAIL , GLfixed factor, GLfixed units
#define forward_glPolygonOffsetxOES(_factor, _units) \
    ({ \
        void *dst = remote_dma(sizeof(glPolygonOffsetxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPolygonOffsetxOES(dst, _factor, _units), NULL); \
    });
#define call_glPolygonOffsetxOES(packed, ret_v) do { \
    glPolygonOffsetxOES_PACKED *unpacked = (glPolygonOffsetxOES_PACKED *)packed; \
    glPolygonOffsetxOES_ARGS *args = (glPolygonOffsetxOES_ARGS *)&unpacked->args; \
    glPolygonOffsetxOES(args->factor, args->units);; \
} while(0)
void glPolygonOffsetxOES(glPolygonOffsetxOES_ARG_EXPAND);
packed_call_t *pack_glPolygonOffsetxOES(glPolygonOffsetxOES_PACKED *_dst glPolygonOffsetxOES_ARG_EXPAND_TAIL);
typedef void (*glPolygonOffsetxOES_PTR)(glPolygonOffsetxOES_ARG_EXPAND);
#endif
#ifndef glPolygonStipple_RETURN
#define glPolygonStipple_RETURN void
#define glPolygonStipple_ARG_NAMES mask
#define glPolygonStipple_ARG_EXPAND const GLubyte * mask
#define glPolygonStipple_ARG_NAMES_TAIL , mask
#define glPolygonStipple_ARG_EXPAND_TAIL , const GLubyte * mask
#define forward_glPolygonStipple(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glPolygonStipple_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPolygonStipple(dst, _mask), NULL); \
    });
#define call_glPolygonStipple(packed, ret_v) do { \
    glPolygonStipple_PACKED *unpacked = (glPolygonStipple_PACKED *)packed; \
    glPolygonStipple_ARGS *args = (glPolygonStipple_ARGS *)&unpacked->args; \
    glPolygonStipple(args->mask);; \
} while(0)
void glPolygonStipple(glPolygonStipple_ARG_EXPAND);
packed_call_t *pack_glPolygonStipple(glPolygonStipple_PACKED *_dst glPolygonStipple_ARG_EXPAND_TAIL);
typedef void (*glPolygonStipple_PTR)(glPolygonStipple_ARG_EXPAND);
#endif
#ifndef glPopAttrib_RETURN
#define glPopAttrib_RETURN void
#define glPopAttrib_ARG_NAMES 
#define glPopAttrib_ARG_EXPAND 
#define glPopAttrib_ARG_NAMES_TAIL 
#define glPopAttrib_ARG_EXPAND_TAIL 
#define forward_glPopAttrib() \
    ({ \
        void *dst = remote_dma(sizeof(glPopAttrib_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPopAttrib(dst), NULL); \
    });
#define call_glPopAttrib(packed, ret_v) do { \
    glPopAttrib();; \
} while(0)
void glPopAttrib(glPopAttrib_ARG_EXPAND);
packed_call_t *pack_glPopAttrib(glPopAttrib_PACKED *_dst glPopAttrib_ARG_EXPAND_TAIL);
typedef void (*glPopAttrib_PTR)(glPopAttrib_ARG_EXPAND);
#endif
#ifndef glPopClientAttrib_RETURN
#define glPopClientAttrib_RETURN void
#define glPopClientAttrib_ARG_NAMES 
#define glPopClientAttrib_ARG_EXPAND 
#define glPopClientAttrib_ARG_NAMES_TAIL 
#define glPopClientAttrib_ARG_EXPAND_TAIL 
#define forward_glPopClientAttrib() \
    ({ \
        void *dst = remote_dma(sizeof(glPopClientAttrib_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPopClientAttrib(dst), NULL); \
    });
#define call_glPopClientAttrib(packed, ret_v) do { \
    glPopClientAttrib();; \
} while(0)
void glPopClientAttrib(glPopClientAttrib_ARG_EXPAND);
packed_call_t *pack_glPopClientAttrib(glPopClientAttrib_PACKED *_dst glPopClientAttrib_ARG_EXPAND_TAIL);
typedef void (*glPopClientAttrib_PTR)(glPopClientAttrib_ARG_EXPAND);
#endif
#ifndef glPopDebugGroup_RETURN
#define glPopDebugGroup_RETURN void
#define glPopDebugGroup_ARG_NAMES 
#define glPopDebugGroup_ARG_EXPAND 
#define glPopDebugGroup_ARG_NAMES_TAIL 
#define glPopDebugGroup_ARG_EXPAND_TAIL 
#define forward_glPopDebugGroup() \
    ({ \
        void *dst = remote_dma(sizeof(glPopDebugGroup_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPopDebugGroup(dst), NULL); \
    });
#define call_glPopDebugGroup(packed, ret_v) do { \
    glPopDebugGroup();; \
} while(0)
void glPopDebugGroup(glPopDebugGroup_ARG_EXPAND);
packed_call_t *pack_glPopDebugGroup(glPopDebugGroup_PACKED *_dst glPopDebugGroup_ARG_EXPAND_TAIL);
typedef void (*glPopDebugGroup_PTR)(glPopDebugGroup_ARG_EXPAND);
#endif
#ifndef glPopMatrix_RETURN
#define glPopMatrix_RETURN void
#define glPopMatrix_ARG_NAMES 
#define glPopMatrix_ARG_EXPAND 
#define glPopMatrix_ARG_NAMES_TAIL 
#define glPopMatrix_ARG_EXPAND_TAIL 
#define forward_glPopMatrix() \
    ({ \
        void *dst = remote_dma(sizeof(glPopMatrix_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPopMatrix(dst), NULL); \
    });
#define call_glPopMatrix(packed, ret_v) do { \
    glPopMatrix();; \
} while(0)
void glPopMatrix(glPopMatrix_ARG_EXPAND);
packed_call_t *pack_glPopMatrix(glPopMatrix_PACKED *_dst glPopMatrix_ARG_EXPAND_TAIL);
typedef void (*glPopMatrix_PTR)(glPopMatrix_ARG_EXPAND);
#endif
#ifndef glPopName_RETURN
#define glPopName_RETURN void
#define glPopName_ARG_NAMES 
#define glPopName_ARG_EXPAND 
#define glPopName_ARG_NAMES_TAIL 
#define glPopName_ARG_EXPAND_TAIL 
#define forward_glPopName() \
    ({ \
        void *dst = remote_dma(sizeof(glPopName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPopName(dst), NULL); \
    });
#define call_glPopName(packed, ret_v) do { \
    glPopName();; \
} while(0)
void glPopName(glPopName_ARG_EXPAND);
packed_call_t *pack_glPopName(glPopName_PACKED *_dst glPopName_ARG_EXPAND_TAIL);
typedef void (*glPopName_PTR)(glPopName_ARG_EXPAND);
#endif
#ifndef glPresentFrameDualFillNV_RETURN
#define glPresentFrameDualFillNV_RETURN void
#define glPresentFrameDualFillNV_ARG_NAMES video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3
#define glPresentFrameDualFillNV_ARG_EXPAND GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3
#define glPresentFrameDualFillNV_ARG_NAMES_TAIL , video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3
#define glPresentFrameDualFillNV_ARG_EXPAND_TAIL , GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3
#define forward_glPresentFrameDualFillNV(_video_slot, _minPresentTime, _beginPresentTimeId, _presentDurationId, _type, _target0, _fill0, _target1, _fill1, _target2, _fill2, _target3, _fill3) \
    ({ \
        void *dst = remote_dma(sizeof(glPresentFrameDualFillNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPresentFrameDualFillNV(dst, _video_slot, _minPresentTime, _beginPresentTimeId, _presentDurationId, _type, _target0, _fill0, _target1, _fill1, _target2, _fill2, _target3, _fill3), NULL); \
    });
#define call_glPresentFrameDualFillNV(packed, ret_v) do { \
    glPresentFrameDualFillNV_PACKED *unpacked = (glPresentFrameDualFillNV_PACKED *)packed; \
    glPresentFrameDualFillNV_ARGS *args = (glPresentFrameDualFillNV_ARGS *)&unpacked->args; \
    glPresentFrameDualFillNV(args->video_slot, args->minPresentTime, args->beginPresentTimeId, args->presentDurationId, args->type, args->target0, args->fill0, args->target1, args->fill1, args->target2, args->fill2, args->target3, args->fill3);; \
} while(0)
void glPresentFrameDualFillNV(glPresentFrameDualFillNV_ARG_EXPAND);
packed_call_t *pack_glPresentFrameDualFillNV(glPresentFrameDualFillNV_PACKED *_dst glPresentFrameDualFillNV_ARG_EXPAND_TAIL);
typedef void (*glPresentFrameDualFillNV_PTR)(glPresentFrameDualFillNV_ARG_EXPAND);
#endif
#ifndef glPresentFrameKeyedNV_RETURN
#define glPresentFrameKeyedNV_RETURN void
#define glPresentFrameKeyedNV_ARG_NAMES video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1
#define glPresentFrameKeyedNV_ARG_EXPAND GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1
#define glPresentFrameKeyedNV_ARG_NAMES_TAIL , video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1
#define glPresentFrameKeyedNV_ARG_EXPAND_TAIL , GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1
#define forward_glPresentFrameKeyedNV(_video_slot, _minPresentTime, _beginPresentTimeId, _presentDurationId, _type, _target0, _fill0, _key0, _target1, _fill1, _key1) \
    ({ \
        void *dst = remote_dma(sizeof(glPresentFrameKeyedNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPresentFrameKeyedNV(dst, _video_slot, _minPresentTime, _beginPresentTimeId, _presentDurationId, _type, _target0, _fill0, _key0, _target1, _fill1, _key1), NULL); \
    });
#define call_glPresentFrameKeyedNV(packed, ret_v) do { \
    glPresentFrameKeyedNV_PACKED *unpacked = (glPresentFrameKeyedNV_PACKED *)packed; \
    glPresentFrameKeyedNV_ARGS *args = (glPresentFrameKeyedNV_ARGS *)&unpacked->args; \
    glPresentFrameKeyedNV(args->video_slot, args->minPresentTime, args->beginPresentTimeId, args->presentDurationId, args->type, args->target0, args->fill0, args->key0, args->target1, args->fill1, args->key1);; \
} while(0)
void glPresentFrameKeyedNV(glPresentFrameKeyedNV_ARG_EXPAND);
packed_call_t *pack_glPresentFrameKeyedNV(glPresentFrameKeyedNV_PACKED *_dst glPresentFrameKeyedNV_ARG_EXPAND_TAIL);
typedef void (*glPresentFrameKeyedNV_PTR)(glPresentFrameKeyedNV_ARG_EXPAND);
#endif
#ifndef glPrimitiveRestartIndex_RETURN
#define glPrimitiveRestartIndex_RETURN void
#define glPrimitiveRestartIndex_ARG_NAMES index
#define glPrimitiveRestartIndex_ARG_EXPAND GLuint index
#define glPrimitiveRestartIndex_ARG_NAMES_TAIL , index
#define glPrimitiveRestartIndex_ARG_EXPAND_TAIL , GLuint index
#define forward_glPrimitiveRestartIndex(_index) \
    ({ \
        void *dst = remote_dma(sizeof(glPrimitiveRestartIndex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPrimitiveRestartIndex(dst, _index), NULL); \
    });
#define call_glPrimitiveRestartIndex(packed, ret_v) do { \
    glPrimitiveRestartIndex_PACKED *unpacked = (glPrimitiveRestartIndex_PACKED *)packed; \
    glPrimitiveRestartIndex_ARGS *args = (glPrimitiveRestartIndex_ARGS *)&unpacked->args; \
    glPrimitiveRestartIndex(args->index);; \
} while(0)
void glPrimitiveRestartIndex(glPrimitiveRestartIndex_ARG_EXPAND);
packed_call_t *pack_glPrimitiveRestartIndex(glPrimitiveRestartIndex_PACKED *_dst glPrimitiveRestartIndex_ARG_EXPAND_TAIL);
typedef void (*glPrimitiveRestartIndex_PTR)(glPrimitiveRestartIndex_ARG_EXPAND);
#endif
#ifndef glPrimitiveRestartIndexNV_RETURN
#define glPrimitiveRestartIndexNV_RETURN void
#define glPrimitiveRestartIndexNV_ARG_NAMES index
#define glPrimitiveRestartIndexNV_ARG_EXPAND GLuint index
#define glPrimitiveRestartIndexNV_ARG_NAMES_TAIL , index
#define glPrimitiveRestartIndexNV_ARG_EXPAND_TAIL , GLuint index
#define forward_glPrimitiveRestartIndexNV(_index) \
    ({ \
        void *dst = remote_dma(sizeof(glPrimitiveRestartIndexNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPrimitiveRestartIndexNV(dst, _index), NULL); \
    });
#define call_glPrimitiveRestartIndexNV(packed, ret_v) do { \
    glPrimitiveRestartIndexNV_PACKED *unpacked = (glPrimitiveRestartIndexNV_PACKED *)packed; \
    glPrimitiveRestartIndexNV_ARGS *args = (glPrimitiveRestartIndexNV_ARGS *)&unpacked->args; \
    glPrimitiveRestartIndexNV(args->index);; \
} while(0)
void glPrimitiveRestartIndexNV(glPrimitiveRestartIndexNV_ARG_EXPAND);
packed_call_t *pack_glPrimitiveRestartIndexNV(glPrimitiveRestartIndexNV_PACKED *_dst glPrimitiveRestartIndexNV_ARG_EXPAND_TAIL);
typedef void (*glPrimitiveRestartIndexNV_PTR)(glPrimitiveRestartIndexNV_ARG_EXPAND);
#endif
#ifndef glPrimitiveRestartNV_RETURN
#define glPrimitiveRestartNV_RETURN void
#define glPrimitiveRestartNV_ARG_NAMES 
#define glPrimitiveRestartNV_ARG_EXPAND 
#define glPrimitiveRestartNV_ARG_NAMES_TAIL 
#define glPrimitiveRestartNV_ARG_EXPAND_TAIL 
#define forward_glPrimitiveRestartNV() \
    ({ \
        void *dst = remote_dma(sizeof(glPrimitiveRestartNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPrimitiveRestartNV(dst), NULL); \
    });
#define call_glPrimitiveRestartNV(packed, ret_v) do { \
    glPrimitiveRestartNV();; \
} while(0)
void glPrimitiveRestartNV(glPrimitiveRestartNV_ARG_EXPAND);
packed_call_t *pack_glPrimitiveRestartNV(glPrimitiveRestartNV_PACKED *_dst glPrimitiveRestartNV_ARG_EXPAND_TAIL);
typedef void (*glPrimitiveRestartNV_PTR)(glPrimitiveRestartNV_ARG_EXPAND);
#endif
#ifndef glPrioritizeTextures_RETURN
#define glPrioritizeTextures_RETURN void
#define glPrioritizeTextures_ARG_NAMES n, textures, priorities
#define glPrioritizeTextures_ARG_EXPAND GLsizei n, const GLuint * textures, const GLfloat * priorities
#define glPrioritizeTextures_ARG_NAMES_TAIL , n, textures, priorities
#define glPrioritizeTextures_ARG_EXPAND_TAIL , GLsizei n, const GLuint * textures, const GLfloat * priorities
#define forward_glPrioritizeTextures(_n, _textures, _priorities) \
    ({ \
        void *dst = remote_dma(sizeof(glPrioritizeTextures_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPrioritizeTextures(dst, _n, _textures, _priorities), NULL); \
    });
#define call_glPrioritizeTextures(packed, ret_v) do { \
    glPrioritizeTextures_PACKED *unpacked = (glPrioritizeTextures_PACKED *)packed; \
    glPrioritizeTextures_ARGS *args = (glPrioritizeTextures_ARGS *)&unpacked->args; \
    glPrioritizeTextures(args->n, args->textures, args->priorities);; \
} while(0)
void glPrioritizeTextures(glPrioritizeTextures_ARG_EXPAND);
packed_call_t *pack_glPrioritizeTextures(glPrioritizeTextures_PACKED *_dst glPrioritizeTextures_ARG_EXPAND_TAIL);
typedef void (*glPrioritizeTextures_PTR)(glPrioritizeTextures_ARG_EXPAND);
#endif
#ifndef glPrioritizeTexturesEXT_RETURN
#define glPrioritizeTexturesEXT_RETURN void
#define glPrioritizeTexturesEXT_ARG_NAMES n, textures, priorities
#define glPrioritizeTexturesEXT_ARG_EXPAND GLsizei n, const GLuint * textures, const GLclampf * priorities
#define glPrioritizeTexturesEXT_ARG_NAMES_TAIL , n, textures, priorities
#define glPrioritizeTexturesEXT_ARG_EXPAND_TAIL , GLsizei n, const GLuint * textures, const GLclampf * priorities
#define forward_glPrioritizeTexturesEXT(_n, _textures, _priorities) \
    ({ \
        void *dst = remote_dma(sizeof(glPrioritizeTexturesEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPrioritizeTexturesEXT(dst, _n, _textures, _priorities), NULL); \
    });
#define call_glPrioritizeTexturesEXT(packed, ret_v) do { \
    glPrioritizeTexturesEXT_PACKED *unpacked = (glPrioritizeTexturesEXT_PACKED *)packed; \
    glPrioritizeTexturesEXT_ARGS *args = (glPrioritizeTexturesEXT_ARGS *)&unpacked->args; \
    glPrioritizeTexturesEXT(args->n, args->textures, args->priorities);; \
} while(0)
void glPrioritizeTexturesEXT(glPrioritizeTexturesEXT_ARG_EXPAND);
packed_call_t *pack_glPrioritizeTexturesEXT(glPrioritizeTexturesEXT_PACKED *_dst glPrioritizeTexturesEXT_ARG_EXPAND_TAIL);
typedef void (*glPrioritizeTexturesEXT_PTR)(glPrioritizeTexturesEXT_ARG_EXPAND);
#endif
#ifndef glPrioritizeTexturesxOES_RETURN
#define glPrioritizeTexturesxOES_RETURN void
#define glPrioritizeTexturesxOES_ARG_NAMES n, textures, priorities
#define glPrioritizeTexturesxOES_ARG_EXPAND GLsizei n, const GLuint * textures, const GLfixed * priorities
#define glPrioritizeTexturesxOES_ARG_NAMES_TAIL , n, textures, priorities
#define glPrioritizeTexturesxOES_ARG_EXPAND_TAIL , GLsizei n, const GLuint * textures, const GLfixed * priorities
#define forward_glPrioritizeTexturesxOES(_n, _textures, _priorities) \
    ({ \
        void *dst = remote_dma(sizeof(glPrioritizeTexturesxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPrioritizeTexturesxOES(dst, _n, _textures, _priorities), NULL); \
    });
#define call_glPrioritizeTexturesxOES(packed, ret_v) do { \
    glPrioritizeTexturesxOES_PACKED *unpacked = (glPrioritizeTexturesxOES_PACKED *)packed; \
    glPrioritizeTexturesxOES_ARGS *args = (glPrioritizeTexturesxOES_ARGS *)&unpacked->args; \
    glPrioritizeTexturesxOES(args->n, args->textures, args->priorities);; \
} while(0)
void glPrioritizeTexturesxOES(glPrioritizeTexturesxOES_ARG_EXPAND);
packed_call_t *pack_glPrioritizeTexturesxOES(glPrioritizeTexturesxOES_PACKED *_dst glPrioritizeTexturesxOES_ARG_EXPAND_TAIL);
typedef void (*glPrioritizeTexturesxOES_PTR)(glPrioritizeTexturesxOES_ARG_EXPAND);
#endif
#ifndef glProgramBinary_RETURN
#define glProgramBinary_RETURN void
#define glProgramBinary_ARG_NAMES program, binaryFormat, binary, length
#define glProgramBinary_ARG_EXPAND GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length
#define glProgramBinary_ARG_NAMES_TAIL , program, binaryFormat, binary, length
#define glProgramBinary_ARG_EXPAND_TAIL , GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length
#define forward_glProgramBinary(_program, _binaryFormat, _binary, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramBinary_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramBinary(dst, _program, _binaryFormat, _binary, _length), NULL); \
    });
#define call_glProgramBinary(packed, ret_v) do { \
    glProgramBinary_PACKED *unpacked = (glProgramBinary_PACKED *)packed; \
    glProgramBinary_ARGS *args = (glProgramBinary_ARGS *)&unpacked->args; \
    glProgramBinary(args->program, args->binaryFormat, args->binary, args->length);; \
} while(0)
void glProgramBinary(glProgramBinary_ARG_EXPAND);
packed_call_t *pack_glProgramBinary(glProgramBinary_PACKED *_dst glProgramBinary_ARG_EXPAND_TAIL);
typedef void (*glProgramBinary_PTR)(glProgramBinary_ARG_EXPAND);
#endif
#ifndef glProgramBufferParametersIivNV_RETURN
#define glProgramBufferParametersIivNV_RETURN void
#define glProgramBufferParametersIivNV_ARG_NAMES target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersIivNV_ARG_EXPAND GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params
#define glProgramBufferParametersIivNV_ARG_NAMES_TAIL , target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersIivNV_ARG_EXPAND_TAIL , GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params
#define forward_glProgramBufferParametersIivNV(_target, _bindingIndex, _wordIndex, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramBufferParametersIivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramBufferParametersIivNV(dst, _target, _bindingIndex, _wordIndex, _count, _params), NULL); \
    });
#define call_glProgramBufferParametersIivNV(packed, ret_v) do { \
    glProgramBufferParametersIivNV_PACKED *unpacked = (glProgramBufferParametersIivNV_PACKED *)packed; \
    glProgramBufferParametersIivNV_ARGS *args = (glProgramBufferParametersIivNV_ARGS *)&unpacked->args; \
    glProgramBufferParametersIivNV(args->target, args->bindingIndex, args->wordIndex, args->count, args->params);; \
} while(0)
void glProgramBufferParametersIivNV(glProgramBufferParametersIivNV_ARG_EXPAND);
packed_call_t *pack_glProgramBufferParametersIivNV(glProgramBufferParametersIivNV_PACKED *_dst glProgramBufferParametersIivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramBufferParametersIivNV_PTR)(glProgramBufferParametersIivNV_ARG_EXPAND);
#endif
#ifndef glProgramBufferParametersIuivNV_RETURN
#define glProgramBufferParametersIuivNV_RETURN void
#define glProgramBufferParametersIuivNV_ARG_NAMES target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersIuivNV_ARG_EXPAND GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params
#define glProgramBufferParametersIuivNV_ARG_NAMES_TAIL , target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersIuivNV_ARG_EXPAND_TAIL , GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params
#define forward_glProgramBufferParametersIuivNV(_target, _bindingIndex, _wordIndex, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramBufferParametersIuivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramBufferParametersIuivNV(dst, _target, _bindingIndex, _wordIndex, _count, _params), NULL); \
    });
#define call_glProgramBufferParametersIuivNV(packed, ret_v) do { \
    glProgramBufferParametersIuivNV_PACKED *unpacked = (glProgramBufferParametersIuivNV_PACKED *)packed; \
    glProgramBufferParametersIuivNV_ARGS *args = (glProgramBufferParametersIuivNV_ARGS *)&unpacked->args; \
    glProgramBufferParametersIuivNV(args->target, args->bindingIndex, args->wordIndex, args->count, args->params);; \
} while(0)
void glProgramBufferParametersIuivNV(glProgramBufferParametersIuivNV_ARG_EXPAND);
packed_call_t *pack_glProgramBufferParametersIuivNV(glProgramBufferParametersIuivNV_PACKED *_dst glProgramBufferParametersIuivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramBufferParametersIuivNV_PTR)(glProgramBufferParametersIuivNV_ARG_EXPAND);
#endif
#ifndef glProgramBufferParametersfvNV_RETURN
#define glProgramBufferParametersfvNV_RETURN void
#define glProgramBufferParametersfvNV_ARG_NAMES target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersfvNV_ARG_EXPAND GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params
#define glProgramBufferParametersfvNV_ARG_NAMES_TAIL , target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersfvNV_ARG_EXPAND_TAIL , GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params
#define forward_glProgramBufferParametersfvNV(_target, _bindingIndex, _wordIndex, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramBufferParametersfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramBufferParametersfvNV(dst, _target, _bindingIndex, _wordIndex, _count, _params), NULL); \
    });
#define call_glProgramBufferParametersfvNV(packed, ret_v) do { \
    glProgramBufferParametersfvNV_PACKED *unpacked = (glProgramBufferParametersfvNV_PACKED *)packed; \
    glProgramBufferParametersfvNV_ARGS *args = (glProgramBufferParametersfvNV_ARGS *)&unpacked->args; \
    glProgramBufferParametersfvNV(args->target, args->bindingIndex, args->wordIndex, args->count, args->params);; \
} while(0)
void glProgramBufferParametersfvNV(glProgramBufferParametersfvNV_ARG_EXPAND);
packed_call_t *pack_glProgramBufferParametersfvNV(glProgramBufferParametersfvNV_PACKED *_dst glProgramBufferParametersfvNV_ARG_EXPAND_TAIL);
typedef void (*glProgramBufferParametersfvNV_PTR)(glProgramBufferParametersfvNV_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameter4dARB_RETURN
#define glProgramEnvParameter4dARB_RETURN void
#define glProgramEnvParameter4dARB_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameter4dARB_ARG_EXPAND GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramEnvParameter4dARB_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramEnvParameter4dARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glProgramEnvParameter4dARB(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameter4dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameter4dARB(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramEnvParameter4dARB(packed, ret_v) do { \
    glProgramEnvParameter4dARB_PACKED *unpacked = (glProgramEnvParameter4dARB_PACKED *)packed; \
    glProgramEnvParameter4dARB_ARGS *args = (glProgramEnvParameter4dARB_ARGS *)&unpacked->args; \
    glProgramEnvParameter4dARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameter4dARB(glProgramEnvParameter4dARB_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameter4dARB(glProgramEnvParameter4dARB_PACKED *_dst glProgramEnvParameter4dARB_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameter4dARB_PTR)(glProgramEnvParameter4dARB_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameter4dvARB_RETURN
#define glProgramEnvParameter4dvARB_RETURN void
#define glProgramEnvParameter4dvARB_ARG_NAMES target, index, params
#define glProgramEnvParameter4dvARB_ARG_EXPAND GLenum target, GLuint index, const GLdouble * params
#define glProgramEnvParameter4dvARB_ARG_NAMES_TAIL , target, index, params
#define glProgramEnvParameter4dvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLdouble * params
#define forward_glProgramEnvParameter4dvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameter4dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameter4dvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramEnvParameter4dvARB(packed, ret_v) do { \
    glProgramEnvParameter4dvARB_PACKED *unpacked = (glProgramEnvParameter4dvARB_PACKED *)packed; \
    glProgramEnvParameter4dvARB_ARGS *args = (glProgramEnvParameter4dvARB_ARGS *)&unpacked->args; \
    glProgramEnvParameter4dvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameter4dvARB(glProgramEnvParameter4dvARB_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameter4dvARB(glProgramEnvParameter4dvARB_PACKED *_dst glProgramEnvParameter4dvARB_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameter4dvARB_PTR)(glProgramEnvParameter4dvARB_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameter4fARB_RETURN
#define glProgramEnvParameter4fARB_RETURN void
#define glProgramEnvParameter4fARB_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameter4fARB_ARG_EXPAND GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramEnvParameter4fARB_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramEnvParameter4fARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glProgramEnvParameter4fARB(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameter4fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameter4fARB(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramEnvParameter4fARB(packed, ret_v) do { \
    glProgramEnvParameter4fARB_PACKED *unpacked = (glProgramEnvParameter4fARB_PACKED *)packed; \
    glProgramEnvParameter4fARB_ARGS *args = (glProgramEnvParameter4fARB_ARGS *)&unpacked->args; \
    glProgramEnvParameter4fARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameter4fARB(glProgramEnvParameter4fARB_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameter4fARB(glProgramEnvParameter4fARB_PACKED *_dst glProgramEnvParameter4fARB_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameter4fARB_PTR)(glProgramEnvParameter4fARB_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameter4fvARB_RETURN
#define glProgramEnvParameter4fvARB_RETURN void
#define glProgramEnvParameter4fvARB_ARG_NAMES target, index, params
#define glProgramEnvParameter4fvARB_ARG_EXPAND GLenum target, GLuint index, const GLfloat * params
#define glProgramEnvParameter4fvARB_ARG_NAMES_TAIL , target, index, params
#define glProgramEnvParameter4fvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLfloat * params
#define forward_glProgramEnvParameter4fvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameter4fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameter4fvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramEnvParameter4fvARB(packed, ret_v) do { \
    glProgramEnvParameter4fvARB_PACKED *unpacked = (glProgramEnvParameter4fvARB_PACKED *)packed; \
    glProgramEnvParameter4fvARB_ARGS *args = (glProgramEnvParameter4fvARB_ARGS *)&unpacked->args; \
    glProgramEnvParameter4fvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameter4fvARB(glProgramEnvParameter4fvARB_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameter4fvARB(glProgramEnvParameter4fvARB_PACKED *_dst glProgramEnvParameter4fvARB_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameter4fvARB_PTR)(glProgramEnvParameter4fvARB_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameterI4iNV_RETURN
#define glProgramEnvParameterI4iNV_RETURN void
#define glProgramEnvParameterI4iNV_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameterI4iNV_ARG_EXPAND GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define glProgramEnvParameterI4iNV_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramEnvParameterI4iNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define forward_glProgramEnvParameterI4iNV(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameterI4iNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameterI4iNV(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramEnvParameterI4iNV(packed, ret_v) do { \
    glProgramEnvParameterI4iNV_PACKED *unpacked = (glProgramEnvParameterI4iNV_PACKED *)packed; \
    glProgramEnvParameterI4iNV_ARGS *args = (glProgramEnvParameterI4iNV_ARGS *)&unpacked->args; \
    glProgramEnvParameterI4iNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameterI4iNV(glProgramEnvParameterI4iNV_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameterI4iNV(glProgramEnvParameterI4iNV_PACKED *_dst glProgramEnvParameterI4iNV_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameterI4iNV_PTR)(glProgramEnvParameterI4iNV_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameterI4ivNV_RETURN
#define glProgramEnvParameterI4ivNV_RETURN void
#define glProgramEnvParameterI4ivNV_ARG_NAMES target, index, params
#define glProgramEnvParameterI4ivNV_ARG_EXPAND GLenum target, GLuint index, const GLint * params
#define glProgramEnvParameterI4ivNV_ARG_NAMES_TAIL , target, index, params
#define glProgramEnvParameterI4ivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLint * params
#define forward_glProgramEnvParameterI4ivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameterI4ivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameterI4ivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramEnvParameterI4ivNV(packed, ret_v) do { \
    glProgramEnvParameterI4ivNV_PACKED *unpacked = (glProgramEnvParameterI4ivNV_PACKED *)packed; \
    glProgramEnvParameterI4ivNV_ARGS *args = (glProgramEnvParameterI4ivNV_ARGS *)&unpacked->args; \
    glProgramEnvParameterI4ivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameterI4ivNV(glProgramEnvParameterI4ivNV_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameterI4ivNV(glProgramEnvParameterI4ivNV_PACKED *_dst glProgramEnvParameterI4ivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameterI4ivNV_PTR)(glProgramEnvParameterI4ivNV_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameterI4uiNV_RETURN
#define glProgramEnvParameterI4uiNV_RETURN void
#define glProgramEnvParameterI4uiNV_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameterI4uiNV_ARG_EXPAND GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glProgramEnvParameterI4uiNV_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramEnvParameterI4uiNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define forward_glProgramEnvParameterI4uiNV(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameterI4uiNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameterI4uiNV(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramEnvParameterI4uiNV(packed, ret_v) do { \
    glProgramEnvParameterI4uiNV_PACKED *unpacked = (glProgramEnvParameterI4uiNV_PACKED *)packed; \
    glProgramEnvParameterI4uiNV_ARGS *args = (glProgramEnvParameterI4uiNV_ARGS *)&unpacked->args; \
    glProgramEnvParameterI4uiNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameterI4uiNV(glProgramEnvParameterI4uiNV_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameterI4uiNV(glProgramEnvParameterI4uiNV_PACKED *_dst glProgramEnvParameterI4uiNV_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameterI4uiNV_PTR)(glProgramEnvParameterI4uiNV_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameterI4uivNV_RETURN
#define glProgramEnvParameterI4uivNV_RETURN void
#define glProgramEnvParameterI4uivNV_ARG_NAMES target, index, params
#define glProgramEnvParameterI4uivNV_ARG_EXPAND GLenum target, GLuint index, const GLuint * params
#define glProgramEnvParameterI4uivNV_ARG_NAMES_TAIL , target, index, params
#define glProgramEnvParameterI4uivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLuint * params
#define forward_glProgramEnvParameterI4uivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameterI4uivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameterI4uivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramEnvParameterI4uivNV(packed, ret_v) do { \
    glProgramEnvParameterI4uivNV_PACKED *unpacked = (glProgramEnvParameterI4uivNV_PACKED *)packed; \
    glProgramEnvParameterI4uivNV_ARGS *args = (glProgramEnvParameterI4uivNV_ARGS *)&unpacked->args; \
    glProgramEnvParameterI4uivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameterI4uivNV(glProgramEnvParameterI4uivNV_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameterI4uivNV(glProgramEnvParameterI4uivNV_PACKED *_dst glProgramEnvParameterI4uivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameterI4uivNV_PTR)(glProgramEnvParameterI4uivNV_ARG_EXPAND);
#endif
#ifndef glProgramEnvParameters4fvEXT_RETURN
#define glProgramEnvParameters4fvEXT_RETURN void
#define glProgramEnvParameters4fvEXT_ARG_NAMES target, index, count, params
#define glProgramEnvParameters4fvEXT_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define glProgramEnvParameters4fvEXT_ARG_NAMES_TAIL , target, index, count, params
#define glProgramEnvParameters4fvEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define forward_glProgramEnvParameters4fvEXT(_target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParameters4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParameters4fvEXT(dst, _target, _index, _count, _params), NULL); \
    });
#define call_glProgramEnvParameters4fvEXT(packed, ret_v) do { \
    glProgramEnvParameters4fvEXT_PACKED *unpacked = (glProgramEnvParameters4fvEXT_PACKED *)packed; \
    glProgramEnvParameters4fvEXT_ARGS *args = (glProgramEnvParameters4fvEXT_ARGS *)&unpacked->args; \
    glProgramEnvParameters4fvEXT(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramEnvParameters4fvEXT(glProgramEnvParameters4fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParameters4fvEXT(glProgramEnvParameters4fvEXT_PACKED *_dst glProgramEnvParameters4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParameters4fvEXT_PTR)(glProgramEnvParameters4fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramEnvParametersI4ivNV_RETURN
#define glProgramEnvParametersI4ivNV_RETURN void
#define glProgramEnvParametersI4ivNV_ARG_NAMES target, index, count, params
#define glProgramEnvParametersI4ivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLint * params
#define glProgramEnvParametersI4ivNV_ARG_NAMES_TAIL , target, index, count, params
#define glProgramEnvParametersI4ivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLint * params
#define forward_glProgramEnvParametersI4ivNV(_target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParametersI4ivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParametersI4ivNV(dst, _target, _index, _count, _params), NULL); \
    });
#define call_glProgramEnvParametersI4ivNV(packed, ret_v) do { \
    glProgramEnvParametersI4ivNV_PACKED *unpacked = (glProgramEnvParametersI4ivNV_PACKED *)packed; \
    glProgramEnvParametersI4ivNV_ARGS *args = (glProgramEnvParametersI4ivNV_ARGS *)&unpacked->args; \
    glProgramEnvParametersI4ivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramEnvParametersI4ivNV(glProgramEnvParametersI4ivNV_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParametersI4ivNV(glProgramEnvParametersI4ivNV_PACKED *_dst glProgramEnvParametersI4ivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParametersI4ivNV_PTR)(glProgramEnvParametersI4ivNV_ARG_EXPAND);
#endif
#ifndef glProgramEnvParametersI4uivNV_RETURN
#define glProgramEnvParametersI4uivNV_RETURN void
#define glProgramEnvParametersI4uivNV_ARG_NAMES target, index, count, params
#define glProgramEnvParametersI4uivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLuint * params
#define glProgramEnvParametersI4uivNV_ARG_NAMES_TAIL , target, index, count, params
#define glProgramEnvParametersI4uivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLuint * params
#define forward_glProgramEnvParametersI4uivNV(_target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramEnvParametersI4uivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramEnvParametersI4uivNV(dst, _target, _index, _count, _params), NULL); \
    });
#define call_glProgramEnvParametersI4uivNV(packed, ret_v) do { \
    glProgramEnvParametersI4uivNV_PACKED *unpacked = (glProgramEnvParametersI4uivNV_PACKED *)packed; \
    glProgramEnvParametersI4uivNV_ARGS *args = (glProgramEnvParametersI4uivNV_ARGS *)&unpacked->args; \
    glProgramEnvParametersI4uivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramEnvParametersI4uivNV(glProgramEnvParametersI4uivNV_ARG_EXPAND);
packed_call_t *pack_glProgramEnvParametersI4uivNV(glProgramEnvParametersI4uivNV_PACKED *_dst glProgramEnvParametersI4uivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramEnvParametersI4uivNV_PTR)(glProgramEnvParametersI4uivNV_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameter4dARB_RETURN
#define glProgramLocalParameter4dARB_RETURN void
#define glProgramLocalParameter4dARB_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameter4dARB_ARG_EXPAND GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramLocalParameter4dARB_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramLocalParameter4dARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glProgramLocalParameter4dARB(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameter4dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameter4dARB(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramLocalParameter4dARB(packed, ret_v) do { \
    glProgramLocalParameter4dARB_PACKED *unpacked = (glProgramLocalParameter4dARB_PACKED *)packed; \
    glProgramLocalParameter4dARB_ARGS *args = (glProgramLocalParameter4dARB_ARGS *)&unpacked->args; \
    glProgramLocalParameter4dARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameter4dARB(glProgramLocalParameter4dARB_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameter4dARB(glProgramLocalParameter4dARB_PACKED *_dst glProgramLocalParameter4dARB_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameter4dARB_PTR)(glProgramLocalParameter4dARB_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameter4dvARB_RETURN
#define glProgramLocalParameter4dvARB_RETURN void
#define glProgramLocalParameter4dvARB_ARG_NAMES target, index, params
#define glProgramLocalParameter4dvARB_ARG_EXPAND GLenum target, GLuint index, const GLdouble * params
#define glProgramLocalParameter4dvARB_ARG_NAMES_TAIL , target, index, params
#define glProgramLocalParameter4dvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLdouble * params
#define forward_glProgramLocalParameter4dvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameter4dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameter4dvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramLocalParameter4dvARB(packed, ret_v) do { \
    glProgramLocalParameter4dvARB_PACKED *unpacked = (glProgramLocalParameter4dvARB_PACKED *)packed; \
    glProgramLocalParameter4dvARB_ARGS *args = (glProgramLocalParameter4dvARB_ARGS *)&unpacked->args; \
    glProgramLocalParameter4dvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameter4dvARB(glProgramLocalParameter4dvARB_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameter4dvARB(glProgramLocalParameter4dvARB_PACKED *_dst glProgramLocalParameter4dvARB_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameter4dvARB_PTR)(glProgramLocalParameter4dvARB_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameter4fARB_RETURN
#define glProgramLocalParameter4fARB_RETURN void
#define glProgramLocalParameter4fARB_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameter4fARB_ARG_EXPAND GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramLocalParameter4fARB_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramLocalParameter4fARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glProgramLocalParameter4fARB(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameter4fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameter4fARB(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramLocalParameter4fARB(packed, ret_v) do { \
    glProgramLocalParameter4fARB_PACKED *unpacked = (glProgramLocalParameter4fARB_PACKED *)packed; \
    glProgramLocalParameter4fARB_ARGS *args = (glProgramLocalParameter4fARB_ARGS *)&unpacked->args; \
    glProgramLocalParameter4fARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameter4fARB(glProgramLocalParameter4fARB_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameter4fARB(glProgramLocalParameter4fARB_PACKED *_dst glProgramLocalParameter4fARB_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameter4fARB_PTR)(glProgramLocalParameter4fARB_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameter4fvARB_RETURN
#define glProgramLocalParameter4fvARB_RETURN void
#define glProgramLocalParameter4fvARB_ARG_NAMES target, index, params
#define glProgramLocalParameter4fvARB_ARG_EXPAND GLenum target, GLuint index, const GLfloat * params
#define glProgramLocalParameter4fvARB_ARG_NAMES_TAIL , target, index, params
#define glProgramLocalParameter4fvARB_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLfloat * params
#define forward_glProgramLocalParameter4fvARB(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameter4fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameter4fvARB(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramLocalParameter4fvARB(packed, ret_v) do { \
    glProgramLocalParameter4fvARB_PACKED *unpacked = (glProgramLocalParameter4fvARB_PACKED *)packed; \
    glProgramLocalParameter4fvARB_ARGS *args = (glProgramLocalParameter4fvARB_ARGS *)&unpacked->args; \
    glProgramLocalParameter4fvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameter4fvARB(glProgramLocalParameter4fvARB_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameter4fvARB(glProgramLocalParameter4fvARB_PACKED *_dst glProgramLocalParameter4fvARB_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameter4fvARB_PTR)(glProgramLocalParameter4fvARB_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameterI4iNV_RETURN
#define glProgramLocalParameterI4iNV_RETURN void
#define glProgramLocalParameterI4iNV_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameterI4iNV_ARG_EXPAND GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define glProgramLocalParameterI4iNV_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramLocalParameterI4iNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define forward_glProgramLocalParameterI4iNV(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameterI4iNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameterI4iNV(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramLocalParameterI4iNV(packed, ret_v) do { \
    glProgramLocalParameterI4iNV_PACKED *unpacked = (glProgramLocalParameterI4iNV_PACKED *)packed; \
    glProgramLocalParameterI4iNV_ARGS *args = (glProgramLocalParameterI4iNV_ARGS *)&unpacked->args; \
    glProgramLocalParameterI4iNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameterI4iNV(glProgramLocalParameterI4iNV_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameterI4iNV(glProgramLocalParameterI4iNV_PACKED *_dst glProgramLocalParameterI4iNV_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameterI4iNV_PTR)(glProgramLocalParameterI4iNV_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameterI4ivNV_RETURN
#define glProgramLocalParameterI4ivNV_RETURN void
#define glProgramLocalParameterI4ivNV_ARG_NAMES target, index, params
#define glProgramLocalParameterI4ivNV_ARG_EXPAND GLenum target, GLuint index, const GLint * params
#define glProgramLocalParameterI4ivNV_ARG_NAMES_TAIL , target, index, params
#define glProgramLocalParameterI4ivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLint * params
#define forward_glProgramLocalParameterI4ivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameterI4ivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameterI4ivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramLocalParameterI4ivNV(packed, ret_v) do { \
    glProgramLocalParameterI4ivNV_PACKED *unpacked = (glProgramLocalParameterI4ivNV_PACKED *)packed; \
    glProgramLocalParameterI4ivNV_ARGS *args = (glProgramLocalParameterI4ivNV_ARGS *)&unpacked->args; \
    glProgramLocalParameterI4ivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameterI4ivNV(glProgramLocalParameterI4ivNV_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameterI4ivNV(glProgramLocalParameterI4ivNV_PACKED *_dst glProgramLocalParameterI4ivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameterI4ivNV_PTR)(glProgramLocalParameterI4ivNV_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameterI4uiNV_RETURN
#define glProgramLocalParameterI4uiNV_RETURN void
#define glProgramLocalParameterI4uiNV_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameterI4uiNV_ARG_EXPAND GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glProgramLocalParameterI4uiNV_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramLocalParameterI4uiNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define forward_glProgramLocalParameterI4uiNV(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameterI4uiNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameterI4uiNV(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramLocalParameterI4uiNV(packed, ret_v) do { \
    glProgramLocalParameterI4uiNV_PACKED *unpacked = (glProgramLocalParameterI4uiNV_PACKED *)packed; \
    glProgramLocalParameterI4uiNV_ARGS *args = (glProgramLocalParameterI4uiNV_ARGS *)&unpacked->args; \
    glProgramLocalParameterI4uiNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameterI4uiNV(glProgramLocalParameterI4uiNV_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameterI4uiNV(glProgramLocalParameterI4uiNV_PACKED *_dst glProgramLocalParameterI4uiNV_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameterI4uiNV_PTR)(glProgramLocalParameterI4uiNV_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameterI4uivNV_RETURN
#define glProgramLocalParameterI4uivNV_RETURN void
#define glProgramLocalParameterI4uivNV_ARG_NAMES target, index, params
#define glProgramLocalParameterI4uivNV_ARG_EXPAND GLenum target, GLuint index, const GLuint * params
#define glProgramLocalParameterI4uivNV_ARG_NAMES_TAIL , target, index, params
#define glProgramLocalParameterI4uivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLuint * params
#define forward_glProgramLocalParameterI4uivNV(_target, _index, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameterI4uivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameterI4uivNV(dst, _target, _index, _params), NULL); \
    });
#define call_glProgramLocalParameterI4uivNV(packed, ret_v) do { \
    glProgramLocalParameterI4uivNV_PACKED *unpacked = (glProgramLocalParameterI4uivNV_PACKED *)packed; \
    glProgramLocalParameterI4uivNV_ARGS *args = (glProgramLocalParameterI4uivNV_ARGS *)&unpacked->args; \
    glProgramLocalParameterI4uivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameterI4uivNV(glProgramLocalParameterI4uivNV_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameterI4uivNV(glProgramLocalParameterI4uivNV_PACKED *_dst glProgramLocalParameterI4uivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameterI4uivNV_PTR)(glProgramLocalParameterI4uivNV_ARG_EXPAND);
#endif
#ifndef glProgramLocalParameters4fvEXT_RETURN
#define glProgramLocalParameters4fvEXT_RETURN void
#define glProgramLocalParameters4fvEXT_ARG_NAMES target, index, count, params
#define glProgramLocalParameters4fvEXT_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define glProgramLocalParameters4fvEXT_ARG_NAMES_TAIL , target, index, count, params
#define glProgramLocalParameters4fvEXT_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define forward_glProgramLocalParameters4fvEXT(_target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParameters4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParameters4fvEXT(dst, _target, _index, _count, _params), NULL); \
    });
#define call_glProgramLocalParameters4fvEXT(packed, ret_v) do { \
    glProgramLocalParameters4fvEXT_PACKED *unpacked = (glProgramLocalParameters4fvEXT_PACKED *)packed; \
    glProgramLocalParameters4fvEXT_ARGS *args = (glProgramLocalParameters4fvEXT_ARGS *)&unpacked->args; \
    glProgramLocalParameters4fvEXT(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramLocalParameters4fvEXT(glProgramLocalParameters4fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParameters4fvEXT(glProgramLocalParameters4fvEXT_PACKED *_dst glProgramLocalParameters4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParameters4fvEXT_PTR)(glProgramLocalParameters4fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramLocalParametersI4ivNV_RETURN
#define glProgramLocalParametersI4ivNV_RETURN void
#define glProgramLocalParametersI4ivNV_ARG_NAMES target, index, count, params
#define glProgramLocalParametersI4ivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLint * params
#define glProgramLocalParametersI4ivNV_ARG_NAMES_TAIL , target, index, count, params
#define glProgramLocalParametersI4ivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLint * params
#define forward_glProgramLocalParametersI4ivNV(_target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParametersI4ivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParametersI4ivNV(dst, _target, _index, _count, _params), NULL); \
    });
#define call_glProgramLocalParametersI4ivNV(packed, ret_v) do { \
    glProgramLocalParametersI4ivNV_PACKED *unpacked = (glProgramLocalParametersI4ivNV_PACKED *)packed; \
    glProgramLocalParametersI4ivNV_ARGS *args = (glProgramLocalParametersI4ivNV_ARGS *)&unpacked->args; \
    glProgramLocalParametersI4ivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramLocalParametersI4ivNV(glProgramLocalParametersI4ivNV_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParametersI4ivNV(glProgramLocalParametersI4ivNV_PACKED *_dst glProgramLocalParametersI4ivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParametersI4ivNV_PTR)(glProgramLocalParametersI4ivNV_ARG_EXPAND);
#endif
#ifndef glProgramLocalParametersI4uivNV_RETURN
#define glProgramLocalParametersI4uivNV_RETURN void
#define glProgramLocalParametersI4uivNV_ARG_NAMES target, index, count, params
#define glProgramLocalParametersI4uivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLuint * params
#define glProgramLocalParametersI4uivNV_ARG_NAMES_TAIL , target, index, count, params
#define glProgramLocalParametersI4uivNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLuint * params
#define forward_glProgramLocalParametersI4uivNV(_target, _index, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramLocalParametersI4uivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramLocalParametersI4uivNV(dst, _target, _index, _count, _params), NULL); \
    });
#define call_glProgramLocalParametersI4uivNV(packed, ret_v) do { \
    glProgramLocalParametersI4uivNV_PACKED *unpacked = (glProgramLocalParametersI4uivNV_PACKED *)packed; \
    glProgramLocalParametersI4uivNV_ARGS *args = (glProgramLocalParametersI4uivNV_ARGS *)&unpacked->args; \
    glProgramLocalParametersI4uivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramLocalParametersI4uivNV(glProgramLocalParametersI4uivNV_ARG_EXPAND);
packed_call_t *pack_glProgramLocalParametersI4uivNV(glProgramLocalParametersI4uivNV_PACKED *_dst glProgramLocalParametersI4uivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramLocalParametersI4uivNV_PTR)(glProgramLocalParametersI4uivNV_ARG_EXPAND);
#endif
#ifndef glProgramNamedParameter4dNV_RETURN
#define glProgramNamedParameter4dNV_RETURN void
#define glProgramNamedParameter4dNV_ARG_NAMES id, len, name, x, y, z, w
#define glProgramNamedParameter4dNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramNamedParameter4dNV_ARG_NAMES_TAIL , id, len, name, x, y, z, w
#define glProgramNamedParameter4dNV_ARG_EXPAND_TAIL , GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glProgramNamedParameter4dNV(_id, _len, _name, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramNamedParameter4dNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramNamedParameter4dNV(dst, _id, _len, _name, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramNamedParameter4dNV(packed, ret_v) do { \
    glProgramNamedParameter4dNV_PACKED *unpacked = (glProgramNamedParameter4dNV_PACKED *)packed; \
    glProgramNamedParameter4dNV_ARGS *args = (glProgramNamedParameter4dNV_ARGS *)&unpacked->args; \
    glProgramNamedParameter4dNV(args->id, args->len, args->name, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramNamedParameter4dNV(glProgramNamedParameter4dNV_ARG_EXPAND);
packed_call_t *pack_glProgramNamedParameter4dNV(glProgramNamedParameter4dNV_PACKED *_dst glProgramNamedParameter4dNV_ARG_EXPAND_TAIL);
typedef void (*glProgramNamedParameter4dNV_PTR)(glProgramNamedParameter4dNV_ARG_EXPAND);
#endif
#ifndef glProgramNamedParameter4dvNV_RETURN
#define glProgramNamedParameter4dvNV_RETURN void
#define glProgramNamedParameter4dvNV_ARG_NAMES id, len, name, v
#define glProgramNamedParameter4dvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v
#define glProgramNamedParameter4dvNV_ARG_NAMES_TAIL , id, len, name, v
#define glProgramNamedParameter4dvNV_ARG_EXPAND_TAIL , GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v
#define forward_glProgramNamedParameter4dvNV(_id, _len, _name, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramNamedParameter4dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramNamedParameter4dvNV(dst, _id, _len, _name, _v), NULL); \
    });
#define call_glProgramNamedParameter4dvNV(packed, ret_v) do { \
    glProgramNamedParameter4dvNV_PACKED *unpacked = (glProgramNamedParameter4dvNV_PACKED *)packed; \
    glProgramNamedParameter4dvNV_ARGS *args = (glProgramNamedParameter4dvNV_ARGS *)&unpacked->args; \
    glProgramNamedParameter4dvNV(args->id, args->len, args->name, args->v);; \
} while(0)
void glProgramNamedParameter4dvNV(glProgramNamedParameter4dvNV_ARG_EXPAND);
packed_call_t *pack_glProgramNamedParameter4dvNV(glProgramNamedParameter4dvNV_PACKED *_dst glProgramNamedParameter4dvNV_ARG_EXPAND_TAIL);
typedef void (*glProgramNamedParameter4dvNV_PTR)(glProgramNamedParameter4dvNV_ARG_EXPAND);
#endif
#ifndef glProgramNamedParameter4fNV_RETURN
#define glProgramNamedParameter4fNV_RETURN void
#define glProgramNamedParameter4fNV_ARG_NAMES id, len, name, x, y, z, w
#define glProgramNamedParameter4fNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramNamedParameter4fNV_ARG_NAMES_TAIL , id, len, name, x, y, z, w
#define glProgramNamedParameter4fNV_ARG_EXPAND_TAIL , GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glProgramNamedParameter4fNV(_id, _len, _name, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramNamedParameter4fNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramNamedParameter4fNV(dst, _id, _len, _name, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramNamedParameter4fNV(packed, ret_v) do { \
    glProgramNamedParameter4fNV_PACKED *unpacked = (glProgramNamedParameter4fNV_PACKED *)packed; \
    glProgramNamedParameter4fNV_ARGS *args = (glProgramNamedParameter4fNV_ARGS *)&unpacked->args; \
    glProgramNamedParameter4fNV(args->id, args->len, args->name, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramNamedParameter4fNV(glProgramNamedParameter4fNV_ARG_EXPAND);
packed_call_t *pack_glProgramNamedParameter4fNV(glProgramNamedParameter4fNV_PACKED *_dst glProgramNamedParameter4fNV_ARG_EXPAND_TAIL);
typedef void (*glProgramNamedParameter4fNV_PTR)(glProgramNamedParameter4fNV_ARG_EXPAND);
#endif
#ifndef glProgramNamedParameter4fvNV_RETURN
#define glProgramNamedParameter4fvNV_RETURN void
#define glProgramNamedParameter4fvNV_ARG_NAMES id, len, name, v
#define glProgramNamedParameter4fvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v
#define glProgramNamedParameter4fvNV_ARG_NAMES_TAIL , id, len, name, v
#define glProgramNamedParameter4fvNV_ARG_EXPAND_TAIL , GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v
#define forward_glProgramNamedParameter4fvNV(_id, _len, _name, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramNamedParameter4fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramNamedParameter4fvNV(dst, _id, _len, _name, _v), NULL); \
    });
#define call_glProgramNamedParameter4fvNV(packed, ret_v) do { \
    glProgramNamedParameter4fvNV_PACKED *unpacked = (glProgramNamedParameter4fvNV_PACKED *)packed; \
    glProgramNamedParameter4fvNV_ARGS *args = (glProgramNamedParameter4fvNV_ARGS *)&unpacked->args; \
    glProgramNamedParameter4fvNV(args->id, args->len, args->name, args->v);; \
} while(0)
void glProgramNamedParameter4fvNV(glProgramNamedParameter4fvNV_ARG_EXPAND);
packed_call_t *pack_glProgramNamedParameter4fvNV(glProgramNamedParameter4fvNV_PACKED *_dst glProgramNamedParameter4fvNV_ARG_EXPAND_TAIL);
typedef void (*glProgramNamedParameter4fvNV_PTR)(glProgramNamedParameter4fvNV_ARG_EXPAND);
#endif
#ifndef glProgramParameter4dNV_RETURN
#define glProgramParameter4dNV_RETURN void
#define glProgramParameter4dNV_ARG_NAMES target, index, x, y, z, w
#define glProgramParameter4dNV_ARG_EXPAND GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramParameter4dNV_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramParameter4dNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glProgramParameter4dNV(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameter4dNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameter4dNV(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramParameter4dNV(packed, ret_v) do { \
    glProgramParameter4dNV_PACKED *unpacked = (glProgramParameter4dNV_PACKED *)packed; \
    glProgramParameter4dNV_ARGS *args = (glProgramParameter4dNV_ARGS *)&unpacked->args; \
    glProgramParameter4dNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramParameter4dNV(glProgramParameter4dNV_ARG_EXPAND);
packed_call_t *pack_glProgramParameter4dNV(glProgramParameter4dNV_PACKED *_dst glProgramParameter4dNV_ARG_EXPAND_TAIL);
typedef void (*glProgramParameter4dNV_PTR)(glProgramParameter4dNV_ARG_EXPAND);
#endif
#ifndef glProgramParameter4dvNV_RETURN
#define glProgramParameter4dvNV_RETURN void
#define glProgramParameter4dvNV_ARG_NAMES target, index, v
#define glProgramParameter4dvNV_ARG_EXPAND GLenum target, GLuint index, const GLdouble * v
#define glProgramParameter4dvNV_ARG_NAMES_TAIL , target, index, v
#define glProgramParameter4dvNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLdouble * v
#define forward_glProgramParameter4dvNV(_target, _index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameter4dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameter4dvNV(dst, _target, _index, _v), NULL); \
    });
#define call_glProgramParameter4dvNV(packed, ret_v) do { \
    glProgramParameter4dvNV_PACKED *unpacked = (glProgramParameter4dvNV_PACKED *)packed; \
    glProgramParameter4dvNV_ARGS *args = (glProgramParameter4dvNV_ARGS *)&unpacked->args; \
    glProgramParameter4dvNV(args->target, args->index, args->v);; \
} while(0)
void glProgramParameter4dvNV(glProgramParameter4dvNV_ARG_EXPAND);
packed_call_t *pack_glProgramParameter4dvNV(glProgramParameter4dvNV_PACKED *_dst glProgramParameter4dvNV_ARG_EXPAND_TAIL);
typedef void (*glProgramParameter4dvNV_PTR)(glProgramParameter4dvNV_ARG_EXPAND);
#endif
#ifndef glProgramParameter4fNV_RETURN
#define glProgramParameter4fNV_RETURN void
#define glProgramParameter4fNV_ARG_NAMES target, index, x, y, z, w
#define glProgramParameter4fNV_ARG_EXPAND GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramParameter4fNV_ARG_NAMES_TAIL , target, index, x, y, z, w
#define glProgramParameter4fNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glProgramParameter4fNV(_target, _index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameter4fNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameter4fNV(dst, _target, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramParameter4fNV(packed, ret_v) do { \
    glProgramParameter4fNV_PACKED *unpacked = (glProgramParameter4fNV_PACKED *)packed; \
    glProgramParameter4fNV_ARGS *args = (glProgramParameter4fNV_ARGS *)&unpacked->args; \
    glProgramParameter4fNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramParameter4fNV(glProgramParameter4fNV_ARG_EXPAND);
packed_call_t *pack_glProgramParameter4fNV(glProgramParameter4fNV_PACKED *_dst glProgramParameter4fNV_ARG_EXPAND_TAIL);
typedef void (*glProgramParameter4fNV_PTR)(glProgramParameter4fNV_ARG_EXPAND);
#endif
#ifndef glProgramParameter4fvNV_RETURN
#define glProgramParameter4fvNV_RETURN void
#define glProgramParameter4fvNV_ARG_NAMES target, index, v
#define glProgramParameter4fvNV_ARG_EXPAND GLenum target, GLuint index, const GLfloat * v
#define glProgramParameter4fvNV_ARG_NAMES_TAIL , target, index, v
#define glProgramParameter4fvNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, const GLfloat * v
#define forward_glProgramParameter4fvNV(_target, _index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameter4fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameter4fvNV(dst, _target, _index, _v), NULL); \
    });
#define call_glProgramParameter4fvNV(packed, ret_v) do { \
    glProgramParameter4fvNV_PACKED *unpacked = (glProgramParameter4fvNV_PACKED *)packed; \
    glProgramParameter4fvNV_ARGS *args = (glProgramParameter4fvNV_ARGS *)&unpacked->args; \
    glProgramParameter4fvNV(args->target, args->index, args->v);; \
} while(0)
void glProgramParameter4fvNV(glProgramParameter4fvNV_ARG_EXPAND);
packed_call_t *pack_glProgramParameter4fvNV(glProgramParameter4fvNV_PACKED *_dst glProgramParameter4fvNV_ARG_EXPAND_TAIL);
typedef void (*glProgramParameter4fvNV_PTR)(glProgramParameter4fvNV_ARG_EXPAND);
#endif
#ifndef glProgramParameteri_RETURN
#define glProgramParameteri_RETURN void
#define glProgramParameteri_ARG_NAMES program, pname, value
#define glProgramParameteri_ARG_EXPAND GLuint program, GLenum pname, GLint value
#define glProgramParameteri_ARG_NAMES_TAIL , program, pname, value
#define glProgramParameteri_ARG_EXPAND_TAIL , GLuint program, GLenum pname, GLint value
#define forward_glProgramParameteri(_program, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameteri_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameteri(dst, _program, _pname, _value), NULL); \
    });
#define call_glProgramParameteri(packed, ret_v) do { \
    glProgramParameteri_PACKED *unpacked = (glProgramParameteri_PACKED *)packed; \
    glProgramParameteri_ARGS *args = (glProgramParameteri_ARGS *)&unpacked->args; \
    glProgramParameteri(args->program, args->pname, args->value);; \
} while(0)
void glProgramParameteri(glProgramParameteri_ARG_EXPAND);
packed_call_t *pack_glProgramParameteri(glProgramParameteri_PACKED *_dst glProgramParameteri_ARG_EXPAND_TAIL);
typedef void (*glProgramParameteri_PTR)(glProgramParameteri_ARG_EXPAND);
#endif
#ifndef glProgramParameteriARB_RETURN
#define glProgramParameteriARB_RETURN void
#define glProgramParameteriARB_ARG_NAMES program, pname, value
#define glProgramParameteriARB_ARG_EXPAND GLuint program, GLenum pname, GLint value
#define glProgramParameteriARB_ARG_NAMES_TAIL , program, pname, value
#define glProgramParameteriARB_ARG_EXPAND_TAIL , GLuint program, GLenum pname, GLint value
#define forward_glProgramParameteriARB(_program, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameteriARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameteriARB(dst, _program, _pname, _value), NULL); \
    });
#define call_glProgramParameteriARB(packed, ret_v) do { \
    glProgramParameteriARB_PACKED *unpacked = (glProgramParameteriARB_PACKED *)packed; \
    glProgramParameteriARB_ARGS *args = (glProgramParameteriARB_ARGS *)&unpacked->args; \
    glProgramParameteriARB(args->program, args->pname, args->value);; \
} while(0)
void glProgramParameteriARB(glProgramParameteriARB_ARG_EXPAND);
packed_call_t *pack_glProgramParameteriARB(glProgramParameteriARB_PACKED *_dst glProgramParameteriARB_ARG_EXPAND_TAIL);
typedef void (*glProgramParameteriARB_PTR)(glProgramParameteriARB_ARG_EXPAND);
#endif
#ifndef glProgramParameteriEXT_RETURN
#define glProgramParameteriEXT_RETURN void
#define glProgramParameteriEXT_ARG_NAMES program, pname, value
#define glProgramParameteriEXT_ARG_EXPAND GLuint program, GLenum pname, GLint value
#define glProgramParameteriEXT_ARG_NAMES_TAIL , program, pname, value
#define glProgramParameteriEXT_ARG_EXPAND_TAIL , GLuint program, GLenum pname, GLint value
#define forward_glProgramParameteriEXT(_program, _pname, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameteriEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameteriEXT(dst, _program, _pname, _value), NULL); \
    });
#define call_glProgramParameteriEXT(packed, ret_v) do { \
    glProgramParameteriEXT_PACKED *unpacked = (glProgramParameteriEXT_PACKED *)packed; \
    glProgramParameteriEXT_ARGS *args = (glProgramParameteriEXT_ARGS *)&unpacked->args; \
    glProgramParameteriEXT(args->program, args->pname, args->value);; \
} while(0)
void glProgramParameteriEXT(glProgramParameteriEXT_ARG_EXPAND);
packed_call_t *pack_glProgramParameteriEXT(glProgramParameteriEXT_PACKED *_dst glProgramParameteriEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramParameteriEXT_PTR)(glProgramParameteriEXT_ARG_EXPAND);
#endif
#ifndef glProgramParameters4dvNV_RETURN
#define glProgramParameters4dvNV_RETURN void
#define glProgramParameters4dvNV_ARG_NAMES target, index, count, v
#define glProgramParameters4dvNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLdouble * v
#define glProgramParameters4dvNV_ARG_NAMES_TAIL , target, index, count, v
#define glProgramParameters4dvNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLdouble * v
#define forward_glProgramParameters4dvNV(_target, _index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameters4dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameters4dvNV(dst, _target, _index, _count, _v), NULL); \
    });
#define call_glProgramParameters4dvNV(packed, ret_v) do { \
    glProgramParameters4dvNV_PACKED *unpacked = (glProgramParameters4dvNV_PACKED *)packed; \
    glProgramParameters4dvNV_ARGS *args = (glProgramParameters4dvNV_ARGS *)&unpacked->args; \
    glProgramParameters4dvNV(args->target, args->index, args->count, args->v);; \
} while(0)
void glProgramParameters4dvNV(glProgramParameters4dvNV_ARG_EXPAND);
packed_call_t *pack_glProgramParameters4dvNV(glProgramParameters4dvNV_PACKED *_dst glProgramParameters4dvNV_ARG_EXPAND_TAIL);
typedef void (*glProgramParameters4dvNV_PTR)(glProgramParameters4dvNV_ARG_EXPAND);
#endif
#ifndef glProgramParameters4fvNV_RETURN
#define glProgramParameters4fvNV_RETURN void
#define glProgramParameters4fvNV_ARG_NAMES target, index, count, v
#define glProgramParameters4fvNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLfloat * v
#define glProgramParameters4fvNV_ARG_NAMES_TAIL , target, index, count, v
#define glProgramParameters4fvNV_ARG_EXPAND_TAIL , GLenum target, GLuint index, GLsizei count, const GLfloat * v
#define forward_glProgramParameters4fvNV(_target, _index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramParameters4fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramParameters4fvNV(dst, _target, _index, _count, _v), NULL); \
    });
#define call_glProgramParameters4fvNV(packed, ret_v) do { \
    glProgramParameters4fvNV_PACKED *unpacked = (glProgramParameters4fvNV_PACKED *)packed; \
    glProgramParameters4fvNV_ARGS *args = (glProgramParameters4fvNV_ARGS *)&unpacked->args; \
    glProgramParameters4fvNV(args->target, args->index, args->count, args->v);; \
} while(0)
void glProgramParameters4fvNV(glProgramParameters4fvNV_ARG_EXPAND);
packed_call_t *pack_glProgramParameters4fvNV(glProgramParameters4fvNV_PACKED *_dst glProgramParameters4fvNV_ARG_EXPAND_TAIL);
typedef void (*glProgramParameters4fvNV_PTR)(glProgramParameters4fvNV_ARG_EXPAND);
#endif
#ifndef glProgramStringARB_RETURN
#define glProgramStringARB_RETURN void
#define glProgramStringARB_ARG_NAMES target, format, len, string
#define glProgramStringARB_ARG_EXPAND GLenum target, GLenum format, GLsizei len, const GLvoid * string
#define glProgramStringARB_ARG_NAMES_TAIL , target, format, len, string
#define glProgramStringARB_ARG_EXPAND_TAIL , GLenum target, GLenum format, GLsizei len, const GLvoid * string
#define forward_glProgramStringARB(_target, _format, _len, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramStringARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramStringARB(dst, _target, _format, _len, _string), NULL); \
    });
#define call_glProgramStringARB(packed, ret_v) do { \
    glProgramStringARB_PACKED *unpacked = (glProgramStringARB_PACKED *)packed; \
    glProgramStringARB_ARGS *args = (glProgramStringARB_ARGS *)&unpacked->args; \
    glProgramStringARB(args->target, args->format, args->len, args->string);; \
} while(0)
void glProgramStringARB(glProgramStringARB_ARG_EXPAND);
packed_call_t *pack_glProgramStringARB(glProgramStringARB_PACKED *_dst glProgramStringARB_ARG_EXPAND_TAIL);
typedef void (*glProgramStringARB_PTR)(glProgramStringARB_ARG_EXPAND);
#endif
#ifndef glProgramSubroutineParametersuivNV_RETURN
#define glProgramSubroutineParametersuivNV_RETURN void
#define glProgramSubroutineParametersuivNV_ARG_NAMES target, count, params
#define glProgramSubroutineParametersuivNV_ARG_EXPAND GLenum target, GLsizei count, const GLuint * params
#define glProgramSubroutineParametersuivNV_ARG_NAMES_TAIL , target, count, params
#define glProgramSubroutineParametersuivNV_ARG_EXPAND_TAIL , GLenum target, GLsizei count, const GLuint * params
#define forward_glProgramSubroutineParametersuivNV(_target, _count, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramSubroutineParametersuivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramSubroutineParametersuivNV(dst, _target, _count, _params), NULL); \
    });
#define call_glProgramSubroutineParametersuivNV(packed, ret_v) do { \
    glProgramSubroutineParametersuivNV_PACKED *unpacked = (glProgramSubroutineParametersuivNV_PACKED *)packed; \
    glProgramSubroutineParametersuivNV_ARGS *args = (glProgramSubroutineParametersuivNV_ARGS *)&unpacked->args; \
    glProgramSubroutineParametersuivNV(args->target, args->count, args->params);; \
} while(0)
void glProgramSubroutineParametersuivNV(glProgramSubroutineParametersuivNV_ARG_EXPAND);
packed_call_t *pack_glProgramSubroutineParametersuivNV(glProgramSubroutineParametersuivNV_PACKED *_dst glProgramSubroutineParametersuivNV_ARG_EXPAND_TAIL);
typedef void (*glProgramSubroutineParametersuivNV_PTR)(glProgramSubroutineParametersuivNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform1d_RETURN
#define glProgramUniform1d_RETURN void
#define glProgramUniform1d_ARG_NAMES program, location, v0
#define glProgramUniform1d_ARG_EXPAND GLuint program, GLint location, GLdouble v0
#define glProgramUniform1d_ARG_NAMES_TAIL , program, location, v0
#define glProgramUniform1d_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble v0
#define forward_glProgramUniform1d(_program, _location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1d(dst, _program, _location, _v0), NULL); \
    });
#define call_glProgramUniform1d(packed, ret_v) do { \
    glProgramUniform1d_PACKED *unpacked = (glProgramUniform1d_PACKED *)packed; \
    glProgramUniform1d_ARGS *args = (glProgramUniform1d_ARGS *)&unpacked->args; \
    glProgramUniform1d(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1d(glProgramUniform1d_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1d(glProgramUniform1d_PACKED *_dst glProgramUniform1d_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1d_PTR)(glProgramUniform1d_ARG_EXPAND);
#endif
#ifndef glProgramUniform1dEXT_RETURN
#define glProgramUniform1dEXT_RETURN void
#define glProgramUniform1dEXT_ARG_NAMES program, location, x
#define glProgramUniform1dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x
#define glProgramUniform1dEXT_ARG_NAMES_TAIL , program, location, x
#define glProgramUniform1dEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble x
#define forward_glProgramUniform1dEXT(_program, _location, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1dEXT(dst, _program, _location, _x), NULL); \
    });
#define call_glProgramUniform1dEXT(packed, ret_v) do { \
    glProgramUniform1dEXT_PACKED *unpacked = (glProgramUniform1dEXT_PACKED *)packed; \
    glProgramUniform1dEXT_ARGS *args = (glProgramUniform1dEXT_ARGS *)&unpacked->args; \
    glProgramUniform1dEXT(args->program, args->location, args->x);; \
} while(0)
void glProgramUniform1dEXT(glProgramUniform1dEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1dEXT(glProgramUniform1dEXT_PACKED *_dst glProgramUniform1dEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1dEXT_PTR)(glProgramUniform1dEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform1dv_RETURN
#define glProgramUniform1dv_RETURN void
#define glProgramUniform1dv_ARG_NAMES program, location, count, value
#define glProgramUniform1dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform1dv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform1dv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1dv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1dv(packed, ret_v) do { \
    glProgramUniform1dv_PACKED *unpacked = (glProgramUniform1dv_PACKED *)packed; \
    glProgramUniform1dv_ARGS *args = (glProgramUniform1dv_ARGS *)&unpacked->args; \
    glProgramUniform1dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1dv(glProgramUniform1dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1dv(glProgramUniform1dv_PACKED *_dst glProgramUniform1dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1dv_PTR)(glProgramUniform1dv_ARG_EXPAND);
#endif
#ifndef glProgramUniform1dvEXT_RETURN
#define glProgramUniform1dvEXT_RETURN void
#define glProgramUniform1dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform1dvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform1dvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1dvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1dvEXT(packed, ret_v) do { \
    glProgramUniform1dvEXT_PACKED *unpacked = (glProgramUniform1dvEXT_PACKED *)packed; \
    glProgramUniform1dvEXT_ARGS *args = (glProgramUniform1dvEXT_ARGS *)&unpacked->args; \
    glProgramUniform1dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1dvEXT(glProgramUniform1dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1dvEXT(glProgramUniform1dvEXT_PACKED *_dst glProgramUniform1dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1dvEXT_PTR)(glProgramUniform1dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform1f_RETURN
#define glProgramUniform1f_RETURN void
#define glProgramUniform1f_ARG_NAMES program, location, v0
#define glProgramUniform1f_ARG_EXPAND GLuint program, GLint location, GLfloat v0
#define glProgramUniform1f_ARG_NAMES_TAIL , program, location, v0
#define glProgramUniform1f_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0
#define forward_glProgramUniform1f(_program, _location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1f(dst, _program, _location, _v0), NULL); \
    });
#define call_glProgramUniform1f(packed, ret_v) do { \
    glProgramUniform1f_PACKED *unpacked = (glProgramUniform1f_PACKED *)packed; \
    glProgramUniform1f_ARGS *args = (glProgramUniform1f_ARGS *)&unpacked->args; \
    glProgramUniform1f(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1f(glProgramUniform1f_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1f(glProgramUniform1f_PACKED *_dst glProgramUniform1f_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1f_PTR)(glProgramUniform1f_ARG_EXPAND);
#endif
#ifndef glProgramUniform1fEXT_RETURN
#define glProgramUniform1fEXT_RETURN void
#define glProgramUniform1fEXT_ARG_NAMES program, location, v0
#define glProgramUniform1fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0
#define glProgramUniform1fEXT_ARG_NAMES_TAIL , program, location, v0
#define glProgramUniform1fEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0
#define forward_glProgramUniform1fEXT(_program, _location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1fEXT(dst, _program, _location, _v0), NULL); \
    });
#define call_glProgramUniform1fEXT(packed, ret_v) do { \
    glProgramUniform1fEXT_PACKED *unpacked = (glProgramUniform1fEXT_PACKED *)packed; \
    glProgramUniform1fEXT_ARGS *args = (glProgramUniform1fEXT_ARGS *)&unpacked->args; \
    glProgramUniform1fEXT(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1fEXT(glProgramUniform1fEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1fEXT(glProgramUniform1fEXT_PACKED *_dst glProgramUniform1fEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1fEXT_PTR)(glProgramUniform1fEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform1fv_RETURN
#define glProgramUniform1fv_RETURN void
#define glProgramUniform1fv_ARG_NAMES program, location, count, value
#define glProgramUniform1fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform1fv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform1fv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1fv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1fv(packed, ret_v) do { \
    glProgramUniform1fv_PACKED *unpacked = (glProgramUniform1fv_PACKED *)packed; \
    glProgramUniform1fv_ARGS *args = (glProgramUniform1fv_ARGS *)&unpacked->args; \
    glProgramUniform1fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1fv(glProgramUniform1fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1fv(glProgramUniform1fv_PACKED *_dst glProgramUniform1fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1fv_PTR)(glProgramUniform1fv_ARG_EXPAND);
#endif
#ifndef glProgramUniform1fvEXT_RETURN
#define glProgramUniform1fvEXT_RETURN void
#define glProgramUniform1fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform1fvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform1fvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1fvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1fvEXT(packed, ret_v) do { \
    glProgramUniform1fvEXT_PACKED *unpacked = (glProgramUniform1fvEXT_PACKED *)packed; \
    glProgramUniform1fvEXT_ARGS *args = (glProgramUniform1fvEXT_ARGS *)&unpacked->args; \
    glProgramUniform1fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1fvEXT(glProgramUniform1fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1fvEXT(glProgramUniform1fvEXT_PACKED *_dst glProgramUniform1fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1fvEXT_PTR)(glProgramUniform1fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform1i_RETURN
#define glProgramUniform1i_RETURN void
#define glProgramUniform1i_ARG_NAMES program, location, v0
#define glProgramUniform1i_ARG_EXPAND GLuint program, GLint location, GLint v0
#define glProgramUniform1i_ARG_NAMES_TAIL , program, location, v0
#define glProgramUniform1i_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0
#define forward_glProgramUniform1i(_program, _location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1i(dst, _program, _location, _v0), NULL); \
    });
#define call_glProgramUniform1i(packed, ret_v) do { \
    glProgramUniform1i_PACKED *unpacked = (glProgramUniform1i_PACKED *)packed; \
    glProgramUniform1i_ARGS *args = (glProgramUniform1i_ARGS *)&unpacked->args; \
    glProgramUniform1i(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1i(glProgramUniform1i_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1i(glProgramUniform1i_PACKED *_dst glProgramUniform1i_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1i_PTR)(glProgramUniform1i_ARG_EXPAND);
#endif
#ifndef glProgramUniform1i64NV_RETURN
#define glProgramUniform1i64NV_RETURN void
#define glProgramUniform1i64NV_ARG_NAMES program, location, x
#define glProgramUniform1i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x
#define glProgramUniform1i64NV_ARG_NAMES_TAIL , program, location, x
#define glProgramUniform1i64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint64EXT x
#define forward_glProgramUniform1i64NV(_program, _location, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1i64NV(dst, _program, _location, _x), NULL); \
    });
#define call_glProgramUniform1i64NV(packed, ret_v) do { \
    glProgramUniform1i64NV_PACKED *unpacked = (glProgramUniform1i64NV_PACKED *)packed; \
    glProgramUniform1i64NV_ARGS *args = (glProgramUniform1i64NV_ARGS *)&unpacked->args; \
    glProgramUniform1i64NV(args->program, args->location, args->x);; \
} while(0)
void glProgramUniform1i64NV(glProgramUniform1i64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1i64NV(glProgramUniform1i64NV_PACKED *_dst glProgramUniform1i64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1i64NV_PTR)(glProgramUniform1i64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform1i64vNV_RETURN
#define glProgramUniform1i64vNV_RETURN void
#define glProgramUniform1i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform1i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform1i64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1i64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define forward_glProgramUniform1i64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1i64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1i64vNV(packed, ret_v) do { \
    glProgramUniform1i64vNV_PACKED *unpacked = (glProgramUniform1i64vNV_PACKED *)packed; \
    glProgramUniform1i64vNV_ARGS *args = (glProgramUniform1i64vNV_ARGS *)&unpacked->args; \
    glProgramUniform1i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1i64vNV(glProgramUniform1i64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1i64vNV(glProgramUniform1i64vNV_PACKED *_dst glProgramUniform1i64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1i64vNV_PTR)(glProgramUniform1i64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform1iEXT_RETURN
#define glProgramUniform1iEXT_RETURN void
#define glProgramUniform1iEXT_ARG_NAMES program, location, v0
#define glProgramUniform1iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0
#define glProgramUniform1iEXT_ARG_NAMES_TAIL , program, location, v0
#define glProgramUniform1iEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0
#define forward_glProgramUniform1iEXT(_program, _location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1iEXT(dst, _program, _location, _v0), NULL); \
    });
#define call_glProgramUniform1iEXT(packed, ret_v) do { \
    glProgramUniform1iEXT_PACKED *unpacked = (glProgramUniform1iEXT_PACKED *)packed; \
    glProgramUniform1iEXT_ARGS *args = (glProgramUniform1iEXT_ARGS *)&unpacked->args; \
    glProgramUniform1iEXT(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1iEXT(glProgramUniform1iEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1iEXT(glProgramUniform1iEXT_PACKED *_dst glProgramUniform1iEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1iEXT_PTR)(glProgramUniform1iEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform1iv_RETURN
#define glProgramUniform1iv_RETURN void
#define glProgramUniform1iv_ARG_NAMES program, location, count, value
#define glProgramUniform1iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform1iv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1iv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform1iv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1iv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1iv(packed, ret_v) do { \
    glProgramUniform1iv_PACKED *unpacked = (glProgramUniform1iv_PACKED *)packed; \
    glProgramUniform1iv_ARGS *args = (glProgramUniform1iv_ARGS *)&unpacked->args; \
    glProgramUniform1iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1iv(glProgramUniform1iv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1iv(glProgramUniform1iv_PACKED *_dst glProgramUniform1iv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1iv_PTR)(glProgramUniform1iv_ARG_EXPAND);
#endif
#ifndef glProgramUniform1ivEXT_RETURN
#define glProgramUniform1ivEXT_RETURN void
#define glProgramUniform1ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform1ivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1ivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform1ivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1ivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1ivEXT(packed, ret_v) do { \
    glProgramUniform1ivEXT_PACKED *unpacked = (glProgramUniform1ivEXT_PACKED *)packed; \
    glProgramUniform1ivEXT_ARGS *args = (glProgramUniform1ivEXT_ARGS *)&unpacked->args; \
    glProgramUniform1ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1ivEXT(glProgramUniform1ivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1ivEXT(glProgramUniform1ivEXT_PACKED *_dst glProgramUniform1ivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1ivEXT_PTR)(glProgramUniform1ivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform1ui_RETURN
#define glProgramUniform1ui_RETURN void
#define glProgramUniform1ui_ARG_NAMES program, location, v0
#define glProgramUniform1ui_ARG_EXPAND GLuint program, GLint location, GLuint v0
#define glProgramUniform1ui_ARG_NAMES_TAIL , program, location, v0
#define glProgramUniform1ui_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0
#define forward_glProgramUniform1ui(_program, _location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1ui(dst, _program, _location, _v0), NULL); \
    });
#define call_glProgramUniform1ui(packed, ret_v) do { \
    glProgramUniform1ui_PACKED *unpacked = (glProgramUniform1ui_PACKED *)packed; \
    glProgramUniform1ui_ARGS *args = (glProgramUniform1ui_ARGS *)&unpacked->args; \
    glProgramUniform1ui(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1ui(glProgramUniform1ui_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1ui(glProgramUniform1ui_PACKED *_dst glProgramUniform1ui_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1ui_PTR)(glProgramUniform1ui_ARG_EXPAND);
#endif
#ifndef glProgramUniform1ui64NV_RETURN
#define glProgramUniform1ui64NV_RETURN void
#define glProgramUniform1ui64NV_ARG_NAMES program, location, x
#define glProgramUniform1ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x
#define glProgramUniform1ui64NV_ARG_NAMES_TAIL , program, location, x
#define glProgramUniform1ui64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint64EXT x
#define forward_glProgramUniform1ui64NV(_program, _location, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1ui64NV(dst, _program, _location, _x), NULL); \
    });
#define call_glProgramUniform1ui64NV(packed, ret_v) do { \
    glProgramUniform1ui64NV_PACKED *unpacked = (glProgramUniform1ui64NV_PACKED *)packed; \
    glProgramUniform1ui64NV_ARGS *args = (glProgramUniform1ui64NV_ARGS *)&unpacked->args; \
    glProgramUniform1ui64NV(args->program, args->location, args->x);; \
} while(0)
void glProgramUniform1ui64NV(glProgramUniform1ui64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1ui64NV(glProgramUniform1ui64NV_PACKED *_dst glProgramUniform1ui64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1ui64NV_PTR)(glProgramUniform1ui64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform1ui64vNV_RETURN
#define glProgramUniform1ui64vNV_RETURN void
#define glProgramUniform1ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform1ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform1ui64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1ui64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glProgramUniform1ui64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1ui64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1ui64vNV(packed, ret_v) do { \
    glProgramUniform1ui64vNV_PACKED *unpacked = (glProgramUniform1ui64vNV_PACKED *)packed; \
    glProgramUniform1ui64vNV_ARGS *args = (glProgramUniform1ui64vNV_ARGS *)&unpacked->args; \
    glProgramUniform1ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1ui64vNV(glProgramUniform1ui64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1ui64vNV(glProgramUniform1ui64vNV_PACKED *_dst glProgramUniform1ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1ui64vNV_PTR)(glProgramUniform1ui64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform1uiEXT_RETURN
#define glProgramUniform1uiEXT_RETURN void
#define glProgramUniform1uiEXT_ARG_NAMES program, location, v0
#define glProgramUniform1uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0
#define glProgramUniform1uiEXT_ARG_NAMES_TAIL , program, location, v0
#define glProgramUniform1uiEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0
#define forward_glProgramUniform1uiEXT(_program, _location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1uiEXT(dst, _program, _location, _v0), NULL); \
    });
#define call_glProgramUniform1uiEXT(packed, ret_v) do { \
    glProgramUniform1uiEXT_PACKED *unpacked = (glProgramUniform1uiEXT_PACKED *)packed; \
    glProgramUniform1uiEXT_ARGS *args = (glProgramUniform1uiEXT_ARGS *)&unpacked->args; \
    glProgramUniform1uiEXT(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1uiEXT(glProgramUniform1uiEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1uiEXT(glProgramUniform1uiEXT_PACKED *_dst glProgramUniform1uiEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1uiEXT_PTR)(glProgramUniform1uiEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform1uiv_RETURN
#define glProgramUniform1uiv_RETURN void
#define glProgramUniform1uiv_ARG_NAMES program, location, count, value
#define glProgramUniform1uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform1uiv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1uiv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform1uiv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1uiv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1uiv(packed, ret_v) do { \
    glProgramUniform1uiv_PACKED *unpacked = (glProgramUniform1uiv_PACKED *)packed; \
    glProgramUniform1uiv_ARGS *args = (glProgramUniform1uiv_ARGS *)&unpacked->args; \
    glProgramUniform1uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1uiv(glProgramUniform1uiv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1uiv(glProgramUniform1uiv_PACKED *_dst glProgramUniform1uiv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1uiv_PTR)(glProgramUniform1uiv_ARG_EXPAND);
#endif
#ifndef glProgramUniform1uivEXT_RETURN
#define glProgramUniform1uivEXT_RETURN void
#define glProgramUniform1uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform1uivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform1uivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform1uivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform1uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform1uivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform1uivEXT(packed, ret_v) do { \
    glProgramUniform1uivEXT_PACKED *unpacked = (glProgramUniform1uivEXT_PACKED *)packed; \
    glProgramUniform1uivEXT_ARGS *args = (glProgramUniform1uivEXT_ARGS *)&unpacked->args; \
    glProgramUniform1uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1uivEXT(glProgramUniform1uivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform1uivEXT(glProgramUniform1uivEXT_PACKED *_dst glProgramUniform1uivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform1uivEXT_PTR)(glProgramUniform1uivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2d_RETURN
#define glProgramUniform2d_RETURN void
#define glProgramUniform2d_ARG_NAMES program, location, v0, v1
#define glProgramUniform2d_ARG_EXPAND GLuint program, GLint location, GLdouble v0, GLdouble v1
#define glProgramUniform2d_ARG_NAMES_TAIL , program, location, v0, v1
#define glProgramUniform2d_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble v0, GLdouble v1
#define forward_glProgramUniform2d(_program, _location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2d(dst, _program, _location, _v0, _v1), NULL); \
    });
#define call_glProgramUniform2d(packed, ret_v) do { \
    glProgramUniform2d_PACKED *unpacked = (glProgramUniform2d_PACKED *)packed; \
    glProgramUniform2d_ARGS *args = (glProgramUniform2d_ARGS *)&unpacked->args; \
    glProgramUniform2d(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2d(glProgramUniform2d_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2d(glProgramUniform2d_PACKED *_dst glProgramUniform2d_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2d_PTR)(glProgramUniform2d_ARG_EXPAND);
#endif
#ifndef glProgramUniform2dEXT_RETURN
#define glProgramUniform2dEXT_RETURN void
#define glProgramUniform2dEXT_ARG_NAMES program, location, x, y
#define glProgramUniform2dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x, GLdouble y
#define glProgramUniform2dEXT_ARG_NAMES_TAIL , program, location, x, y
#define glProgramUniform2dEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble x, GLdouble y
#define forward_glProgramUniform2dEXT(_program, _location, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2dEXT(dst, _program, _location, _x, _y), NULL); \
    });
#define call_glProgramUniform2dEXT(packed, ret_v) do { \
    glProgramUniform2dEXT_PACKED *unpacked = (glProgramUniform2dEXT_PACKED *)packed; \
    glProgramUniform2dEXT_ARGS *args = (glProgramUniform2dEXT_ARGS *)&unpacked->args; \
    glProgramUniform2dEXT(args->program, args->location, args->x, args->y);; \
} while(0)
void glProgramUniform2dEXT(glProgramUniform2dEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2dEXT(glProgramUniform2dEXT_PACKED *_dst glProgramUniform2dEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2dEXT_PTR)(glProgramUniform2dEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2dv_RETURN
#define glProgramUniform2dv_RETURN void
#define glProgramUniform2dv_ARG_NAMES program, location, count, value
#define glProgramUniform2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform2dv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform2dv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2dv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2dv(packed, ret_v) do { \
    glProgramUniform2dv_PACKED *unpacked = (glProgramUniform2dv_PACKED *)packed; \
    glProgramUniform2dv_ARGS *args = (glProgramUniform2dv_ARGS *)&unpacked->args; \
    glProgramUniform2dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2dv(glProgramUniform2dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2dv(glProgramUniform2dv_PACKED *_dst glProgramUniform2dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2dv_PTR)(glProgramUniform2dv_ARG_EXPAND);
#endif
#ifndef glProgramUniform2dvEXT_RETURN
#define glProgramUniform2dvEXT_RETURN void
#define glProgramUniform2dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform2dvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform2dvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2dvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2dvEXT(packed, ret_v) do { \
    glProgramUniform2dvEXT_PACKED *unpacked = (glProgramUniform2dvEXT_PACKED *)packed; \
    glProgramUniform2dvEXT_ARGS *args = (glProgramUniform2dvEXT_ARGS *)&unpacked->args; \
    glProgramUniform2dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2dvEXT(glProgramUniform2dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2dvEXT(glProgramUniform2dvEXT_PACKED *_dst glProgramUniform2dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2dvEXT_PTR)(glProgramUniform2dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2f_RETURN
#define glProgramUniform2f_RETURN void
#define glProgramUniform2f_ARG_NAMES program, location, v0, v1
#define glProgramUniform2f_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1
#define glProgramUniform2f_ARG_NAMES_TAIL , program, location, v0, v1
#define glProgramUniform2f_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0, GLfloat v1
#define forward_glProgramUniform2f(_program, _location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2f(dst, _program, _location, _v0, _v1), NULL); \
    });
#define call_glProgramUniform2f(packed, ret_v) do { \
    glProgramUniform2f_PACKED *unpacked = (glProgramUniform2f_PACKED *)packed; \
    glProgramUniform2f_ARGS *args = (glProgramUniform2f_ARGS *)&unpacked->args; \
    glProgramUniform2f(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2f(glProgramUniform2f_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2f(glProgramUniform2f_PACKED *_dst glProgramUniform2f_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2f_PTR)(glProgramUniform2f_ARG_EXPAND);
#endif
#ifndef glProgramUniform2fEXT_RETURN
#define glProgramUniform2fEXT_RETURN void
#define glProgramUniform2fEXT_ARG_NAMES program, location, v0, v1
#define glProgramUniform2fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1
#define glProgramUniform2fEXT_ARG_NAMES_TAIL , program, location, v0, v1
#define glProgramUniform2fEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0, GLfloat v1
#define forward_glProgramUniform2fEXT(_program, _location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2fEXT(dst, _program, _location, _v0, _v1), NULL); \
    });
#define call_glProgramUniform2fEXT(packed, ret_v) do { \
    glProgramUniform2fEXT_PACKED *unpacked = (glProgramUniform2fEXT_PACKED *)packed; \
    glProgramUniform2fEXT_ARGS *args = (glProgramUniform2fEXT_ARGS *)&unpacked->args; \
    glProgramUniform2fEXT(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2fEXT(glProgramUniform2fEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2fEXT(glProgramUniform2fEXT_PACKED *_dst glProgramUniform2fEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2fEXT_PTR)(glProgramUniform2fEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2fv_RETURN
#define glProgramUniform2fv_RETURN void
#define glProgramUniform2fv_ARG_NAMES program, location, count, value
#define glProgramUniform2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform2fv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform2fv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2fv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2fv(packed, ret_v) do { \
    glProgramUniform2fv_PACKED *unpacked = (glProgramUniform2fv_PACKED *)packed; \
    glProgramUniform2fv_ARGS *args = (glProgramUniform2fv_ARGS *)&unpacked->args; \
    glProgramUniform2fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2fv(glProgramUniform2fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2fv(glProgramUniform2fv_PACKED *_dst glProgramUniform2fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2fv_PTR)(glProgramUniform2fv_ARG_EXPAND);
#endif
#ifndef glProgramUniform2fvEXT_RETURN
#define glProgramUniform2fvEXT_RETURN void
#define glProgramUniform2fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform2fvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform2fvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2fvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2fvEXT(packed, ret_v) do { \
    glProgramUniform2fvEXT_PACKED *unpacked = (glProgramUniform2fvEXT_PACKED *)packed; \
    glProgramUniform2fvEXT_ARGS *args = (glProgramUniform2fvEXT_ARGS *)&unpacked->args; \
    glProgramUniform2fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2fvEXT(glProgramUniform2fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2fvEXT(glProgramUniform2fvEXT_PACKED *_dst glProgramUniform2fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2fvEXT_PTR)(glProgramUniform2fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2i_RETURN
#define glProgramUniform2i_RETURN void
#define glProgramUniform2i_ARG_NAMES program, location, v0, v1
#define glProgramUniform2i_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1
#define glProgramUniform2i_ARG_NAMES_TAIL , program, location, v0, v1
#define glProgramUniform2i_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0, GLint v1
#define forward_glProgramUniform2i(_program, _location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2i(dst, _program, _location, _v0, _v1), NULL); \
    });
#define call_glProgramUniform2i(packed, ret_v) do { \
    glProgramUniform2i_PACKED *unpacked = (glProgramUniform2i_PACKED *)packed; \
    glProgramUniform2i_ARGS *args = (glProgramUniform2i_ARGS *)&unpacked->args; \
    glProgramUniform2i(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2i(glProgramUniform2i_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2i(glProgramUniform2i_PACKED *_dst glProgramUniform2i_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2i_PTR)(glProgramUniform2i_ARG_EXPAND);
#endif
#ifndef glProgramUniform2i64NV_RETURN
#define glProgramUniform2i64NV_RETURN void
#define glProgramUniform2i64NV_ARG_NAMES program, location, x, y
#define glProgramUniform2i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x, GLint64EXT y
#define glProgramUniform2i64NV_ARG_NAMES_TAIL , program, location, x, y
#define glProgramUniform2i64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint64EXT x, GLint64EXT y
#define forward_glProgramUniform2i64NV(_program, _location, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2i64NV(dst, _program, _location, _x, _y), NULL); \
    });
#define call_glProgramUniform2i64NV(packed, ret_v) do { \
    glProgramUniform2i64NV_PACKED *unpacked = (glProgramUniform2i64NV_PACKED *)packed; \
    glProgramUniform2i64NV_ARGS *args = (glProgramUniform2i64NV_ARGS *)&unpacked->args; \
    glProgramUniform2i64NV(args->program, args->location, args->x, args->y);; \
} while(0)
void glProgramUniform2i64NV(glProgramUniform2i64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2i64NV(glProgramUniform2i64NV_PACKED *_dst glProgramUniform2i64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2i64NV_PTR)(glProgramUniform2i64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform2i64vNV_RETURN
#define glProgramUniform2i64vNV_RETURN void
#define glProgramUniform2i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform2i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform2i64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2i64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define forward_glProgramUniform2i64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2i64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2i64vNV(packed, ret_v) do { \
    glProgramUniform2i64vNV_PACKED *unpacked = (glProgramUniform2i64vNV_PACKED *)packed; \
    glProgramUniform2i64vNV_ARGS *args = (glProgramUniform2i64vNV_ARGS *)&unpacked->args; \
    glProgramUniform2i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2i64vNV(glProgramUniform2i64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2i64vNV(glProgramUniform2i64vNV_PACKED *_dst glProgramUniform2i64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2i64vNV_PTR)(glProgramUniform2i64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform2iEXT_RETURN
#define glProgramUniform2iEXT_RETURN void
#define glProgramUniform2iEXT_ARG_NAMES program, location, v0, v1
#define glProgramUniform2iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1
#define glProgramUniform2iEXT_ARG_NAMES_TAIL , program, location, v0, v1
#define glProgramUniform2iEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0, GLint v1
#define forward_glProgramUniform2iEXT(_program, _location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2iEXT(dst, _program, _location, _v0, _v1), NULL); \
    });
#define call_glProgramUniform2iEXT(packed, ret_v) do { \
    glProgramUniform2iEXT_PACKED *unpacked = (glProgramUniform2iEXT_PACKED *)packed; \
    glProgramUniform2iEXT_ARGS *args = (glProgramUniform2iEXT_ARGS *)&unpacked->args; \
    glProgramUniform2iEXT(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2iEXT(glProgramUniform2iEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2iEXT(glProgramUniform2iEXT_PACKED *_dst glProgramUniform2iEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2iEXT_PTR)(glProgramUniform2iEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2iv_RETURN
#define glProgramUniform2iv_RETURN void
#define glProgramUniform2iv_ARG_NAMES program, location, count, value
#define glProgramUniform2iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform2iv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2iv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform2iv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2iv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2iv(packed, ret_v) do { \
    glProgramUniform2iv_PACKED *unpacked = (glProgramUniform2iv_PACKED *)packed; \
    glProgramUniform2iv_ARGS *args = (glProgramUniform2iv_ARGS *)&unpacked->args; \
    glProgramUniform2iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2iv(glProgramUniform2iv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2iv(glProgramUniform2iv_PACKED *_dst glProgramUniform2iv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2iv_PTR)(glProgramUniform2iv_ARG_EXPAND);
#endif
#ifndef glProgramUniform2ivEXT_RETURN
#define glProgramUniform2ivEXT_RETURN void
#define glProgramUniform2ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform2ivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2ivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform2ivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2ivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2ivEXT(packed, ret_v) do { \
    glProgramUniform2ivEXT_PACKED *unpacked = (glProgramUniform2ivEXT_PACKED *)packed; \
    glProgramUniform2ivEXT_ARGS *args = (glProgramUniform2ivEXT_ARGS *)&unpacked->args; \
    glProgramUniform2ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2ivEXT(glProgramUniform2ivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2ivEXT(glProgramUniform2ivEXT_PACKED *_dst glProgramUniform2ivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2ivEXT_PTR)(glProgramUniform2ivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2ui_RETURN
#define glProgramUniform2ui_RETURN void
#define glProgramUniform2ui_ARG_NAMES program, location, v0, v1
#define glProgramUniform2ui_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1
#define glProgramUniform2ui_ARG_NAMES_TAIL , program, location, v0, v1
#define glProgramUniform2ui_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0, GLuint v1
#define forward_glProgramUniform2ui(_program, _location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2ui(dst, _program, _location, _v0, _v1), NULL); \
    });
#define call_glProgramUniform2ui(packed, ret_v) do { \
    glProgramUniform2ui_PACKED *unpacked = (glProgramUniform2ui_PACKED *)packed; \
    glProgramUniform2ui_ARGS *args = (glProgramUniform2ui_ARGS *)&unpacked->args; \
    glProgramUniform2ui(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2ui(glProgramUniform2ui_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2ui(glProgramUniform2ui_PACKED *_dst glProgramUniform2ui_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2ui_PTR)(glProgramUniform2ui_ARG_EXPAND);
#endif
#ifndef glProgramUniform2ui64NV_RETURN
#define glProgramUniform2ui64NV_RETURN void
#define glProgramUniform2ui64NV_ARG_NAMES program, location, x, y
#define glProgramUniform2ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y
#define glProgramUniform2ui64NV_ARG_NAMES_TAIL , program, location, x, y
#define glProgramUniform2ui64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y
#define forward_glProgramUniform2ui64NV(_program, _location, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2ui64NV(dst, _program, _location, _x, _y), NULL); \
    });
#define call_glProgramUniform2ui64NV(packed, ret_v) do { \
    glProgramUniform2ui64NV_PACKED *unpacked = (glProgramUniform2ui64NV_PACKED *)packed; \
    glProgramUniform2ui64NV_ARGS *args = (glProgramUniform2ui64NV_ARGS *)&unpacked->args; \
    glProgramUniform2ui64NV(args->program, args->location, args->x, args->y);; \
} while(0)
void glProgramUniform2ui64NV(glProgramUniform2ui64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2ui64NV(glProgramUniform2ui64NV_PACKED *_dst glProgramUniform2ui64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2ui64NV_PTR)(glProgramUniform2ui64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform2ui64vNV_RETURN
#define glProgramUniform2ui64vNV_RETURN void
#define glProgramUniform2ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform2ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform2ui64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2ui64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glProgramUniform2ui64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2ui64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2ui64vNV(packed, ret_v) do { \
    glProgramUniform2ui64vNV_PACKED *unpacked = (glProgramUniform2ui64vNV_PACKED *)packed; \
    glProgramUniform2ui64vNV_ARGS *args = (glProgramUniform2ui64vNV_ARGS *)&unpacked->args; \
    glProgramUniform2ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2ui64vNV(glProgramUniform2ui64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2ui64vNV(glProgramUniform2ui64vNV_PACKED *_dst glProgramUniform2ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2ui64vNV_PTR)(glProgramUniform2ui64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform2uiEXT_RETURN
#define glProgramUniform2uiEXT_RETURN void
#define glProgramUniform2uiEXT_ARG_NAMES program, location, v0, v1
#define glProgramUniform2uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1
#define glProgramUniform2uiEXT_ARG_NAMES_TAIL , program, location, v0, v1
#define glProgramUniform2uiEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0, GLuint v1
#define forward_glProgramUniform2uiEXT(_program, _location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2uiEXT(dst, _program, _location, _v0, _v1), NULL); \
    });
#define call_glProgramUniform2uiEXT(packed, ret_v) do { \
    glProgramUniform2uiEXT_PACKED *unpacked = (glProgramUniform2uiEXT_PACKED *)packed; \
    glProgramUniform2uiEXT_ARGS *args = (glProgramUniform2uiEXT_ARGS *)&unpacked->args; \
    glProgramUniform2uiEXT(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2uiEXT(glProgramUniform2uiEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2uiEXT(glProgramUniform2uiEXT_PACKED *_dst glProgramUniform2uiEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2uiEXT_PTR)(glProgramUniform2uiEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform2uiv_RETURN
#define glProgramUniform2uiv_RETURN void
#define glProgramUniform2uiv_ARG_NAMES program, location, count, value
#define glProgramUniform2uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform2uiv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2uiv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform2uiv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2uiv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2uiv(packed, ret_v) do { \
    glProgramUniform2uiv_PACKED *unpacked = (glProgramUniform2uiv_PACKED *)packed; \
    glProgramUniform2uiv_ARGS *args = (glProgramUniform2uiv_ARGS *)&unpacked->args; \
    glProgramUniform2uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2uiv(glProgramUniform2uiv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2uiv(glProgramUniform2uiv_PACKED *_dst glProgramUniform2uiv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2uiv_PTR)(glProgramUniform2uiv_ARG_EXPAND);
#endif
#ifndef glProgramUniform2uivEXT_RETURN
#define glProgramUniform2uivEXT_RETURN void
#define glProgramUniform2uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform2uivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform2uivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform2uivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform2uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform2uivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform2uivEXT(packed, ret_v) do { \
    glProgramUniform2uivEXT_PACKED *unpacked = (glProgramUniform2uivEXT_PACKED *)packed; \
    glProgramUniform2uivEXT_ARGS *args = (glProgramUniform2uivEXT_ARGS *)&unpacked->args; \
    glProgramUniform2uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2uivEXT(glProgramUniform2uivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform2uivEXT(glProgramUniform2uivEXT_PACKED *_dst glProgramUniform2uivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform2uivEXT_PTR)(glProgramUniform2uivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3d_RETURN
#define glProgramUniform3d_RETURN void
#define glProgramUniform3d_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3d_ARG_EXPAND GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2
#define glProgramUniform3d_ARG_NAMES_TAIL , program, location, v0, v1, v2
#define glProgramUniform3d_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2
#define forward_glProgramUniform3d(_program, _location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3d(dst, _program, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glProgramUniform3d(packed, ret_v) do { \
    glProgramUniform3d_PACKED *unpacked = (glProgramUniform3d_PACKED *)packed; \
    glProgramUniform3d_ARGS *args = (glProgramUniform3d_ARGS *)&unpacked->args; \
    glProgramUniform3d(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3d(glProgramUniform3d_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3d(glProgramUniform3d_PACKED *_dst glProgramUniform3d_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3d_PTR)(glProgramUniform3d_ARG_EXPAND);
#endif
#ifndef glProgramUniform3dEXT_RETURN
#define glProgramUniform3dEXT_RETURN void
#define glProgramUniform3dEXT_ARG_NAMES program, location, x, y, z
#define glProgramUniform3dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z
#define glProgramUniform3dEXT_ARG_NAMES_TAIL , program, location, x, y, z
#define glProgramUniform3dEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z
#define forward_glProgramUniform3dEXT(_program, _location, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3dEXT(dst, _program, _location, _x, _y, _z), NULL); \
    });
#define call_glProgramUniform3dEXT(packed, ret_v) do { \
    glProgramUniform3dEXT_PACKED *unpacked = (glProgramUniform3dEXT_PACKED *)packed; \
    glProgramUniform3dEXT_ARGS *args = (glProgramUniform3dEXT_ARGS *)&unpacked->args; \
    glProgramUniform3dEXT(args->program, args->location, args->x, args->y, args->z);; \
} while(0)
void glProgramUniform3dEXT(glProgramUniform3dEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3dEXT(glProgramUniform3dEXT_PACKED *_dst glProgramUniform3dEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3dEXT_PTR)(glProgramUniform3dEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3dv_RETURN
#define glProgramUniform3dv_RETURN void
#define glProgramUniform3dv_ARG_NAMES program, location, count, value
#define glProgramUniform3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform3dv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform3dv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3dv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3dv(packed, ret_v) do { \
    glProgramUniform3dv_PACKED *unpacked = (glProgramUniform3dv_PACKED *)packed; \
    glProgramUniform3dv_ARGS *args = (glProgramUniform3dv_ARGS *)&unpacked->args; \
    glProgramUniform3dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3dv(glProgramUniform3dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3dv(glProgramUniform3dv_PACKED *_dst glProgramUniform3dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3dv_PTR)(glProgramUniform3dv_ARG_EXPAND);
#endif
#ifndef glProgramUniform3dvEXT_RETURN
#define glProgramUniform3dvEXT_RETURN void
#define glProgramUniform3dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform3dvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform3dvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3dvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3dvEXT(packed, ret_v) do { \
    glProgramUniform3dvEXT_PACKED *unpacked = (glProgramUniform3dvEXT_PACKED *)packed; \
    glProgramUniform3dvEXT_ARGS *args = (glProgramUniform3dvEXT_ARGS *)&unpacked->args; \
    glProgramUniform3dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3dvEXT(glProgramUniform3dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3dvEXT(glProgramUniform3dvEXT_PACKED *_dst glProgramUniform3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3dvEXT_PTR)(glProgramUniform3dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3f_RETURN
#define glProgramUniform3f_RETURN void
#define glProgramUniform3f_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3f_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glProgramUniform3f_ARG_NAMES_TAIL , program, location, v0, v1, v2
#define glProgramUniform3f_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define forward_glProgramUniform3f(_program, _location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3f(dst, _program, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glProgramUniform3f(packed, ret_v) do { \
    glProgramUniform3f_PACKED *unpacked = (glProgramUniform3f_PACKED *)packed; \
    glProgramUniform3f_ARGS *args = (glProgramUniform3f_ARGS *)&unpacked->args; \
    glProgramUniform3f(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3f(glProgramUniform3f_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3f(glProgramUniform3f_PACKED *_dst glProgramUniform3f_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3f_PTR)(glProgramUniform3f_ARG_EXPAND);
#endif
#ifndef glProgramUniform3fEXT_RETURN
#define glProgramUniform3fEXT_RETURN void
#define glProgramUniform3fEXT_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glProgramUniform3fEXT_ARG_NAMES_TAIL , program, location, v0, v1, v2
#define glProgramUniform3fEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define forward_glProgramUniform3fEXT(_program, _location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3fEXT(dst, _program, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glProgramUniform3fEXT(packed, ret_v) do { \
    glProgramUniform3fEXT_PACKED *unpacked = (glProgramUniform3fEXT_PACKED *)packed; \
    glProgramUniform3fEXT_ARGS *args = (glProgramUniform3fEXT_ARGS *)&unpacked->args; \
    glProgramUniform3fEXT(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3fEXT(glProgramUniform3fEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3fEXT(glProgramUniform3fEXT_PACKED *_dst glProgramUniform3fEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3fEXT_PTR)(glProgramUniform3fEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3fv_RETURN
#define glProgramUniform3fv_RETURN void
#define glProgramUniform3fv_ARG_NAMES program, location, count, value
#define glProgramUniform3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform3fv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform3fv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3fv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3fv(packed, ret_v) do { \
    glProgramUniform3fv_PACKED *unpacked = (glProgramUniform3fv_PACKED *)packed; \
    glProgramUniform3fv_ARGS *args = (glProgramUniform3fv_ARGS *)&unpacked->args; \
    glProgramUniform3fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3fv(glProgramUniform3fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3fv(glProgramUniform3fv_PACKED *_dst glProgramUniform3fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3fv_PTR)(glProgramUniform3fv_ARG_EXPAND);
#endif
#ifndef glProgramUniform3fvEXT_RETURN
#define glProgramUniform3fvEXT_RETURN void
#define glProgramUniform3fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform3fvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform3fvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3fvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3fvEXT(packed, ret_v) do { \
    glProgramUniform3fvEXT_PACKED *unpacked = (glProgramUniform3fvEXT_PACKED *)packed; \
    glProgramUniform3fvEXT_ARGS *args = (glProgramUniform3fvEXT_ARGS *)&unpacked->args; \
    glProgramUniform3fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3fvEXT(glProgramUniform3fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3fvEXT(glProgramUniform3fvEXT_PACKED *_dst glProgramUniform3fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3fvEXT_PTR)(glProgramUniform3fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3i_RETURN
#define glProgramUniform3i_RETURN void
#define glProgramUniform3i_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3i_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2
#define glProgramUniform3i_ARG_NAMES_TAIL , program, location, v0, v1, v2
#define glProgramUniform3i_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0, GLint v1, GLint v2
#define forward_glProgramUniform3i(_program, _location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3i(dst, _program, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glProgramUniform3i(packed, ret_v) do { \
    glProgramUniform3i_PACKED *unpacked = (glProgramUniform3i_PACKED *)packed; \
    glProgramUniform3i_ARGS *args = (glProgramUniform3i_ARGS *)&unpacked->args; \
    glProgramUniform3i(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3i(glProgramUniform3i_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3i(glProgramUniform3i_PACKED *_dst glProgramUniform3i_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3i_PTR)(glProgramUniform3i_ARG_EXPAND);
#endif
#ifndef glProgramUniform3i64NV_RETURN
#define glProgramUniform3i64NV_RETURN void
#define glProgramUniform3i64NV_ARG_NAMES program, location, x, y, z
#define glProgramUniform3i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define glProgramUniform3i64NV_ARG_NAMES_TAIL , program, location, x, y, z
#define glProgramUniform3i64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define forward_glProgramUniform3i64NV(_program, _location, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3i64NV(dst, _program, _location, _x, _y, _z), NULL); \
    });
#define call_glProgramUniform3i64NV(packed, ret_v) do { \
    glProgramUniform3i64NV_PACKED *unpacked = (glProgramUniform3i64NV_PACKED *)packed; \
    glProgramUniform3i64NV_ARGS *args = (glProgramUniform3i64NV_ARGS *)&unpacked->args; \
    glProgramUniform3i64NV(args->program, args->location, args->x, args->y, args->z);; \
} while(0)
void glProgramUniform3i64NV(glProgramUniform3i64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3i64NV(glProgramUniform3i64NV_PACKED *_dst glProgramUniform3i64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3i64NV_PTR)(glProgramUniform3i64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform3i64vNV_RETURN
#define glProgramUniform3i64vNV_RETURN void
#define glProgramUniform3i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform3i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform3i64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3i64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define forward_glProgramUniform3i64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3i64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3i64vNV(packed, ret_v) do { \
    glProgramUniform3i64vNV_PACKED *unpacked = (glProgramUniform3i64vNV_PACKED *)packed; \
    glProgramUniform3i64vNV_ARGS *args = (glProgramUniform3i64vNV_ARGS *)&unpacked->args; \
    glProgramUniform3i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3i64vNV(glProgramUniform3i64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3i64vNV(glProgramUniform3i64vNV_PACKED *_dst glProgramUniform3i64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3i64vNV_PTR)(glProgramUniform3i64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform3iEXT_RETURN
#define glProgramUniform3iEXT_RETURN void
#define glProgramUniform3iEXT_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2
#define glProgramUniform3iEXT_ARG_NAMES_TAIL , program, location, v0, v1, v2
#define glProgramUniform3iEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0, GLint v1, GLint v2
#define forward_glProgramUniform3iEXT(_program, _location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3iEXT(dst, _program, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glProgramUniform3iEXT(packed, ret_v) do { \
    glProgramUniform3iEXT_PACKED *unpacked = (glProgramUniform3iEXT_PACKED *)packed; \
    glProgramUniform3iEXT_ARGS *args = (glProgramUniform3iEXT_ARGS *)&unpacked->args; \
    glProgramUniform3iEXT(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3iEXT(glProgramUniform3iEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3iEXT(glProgramUniform3iEXT_PACKED *_dst glProgramUniform3iEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3iEXT_PTR)(glProgramUniform3iEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3iv_RETURN
#define glProgramUniform3iv_RETURN void
#define glProgramUniform3iv_ARG_NAMES program, location, count, value
#define glProgramUniform3iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform3iv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3iv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform3iv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3iv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3iv(packed, ret_v) do { \
    glProgramUniform3iv_PACKED *unpacked = (glProgramUniform3iv_PACKED *)packed; \
    glProgramUniform3iv_ARGS *args = (glProgramUniform3iv_ARGS *)&unpacked->args; \
    glProgramUniform3iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3iv(glProgramUniform3iv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3iv(glProgramUniform3iv_PACKED *_dst glProgramUniform3iv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3iv_PTR)(glProgramUniform3iv_ARG_EXPAND);
#endif
#ifndef glProgramUniform3ivEXT_RETURN
#define glProgramUniform3ivEXT_RETURN void
#define glProgramUniform3ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform3ivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3ivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform3ivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3ivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3ivEXT(packed, ret_v) do { \
    glProgramUniform3ivEXT_PACKED *unpacked = (glProgramUniform3ivEXT_PACKED *)packed; \
    glProgramUniform3ivEXT_ARGS *args = (glProgramUniform3ivEXT_ARGS *)&unpacked->args; \
    glProgramUniform3ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3ivEXT(glProgramUniform3ivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3ivEXT(glProgramUniform3ivEXT_PACKED *_dst glProgramUniform3ivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3ivEXT_PTR)(glProgramUniform3ivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3ui_RETURN
#define glProgramUniform3ui_RETURN void
#define glProgramUniform3ui_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3ui_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2
#define glProgramUniform3ui_ARG_NAMES_TAIL , program, location, v0, v1, v2
#define glProgramUniform3ui_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2
#define forward_glProgramUniform3ui(_program, _location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3ui(dst, _program, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glProgramUniform3ui(packed, ret_v) do { \
    glProgramUniform3ui_PACKED *unpacked = (glProgramUniform3ui_PACKED *)packed; \
    glProgramUniform3ui_ARGS *args = (glProgramUniform3ui_ARGS *)&unpacked->args; \
    glProgramUniform3ui(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3ui(glProgramUniform3ui_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3ui(glProgramUniform3ui_PACKED *_dst glProgramUniform3ui_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3ui_PTR)(glProgramUniform3ui_ARG_EXPAND);
#endif
#ifndef glProgramUniform3ui64NV_RETURN
#define glProgramUniform3ui64NV_RETURN void
#define glProgramUniform3ui64NV_ARG_NAMES program, location, x, y, z
#define glProgramUniform3ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define glProgramUniform3ui64NV_ARG_NAMES_TAIL , program, location, x, y, z
#define glProgramUniform3ui64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define forward_glProgramUniform3ui64NV(_program, _location, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3ui64NV(dst, _program, _location, _x, _y, _z), NULL); \
    });
#define call_glProgramUniform3ui64NV(packed, ret_v) do { \
    glProgramUniform3ui64NV_PACKED *unpacked = (glProgramUniform3ui64NV_PACKED *)packed; \
    glProgramUniform3ui64NV_ARGS *args = (glProgramUniform3ui64NV_ARGS *)&unpacked->args; \
    glProgramUniform3ui64NV(args->program, args->location, args->x, args->y, args->z);; \
} while(0)
void glProgramUniform3ui64NV(glProgramUniform3ui64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3ui64NV(glProgramUniform3ui64NV_PACKED *_dst glProgramUniform3ui64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3ui64NV_PTR)(glProgramUniform3ui64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform3ui64vNV_RETURN
#define glProgramUniform3ui64vNV_RETURN void
#define glProgramUniform3ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform3ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform3ui64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3ui64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glProgramUniform3ui64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3ui64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3ui64vNV(packed, ret_v) do { \
    glProgramUniform3ui64vNV_PACKED *unpacked = (glProgramUniform3ui64vNV_PACKED *)packed; \
    glProgramUniform3ui64vNV_ARGS *args = (glProgramUniform3ui64vNV_ARGS *)&unpacked->args; \
    glProgramUniform3ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3ui64vNV(glProgramUniform3ui64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3ui64vNV(glProgramUniform3ui64vNV_PACKED *_dst glProgramUniform3ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3ui64vNV_PTR)(glProgramUniform3ui64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform3uiEXT_RETURN
#define glProgramUniform3uiEXT_RETURN void
#define glProgramUniform3uiEXT_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2
#define glProgramUniform3uiEXT_ARG_NAMES_TAIL , program, location, v0, v1, v2
#define glProgramUniform3uiEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2
#define forward_glProgramUniform3uiEXT(_program, _location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3uiEXT(dst, _program, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glProgramUniform3uiEXT(packed, ret_v) do { \
    glProgramUniform3uiEXT_PACKED *unpacked = (glProgramUniform3uiEXT_PACKED *)packed; \
    glProgramUniform3uiEXT_ARGS *args = (glProgramUniform3uiEXT_ARGS *)&unpacked->args; \
    glProgramUniform3uiEXT(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3uiEXT(glProgramUniform3uiEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3uiEXT(glProgramUniform3uiEXT_PACKED *_dst glProgramUniform3uiEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3uiEXT_PTR)(glProgramUniform3uiEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform3uiv_RETURN
#define glProgramUniform3uiv_RETURN void
#define glProgramUniform3uiv_ARG_NAMES program, location, count, value
#define glProgramUniform3uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform3uiv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3uiv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform3uiv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3uiv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3uiv(packed, ret_v) do { \
    glProgramUniform3uiv_PACKED *unpacked = (glProgramUniform3uiv_PACKED *)packed; \
    glProgramUniform3uiv_ARGS *args = (glProgramUniform3uiv_ARGS *)&unpacked->args; \
    glProgramUniform3uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3uiv(glProgramUniform3uiv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3uiv(glProgramUniform3uiv_PACKED *_dst glProgramUniform3uiv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3uiv_PTR)(glProgramUniform3uiv_ARG_EXPAND);
#endif
#ifndef glProgramUniform3uivEXT_RETURN
#define glProgramUniform3uivEXT_RETURN void
#define glProgramUniform3uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform3uivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform3uivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform3uivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform3uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform3uivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform3uivEXT(packed, ret_v) do { \
    glProgramUniform3uivEXT_PACKED *unpacked = (glProgramUniform3uivEXT_PACKED *)packed; \
    glProgramUniform3uivEXT_ARGS *args = (glProgramUniform3uivEXT_ARGS *)&unpacked->args; \
    glProgramUniform3uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3uivEXT(glProgramUniform3uivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform3uivEXT(glProgramUniform3uivEXT_PACKED *_dst glProgramUniform3uivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform3uivEXT_PTR)(glProgramUniform3uivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4d_RETURN
#define glProgramUniform4d_RETURN void
#define glProgramUniform4d_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4d_ARG_EXPAND GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3
#define glProgramUniform4d_ARG_NAMES_TAIL , program, location, v0, v1, v2, v3
#define glProgramUniform4d_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3
#define forward_glProgramUniform4d(_program, _location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4d(dst, _program, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glProgramUniform4d(packed, ret_v) do { \
    glProgramUniform4d_PACKED *unpacked = (glProgramUniform4d_PACKED *)packed; \
    glProgramUniform4d_ARGS *args = (glProgramUniform4d_ARGS *)&unpacked->args; \
    glProgramUniform4d(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4d(glProgramUniform4d_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4d(glProgramUniform4d_PACKED *_dst glProgramUniform4d_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4d_PTR)(glProgramUniform4d_ARG_EXPAND);
#endif
#ifndef glProgramUniform4dEXT_RETURN
#define glProgramUniform4dEXT_RETURN void
#define glProgramUniform4dEXT_ARG_NAMES program, location, x, y, z, w
#define glProgramUniform4dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramUniform4dEXT_ARG_NAMES_TAIL , program, location, x, y, z, w
#define glProgramUniform4dEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glProgramUniform4dEXT(_program, _location, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4dEXT(dst, _program, _location, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramUniform4dEXT(packed, ret_v) do { \
    glProgramUniform4dEXT_PACKED *unpacked = (glProgramUniform4dEXT_PACKED *)packed; \
    glProgramUniform4dEXT_ARGS *args = (glProgramUniform4dEXT_ARGS *)&unpacked->args; \
    glProgramUniform4dEXT(args->program, args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramUniform4dEXT(glProgramUniform4dEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4dEXT(glProgramUniform4dEXT_PACKED *_dst glProgramUniform4dEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4dEXT_PTR)(glProgramUniform4dEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4dv_RETURN
#define glProgramUniform4dv_RETURN void
#define glProgramUniform4dv_ARG_NAMES program, location, count, value
#define glProgramUniform4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform4dv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform4dv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4dv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4dv(packed, ret_v) do { \
    glProgramUniform4dv_PACKED *unpacked = (glProgramUniform4dv_PACKED *)packed; \
    glProgramUniform4dv_ARGS *args = (glProgramUniform4dv_ARGS *)&unpacked->args; \
    glProgramUniform4dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4dv(glProgramUniform4dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4dv(glProgramUniform4dv_PACKED *_dst glProgramUniform4dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4dv_PTR)(glProgramUniform4dv_ARG_EXPAND);
#endif
#ifndef glProgramUniform4dvEXT_RETURN
#define glProgramUniform4dvEXT_RETURN void
#define glProgramUniform4dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform4dvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLdouble * value
#define forward_glProgramUniform4dvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4dvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4dvEXT(packed, ret_v) do { \
    glProgramUniform4dvEXT_PACKED *unpacked = (glProgramUniform4dvEXT_PACKED *)packed; \
    glProgramUniform4dvEXT_ARGS *args = (glProgramUniform4dvEXT_ARGS *)&unpacked->args; \
    glProgramUniform4dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4dvEXT(glProgramUniform4dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4dvEXT(glProgramUniform4dvEXT_PACKED *_dst glProgramUniform4dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4dvEXT_PTR)(glProgramUniform4dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4f_RETURN
#define glProgramUniform4f_RETURN void
#define glProgramUniform4f_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4f_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glProgramUniform4f_ARG_NAMES_TAIL , program, location, v0, v1, v2, v3
#define glProgramUniform4f_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define forward_glProgramUniform4f(_program, _location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4f(dst, _program, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glProgramUniform4f(packed, ret_v) do { \
    glProgramUniform4f_PACKED *unpacked = (glProgramUniform4f_PACKED *)packed; \
    glProgramUniform4f_ARGS *args = (glProgramUniform4f_ARGS *)&unpacked->args; \
    glProgramUniform4f(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4f(glProgramUniform4f_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4f(glProgramUniform4f_PACKED *_dst glProgramUniform4f_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4f_PTR)(glProgramUniform4f_ARG_EXPAND);
#endif
#ifndef glProgramUniform4fEXT_RETURN
#define glProgramUniform4fEXT_RETURN void
#define glProgramUniform4fEXT_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glProgramUniform4fEXT_ARG_NAMES_TAIL , program, location, v0, v1, v2, v3
#define glProgramUniform4fEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define forward_glProgramUniform4fEXT(_program, _location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4fEXT(dst, _program, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glProgramUniform4fEXT(packed, ret_v) do { \
    glProgramUniform4fEXT_PACKED *unpacked = (glProgramUniform4fEXT_PACKED *)packed; \
    glProgramUniform4fEXT_ARGS *args = (glProgramUniform4fEXT_ARGS *)&unpacked->args; \
    glProgramUniform4fEXT(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4fEXT(glProgramUniform4fEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4fEXT(glProgramUniform4fEXT_PACKED *_dst glProgramUniform4fEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4fEXT_PTR)(glProgramUniform4fEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4fv_RETURN
#define glProgramUniform4fv_RETURN void
#define glProgramUniform4fv_ARG_NAMES program, location, count, value
#define glProgramUniform4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform4fv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform4fv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4fv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4fv(packed, ret_v) do { \
    glProgramUniform4fv_PACKED *unpacked = (glProgramUniform4fv_PACKED *)packed; \
    glProgramUniform4fv_ARGS *args = (glProgramUniform4fv_ARGS *)&unpacked->args; \
    glProgramUniform4fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4fv(glProgramUniform4fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4fv(glProgramUniform4fv_PACKED *_dst glProgramUniform4fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4fv_PTR)(glProgramUniform4fv_ARG_EXPAND);
#endif
#ifndef glProgramUniform4fvEXT_RETURN
#define glProgramUniform4fvEXT_RETURN void
#define glProgramUniform4fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform4fvEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLfloat * value
#define forward_glProgramUniform4fvEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4fvEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4fvEXT(packed, ret_v) do { \
    glProgramUniform4fvEXT_PACKED *unpacked = (glProgramUniform4fvEXT_PACKED *)packed; \
    glProgramUniform4fvEXT_ARGS *args = (glProgramUniform4fvEXT_ARGS *)&unpacked->args; \
    glProgramUniform4fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4fvEXT(glProgramUniform4fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4fvEXT(glProgramUniform4fvEXT_PACKED *_dst glProgramUniform4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4fvEXT_PTR)(glProgramUniform4fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4i_RETURN
#define glProgramUniform4i_RETURN void
#define glProgramUniform4i_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4i_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glProgramUniform4i_ARG_NAMES_TAIL , program, location, v0, v1, v2, v3
#define glProgramUniform4i_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define forward_glProgramUniform4i(_program, _location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4i(dst, _program, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glProgramUniform4i(packed, ret_v) do { \
    glProgramUniform4i_PACKED *unpacked = (glProgramUniform4i_PACKED *)packed; \
    glProgramUniform4i_ARGS *args = (glProgramUniform4i_ARGS *)&unpacked->args; \
    glProgramUniform4i(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4i(glProgramUniform4i_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4i(glProgramUniform4i_PACKED *_dst glProgramUniform4i_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4i_PTR)(glProgramUniform4i_ARG_EXPAND);
#endif
#ifndef glProgramUniform4i64NV_RETURN
#define glProgramUniform4i64NV_RETURN void
#define glProgramUniform4i64NV_ARG_NAMES program, location, x, y, z, w
#define glProgramUniform4i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define glProgramUniform4i64NV_ARG_NAMES_TAIL , program, location, x, y, z, w
#define glProgramUniform4i64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define forward_glProgramUniform4i64NV(_program, _location, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4i64NV(dst, _program, _location, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramUniform4i64NV(packed, ret_v) do { \
    glProgramUniform4i64NV_PACKED *unpacked = (glProgramUniform4i64NV_PACKED *)packed; \
    glProgramUniform4i64NV_ARGS *args = (glProgramUniform4i64NV_ARGS *)&unpacked->args; \
    glProgramUniform4i64NV(args->program, args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramUniform4i64NV(glProgramUniform4i64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4i64NV(glProgramUniform4i64NV_PACKED *_dst glProgramUniform4i64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4i64NV_PTR)(glProgramUniform4i64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform4i64vNV_RETURN
#define glProgramUniform4i64vNV_RETURN void
#define glProgramUniform4i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform4i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform4i64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4i64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define forward_glProgramUniform4i64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4i64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4i64vNV(packed, ret_v) do { \
    glProgramUniform4i64vNV_PACKED *unpacked = (glProgramUniform4i64vNV_PACKED *)packed; \
    glProgramUniform4i64vNV_ARGS *args = (glProgramUniform4i64vNV_ARGS *)&unpacked->args; \
    glProgramUniform4i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4i64vNV(glProgramUniform4i64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4i64vNV(glProgramUniform4i64vNV_PACKED *_dst glProgramUniform4i64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4i64vNV_PTR)(glProgramUniform4i64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform4iEXT_RETURN
#define glProgramUniform4iEXT_RETURN void
#define glProgramUniform4iEXT_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glProgramUniform4iEXT_ARG_NAMES_TAIL , program, location, v0, v1, v2, v3
#define glProgramUniform4iEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define forward_glProgramUniform4iEXT(_program, _location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4iEXT(dst, _program, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glProgramUniform4iEXT(packed, ret_v) do { \
    glProgramUniform4iEXT_PACKED *unpacked = (glProgramUniform4iEXT_PACKED *)packed; \
    glProgramUniform4iEXT_ARGS *args = (glProgramUniform4iEXT_ARGS *)&unpacked->args; \
    glProgramUniform4iEXT(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4iEXT(glProgramUniform4iEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4iEXT(glProgramUniform4iEXT_PACKED *_dst glProgramUniform4iEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4iEXT_PTR)(glProgramUniform4iEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4iv_RETURN
#define glProgramUniform4iv_RETURN void
#define glProgramUniform4iv_ARG_NAMES program, location, count, value
#define glProgramUniform4iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform4iv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4iv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform4iv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4iv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4iv(packed, ret_v) do { \
    glProgramUniform4iv_PACKED *unpacked = (glProgramUniform4iv_PACKED *)packed; \
    glProgramUniform4iv_ARGS *args = (glProgramUniform4iv_ARGS *)&unpacked->args; \
    glProgramUniform4iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4iv(glProgramUniform4iv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4iv(glProgramUniform4iv_PACKED *_dst glProgramUniform4iv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4iv_PTR)(glProgramUniform4iv_ARG_EXPAND);
#endif
#ifndef glProgramUniform4ivEXT_RETURN
#define glProgramUniform4ivEXT_RETURN void
#define glProgramUniform4ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform4ivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4ivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLint * value
#define forward_glProgramUniform4ivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4ivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4ivEXT(packed, ret_v) do { \
    glProgramUniform4ivEXT_PACKED *unpacked = (glProgramUniform4ivEXT_PACKED *)packed; \
    glProgramUniform4ivEXT_ARGS *args = (glProgramUniform4ivEXT_ARGS *)&unpacked->args; \
    glProgramUniform4ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4ivEXT(glProgramUniform4ivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4ivEXT(glProgramUniform4ivEXT_PACKED *_dst glProgramUniform4ivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4ivEXT_PTR)(glProgramUniform4ivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4ui_RETURN
#define glProgramUniform4ui_RETURN void
#define glProgramUniform4ui_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4ui_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glProgramUniform4ui_ARG_NAMES_TAIL , program, location, v0, v1, v2, v3
#define glProgramUniform4ui_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define forward_glProgramUniform4ui(_program, _location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4ui(dst, _program, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glProgramUniform4ui(packed, ret_v) do { \
    glProgramUniform4ui_PACKED *unpacked = (glProgramUniform4ui_PACKED *)packed; \
    glProgramUniform4ui_ARGS *args = (glProgramUniform4ui_ARGS *)&unpacked->args; \
    glProgramUniform4ui(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4ui(glProgramUniform4ui_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4ui(glProgramUniform4ui_PACKED *_dst glProgramUniform4ui_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4ui_PTR)(glProgramUniform4ui_ARG_EXPAND);
#endif
#ifndef glProgramUniform4ui64NV_RETURN
#define glProgramUniform4ui64NV_RETURN void
#define glProgramUniform4ui64NV_ARG_NAMES program, location, x, y, z, w
#define glProgramUniform4ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define glProgramUniform4ui64NV_ARG_NAMES_TAIL , program, location, x, y, z, w
#define glProgramUniform4ui64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define forward_glProgramUniform4ui64NV(_program, _location, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4ui64NV(dst, _program, _location, _x, _y, _z, _w), NULL); \
    });
#define call_glProgramUniform4ui64NV(packed, ret_v) do { \
    glProgramUniform4ui64NV_PACKED *unpacked = (glProgramUniform4ui64NV_PACKED *)packed; \
    glProgramUniform4ui64NV_ARGS *args = (glProgramUniform4ui64NV_ARGS *)&unpacked->args; \
    glProgramUniform4ui64NV(args->program, args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramUniform4ui64NV(glProgramUniform4ui64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4ui64NV(glProgramUniform4ui64NV_PACKED *_dst glProgramUniform4ui64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4ui64NV_PTR)(glProgramUniform4ui64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniform4ui64vNV_RETURN
#define glProgramUniform4ui64vNV_RETURN void
#define glProgramUniform4ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform4ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform4ui64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4ui64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glProgramUniform4ui64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4ui64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4ui64vNV(packed, ret_v) do { \
    glProgramUniform4ui64vNV_PACKED *unpacked = (glProgramUniform4ui64vNV_PACKED *)packed; \
    glProgramUniform4ui64vNV_ARGS *args = (glProgramUniform4ui64vNV_ARGS *)&unpacked->args; \
    glProgramUniform4ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4ui64vNV(glProgramUniform4ui64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4ui64vNV(glProgramUniform4ui64vNV_PACKED *_dst glProgramUniform4ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4ui64vNV_PTR)(glProgramUniform4ui64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniform4uiEXT_RETURN
#define glProgramUniform4uiEXT_RETURN void
#define glProgramUniform4uiEXT_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glProgramUniform4uiEXT_ARG_NAMES_TAIL , program, location, v0, v1, v2, v3
#define glProgramUniform4uiEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define forward_glProgramUniform4uiEXT(_program, _location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4uiEXT(dst, _program, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glProgramUniform4uiEXT(packed, ret_v) do { \
    glProgramUniform4uiEXT_PACKED *unpacked = (glProgramUniform4uiEXT_PACKED *)packed; \
    glProgramUniform4uiEXT_ARGS *args = (glProgramUniform4uiEXT_ARGS *)&unpacked->args; \
    glProgramUniform4uiEXT(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4uiEXT(glProgramUniform4uiEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4uiEXT(glProgramUniform4uiEXT_PACKED *_dst glProgramUniform4uiEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4uiEXT_PTR)(glProgramUniform4uiEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniform4uiv_RETURN
#define glProgramUniform4uiv_RETURN void
#define glProgramUniform4uiv_ARG_NAMES program, location, count, value
#define glProgramUniform4uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform4uiv_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4uiv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform4uiv(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4uiv(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4uiv(packed, ret_v) do { \
    glProgramUniform4uiv_PACKED *unpacked = (glProgramUniform4uiv_PACKED *)packed; \
    glProgramUniform4uiv_ARGS *args = (glProgramUniform4uiv_ARGS *)&unpacked->args; \
    glProgramUniform4uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4uiv(glProgramUniform4uiv_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4uiv(glProgramUniform4uiv_PACKED *_dst glProgramUniform4uiv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4uiv_PTR)(glProgramUniform4uiv_ARG_EXPAND);
#endif
#ifndef glProgramUniform4uivEXT_RETURN
#define glProgramUniform4uivEXT_RETURN void
#define glProgramUniform4uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform4uivEXT_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniform4uivEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint * value
#define forward_glProgramUniform4uivEXT(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniform4uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniform4uivEXT(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniform4uivEXT(packed, ret_v) do { \
    glProgramUniform4uivEXT_PACKED *unpacked = (glProgramUniform4uivEXT_PACKED *)packed; \
    glProgramUniform4uivEXT_ARGS *args = (glProgramUniform4uivEXT_ARGS *)&unpacked->args; \
    glProgramUniform4uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4uivEXT(glProgramUniform4uivEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniform4uivEXT(glProgramUniform4uivEXT_PACKED *_dst glProgramUniform4uivEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniform4uivEXT_PTR)(glProgramUniform4uivEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformHandleui64NV_RETURN
#define glProgramUniformHandleui64NV_RETURN void
#define glProgramUniformHandleui64NV_ARG_NAMES program, location, value
#define glProgramUniformHandleui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64 value
#define glProgramUniformHandleui64NV_ARG_NAMES_TAIL , program, location, value
#define glProgramUniformHandleui64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint64 value
#define forward_glProgramUniformHandleui64NV(_program, _location, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformHandleui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformHandleui64NV(dst, _program, _location, _value), NULL); \
    });
#define call_glProgramUniformHandleui64NV(packed, ret_v) do { \
    glProgramUniformHandleui64NV_PACKED *unpacked = (glProgramUniformHandleui64NV_PACKED *)packed; \
    glProgramUniformHandleui64NV_ARGS *args = (glProgramUniformHandleui64NV_ARGS *)&unpacked->args; \
    glProgramUniformHandleui64NV(args->program, args->location, args->value);; \
} while(0)
void glProgramUniformHandleui64NV(glProgramUniformHandleui64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniformHandleui64NV(glProgramUniformHandleui64NV_PACKED *_dst glProgramUniformHandleui64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformHandleui64NV_PTR)(glProgramUniformHandleui64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniformHandleui64vNV_RETURN
#define glProgramUniformHandleui64vNV_RETURN void
#define glProgramUniformHandleui64vNV_ARG_NAMES program, location, count, values
#define glProgramUniformHandleui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64 * values
#define glProgramUniformHandleui64vNV_ARG_NAMES_TAIL , program, location, count, values
#define glProgramUniformHandleui64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint64 * values
#define forward_glProgramUniformHandleui64vNV(_program, _location, _count, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformHandleui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformHandleui64vNV(dst, _program, _location, _count, _values), NULL); \
    });
#define call_glProgramUniformHandleui64vNV(packed, ret_v) do { \
    glProgramUniformHandleui64vNV_PACKED *unpacked = (glProgramUniformHandleui64vNV_PACKED *)packed; \
    glProgramUniformHandleui64vNV_ARGS *args = (glProgramUniformHandleui64vNV_ARGS *)&unpacked->args; \
    glProgramUniformHandleui64vNV(args->program, args->location, args->count, args->values);; \
} while(0)
void glProgramUniformHandleui64vNV(glProgramUniformHandleui64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniformHandleui64vNV(glProgramUniformHandleui64vNV_PACKED *_dst glProgramUniformHandleui64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformHandleui64vNV_PTR)(glProgramUniformHandleui64vNV_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2dv_RETURN
#define glProgramUniformMatrix2dv_RETURN void
#define glProgramUniformMatrix2dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix2dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2dv(packed, ret_v) do { \
    glProgramUniformMatrix2dv_PACKED *unpacked = (glProgramUniformMatrix2dv_PACKED *)packed; \
    glProgramUniformMatrix2dv_ARGS *args = (glProgramUniformMatrix2dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2dv(glProgramUniformMatrix2dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2dv(glProgramUniformMatrix2dv_PACKED *_dst glProgramUniformMatrix2dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2dv_PTR)(glProgramUniformMatrix2dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2dvEXT_RETURN
#define glProgramUniformMatrix2dvEXT_RETURN void
#define glProgramUniformMatrix2dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix2dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix2dvEXT_PACKED *unpacked = (glProgramUniformMatrix2dvEXT_PACKED *)packed; \
    glProgramUniformMatrix2dvEXT_ARGS *args = (glProgramUniformMatrix2dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2dvEXT(glProgramUniformMatrix2dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2dvEXT(glProgramUniformMatrix2dvEXT_PACKED *_dst glProgramUniformMatrix2dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2dvEXT_PTR)(glProgramUniformMatrix2dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2fv_RETURN
#define glProgramUniformMatrix2fv_RETURN void
#define glProgramUniformMatrix2fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix2fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2fv(packed, ret_v) do { \
    glProgramUniformMatrix2fv_PACKED *unpacked = (glProgramUniformMatrix2fv_PACKED *)packed; \
    glProgramUniformMatrix2fv_ARGS *args = (glProgramUniformMatrix2fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2fv(glProgramUniformMatrix2fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2fv(glProgramUniformMatrix2fv_PACKED *_dst glProgramUniformMatrix2fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2fv_PTR)(glProgramUniformMatrix2fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2fvEXT_RETURN
#define glProgramUniformMatrix2fvEXT_RETURN void
#define glProgramUniformMatrix2fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix2fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix2fvEXT_PACKED *unpacked = (glProgramUniformMatrix2fvEXT_PACKED *)packed; \
    glProgramUniformMatrix2fvEXT_ARGS *args = (glProgramUniformMatrix2fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2fvEXT(glProgramUniformMatrix2fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2fvEXT(glProgramUniformMatrix2fvEXT_PACKED *_dst glProgramUniformMatrix2fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2fvEXT_PTR)(glProgramUniformMatrix2fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x3dv_RETURN
#define glProgramUniformMatrix2x3dv_RETURN void
#define glProgramUniformMatrix2x3dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x3dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x3dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix2x3dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x3dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x3dv(packed, ret_v) do { \
    glProgramUniformMatrix2x3dv_PACKED *unpacked = (glProgramUniformMatrix2x3dv_PACKED *)packed; \
    glProgramUniformMatrix2x3dv_ARGS *args = (glProgramUniformMatrix2x3dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x3dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3dv(glProgramUniformMatrix2x3dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x3dv(glProgramUniformMatrix2x3dv_PACKED *_dst glProgramUniformMatrix2x3dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x3dv_PTR)(glProgramUniformMatrix2x3dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x3dvEXT_RETURN
#define glProgramUniformMatrix2x3dvEXT_RETURN void
#define glProgramUniformMatrix2x3dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x3dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x3dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix2x3dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x3dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x3dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix2x3dvEXT_PACKED *unpacked = (glProgramUniformMatrix2x3dvEXT_PACKED *)packed; \
    glProgramUniformMatrix2x3dvEXT_ARGS *args = (glProgramUniformMatrix2x3dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x3dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3dvEXT(glProgramUniformMatrix2x3dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x3dvEXT(glProgramUniformMatrix2x3dvEXT_PACKED *_dst glProgramUniformMatrix2x3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x3dvEXT_PTR)(glProgramUniformMatrix2x3dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x3fv_RETURN
#define glProgramUniformMatrix2x3fv_RETURN void
#define glProgramUniformMatrix2x3fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x3fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x3fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix2x3fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x3fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x3fv(packed, ret_v) do { \
    glProgramUniformMatrix2x3fv_PACKED *unpacked = (glProgramUniformMatrix2x3fv_PACKED *)packed; \
    glProgramUniformMatrix2x3fv_ARGS *args = (glProgramUniformMatrix2x3fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x3fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3fv(glProgramUniformMatrix2x3fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x3fv(glProgramUniformMatrix2x3fv_PACKED *_dst glProgramUniformMatrix2x3fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x3fv_PTR)(glProgramUniformMatrix2x3fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x3fvEXT_RETURN
#define glProgramUniformMatrix2x3fvEXT_RETURN void
#define glProgramUniformMatrix2x3fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x3fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x3fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix2x3fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x3fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x3fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x3fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix2x3fvEXT_PACKED *unpacked = (glProgramUniformMatrix2x3fvEXT_PACKED *)packed; \
    glProgramUniformMatrix2x3fvEXT_ARGS *args = (glProgramUniformMatrix2x3fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x3fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3fvEXT(glProgramUniformMatrix2x3fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x3fvEXT(glProgramUniformMatrix2x3fvEXT_PACKED *_dst glProgramUniformMatrix2x3fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x3fvEXT_PTR)(glProgramUniformMatrix2x3fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x4dv_RETURN
#define glProgramUniformMatrix2x4dv_RETURN void
#define glProgramUniformMatrix2x4dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x4dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x4dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix2x4dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x4dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x4dv(packed, ret_v) do { \
    glProgramUniformMatrix2x4dv_PACKED *unpacked = (glProgramUniformMatrix2x4dv_PACKED *)packed; \
    glProgramUniformMatrix2x4dv_ARGS *args = (glProgramUniformMatrix2x4dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x4dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4dv(glProgramUniformMatrix2x4dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x4dv(glProgramUniformMatrix2x4dv_PACKED *_dst glProgramUniformMatrix2x4dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x4dv_PTR)(glProgramUniformMatrix2x4dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x4dvEXT_RETURN
#define glProgramUniformMatrix2x4dvEXT_RETURN void
#define glProgramUniformMatrix2x4dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x4dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x4dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix2x4dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x4dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x4dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x4dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix2x4dvEXT_PACKED *unpacked = (glProgramUniformMatrix2x4dvEXT_PACKED *)packed; \
    glProgramUniformMatrix2x4dvEXT_ARGS *args = (glProgramUniformMatrix2x4dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x4dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4dvEXT(glProgramUniformMatrix2x4dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x4dvEXT(glProgramUniformMatrix2x4dvEXT_PACKED *_dst glProgramUniformMatrix2x4dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x4dvEXT_PTR)(glProgramUniformMatrix2x4dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x4fv_RETURN
#define glProgramUniformMatrix2x4fv_RETURN void
#define glProgramUniformMatrix2x4fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x4fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x4fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix2x4fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x4fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x4fv(packed, ret_v) do { \
    glProgramUniformMatrix2x4fv_PACKED *unpacked = (glProgramUniformMatrix2x4fv_PACKED *)packed; \
    glProgramUniformMatrix2x4fv_ARGS *args = (glProgramUniformMatrix2x4fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x4fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4fv(glProgramUniformMatrix2x4fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x4fv(glProgramUniformMatrix2x4fv_PACKED *_dst glProgramUniformMatrix2x4fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x4fv_PTR)(glProgramUniformMatrix2x4fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix2x4fvEXT_RETURN
#define glProgramUniformMatrix2x4fvEXT_RETURN void
#define glProgramUniformMatrix2x4fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x4fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix2x4fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix2x4fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix2x4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix2x4fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix2x4fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix2x4fvEXT_PACKED *unpacked = (glProgramUniformMatrix2x4fvEXT_PACKED *)packed; \
    glProgramUniformMatrix2x4fvEXT_ARGS *args = (glProgramUniformMatrix2x4fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix2x4fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4fvEXT(glProgramUniformMatrix2x4fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix2x4fvEXT(glProgramUniformMatrix2x4fvEXT_PACKED *_dst glProgramUniformMatrix2x4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix2x4fvEXT_PTR)(glProgramUniformMatrix2x4fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3dv_RETURN
#define glProgramUniformMatrix3dv_RETURN void
#define glProgramUniformMatrix3dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix3dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3dv(packed, ret_v) do { \
    glProgramUniformMatrix3dv_PACKED *unpacked = (glProgramUniformMatrix3dv_PACKED *)packed; \
    glProgramUniformMatrix3dv_ARGS *args = (glProgramUniformMatrix3dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3dv(glProgramUniformMatrix3dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3dv(glProgramUniformMatrix3dv_PACKED *_dst glProgramUniformMatrix3dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3dv_PTR)(glProgramUniformMatrix3dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3dvEXT_RETURN
#define glProgramUniformMatrix3dvEXT_RETURN void
#define glProgramUniformMatrix3dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix3dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix3dvEXT_PACKED *unpacked = (glProgramUniformMatrix3dvEXT_PACKED *)packed; \
    glProgramUniformMatrix3dvEXT_ARGS *args = (glProgramUniformMatrix3dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3dvEXT(glProgramUniformMatrix3dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3dvEXT(glProgramUniformMatrix3dvEXT_PACKED *_dst glProgramUniformMatrix3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3dvEXT_PTR)(glProgramUniformMatrix3dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3fv_RETURN
#define glProgramUniformMatrix3fv_RETURN void
#define glProgramUniformMatrix3fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix3fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3fv(packed, ret_v) do { \
    glProgramUniformMatrix3fv_PACKED *unpacked = (glProgramUniformMatrix3fv_PACKED *)packed; \
    glProgramUniformMatrix3fv_ARGS *args = (glProgramUniformMatrix3fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3fv(glProgramUniformMatrix3fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3fv(glProgramUniformMatrix3fv_PACKED *_dst glProgramUniformMatrix3fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3fv_PTR)(glProgramUniformMatrix3fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3fvEXT_RETURN
#define glProgramUniformMatrix3fvEXT_RETURN void
#define glProgramUniformMatrix3fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix3fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix3fvEXT_PACKED *unpacked = (glProgramUniformMatrix3fvEXT_PACKED *)packed; \
    glProgramUniformMatrix3fvEXT_ARGS *args = (glProgramUniformMatrix3fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3fvEXT(glProgramUniformMatrix3fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3fvEXT(glProgramUniformMatrix3fvEXT_PACKED *_dst glProgramUniformMatrix3fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3fvEXT_PTR)(glProgramUniformMatrix3fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x2dv_RETURN
#define glProgramUniformMatrix3x2dv_RETURN void
#define glProgramUniformMatrix3x2dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x2dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x2dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix3x2dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x2dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x2dv(packed, ret_v) do { \
    glProgramUniformMatrix3x2dv_PACKED *unpacked = (glProgramUniformMatrix3x2dv_PACKED *)packed; \
    glProgramUniformMatrix3x2dv_ARGS *args = (glProgramUniformMatrix3x2dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x2dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2dv(glProgramUniformMatrix3x2dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x2dv(glProgramUniformMatrix3x2dv_PACKED *_dst glProgramUniformMatrix3x2dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x2dv_PTR)(glProgramUniformMatrix3x2dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x2dvEXT_RETURN
#define glProgramUniformMatrix3x2dvEXT_RETURN void
#define glProgramUniformMatrix3x2dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x2dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x2dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix3x2dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x2dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x2dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x2dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix3x2dvEXT_PACKED *unpacked = (glProgramUniformMatrix3x2dvEXT_PACKED *)packed; \
    glProgramUniformMatrix3x2dvEXT_ARGS *args = (glProgramUniformMatrix3x2dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x2dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2dvEXT(glProgramUniformMatrix3x2dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x2dvEXT(glProgramUniformMatrix3x2dvEXT_PACKED *_dst glProgramUniformMatrix3x2dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x2dvEXT_PTR)(glProgramUniformMatrix3x2dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x2fv_RETURN
#define glProgramUniformMatrix3x2fv_RETURN void
#define glProgramUniformMatrix3x2fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x2fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x2fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix3x2fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x2fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x2fv(packed, ret_v) do { \
    glProgramUniformMatrix3x2fv_PACKED *unpacked = (glProgramUniformMatrix3x2fv_PACKED *)packed; \
    glProgramUniformMatrix3x2fv_ARGS *args = (glProgramUniformMatrix3x2fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x2fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2fv(glProgramUniformMatrix3x2fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x2fv(glProgramUniformMatrix3x2fv_PACKED *_dst glProgramUniformMatrix3x2fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x2fv_PTR)(glProgramUniformMatrix3x2fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x2fvEXT_RETURN
#define glProgramUniformMatrix3x2fvEXT_RETURN void
#define glProgramUniformMatrix3x2fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x2fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x2fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix3x2fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x2fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x2fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x2fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix3x2fvEXT_PACKED *unpacked = (glProgramUniformMatrix3x2fvEXT_PACKED *)packed; \
    glProgramUniformMatrix3x2fvEXT_ARGS *args = (glProgramUniformMatrix3x2fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x2fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2fvEXT(glProgramUniformMatrix3x2fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x2fvEXT(glProgramUniformMatrix3x2fvEXT_PACKED *_dst glProgramUniformMatrix3x2fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x2fvEXT_PTR)(glProgramUniformMatrix3x2fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x4dv_RETURN
#define glProgramUniformMatrix3x4dv_RETURN void
#define glProgramUniformMatrix3x4dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x4dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x4dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix3x4dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x4dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x4dv(packed, ret_v) do { \
    glProgramUniformMatrix3x4dv_PACKED *unpacked = (glProgramUniformMatrix3x4dv_PACKED *)packed; \
    glProgramUniformMatrix3x4dv_ARGS *args = (glProgramUniformMatrix3x4dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x4dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4dv(glProgramUniformMatrix3x4dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x4dv(glProgramUniformMatrix3x4dv_PACKED *_dst glProgramUniformMatrix3x4dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x4dv_PTR)(glProgramUniformMatrix3x4dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x4dvEXT_RETURN
#define glProgramUniformMatrix3x4dvEXT_RETURN void
#define glProgramUniformMatrix3x4dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x4dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x4dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix3x4dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x4dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x4dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x4dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix3x4dvEXT_PACKED *unpacked = (glProgramUniformMatrix3x4dvEXT_PACKED *)packed; \
    glProgramUniformMatrix3x4dvEXT_ARGS *args = (glProgramUniformMatrix3x4dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x4dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4dvEXT(glProgramUniformMatrix3x4dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x4dvEXT(glProgramUniformMatrix3x4dvEXT_PACKED *_dst glProgramUniformMatrix3x4dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x4dvEXT_PTR)(glProgramUniformMatrix3x4dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x4fv_RETURN
#define glProgramUniformMatrix3x4fv_RETURN void
#define glProgramUniformMatrix3x4fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x4fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x4fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix3x4fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x4fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x4fv(packed, ret_v) do { \
    glProgramUniformMatrix3x4fv_PACKED *unpacked = (glProgramUniformMatrix3x4fv_PACKED *)packed; \
    glProgramUniformMatrix3x4fv_ARGS *args = (glProgramUniformMatrix3x4fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x4fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4fv(glProgramUniformMatrix3x4fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x4fv(glProgramUniformMatrix3x4fv_PACKED *_dst glProgramUniformMatrix3x4fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x4fv_PTR)(glProgramUniformMatrix3x4fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix3x4fvEXT_RETURN
#define glProgramUniformMatrix3x4fvEXT_RETURN void
#define glProgramUniformMatrix3x4fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x4fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix3x4fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix3x4fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix3x4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix3x4fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix3x4fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix3x4fvEXT_PACKED *unpacked = (glProgramUniformMatrix3x4fvEXT_PACKED *)packed; \
    glProgramUniformMatrix3x4fvEXT_ARGS *args = (glProgramUniformMatrix3x4fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix3x4fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4fvEXT(glProgramUniformMatrix3x4fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix3x4fvEXT(glProgramUniformMatrix3x4fvEXT_PACKED *_dst glProgramUniformMatrix3x4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix3x4fvEXT_PTR)(glProgramUniformMatrix3x4fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4dv_RETURN
#define glProgramUniformMatrix4dv_RETURN void
#define glProgramUniformMatrix4dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix4dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4dv(packed, ret_v) do { \
    glProgramUniformMatrix4dv_PACKED *unpacked = (glProgramUniformMatrix4dv_PACKED *)packed; \
    glProgramUniformMatrix4dv_ARGS *args = (glProgramUniformMatrix4dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4dv(glProgramUniformMatrix4dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4dv(glProgramUniformMatrix4dv_PACKED *_dst glProgramUniformMatrix4dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4dv_PTR)(glProgramUniformMatrix4dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4dvEXT_RETURN
#define glProgramUniformMatrix4dvEXT_RETURN void
#define glProgramUniformMatrix4dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix4dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix4dvEXT_PACKED *unpacked = (glProgramUniformMatrix4dvEXT_PACKED *)packed; \
    glProgramUniformMatrix4dvEXT_ARGS *args = (glProgramUniformMatrix4dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4dvEXT(glProgramUniformMatrix4dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4dvEXT(glProgramUniformMatrix4dvEXT_PACKED *_dst glProgramUniformMatrix4dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4dvEXT_PTR)(glProgramUniformMatrix4dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4fv_RETURN
#define glProgramUniformMatrix4fv_RETURN void
#define glProgramUniformMatrix4fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix4fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4fv(packed, ret_v) do { \
    glProgramUniformMatrix4fv_PACKED *unpacked = (glProgramUniformMatrix4fv_PACKED *)packed; \
    glProgramUniformMatrix4fv_ARGS *args = (glProgramUniformMatrix4fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4fv(glProgramUniformMatrix4fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4fv(glProgramUniformMatrix4fv_PACKED *_dst glProgramUniformMatrix4fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4fv_PTR)(glProgramUniformMatrix4fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4fvEXT_RETURN
#define glProgramUniformMatrix4fvEXT_RETURN void
#define glProgramUniformMatrix4fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix4fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix4fvEXT_PACKED *unpacked = (glProgramUniformMatrix4fvEXT_PACKED *)packed; \
    glProgramUniformMatrix4fvEXT_ARGS *args = (glProgramUniformMatrix4fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4fvEXT(glProgramUniformMatrix4fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4fvEXT(glProgramUniformMatrix4fvEXT_PACKED *_dst glProgramUniformMatrix4fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4fvEXT_PTR)(glProgramUniformMatrix4fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x2dv_RETURN
#define glProgramUniformMatrix4x2dv_RETURN void
#define glProgramUniformMatrix4x2dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x2dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x2dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix4x2dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x2dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x2dv(packed, ret_v) do { \
    glProgramUniformMatrix4x2dv_PACKED *unpacked = (glProgramUniformMatrix4x2dv_PACKED *)packed; \
    glProgramUniformMatrix4x2dv_ARGS *args = (glProgramUniformMatrix4x2dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x2dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2dv(glProgramUniformMatrix4x2dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x2dv(glProgramUniformMatrix4x2dv_PACKED *_dst glProgramUniformMatrix4x2dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x2dv_PTR)(glProgramUniformMatrix4x2dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x2dvEXT_RETURN
#define glProgramUniformMatrix4x2dvEXT_RETURN void
#define glProgramUniformMatrix4x2dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x2dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x2dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix4x2dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x2dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x2dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x2dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix4x2dvEXT_PACKED *unpacked = (glProgramUniformMatrix4x2dvEXT_PACKED *)packed; \
    glProgramUniformMatrix4x2dvEXT_ARGS *args = (glProgramUniformMatrix4x2dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x2dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2dvEXT(glProgramUniformMatrix4x2dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x2dvEXT(glProgramUniformMatrix4x2dvEXT_PACKED *_dst glProgramUniformMatrix4x2dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x2dvEXT_PTR)(glProgramUniformMatrix4x2dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x2fv_RETURN
#define glProgramUniformMatrix4x2fv_RETURN void
#define glProgramUniformMatrix4x2fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x2fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x2fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix4x2fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x2fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x2fv(packed, ret_v) do { \
    glProgramUniformMatrix4x2fv_PACKED *unpacked = (glProgramUniformMatrix4x2fv_PACKED *)packed; \
    glProgramUniformMatrix4x2fv_ARGS *args = (glProgramUniformMatrix4x2fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x2fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2fv(glProgramUniformMatrix4x2fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x2fv(glProgramUniformMatrix4x2fv_PACKED *_dst glProgramUniformMatrix4x2fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x2fv_PTR)(glProgramUniformMatrix4x2fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x2fvEXT_RETURN
#define glProgramUniformMatrix4x2fvEXT_RETURN void
#define glProgramUniformMatrix4x2fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x2fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x2fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix4x2fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x2fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x2fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x2fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix4x2fvEXT_PACKED *unpacked = (glProgramUniformMatrix4x2fvEXT_PACKED *)packed; \
    glProgramUniformMatrix4x2fvEXT_ARGS *args = (glProgramUniformMatrix4x2fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x2fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2fvEXT(glProgramUniformMatrix4x2fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x2fvEXT(glProgramUniformMatrix4x2fvEXT_PACKED *_dst glProgramUniformMatrix4x2fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x2fvEXT_PTR)(glProgramUniformMatrix4x2fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x3dv_RETURN
#define glProgramUniformMatrix4x3dv_RETURN void
#define glProgramUniformMatrix4x3dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x3dv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x3dv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix4x3dv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x3dv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x3dv(packed, ret_v) do { \
    glProgramUniformMatrix4x3dv_PACKED *unpacked = (glProgramUniformMatrix4x3dv_PACKED *)packed; \
    glProgramUniformMatrix4x3dv_ARGS *args = (glProgramUniformMatrix4x3dv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x3dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3dv(glProgramUniformMatrix4x3dv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x3dv(glProgramUniformMatrix4x3dv_PACKED *_dst glProgramUniformMatrix4x3dv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x3dv_PTR)(glProgramUniformMatrix4x3dv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x3dvEXT_RETURN
#define glProgramUniformMatrix4x3dvEXT_RETURN void
#define glProgramUniformMatrix4x3dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x3dvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x3dvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glProgramUniformMatrix4x3dvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x3dvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x3dvEXT(packed, ret_v) do { \
    glProgramUniformMatrix4x3dvEXT_PACKED *unpacked = (glProgramUniformMatrix4x3dvEXT_PACKED *)packed; \
    glProgramUniformMatrix4x3dvEXT_ARGS *args = (glProgramUniformMatrix4x3dvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x3dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3dvEXT(glProgramUniformMatrix4x3dvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x3dvEXT(glProgramUniformMatrix4x3dvEXT_PACKED *_dst glProgramUniformMatrix4x3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x3dvEXT_PTR)(glProgramUniformMatrix4x3dvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x3fv_RETURN
#define glProgramUniformMatrix4x3fv_RETURN void
#define glProgramUniformMatrix4x3fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x3fv_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x3fv_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix4x3fv(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x3fv(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x3fv(packed, ret_v) do { \
    glProgramUniformMatrix4x3fv_PACKED *unpacked = (glProgramUniformMatrix4x3fv_PACKED *)packed; \
    glProgramUniformMatrix4x3fv_ARGS *args = (glProgramUniformMatrix4x3fv_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x3fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3fv(glProgramUniformMatrix4x3fv_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x3fv(glProgramUniformMatrix4x3fv_PACKED *_dst glProgramUniformMatrix4x3fv_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x3fv_PTR)(glProgramUniformMatrix4x3fv_ARG_EXPAND);
#endif
#ifndef glProgramUniformMatrix4x3fvEXT_RETURN
#define glProgramUniformMatrix4x3fvEXT_RETURN void
#define glProgramUniformMatrix4x3fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x3fvEXT_ARG_NAMES_TAIL , program, location, count, transpose, value
#define glProgramUniformMatrix4x3fvEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glProgramUniformMatrix4x3fvEXT(_program, _location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformMatrix4x3fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformMatrix4x3fvEXT(dst, _program, _location, _count, _transpose, _value), NULL); \
    });
#define call_glProgramUniformMatrix4x3fvEXT(packed, ret_v) do { \
    glProgramUniformMatrix4x3fvEXT_PACKED *unpacked = (glProgramUniformMatrix4x3fvEXT_PACKED *)packed; \
    glProgramUniformMatrix4x3fvEXT_ARGS *args = (glProgramUniformMatrix4x3fvEXT_ARGS *)&unpacked->args; \
    glProgramUniformMatrix4x3fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3fvEXT(glProgramUniformMatrix4x3fvEXT_ARG_EXPAND);
packed_call_t *pack_glProgramUniformMatrix4x3fvEXT(glProgramUniformMatrix4x3fvEXT_PACKED *_dst glProgramUniformMatrix4x3fvEXT_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformMatrix4x3fvEXT_PTR)(glProgramUniformMatrix4x3fvEXT_ARG_EXPAND);
#endif
#ifndef glProgramUniformui64NV_RETURN
#define glProgramUniformui64NV_RETURN void
#define glProgramUniformui64NV_ARG_NAMES program, location, value
#define glProgramUniformui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT value
#define glProgramUniformui64NV_ARG_NAMES_TAIL , program, location, value
#define glProgramUniformui64NV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint64EXT value
#define forward_glProgramUniformui64NV(_program, _location, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformui64NV(dst, _program, _location, _value), NULL); \
    });
#define call_glProgramUniformui64NV(packed, ret_v) do { \
    glProgramUniformui64NV_PACKED *unpacked = (glProgramUniformui64NV_PACKED *)packed; \
    glProgramUniformui64NV_ARGS *args = (glProgramUniformui64NV_ARGS *)&unpacked->args; \
    glProgramUniformui64NV(args->program, args->location, args->value);; \
} while(0)
void glProgramUniformui64NV(glProgramUniformui64NV_ARG_EXPAND);
packed_call_t *pack_glProgramUniformui64NV(glProgramUniformui64NV_PACKED *_dst glProgramUniformui64NV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformui64NV_PTR)(glProgramUniformui64NV_ARG_EXPAND);
#endif
#ifndef glProgramUniformui64vNV_RETURN
#define glProgramUniformui64vNV_RETURN void
#define glProgramUniformui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniformui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniformui64vNV_ARG_NAMES_TAIL , program, location, count, value
#define glProgramUniformui64vNV_ARG_EXPAND_TAIL , GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glProgramUniformui64vNV(_program, _location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramUniformui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramUniformui64vNV(dst, _program, _location, _count, _value), NULL); \
    });
#define call_glProgramUniformui64vNV(packed, ret_v) do { \
    glProgramUniformui64vNV_PACKED *unpacked = (glProgramUniformui64vNV_PACKED *)packed; \
    glProgramUniformui64vNV_ARGS *args = (glProgramUniformui64vNV_ARGS *)&unpacked->args; \
    glProgramUniformui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniformui64vNV(glProgramUniformui64vNV_ARG_EXPAND);
packed_call_t *pack_glProgramUniformui64vNV(glProgramUniformui64vNV_PACKED *_dst glProgramUniformui64vNV_ARG_EXPAND_TAIL);
typedef void (*glProgramUniformui64vNV_PTR)(glProgramUniformui64vNV_ARG_EXPAND);
#endif
#ifndef glProgramVertexLimitNV_RETURN
#define glProgramVertexLimitNV_RETURN void
#define glProgramVertexLimitNV_ARG_NAMES target, limit
#define glProgramVertexLimitNV_ARG_EXPAND GLenum target, GLint limit
#define glProgramVertexLimitNV_ARG_NAMES_TAIL , target, limit
#define glProgramVertexLimitNV_ARG_EXPAND_TAIL , GLenum target, GLint limit
#define forward_glProgramVertexLimitNV(_target, _limit) \
    ({ \
        void *dst = remote_dma(sizeof(glProgramVertexLimitNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProgramVertexLimitNV(dst, _target, _limit), NULL); \
    });
#define call_glProgramVertexLimitNV(packed, ret_v) do { \
    glProgramVertexLimitNV_PACKED *unpacked = (glProgramVertexLimitNV_PACKED *)packed; \
    glProgramVertexLimitNV_ARGS *args = (glProgramVertexLimitNV_ARGS *)&unpacked->args; \
    glProgramVertexLimitNV(args->target, args->limit);; \
} while(0)
void glProgramVertexLimitNV(glProgramVertexLimitNV_ARG_EXPAND);
packed_call_t *pack_glProgramVertexLimitNV(glProgramVertexLimitNV_PACKED *_dst glProgramVertexLimitNV_ARG_EXPAND_TAIL);
typedef void (*glProgramVertexLimitNV_PTR)(glProgramVertexLimitNV_ARG_EXPAND);
#endif
#ifndef glProvokingVertex_RETURN
#define glProvokingVertex_RETURN void
#define glProvokingVertex_ARG_NAMES mode
#define glProvokingVertex_ARG_EXPAND GLenum mode
#define glProvokingVertex_ARG_NAMES_TAIL , mode
#define glProvokingVertex_ARG_EXPAND_TAIL , GLenum mode
#define forward_glProvokingVertex(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glProvokingVertex_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProvokingVertex(dst, _mode), NULL); \
    });
#define call_glProvokingVertex(packed, ret_v) do { \
    glProvokingVertex_PACKED *unpacked = (glProvokingVertex_PACKED *)packed; \
    glProvokingVertex_ARGS *args = (glProvokingVertex_ARGS *)&unpacked->args; \
    glProvokingVertex(args->mode);; \
} while(0)
void glProvokingVertex(glProvokingVertex_ARG_EXPAND);
packed_call_t *pack_glProvokingVertex(glProvokingVertex_PACKED *_dst glProvokingVertex_ARG_EXPAND_TAIL);
typedef void (*glProvokingVertex_PTR)(glProvokingVertex_ARG_EXPAND);
#endif
#ifndef glProvokingVertexEXT_RETURN
#define glProvokingVertexEXT_RETURN void
#define glProvokingVertexEXT_ARG_NAMES mode
#define glProvokingVertexEXT_ARG_EXPAND GLenum mode
#define glProvokingVertexEXT_ARG_NAMES_TAIL , mode
#define glProvokingVertexEXT_ARG_EXPAND_TAIL , GLenum mode
#define forward_glProvokingVertexEXT(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glProvokingVertexEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glProvokingVertexEXT(dst, _mode), NULL); \
    });
#define call_glProvokingVertexEXT(packed, ret_v) do { \
    glProvokingVertexEXT_PACKED *unpacked = (glProvokingVertexEXT_PACKED *)packed; \
    glProvokingVertexEXT_ARGS *args = (glProvokingVertexEXT_ARGS *)&unpacked->args; \
    glProvokingVertexEXT(args->mode);; \
} while(0)
void glProvokingVertexEXT(glProvokingVertexEXT_ARG_EXPAND);
packed_call_t *pack_glProvokingVertexEXT(glProvokingVertexEXT_PACKED *_dst glProvokingVertexEXT_ARG_EXPAND_TAIL);
typedef void (*glProvokingVertexEXT_PTR)(glProvokingVertexEXT_ARG_EXPAND);
#endif
#ifndef glPushAttrib_RETURN
#define glPushAttrib_RETURN void
#define glPushAttrib_ARG_NAMES mask
#define glPushAttrib_ARG_EXPAND GLbitfield mask
#define glPushAttrib_ARG_NAMES_TAIL , mask
#define glPushAttrib_ARG_EXPAND_TAIL , GLbitfield mask
#define forward_glPushAttrib(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glPushAttrib_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPushAttrib(dst, _mask), NULL); \
    });
#define call_glPushAttrib(packed, ret_v) do { \
    glPushAttrib_PACKED *unpacked = (glPushAttrib_PACKED *)packed; \
    glPushAttrib_ARGS *args = (glPushAttrib_ARGS *)&unpacked->args; \
    glPushAttrib(args->mask);; \
} while(0)
void glPushAttrib(glPushAttrib_ARG_EXPAND);
packed_call_t *pack_glPushAttrib(glPushAttrib_PACKED *_dst glPushAttrib_ARG_EXPAND_TAIL);
typedef void (*glPushAttrib_PTR)(glPushAttrib_ARG_EXPAND);
#endif
#ifndef glPushClientAttrib_RETURN
#define glPushClientAttrib_RETURN void
#define glPushClientAttrib_ARG_NAMES mask
#define glPushClientAttrib_ARG_EXPAND GLbitfield mask
#define glPushClientAttrib_ARG_NAMES_TAIL , mask
#define glPushClientAttrib_ARG_EXPAND_TAIL , GLbitfield mask
#define forward_glPushClientAttrib(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glPushClientAttrib_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPushClientAttrib(dst, _mask), NULL); \
    });
#define call_glPushClientAttrib(packed, ret_v) do { \
    glPushClientAttrib_PACKED *unpacked = (glPushClientAttrib_PACKED *)packed; \
    glPushClientAttrib_ARGS *args = (glPushClientAttrib_ARGS *)&unpacked->args; \
    glPushClientAttrib(args->mask);; \
} while(0)
void glPushClientAttrib(glPushClientAttrib_ARG_EXPAND);
packed_call_t *pack_glPushClientAttrib(glPushClientAttrib_PACKED *_dst glPushClientAttrib_ARG_EXPAND_TAIL);
typedef void (*glPushClientAttrib_PTR)(glPushClientAttrib_ARG_EXPAND);
#endif
#ifndef glPushClientAttribDefaultEXT_RETURN
#define glPushClientAttribDefaultEXT_RETURN void
#define glPushClientAttribDefaultEXT_ARG_NAMES mask
#define glPushClientAttribDefaultEXT_ARG_EXPAND GLbitfield mask
#define glPushClientAttribDefaultEXT_ARG_NAMES_TAIL , mask
#define glPushClientAttribDefaultEXT_ARG_EXPAND_TAIL , GLbitfield mask
#define forward_glPushClientAttribDefaultEXT(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glPushClientAttribDefaultEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPushClientAttribDefaultEXT(dst, _mask), NULL); \
    });
#define call_glPushClientAttribDefaultEXT(packed, ret_v) do { \
    glPushClientAttribDefaultEXT_PACKED *unpacked = (glPushClientAttribDefaultEXT_PACKED *)packed; \
    glPushClientAttribDefaultEXT_ARGS *args = (glPushClientAttribDefaultEXT_ARGS *)&unpacked->args; \
    glPushClientAttribDefaultEXT(args->mask);; \
} while(0)
void glPushClientAttribDefaultEXT(glPushClientAttribDefaultEXT_ARG_EXPAND);
packed_call_t *pack_glPushClientAttribDefaultEXT(glPushClientAttribDefaultEXT_PACKED *_dst glPushClientAttribDefaultEXT_ARG_EXPAND_TAIL);
typedef void (*glPushClientAttribDefaultEXT_PTR)(glPushClientAttribDefaultEXT_ARG_EXPAND);
#endif
#ifndef glPushDebugGroup_RETURN
#define glPushDebugGroup_RETURN void
#define glPushDebugGroup_ARG_NAMES source, id, length, message
#define glPushDebugGroup_ARG_EXPAND GLenum source, GLuint id, GLsizei length, const GLchar * message
#define glPushDebugGroup_ARG_NAMES_TAIL , source, id, length, message
#define glPushDebugGroup_ARG_EXPAND_TAIL , GLenum source, GLuint id, GLsizei length, const GLchar * message
#define forward_glPushDebugGroup(_source, _id, _length, _message) \
    ({ \
        void *dst = remote_dma(sizeof(glPushDebugGroup_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPushDebugGroup(dst, _source, _id, _length, _message), NULL); \
    });
#define call_glPushDebugGroup(packed, ret_v) do { \
    glPushDebugGroup_PACKED *unpacked = (glPushDebugGroup_PACKED *)packed; \
    glPushDebugGroup_ARGS *args = (glPushDebugGroup_ARGS *)&unpacked->args; \
    glPushDebugGroup(args->source, args->id, args->length, args->message);; \
} while(0)
void glPushDebugGroup(glPushDebugGroup_ARG_EXPAND);
packed_call_t *pack_glPushDebugGroup(glPushDebugGroup_PACKED *_dst glPushDebugGroup_ARG_EXPAND_TAIL);
typedef void (*glPushDebugGroup_PTR)(glPushDebugGroup_ARG_EXPAND);
#endif
#ifndef glPushMatrix_RETURN
#define glPushMatrix_RETURN void
#define glPushMatrix_ARG_NAMES 
#define glPushMatrix_ARG_EXPAND 
#define glPushMatrix_ARG_NAMES_TAIL 
#define glPushMatrix_ARG_EXPAND_TAIL 
#define forward_glPushMatrix() \
    ({ \
        void *dst = remote_dma(sizeof(glPushMatrix_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPushMatrix(dst), NULL); \
    });
#define call_glPushMatrix(packed, ret_v) do { \
    glPushMatrix();; \
} while(0)
void glPushMatrix(glPushMatrix_ARG_EXPAND);
packed_call_t *pack_glPushMatrix(glPushMatrix_PACKED *_dst glPushMatrix_ARG_EXPAND_TAIL);
typedef void (*glPushMatrix_PTR)(glPushMatrix_ARG_EXPAND);
#endif
#ifndef glPushName_RETURN
#define glPushName_RETURN void
#define glPushName_ARG_NAMES name
#define glPushName_ARG_EXPAND GLuint name
#define glPushName_ARG_NAMES_TAIL , name
#define glPushName_ARG_EXPAND_TAIL , GLuint name
#define forward_glPushName(_name) \
    ({ \
        void *dst = remote_dma(sizeof(glPushName_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glPushName(dst, _name), NULL); \
    });
#define call_glPushName(packed, ret_v) do { \
    glPushName_PACKED *unpacked = (glPushName_PACKED *)packed; \
    glPushName_ARGS *args = (glPushName_ARGS *)&unpacked->args; \
    glPushName(args->name);; \
} while(0)
void glPushName(glPushName_ARG_EXPAND);
packed_call_t *pack_glPushName(glPushName_PACKED *_dst glPushName_ARG_EXPAND_TAIL);
typedef void (*glPushName_PTR)(glPushName_ARG_EXPAND);
#endif
#ifndef glQueryCounter_RETURN
#define glQueryCounter_RETURN void
#define glQueryCounter_ARG_NAMES id, target
#define glQueryCounter_ARG_EXPAND GLuint id, GLenum target
#define glQueryCounter_ARG_NAMES_TAIL , id, target
#define glQueryCounter_ARG_EXPAND_TAIL , GLuint id, GLenum target
#define forward_glQueryCounter(_id, _target) \
    ({ \
        void *dst = remote_dma(sizeof(glQueryCounter_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glQueryCounter(dst, _id, _target), NULL); \
    });
#define call_glQueryCounter(packed, ret_v) do { \
    glQueryCounter_PACKED *unpacked = (glQueryCounter_PACKED *)packed; \
    glQueryCounter_ARGS *args = (glQueryCounter_ARGS *)&unpacked->args; \
    glQueryCounter(args->id, args->target);; \
} while(0)
void glQueryCounter(glQueryCounter_ARG_EXPAND);
packed_call_t *pack_glQueryCounter(glQueryCounter_PACKED *_dst glQueryCounter_ARG_EXPAND_TAIL);
typedef void (*glQueryCounter_PTR)(glQueryCounter_ARG_EXPAND);
#endif
#ifndef glQueryMatrixxOES_RETURN
#define glQueryMatrixxOES_RETURN GLbitfield
#define glQueryMatrixxOES_ARG_NAMES mantissa, exponent
#define glQueryMatrixxOES_ARG_EXPAND GLfixed * mantissa, GLint * exponent
#define glQueryMatrixxOES_ARG_NAMES_TAIL , mantissa, exponent
#define glQueryMatrixxOES_ARG_EXPAND_TAIL , GLfixed * mantissa, GLint * exponent
#define forward_glQueryMatrixxOES(_mantissa, _exponent) \
    ({ \
        void *dst = remote_dma(sizeof(glQueryMatrixxOES_PACKED)); \
        GLbitfield ret = (GLbitfield)0; \
        remote_dma_send((packed_call_t *)pack_glQueryMatrixxOES(dst, _mantissa, _exponent), &ret); \
        ret; \
    });
#define call_glQueryMatrixxOES(packed, ret_v) do { \
    glQueryMatrixxOES_PACKED *unpacked = (glQueryMatrixxOES_PACKED *)packed; \
    glQueryMatrixxOES_ARGS *args = (glQueryMatrixxOES_ARGS *)&unpacked->args; \
    GLbitfield *ret = (GLbitfield *)ret_v; \
    if (ret != NULL) { \
        *ret = glQueryMatrixxOES(args->mantissa, args->exponent);; \
    } else { \
        glQueryMatrixxOES(args->mantissa, args->exponent);; \
    } \
} while(0)
GLbitfield glQueryMatrixxOES(glQueryMatrixxOES_ARG_EXPAND);
packed_call_t *pack_glQueryMatrixxOES(glQueryMatrixxOES_PACKED *_dst glQueryMatrixxOES_ARG_EXPAND_TAIL);
typedef GLbitfield (*glQueryMatrixxOES_PTR)(glQueryMatrixxOES_ARG_EXPAND);
#endif
#ifndef glRasterPos2d_RETURN
#define glRasterPos2d_RETURN void
#define glRasterPos2d_ARG_NAMES x, y
#define glRasterPos2d_ARG_EXPAND GLdouble x, GLdouble y
#define glRasterPos2d_ARG_NAMES_TAIL , x, y
#define glRasterPos2d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y
#define forward_glRasterPos2d(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2d(dst, _x, _y), NULL); \
    });
#define call_glRasterPos2d(packed, ret_v) do { \
    glRasterPos2d_PACKED *unpacked = (glRasterPos2d_PACKED *)packed; \
    glRasterPos2d_ARGS *args = (glRasterPos2d_ARGS *)&unpacked->args; \
    glRasterPos2d(args->x, args->y);; \
} while(0)
void glRasterPos2d(glRasterPos2d_ARG_EXPAND);
packed_call_t *pack_glRasterPos2d(glRasterPos2d_PACKED *_dst glRasterPos2d_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2d_PTR)(glRasterPos2d_ARG_EXPAND);
#endif
#ifndef glRasterPos2dv_RETURN
#define glRasterPos2dv_RETURN void
#define glRasterPos2dv_ARG_NAMES v
#define glRasterPos2dv_ARG_EXPAND const GLdouble * v
#define glRasterPos2dv_ARG_NAMES_TAIL , v
#define glRasterPos2dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glRasterPos2dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2dv(dst, _v), NULL); \
    });
#define call_glRasterPos2dv(packed, ret_v) do { \
    glRasterPos2dv_PACKED *unpacked = (glRasterPos2dv_PACKED *)packed; \
    glRasterPos2dv_ARGS *args = (glRasterPos2dv_ARGS *)&unpacked->args; \
    glRasterPos2dv(args->v);; \
} while(0)
void glRasterPos2dv(glRasterPos2dv_ARG_EXPAND);
packed_call_t *pack_glRasterPos2dv(glRasterPos2dv_PACKED *_dst glRasterPos2dv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2dv_PTR)(glRasterPos2dv_ARG_EXPAND);
#endif
#ifndef glRasterPos2f_RETURN
#define glRasterPos2f_RETURN void
#define glRasterPos2f_ARG_NAMES x, y
#define glRasterPos2f_ARG_EXPAND GLfloat x, GLfloat y
#define glRasterPos2f_ARG_NAMES_TAIL , x, y
#define glRasterPos2f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y
#define forward_glRasterPos2f(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2f(dst, _x, _y), NULL); \
    });
#define call_glRasterPos2f(packed, ret_v) do { \
    glRasterPos2f_PACKED *unpacked = (glRasterPos2f_PACKED *)packed; \
    glRasterPos2f_ARGS *args = (glRasterPos2f_ARGS *)&unpacked->args; \
    glRasterPos2f(args->x, args->y);; \
} while(0)
void glRasterPos2f(glRasterPos2f_ARG_EXPAND);
packed_call_t *pack_glRasterPos2f(glRasterPos2f_PACKED *_dst glRasterPos2f_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2f_PTR)(glRasterPos2f_ARG_EXPAND);
#endif
#ifndef glRasterPos2fv_RETURN
#define glRasterPos2fv_RETURN void
#define glRasterPos2fv_ARG_NAMES v
#define glRasterPos2fv_ARG_EXPAND const GLfloat * v
#define glRasterPos2fv_ARG_NAMES_TAIL , v
#define glRasterPos2fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glRasterPos2fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2fv(dst, _v), NULL); \
    });
#define call_glRasterPos2fv(packed, ret_v) do { \
    glRasterPos2fv_PACKED *unpacked = (glRasterPos2fv_PACKED *)packed; \
    glRasterPos2fv_ARGS *args = (glRasterPos2fv_ARGS *)&unpacked->args; \
    glRasterPos2fv(args->v);; \
} while(0)
void glRasterPos2fv(glRasterPos2fv_ARG_EXPAND);
packed_call_t *pack_glRasterPos2fv(glRasterPos2fv_PACKED *_dst glRasterPos2fv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2fv_PTR)(glRasterPos2fv_ARG_EXPAND);
#endif
#ifndef glRasterPos2i_RETURN
#define glRasterPos2i_RETURN void
#define glRasterPos2i_ARG_NAMES x, y
#define glRasterPos2i_ARG_EXPAND GLint x, GLint y
#define glRasterPos2i_ARG_NAMES_TAIL , x, y
#define glRasterPos2i_ARG_EXPAND_TAIL , GLint x, GLint y
#define forward_glRasterPos2i(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2i(dst, _x, _y), NULL); \
    });
#define call_glRasterPos2i(packed, ret_v) do { \
    glRasterPos2i_PACKED *unpacked = (glRasterPos2i_PACKED *)packed; \
    glRasterPos2i_ARGS *args = (glRasterPos2i_ARGS *)&unpacked->args; \
    glRasterPos2i(args->x, args->y);; \
} while(0)
void glRasterPos2i(glRasterPos2i_ARG_EXPAND);
packed_call_t *pack_glRasterPos2i(glRasterPos2i_PACKED *_dst glRasterPos2i_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2i_PTR)(glRasterPos2i_ARG_EXPAND);
#endif
#ifndef glRasterPos2iv_RETURN
#define glRasterPos2iv_RETURN void
#define glRasterPos2iv_ARG_NAMES v
#define glRasterPos2iv_ARG_EXPAND const GLint * v
#define glRasterPos2iv_ARG_NAMES_TAIL , v
#define glRasterPos2iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glRasterPos2iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2iv(dst, _v), NULL); \
    });
#define call_glRasterPos2iv(packed, ret_v) do { \
    glRasterPos2iv_PACKED *unpacked = (glRasterPos2iv_PACKED *)packed; \
    glRasterPos2iv_ARGS *args = (glRasterPos2iv_ARGS *)&unpacked->args; \
    glRasterPos2iv(args->v);; \
} while(0)
void glRasterPos2iv(glRasterPos2iv_ARG_EXPAND);
packed_call_t *pack_glRasterPos2iv(glRasterPos2iv_PACKED *_dst glRasterPos2iv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2iv_PTR)(glRasterPos2iv_ARG_EXPAND);
#endif
#ifndef glRasterPos2s_RETURN
#define glRasterPos2s_RETURN void
#define glRasterPos2s_ARG_NAMES x, y
#define glRasterPos2s_ARG_EXPAND GLshort x, GLshort y
#define glRasterPos2s_ARG_NAMES_TAIL , x, y
#define glRasterPos2s_ARG_EXPAND_TAIL , GLshort x, GLshort y
#define forward_glRasterPos2s(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2s(dst, _x, _y), NULL); \
    });
#define call_glRasterPos2s(packed, ret_v) do { \
    glRasterPos2s_PACKED *unpacked = (glRasterPos2s_PACKED *)packed; \
    glRasterPos2s_ARGS *args = (glRasterPos2s_ARGS *)&unpacked->args; \
    glRasterPos2s(args->x, args->y);; \
} while(0)
void glRasterPos2s(glRasterPos2s_ARG_EXPAND);
packed_call_t *pack_glRasterPos2s(glRasterPos2s_PACKED *_dst glRasterPos2s_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2s_PTR)(glRasterPos2s_ARG_EXPAND);
#endif
#ifndef glRasterPos2sv_RETURN
#define glRasterPos2sv_RETURN void
#define glRasterPos2sv_ARG_NAMES v
#define glRasterPos2sv_ARG_EXPAND const GLshort * v
#define glRasterPos2sv_ARG_NAMES_TAIL , v
#define glRasterPos2sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glRasterPos2sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2sv(dst, _v), NULL); \
    });
#define call_glRasterPos2sv(packed, ret_v) do { \
    glRasterPos2sv_PACKED *unpacked = (glRasterPos2sv_PACKED *)packed; \
    glRasterPos2sv_ARGS *args = (glRasterPos2sv_ARGS *)&unpacked->args; \
    glRasterPos2sv(args->v);; \
} while(0)
void glRasterPos2sv(glRasterPos2sv_ARG_EXPAND);
packed_call_t *pack_glRasterPos2sv(glRasterPos2sv_PACKED *_dst glRasterPos2sv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2sv_PTR)(glRasterPos2sv_ARG_EXPAND);
#endif
#ifndef glRasterPos2xOES_RETURN
#define glRasterPos2xOES_RETURN void
#define glRasterPos2xOES_ARG_NAMES x, y
#define glRasterPos2xOES_ARG_EXPAND GLfixed x, GLfixed y
#define glRasterPos2xOES_ARG_NAMES_TAIL , x, y
#define glRasterPos2xOES_ARG_EXPAND_TAIL , GLfixed x, GLfixed y
#define forward_glRasterPos2xOES(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2xOES(dst, _x, _y), NULL); \
    });
#define call_glRasterPos2xOES(packed, ret_v) do { \
    glRasterPos2xOES_PACKED *unpacked = (glRasterPos2xOES_PACKED *)packed; \
    glRasterPos2xOES_ARGS *args = (glRasterPos2xOES_ARGS *)&unpacked->args; \
    glRasterPos2xOES(args->x, args->y);; \
} while(0)
void glRasterPos2xOES(glRasterPos2xOES_ARG_EXPAND);
packed_call_t *pack_glRasterPos2xOES(glRasterPos2xOES_PACKED *_dst glRasterPos2xOES_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2xOES_PTR)(glRasterPos2xOES_ARG_EXPAND);
#endif
#ifndef glRasterPos2xvOES_RETURN
#define glRasterPos2xvOES_RETURN void
#define glRasterPos2xvOES_ARG_NAMES coords
#define glRasterPos2xvOES_ARG_EXPAND const GLfixed * coords
#define glRasterPos2xvOES_ARG_NAMES_TAIL , coords
#define glRasterPos2xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glRasterPos2xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos2xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos2xvOES(dst, _coords), NULL); \
    });
#define call_glRasterPos2xvOES(packed, ret_v) do { \
    glRasterPos2xvOES_PACKED *unpacked = (glRasterPos2xvOES_PACKED *)packed; \
    glRasterPos2xvOES_ARGS *args = (glRasterPos2xvOES_ARGS *)&unpacked->args; \
    glRasterPos2xvOES(args->coords);; \
} while(0)
void glRasterPos2xvOES(glRasterPos2xvOES_ARG_EXPAND);
packed_call_t *pack_glRasterPos2xvOES(glRasterPos2xvOES_PACKED *_dst glRasterPos2xvOES_ARG_EXPAND_TAIL);
typedef void (*glRasterPos2xvOES_PTR)(glRasterPos2xvOES_ARG_EXPAND);
#endif
#ifndef glRasterPos3d_RETURN
#define glRasterPos3d_RETURN void
#define glRasterPos3d_ARG_NAMES x, y, z
#define glRasterPos3d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glRasterPos3d_ARG_NAMES_TAIL , x, y, z
#define glRasterPos3d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z
#define forward_glRasterPos3d(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3d(dst, _x, _y, _z), NULL); \
    });
#define call_glRasterPos3d(packed, ret_v) do { \
    glRasterPos3d_PACKED *unpacked = (glRasterPos3d_PACKED *)packed; \
    glRasterPos3d_ARGS *args = (glRasterPos3d_ARGS *)&unpacked->args; \
    glRasterPos3d(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3d(glRasterPos3d_ARG_EXPAND);
packed_call_t *pack_glRasterPos3d(glRasterPos3d_PACKED *_dst glRasterPos3d_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3d_PTR)(glRasterPos3d_ARG_EXPAND);
#endif
#ifndef glRasterPos3dv_RETURN
#define glRasterPos3dv_RETURN void
#define glRasterPos3dv_ARG_NAMES v
#define glRasterPos3dv_ARG_EXPAND const GLdouble * v
#define glRasterPos3dv_ARG_NAMES_TAIL , v
#define glRasterPos3dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glRasterPos3dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3dv(dst, _v), NULL); \
    });
#define call_glRasterPos3dv(packed, ret_v) do { \
    glRasterPos3dv_PACKED *unpacked = (glRasterPos3dv_PACKED *)packed; \
    glRasterPos3dv_ARGS *args = (glRasterPos3dv_ARGS *)&unpacked->args; \
    glRasterPos3dv(args->v);; \
} while(0)
void glRasterPos3dv(glRasterPos3dv_ARG_EXPAND);
packed_call_t *pack_glRasterPos3dv(glRasterPos3dv_PACKED *_dst glRasterPos3dv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3dv_PTR)(glRasterPos3dv_ARG_EXPAND);
#endif
#ifndef glRasterPos3f_RETURN
#define glRasterPos3f_RETURN void
#define glRasterPos3f_ARG_NAMES x, y, z
#define glRasterPos3f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glRasterPos3f_ARG_NAMES_TAIL , x, y, z
#define glRasterPos3f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z
#define forward_glRasterPos3f(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3f(dst, _x, _y, _z), NULL); \
    });
#define call_glRasterPos3f(packed, ret_v) do { \
    glRasterPos3f_PACKED *unpacked = (glRasterPos3f_PACKED *)packed; \
    glRasterPos3f_ARGS *args = (glRasterPos3f_ARGS *)&unpacked->args; \
    glRasterPos3f(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3f(glRasterPos3f_ARG_EXPAND);
packed_call_t *pack_glRasterPos3f(glRasterPos3f_PACKED *_dst glRasterPos3f_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3f_PTR)(glRasterPos3f_ARG_EXPAND);
#endif
#ifndef glRasterPos3fv_RETURN
#define glRasterPos3fv_RETURN void
#define glRasterPos3fv_ARG_NAMES v
#define glRasterPos3fv_ARG_EXPAND const GLfloat * v
#define glRasterPos3fv_ARG_NAMES_TAIL , v
#define glRasterPos3fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glRasterPos3fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3fv(dst, _v), NULL); \
    });
#define call_glRasterPos3fv(packed, ret_v) do { \
    glRasterPos3fv_PACKED *unpacked = (glRasterPos3fv_PACKED *)packed; \
    glRasterPos3fv_ARGS *args = (glRasterPos3fv_ARGS *)&unpacked->args; \
    glRasterPos3fv(args->v);; \
} while(0)
void glRasterPos3fv(glRasterPos3fv_ARG_EXPAND);
packed_call_t *pack_glRasterPos3fv(glRasterPos3fv_PACKED *_dst glRasterPos3fv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3fv_PTR)(glRasterPos3fv_ARG_EXPAND);
#endif
#ifndef glRasterPos3i_RETURN
#define glRasterPos3i_RETURN void
#define glRasterPos3i_ARG_NAMES x, y, z
#define glRasterPos3i_ARG_EXPAND GLint x, GLint y, GLint z
#define glRasterPos3i_ARG_NAMES_TAIL , x, y, z
#define glRasterPos3i_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z
#define forward_glRasterPos3i(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3i(dst, _x, _y, _z), NULL); \
    });
#define call_glRasterPos3i(packed, ret_v) do { \
    glRasterPos3i_PACKED *unpacked = (glRasterPos3i_PACKED *)packed; \
    glRasterPos3i_ARGS *args = (glRasterPos3i_ARGS *)&unpacked->args; \
    glRasterPos3i(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3i(glRasterPos3i_ARG_EXPAND);
packed_call_t *pack_glRasterPos3i(glRasterPos3i_PACKED *_dst glRasterPos3i_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3i_PTR)(glRasterPos3i_ARG_EXPAND);
#endif
#ifndef glRasterPos3iv_RETURN
#define glRasterPos3iv_RETURN void
#define glRasterPos3iv_ARG_NAMES v
#define glRasterPos3iv_ARG_EXPAND const GLint * v
#define glRasterPos3iv_ARG_NAMES_TAIL , v
#define glRasterPos3iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glRasterPos3iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3iv(dst, _v), NULL); \
    });
#define call_glRasterPos3iv(packed, ret_v) do { \
    glRasterPos3iv_PACKED *unpacked = (glRasterPos3iv_PACKED *)packed; \
    glRasterPos3iv_ARGS *args = (glRasterPos3iv_ARGS *)&unpacked->args; \
    glRasterPos3iv(args->v);; \
} while(0)
void glRasterPos3iv(glRasterPos3iv_ARG_EXPAND);
packed_call_t *pack_glRasterPos3iv(glRasterPos3iv_PACKED *_dst glRasterPos3iv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3iv_PTR)(glRasterPos3iv_ARG_EXPAND);
#endif
#ifndef glRasterPos3s_RETURN
#define glRasterPos3s_RETURN void
#define glRasterPos3s_ARG_NAMES x, y, z
#define glRasterPos3s_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glRasterPos3s_ARG_NAMES_TAIL , x, y, z
#define glRasterPos3s_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z
#define forward_glRasterPos3s(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3s(dst, _x, _y, _z), NULL); \
    });
#define call_glRasterPos3s(packed, ret_v) do { \
    glRasterPos3s_PACKED *unpacked = (glRasterPos3s_PACKED *)packed; \
    glRasterPos3s_ARGS *args = (glRasterPos3s_ARGS *)&unpacked->args; \
    glRasterPos3s(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3s(glRasterPos3s_ARG_EXPAND);
packed_call_t *pack_glRasterPos3s(glRasterPos3s_PACKED *_dst glRasterPos3s_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3s_PTR)(glRasterPos3s_ARG_EXPAND);
#endif
#ifndef glRasterPos3sv_RETURN
#define glRasterPos3sv_RETURN void
#define glRasterPos3sv_ARG_NAMES v
#define glRasterPos3sv_ARG_EXPAND const GLshort * v
#define glRasterPos3sv_ARG_NAMES_TAIL , v
#define glRasterPos3sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glRasterPos3sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3sv(dst, _v), NULL); \
    });
#define call_glRasterPos3sv(packed, ret_v) do { \
    glRasterPos3sv_PACKED *unpacked = (glRasterPos3sv_PACKED *)packed; \
    glRasterPos3sv_ARGS *args = (glRasterPos3sv_ARGS *)&unpacked->args; \
    glRasterPos3sv(args->v);; \
} while(0)
void glRasterPos3sv(glRasterPos3sv_ARG_EXPAND);
packed_call_t *pack_glRasterPos3sv(glRasterPos3sv_PACKED *_dst glRasterPos3sv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3sv_PTR)(glRasterPos3sv_ARG_EXPAND);
#endif
#ifndef glRasterPos3xOES_RETURN
#define glRasterPos3xOES_RETURN void
#define glRasterPos3xOES_ARG_NAMES x, y, z
#define glRasterPos3xOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glRasterPos3xOES_ARG_NAMES_TAIL , x, y, z
#define glRasterPos3xOES_ARG_EXPAND_TAIL , GLfixed x, GLfixed y, GLfixed z
#define forward_glRasterPos3xOES(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3xOES(dst, _x, _y, _z), NULL); \
    });
#define call_glRasterPos3xOES(packed, ret_v) do { \
    glRasterPos3xOES_PACKED *unpacked = (glRasterPos3xOES_PACKED *)packed; \
    glRasterPos3xOES_ARGS *args = (glRasterPos3xOES_ARGS *)&unpacked->args; \
    glRasterPos3xOES(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3xOES(glRasterPos3xOES_ARG_EXPAND);
packed_call_t *pack_glRasterPos3xOES(glRasterPos3xOES_PACKED *_dst glRasterPos3xOES_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3xOES_PTR)(glRasterPos3xOES_ARG_EXPAND);
#endif
#ifndef glRasterPos3xvOES_RETURN
#define glRasterPos3xvOES_RETURN void
#define glRasterPos3xvOES_ARG_NAMES coords
#define glRasterPos3xvOES_ARG_EXPAND const GLfixed * coords
#define glRasterPos3xvOES_ARG_NAMES_TAIL , coords
#define glRasterPos3xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glRasterPos3xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos3xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos3xvOES(dst, _coords), NULL); \
    });
#define call_glRasterPos3xvOES(packed, ret_v) do { \
    glRasterPos3xvOES_PACKED *unpacked = (glRasterPos3xvOES_PACKED *)packed; \
    glRasterPos3xvOES_ARGS *args = (glRasterPos3xvOES_ARGS *)&unpacked->args; \
    glRasterPos3xvOES(args->coords);; \
} while(0)
void glRasterPos3xvOES(glRasterPos3xvOES_ARG_EXPAND);
packed_call_t *pack_glRasterPos3xvOES(glRasterPos3xvOES_PACKED *_dst glRasterPos3xvOES_ARG_EXPAND_TAIL);
typedef void (*glRasterPos3xvOES_PTR)(glRasterPos3xvOES_ARG_EXPAND);
#endif
#ifndef glRasterPos4d_RETURN
#define glRasterPos4d_RETURN void
#define glRasterPos4d_ARG_NAMES x, y, z, w
#define glRasterPos4d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glRasterPos4d_ARG_NAMES_TAIL , x, y, z, w
#define glRasterPos4d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glRasterPos4d(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4d(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glRasterPos4d(packed, ret_v) do { \
    glRasterPos4d_PACKED *unpacked = (glRasterPos4d_PACKED *)packed; \
    glRasterPos4d_ARGS *args = (glRasterPos4d_ARGS *)&unpacked->args; \
    glRasterPos4d(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4d(glRasterPos4d_ARG_EXPAND);
packed_call_t *pack_glRasterPos4d(glRasterPos4d_PACKED *_dst glRasterPos4d_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4d_PTR)(glRasterPos4d_ARG_EXPAND);
#endif
#ifndef glRasterPos4dv_RETURN
#define glRasterPos4dv_RETURN void
#define glRasterPos4dv_ARG_NAMES v
#define glRasterPos4dv_ARG_EXPAND const GLdouble * v
#define glRasterPos4dv_ARG_NAMES_TAIL , v
#define glRasterPos4dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glRasterPos4dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4dv(dst, _v), NULL); \
    });
#define call_glRasterPos4dv(packed, ret_v) do { \
    glRasterPos4dv_PACKED *unpacked = (glRasterPos4dv_PACKED *)packed; \
    glRasterPos4dv_ARGS *args = (glRasterPos4dv_ARGS *)&unpacked->args; \
    glRasterPos4dv(args->v);; \
} while(0)
void glRasterPos4dv(glRasterPos4dv_ARG_EXPAND);
packed_call_t *pack_glRasterPos4dv(glRasterPos4dv_PACKED *_dst glRasterPos4dv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4dv_PTR)(glRasterPos4dv_ARG_EXPAND);
#endif
#ifndef glRasterPos4f_RETURN
#define glRasterPos4f_RETURN void
#define glRasterPos4f_ARG_NAMES x, y, z, w
#define glRasterPos4f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glRasterPos4f_ARG_NAMES_TAIL , x, y, z, w
#define glRasterPos4f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glRasterPos4f(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4f(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glRasterPos4f(packed, ret_v) do { \
    glRasterPos4f_PACKED *unpacked = (glRasterPos4f_PACKED *)packed; \
    glRasterPos4f_ARGS *args = (glRasterPos4f_ARGS *)&unpacked->args; \
    glRasterPos4f(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4f(glRasterPos4f_ARG_EXPAND);
packed_call_t *pack_glRasterPos4f(glRasterPos4f_PACKED *_dst glRasterPos4f_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4f_PTR)(glRasterPos4f_ARG_EXPAND);
#endif
#ifndef glRasterPos4fv_RETURN
#define glRasterPos4fv_RETURN void
#define glRasterPos4fv_ARG_NAMES v
#define glRasterPos4fv_ARG_EXPAND const GLfloat * v
#define glRasterPos4fv_ARG_NAMES_TAIL , v
#define glRasterPos4fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glRasterPos4fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4fv(dst, _v), NULL); \
    });
#define call_glRasterPos4fv(packed, ret_v) do { \
    glRasterPos4fv_PACKED *unpacked = (glRasterPos4fv_PACKED *)packed; \
    glRasterPos4fv_ARGS *args = (glRasterPos4fv_ARGS *)&unpacked->args; \
    glRasterPos4fv(args->v);; \
} while(0)
void glRasterPos4fv(glRasterPos4fv_ARG_EXPAND);
packed_call_t *pack_glRasterPos4fv(glRasterPos4fv_PACKED *_dst glRasterPos4fv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4fv_PTR)(glRasterPos4fv_ARG_EXPAND);
#endif
#ifndef glRasterPos4i_RETURN
#define glRasterPos4i_RETURN void
#define glRasterPos4i_ARG_NAMES x, y, z, w
#define glRasterPos4i_ARG_EXPAND GLint x, GLint y, GLint z, GLint w
#define glRasterPos4i_ARG_NAMES_TAIL , x, y, z, w
#define glRasterPos4i_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z, GLint w
#define forward_glRasterPos4i(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4i(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glRasterPos4i(packed, ret_v) do { \
    glRasterPos4i_PACKED *unpacked = (glRasterPos4i_PACKED *)packed; \
    glRasterPos4i_ARGS *args = (glRasterPos4i_ARGS *)&unpacked->args; \
    glRasterPos4i(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4i(glRasterPos4i_ARG_EXPAND);
packed_call_t *pack_glRasterPos4i(glRasterPos4i_PACKED *_dst glRasterPos4i_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4i_PTR)(glRasterPos4i_ARG_EXPAND);
#endif
#ifndef glRasterPos4iv_RETURN
#define glRasterPos4iv_RETURN void
#define glRasterPos4iv_ARG_NAMES v
#define glRasterPos4iv_ARG_EXPAND const GLint * v
#define glRasterPos4iv_ARG_NAMES_TAIL , v
#define glRasterPos4iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glRasterPos4iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4iv(dst, _v), NULL); \
    });
#define call_glRasterPos4iv(packed, ret_v) do { \
    glRasterPos4iv_PACKED *unpacked = (glRasterPos4iv_PACKED *)packed; \
    glRasterPos4iv_ARGS *args = (glRasterPos4iv_ARGS *)&unpacked->args; \
    glRasterPos4iv(args->v);; \
} while(0)
void glRasterPos4iv(glRasterPos4iv_ARG_EXPAND);
packed_call_t *pack_glRasterPos4iv(glRasterPos4iv_PACKED *_dst glRasterPos4iv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4iv_PTR)(glRasterPos4iv_ARG_EXPAND);
#endif
#ifndef glRasterPos4s_RETURN
#define glRasterPos4s_RETURN void
#define glRasterPos4s_ARG_NAMES x, y, z, w
#define glRasterPos4s_ARG_EXPAND GLshort x, GLshort y, GLshort z, GLshort w
#define glRasterPos4s_ARG_NAMES_TAIL , x, y, z, w
#define glRasterPos4s_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z, GLshort w
#define forward_glRasterPos4s(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4s(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glRasterPos4s(packed, ret_v) do { \
    glRasterPos4s_PACKED *unpacked = (glRasterPos4s_PACKED *)packed; \
    glRasterPos4s_ARGS *args = (glRasterPos4s_ARGS *)&unpacked->args; \
    glRasterPos4s(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4s(glRasterPos4s_ARG_EXPAND);
packed_call_t *pack_glRasterPos4s(glRasterPos4s_PACKED *_dst glRasterPos4s_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4s_PTR)(glRasterPos4s_ARG_EXPAND);
#endif
#ifndef glRasterPos4sv_RETURN
#define glRasterPos4sv_RETURN void
#define glRasterPos4sv_ARG_NAMES v
#define glRasterPos4sv_ARG_EXPAND const GLshort * v
#define glRasterPos4sv_ARG_NAMES_TAIL , v
#define glRasterPos4sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glRasterPos4sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4sv(dst, _v), NULL); \
    });
#define call_glRasterPos4sv(packed, ret_v) do { \
    glRasterPos4sv_PACKED *unpacked = (glRasterPos4sv_PACKED *)packed; \
    glRasterPos4sv_ARGS *args = (glRasterPos4sv_ARGS *)&unpacked->args; \
    glRasterPos4sv(args->v);; \
} while(0)
void glRasterPos4sv(glRasterPos4sv_ARG_EXPAND);
packed_call_t *pack_glRasterPos4sv(glRasterPos4sv_PACKED *_dst glRasterPos4sv_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4sv_PTR)(glRasterPos4sv_ARG_EXPAND);
#endif
#ifndef glRasterPos4xOES_RETURN
#define glRasterPos4xOES_RETURN void
#define glRasterPos4xOES_ARG_NAMES x, y, z, w
#define glRasterPos4xOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z, GLfixed w
#define glRasterPos4xOES_ARG_NAMES_TAIL , x, y, z, w
#define glRasterPos4xOES_ARG_EXPAND_TAIL , GLfixed x, GLfixed y, GLfixed z, GLfixed w
#define forward_glRasterPos4xOES(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4xOES(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glRasterPos4xOES(packed, ret_v) do { \
    glRasterPos4xOES_PACKED *unpacked = (glRasterPos4xOES_PACKED *)packed; \
    glRasterPos4xOES_ARGS *args = (glRasterPos4xOES_ARGS *)&unpacked->args; \
    glRasterPos4xOES(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4xOES(glRasterPos4xOES_ARG_EXPAND);
packed_call_t *pack_glRasterPos4xOES(glRasterPos4xOES_PACKED *_dst glRasterPos4xOES_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4xOES_PTR)(glRasterPos4xOES_ARG_EXPAND);
#endif
#ifndef glRasterPos4xvOES_RETURN
#define glRasterPos4xvOES_RETURN void
#define glRasterPos4xvOES_ARG_NAMES coords
#define glRasterPos4xvOES_ARG_EXPAND const GLfixed * coords
#define glRasterPos4xvOES_ARG_NAMES_TAIL , coords
#define glRasterPos4xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glRasterPos4xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glRasterPos4xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRasterPos4xvOES(dst, _coords), NULL); \
    });
#define call_glRasterPos4xvOES(packed, ret_v) do { \
    glRasterPos4xvOES_PACKED *unpacked = (glRasterPos4xvOES_PACKED *)packed; \
    glRasterPos4xvOES_ARGS *args = (glRasterPos4xvOES_ARGS *)&unpacked->args; \
    glRasterPos4xvOES(args->coords);; \
} while(0)
void glRasterPos4xvOES(glRasterPos4xvOES_ARG_EXPAND);
packed_call_t *pack_glRasterPos4xvOES(glRasterPos4xvOES_PACKED *_dst glRasterPos4xvOES_ARG_EXPAND_TAIL);
typedef void (*glRasterPos4xvOES_PTR)(glRasterPos4xvOES_ARG_EXPAND);
#endif
#ifndef glReadBuffer_RETURN
#define glReadBuffer_RETURN void
#define glReadBuffer_ARG_NAMES mode
#define glReadBuffer_ARG_EXPAND GLenum mode
#define glReadBuffer_ARG_NAMES_TAIL , mode
#define glReadBuffer_ARG_EXPAND_TAIL , GLenum mode
#define forward_glReadBuffer(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glReadBuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReadBuffer(dst, _mode), NULL); \
    });
#define call_glReadBuffer(packed, ret_v) do { \
    glReadBuffer_PACKED *unpacked = (glReadBuffer_PACKED *)packed; \
    glReadBuffer_ARGS *args = (glReadBuffer_ARGS *)&unpacked->args; \
    glReadBuffer(args->mode);; \
} while(0)
void glReadBuffer(glReadBuffer_ARG_EXPAND);
packed_call_t *pack_glReadBuffer(glReadBuffer_PACKED *_dst glReadBuffer_ARG_EXPAND_TAIL);
typedef void (*glReadBuffer_PTR)(glReadBuffer_ARG_EXPAND);
#endif
#ifndef glReadInstrumentsSGIX_RETURN
#define glReadInstrumentsSGIX_RETURN void
#define glReadInstrumentsSGIX_ARG_NAMES marker
#define glReadInstrumentsSGIX_ARG_EXPAND GLint marker
#define glReadInstrumentsSGIX_ARG_NAMES_TAIL , marker
#define glReadInstrumentsSGIX_ARG_EXPAND_TAIL , GLint marker
#define forward_glReadInstrumentsSGIX(_marker) \
    ({ \
        void *dst = remote_dma(sizeof(glReadInstrumentsSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReadInstrumentsSGIX(dst, _marker), NULL); \
    });
#define call_glReadInstrumentsSGIX(packed, ret_v) do { \
    glReadInstrumentsSGIX_PACKED *unpacked = (glReadInstrumentsSGIX_PACKED *)packed; \
    glReadInstrumentsSGIX_ARGS *args = (glReadInstrumentsSGIX_ARGS *)&unpacked->args; \
    glReadInstrumentsSGIX(args->marker);; \
} while(0)
void glReadInstrumentsSGIX(glReadInstrumentsSGIX_ARG_EXPAND);
packed_call_t *pack_glReadInstrumentsSGIX(glReadInstrumentsSGIX_PACKED *_dst glReadInstrumentsSGIX_ARG_EXPAND_TAIL);
typedef void (*glReadInstrumentsSGIX_PTR)(glReadInstrumentsSGIX_ARG_EXPAND);
#endif
#ifndef glReadPixels_RETURN
#define glReadPixels_RETURN void
#define glReadPixels_ARG_NAMES x, y, width, height, format, type, pixels
#define glReadPixels_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels
#define glReadPixels_ARG_NAMES_TAIL , x, y, width, height, format, type, pixels
#define glReadPixels_ARG_EXPAND_TAIL , GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels
#define forward_glReadPixels(_x, _y, _width, _height, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glReadPixels_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReadPixels(dst, _x, _y, _width, _height, _format, _type, _pixels), NULL); \
    });
#define call_glReadPixels(packed, ret_v) do { \
    glReadPixels_PACKED *unpacked = (glReadPixels_PACKED *)packed; \
    glReadPixels_ARGS *args = (glReadPixels_ARGS *)&unpacked->args; \
    glReadPixels(args->x, args->y, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glReadPixels(glReadPixels_ARG_EXPAND);
packed_call_t *pack_glReadPixels(glReadPixels_PACKED *_dst glReadPixels_ARG_EXPAND_TAIL);
typedef void (*glReadPixels_PTR)(glReadPixels_ARG_EXPAND);
#endif
#ifndef glReadnPixelsARB_RETURN
#define glReadnPixelsARB_RETURN void
#define glReadnPixelsARB_ARG_NAMES x, y, width, height, format, type, bufSize, data
#define glReadnPixelsARB_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data
#define glReadnPixelsARB_ARG_NAMES_TAIL , x, y, width, height, format, type, bufSize, data
#define glReadnPixelsARB_ARG_EXPAND_TAIL , GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data
#define forward_glReadnPixelsARB(_x, _y, _width, _height, _format, _type, _bufSize, _data) \
    ({ \
        void *dst = remote_dma(sizeof(glReadnPixelsARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReadnPixelsARB(dst, _x, _y, _width, _height, _format, _type, _bufSize, _data), NULL); \
    });
#define call_glReadnPixelsARB(packed, ret_v) do { \
    glReadnPixelsARB_PACKED *unpacked = (glReadnPixelsARB_PACKED *)packed; \
    glReadnPixelsARB_ARGS *args = (glReadnPixelsARB_ARGS *)&unpacked->args; \
    glReadnPixelsARB(args->x, args->y, args->width, args->height, args->format, args->type, args->bufSize, args->data);; \
} while(0)
void glReadnPixelsARB(glReadnPixelsARB_ARG_EXPAND);
packed_call_t *pack_glReadnPixelsARB(glReadnPixelsARB_PACKED *_dst glReadnPixelsARB_ARG_EXPAND_TAIL);
typedef void (*glReadnPixelsARB_PTR)(glReadnPixelsARB_ARG_EXPAND);
#endif
#ifndef glRectd_RETURN
#define glRectd_RETURN void
#define glRectd_ARG_NAMES x1, y1, x2, y2
#define glRectd_ARG_EXPAND GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2
#define glRectd_ARG_NAMES_TAIL , x1, y1, x2, y2
#define glRectd_ARG_EXPAND_TAIL , GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2
#define forward_glRectd(_x1, _y1, _x2, _y2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectd_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectd(dst, _x1, _y1, _x2, _y2), NULL); \
    });
#define call_glRectd(packed, ret_v) do { \
    glRectd_PACKED *unpacked = (glRectd_PACKED *)packed; \
    glRectd_ARGS *args = (glRectd_ARGS *)&unpacked->args; \
    glRectd(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRectd(glRectd_ARG_EXPAND);
packed_call_t *pack_glRectd(glRectd_PACKED *_dst glRectd_ARG_EXPAND_TAIL);
typedef void (*glRectd_PTR)(glRectd_ARG_EXPAND);
#endif
#ifndef glRectdv_RETURN
#define glRectdv_RETURN void
#define glRectdv_ARG_NAMES v1, v2
#define glRectdv_ARG_EXPAND const GLdouble * v1, const GLdouble * v2
#define glRectdv_ARG_NAMES_TAIL , v1, v2
#define glRectdv_ARG_EXPAND_TAIL , const GLdouble * v1, const GLdouble * v2
#define forward_glRectdv(_v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectdv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectdv(dst, _v1, _v2), NULL); \
    });
#define call_glRectdv(packed, ret_v) do { \
    glRectdv_PACKED *unpacked = (glRectdv_PACKED *)packed; \
    glRectdv_ARGS *args = (glRectdv_ARGS *)&unpacked->args; \
    glRectdv(args->v1, args->v2);; \
} while(0)
void glRectdv(glRectdv_ARG_EXPAND);
packed_call_t *pack_glRectdv(glRectdv_PACKED *_dst glRectdv_ARG_EXPAND_TAIL);
typedef void (*glRectdv_PTR)(glRectdv_ARG_EXPAND);
#endif
#ifndef glRectf_RETURN
#define glRectf_RETURN void
#define glRectf_ARG_NAMES x1, y1, x2, y2
#define glRectf_ARG_EXPAND GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2
#define glRectf_ARG_NAMES_TAIL , x1, y1, x2, y2
#define glRectf_ARG_EXPAND_TAIL , GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2
#define forward_glRectf(_x1, _y1, _x2, _y2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectf(dst, _x1, _y1, _x2, _y2), NULL); \
    });
#define call_glRectf(packed, ret_v) do { \
    glRectf_PACKED *unpacked = (glRectf_PACKED *)packed; \
    glRectf_ARGS *args = (glRectf_ARGS *)&unpacked->args; \
    glRectf(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRectf(glRectf_ARG_EXPAND);
packed_call_t *pack_glRectf(glRectf_PACKED *_dst glRectf_ARG_EXPAND_TAIL);
typedef void (*glRectf_PTR)(glRectf_ARG_EXPAND);
#endif
#ifndef glRectfv_RETURN
#define glRectfv_RETURN void
#define glRectfv_ARG_NAMES v1, v2
#define glRectfv_ARG_EXPAND const GLfloat * v1, const GLfloat * v2
#define glRectfv_ARG_NAMES_TAIL , v1, v2
#define glRectfv_ARG_EXPAND_TAIL , const GLfloat * v1, const GLfloat * v2
#define forward_glRectfv(_v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectfv(dst, _v1, _v2), NULL); \
    });
#define call_glRectfv(packed, ret_v) do { \
    glRectfv_PACKED *unpacked = (glRectfv_PACKED *)packed; \
    glRectfv_ARGS *args = (glRectfv_ARGS *)&unpacked->args; \
    glRectfv(args->v1, args->v2);; \
} while(0)
void glRectfv(glRectfv_ARG_EXPAND);
packed_call_t *pack_glRectfv(glRectfv_PACKED *_dst glRectfv_ARG_EXPAND_TAIL);
typedef void (*glRectfv_PTR)(glRectfv_ARG_EXPAND);
#endif
#ifndef glRecti_RETURN
#define glRecti_RETURN void
#define glRecti_ARG_NAMES x1, y1, x2, y2
#define glRecti_ARG_EXPAND GLint x1, GLint y1, GLint x2, GLint y2
#define glRecti_ARG_NAMES_TAIL , x1, y1, x2, y2
#define glRecti_ARG_EXPAND_TAIL , GLint x1, GLint y1, GLint x2, GLint y2
#define forward_glRecti(_x1, _y1, _x2, _y2) \
    ({ \
        void *dst = remote_dma(sizeof(glRecti_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRecti(dst, _x1, _y1, _x2, _y2), NULL); \
    });
#define call_glRecti(packed, ret_v) do { \
    glRecti_PACKED *unpacked = (glRecti_PACKED *)packed; \
    glRecti_ARGS *args = (glRecti_ARGS *)&unpacked->args; \
    glRecti(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRecti(glRecti_ARG_EXPAND);
packed_call_t *pack_glRecti(glRecti_PACKED *_dst glRecti_ARG_EXPAND_TAIL);
typedef void (*glRecti_PTR)(glRecti_ARG_EXPAND);
#endif
#ifndef glRectiv_RETURN
#define glRectiv_RETURN void
#define glRectiv_ARG_NAMES v1, v2
#define glRectiv_ARG_EXPAND const GLint * v1, const GLint * v2
#define glRectiv_ARG_NAMES_TAIL , v1, v2
#define glRectiv_ARG_EXPAND_TAIL , const GLint * v1, const GLint * v2
#define forward_glRectiv(_v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectiv(dst, _v1, _v2), NULL); \
    });
#define call_glRectiv(packed, ret_v) do { \
    glRectiv_PACKED *unpacked = (glRectiv_PACKED *)packed; \
    glRectiv_ARGS *args = (glRectiv_ARGS *)&unpacked->args; \
    glRectiv(args->v1, args->v2);; \
} while(0)
void glRectiv(glRectiv_ARG_EXPAND);
packed_call_t *pack_glRectiv(glRectiv_PACKED *_dst glRectiv_ARG_EXPAND_TAIL);
typedef void (*glRectiv_PTR)(glRectiv_ARG_EXPAND);
#endif
#ifndef glRects_RETURN
#define glRects_RETURN void
#define glRects_ARG_NAMES x1, y1, x2, y2
#define glRects_ARG_EXPAND GLshort x1, GLshort y1, GLshort x2, GLshort y2
#define glRects_ARG_NAMES_TAIL , x1, y1, x2, y2
#define glRects_ARG_EXPAND_TAIL , GLshort x1, GLshort y1, GLshort x2, GLshort y2
#define forward_glRects(_x1, _y1, _x2, _y2) \
    ({ \
        void *dst = remote_dma(sizeof(glRects_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRects(dst, _x1, _y1, _x2, _y2), NULL); \
    });
#define call_glRects(packed, ret_v) do { \
    glRects_PACKED *unpacked = (glRects_PACKED *)packed; \
    glRects_ARGS *args = (glRects_ARGS *)&unpacked->args; \
    glRects(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRects(glRects_ARG_EXPAND);
packed_call_t *pack_glRects(glRects_PACKED *_dst glRects_ARG_EXPAND_TAIL);
typedef void (*glRects_PTR)(glRects_ARG_EXPAND);
#endif
#ifndef glRectsv_RETURN
#define glRectsv_RETURN void
#define glRectsv_ARG_NAMES v1, v2
#define glRectsv_ARG_EXPAND const GLshort * v1, const GLshort * v2
#define glRectsv_ARG_NAMES_TAIL , v1, v2
#define glRectsv_ARG_EXPAND_TAIL , const GLshort * v1, const GLshort * v2
#define forward_glRectsv(_v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectsv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectsv(dst, _v1, _v2), NULL); \
    });
#define call_glRectsv(packed, ret_v) do { \
    glRectsv_PACKED *unpacked = (glRectsv_PACKED *)packed; \
    glRectsv_ARGS *args = (glRectsv_ARGS *)&unpacked->args; \
    glRectsv(args->v1, args->v2);; \
} while(0)
void glRectsv(glRectsv_ARG_EXPAND);
packed_call_t *pack_glRectsv(glRectsv_PACKED *_dst glRectsv_ARG_EXPAND_TAIL);
typedef void (*glRectsv_PTR)(glRectsv_ARG_EXPAND);
#endif
#ifndef glRectxOES_RETURN
#define glRectxOES_RETURN void
#define glRectxOES_ARG_NAMES x1, y1, x2, y2
#define glRectxOES_ARG_EXPAND GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2
#define glRectxOES_ARG_NAMES_TAIL , x1, y1, x2, y2
#define glRectxOES_ARG_EXPAND_TAIL , GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2
#define forward_glRectxOES(_x1, _y1, _x2, _y2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectxOES(dst, _x1, _y1, _x2, _y2), NULL); \
    });
#define call_glRectxOES(packed, ret_v) do { \
    glRectxOES_PACKED *unpacked = (glRectxOES_PACKED *)packed; \
    glRectxOES_ARGS *args = (glRectxOES_ARGS *)&unpacked->args; \
    glRectxOES(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRectxOES(glRectxOES_ARG_EXPAND);
packed_call_t *pack_glRectxOES(glRectxOES_PACKED *_dst glRectxOES_ARG_EXPAND_TAIL);
typedef void (*glRectxOES_PTR)(glRectxOES_ARG_EXPAND);
#endif
#ifndef glRectxvOES_RETURN
#define glRectxvOES_RETURN void
#define glRectxvOES_ARG_NAMES v1, v2
#define glRectxvOES_ARG_EXPAND const GLfixed * v1, const GLfixed * v2
#define glRectxvOES_ARG_NAMES_TAIL , v1, v2
#define glRectxvOES_ARG_EXPAND_TAIL , const GLfixed * v1, const GLfixed * v2
#define forward_glRectxvOES(_v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glRectxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRectxvOES(dst, _v1, _v2), NULL); \
    });
#define call_glRectxvOES(packed, ret_v) do { \
    glRectxvOES_PACKED *unpacked = (glRectxvOES_PACKED *)packed; \
    glRectxvOES_ARGS *args = (glRectxvOES_ARGS *)&unpacked->args; \
    glRectxvOES(args->v1, args->v2);; \
} while(0)
void glRectxvOES(glRectxvOES_ARG_EXPAND);
packed_call_t *pack_glRectxvOES(glRectxvOES_PACKED *_dst glRectxvOES_ARG_EXPAND_TAIL);
typedef void (*glRectxvOES_PTR)(glRectxvOES_ARG_EXPAND);
#endif
#ifndef glReferencePlaneSGIX_RETURN
#define glReferencePlaneSGIX_RETURN void
#define glReferencePlaneSGIX_ARG_NAMES equation
#define glReferencePlaneSGIX_ARG_EXPAND const GLdouble * equation
#define glReferencePlaneSGIX_ARG_NAMES_TAIL , equation
#define glReferencePlaneSGIX_ARG_EXPAND_TAIL , const GLdouble * equation
#define forward_glReferencePlaneSGIX(_equation) \
    ({ \
        void *dst = remote_dma(sizeof(glReferencePlaneSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReferencePlaneSGIX(dst, _equation), NULL); \
    });
#define call_glReferencePlaneSGIX(packed, ret_v) do { \
    glReferencePlaneSGIX_PACKED *unpacked = (glReferencePlaneSGIX_PACKED *)packed; \
    glReferencePlaneSGIX_ARGS *args = (glReferencePlaneSGIX_ARGS *)&unpacked->args; \
    glReferencePlaneSGIX(args->equation);; \
} while(0)
void glReferencePlaneSGIX(glReferencePlaneSGIX_ARG_EXPAND);
packed_call_t *pack_glReferencePlaneSGIX(glReferencePlaneSGIX_PACKED *_dst glReferencePlaneSGIX_ARG_EXPAND_TAIL);
typedef void (*glReferencePlaneSGIX_PTR)(glReferencePlaneSGIX_ARG_EXPAND);
#endif
#ifndef glReleaseShaderCompiler_RETURN
#define glReleaseShaderCompiler_RETURN void
#define glReleaseShaderCompiler_ARG_NAMES 
#define glReleaseShaderCompiler_ARG_EXPAND 
#define glReleaseShaderCompiler_ARG_NAMES_TAIL 
#define glReleaseShaderCompiler_ARG_EXPAND_TAIL 
#define forward_glReleaseShaderCompiler() \
    ({ \
        void *dst = remote_dma(sizeof(glReleaseShaderCompiler_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReleaseShaderCompiler(dst), NULL); \
    });
#define call_glReleaseShaderCompiler(packed, ret_v) do { \
    glReleaseShaderCompiler();; \
} while(0)
void glReleaseShaderCompiler(glReleaseShaderCompiler_ARG_EXPAND);
packed_call_t *pack_glReleaseShaderCompiler(glReleaseShaderCompiler_PACKED *_dst glReleaseShaderCompiler_ARG_EXPAND_TAIL);
typedef void (*glReleaseShaderCompiler_PTR)(glReleaseShaderCompiler_ARG_EXPAND);
#endif
#ifndef glRenderMode_RETURN
#define glRenderMode_RETURN GLint
#define glRenderMode_ARG_NAMES mode
#define glRenderMode_ARG_EXPAND GLenum mode
#define glRenderMode_ARG_NAMES_TAIL , mode
#define glRenderMode_ARG_EXPAND_TAIL , GLenum mode
#define forward_glRenderMode(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glRenderMode_PACKED)); \
        GLint ret = (GLint)0; \
        remote_dma_send((packed_call_t *)pack_glRenderMode(dst, _mode), &ret); \
        ret; \
    });
#define call_glRenderMode(packed, ret_v) do { \
    glRenderMode_PACKED *unpacked = (glRenderMode_PACKED *)packed; \
    glRenderMode_ARGS *args = (glRenderMode_ARGS *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glRenderMode(args->mode);; \
    } else { \
        glRenderMode(args->mode);; \
    } \
} while(0)
GLint glRenderMode(glRenderMode_ARG_EXPAND);
packed_call_t *pack_glRenderMode(glRenderMode_PACKED *_dst glRenderMode_ARG_EXPAND_TAIL);
typedef GLint (*glRenderMode_PTR)(glRenderMode_ARG_EXPAND);
#endif
#ifndef glRenderbufferStorage_RETURN
#define glRenderbufferStorage_RETURN void
#define glRenderbufferStorage_ARG_NAMES target, internalformat, width, height
#define glRenderbufferStorage_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorage_ARG_NAMES_TAIL , target, internalformat, width, height
#define glRenderbufferStorage_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glRenderbufferStorage(_target, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glRenderbufferStorage_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRenderbufferStorage(dst, _target, _internalformat, _width, _height), NULL); \
    });
#define call_glRenderbufferStorage(packed, ret_v) do { \
    glRenderbufferStorage_PACKED *unpacked = (glRenderbufferStorage_PACKED *)packed; \
    glRenderbufferStorage_ARGS *args = (glRenderbufferStorage_ARGS *)&unpacked->args; \
    glRenderbufferStorage(args->target, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorage(glRenderbufferStorage_ARG_EXPAND);
packed_call_t *pack_glRenderbufferStorage(glRenderbufferStorage_PACKED *_dst glRenderbufferStorage_ARG_EXPAND_TAIL);
typedef void (*glRenderbufferStorage_PTR)(glRenderbufferStorage_ARG_EXPAND);
#endif
#ifndef glRenderbufferStorageEXT_RETURN
#define glRenderbufferStorageEXT_RETURN void
#define glRenderbufferStorageEXT_ARG_NAMES target, internalformat, width, height
#define glRenderbufferStorageEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageEXT_ARG_NAMES_TAIL , target, internalformat, width, height
#define glRenderbufferStorageEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glRenderbufferStorageEXT(_target, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glRenderbufferStorageEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRenderbufferStorageEXT(dst, _target, _internalformat, _width, _height), NULL); \
    });
#define call_glRenderbufferStorageEXT(packed, ret_v) do { \
    glRenderbufferStorageEXT_PACKED *unpacked = (glRenderbufferStorageEXT_PACKED *)packed; \
    glRenderbufferStorageEXT_ARGS *args = (glRenderbufferStorageEXT_ARGS *)&unpacked->args; \
    glRenderbufferStorageEXT(args->target, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageEXT(glRenderbufferStorageEXT_ARG_EXPAND);
packed_call_t *pack_glRenderbufferStorageEXT(glRenderbufferStorageEXT_PACKED *_dst glRenderbufferStorageEXT_ARG_EXPAND_TAIL);
typedef void (*glRenderbufferStorageEXT_PTR)(glRenderbufferStorageEXT_ARG_EXPAND);
#endif
#ifndef glRenderbufferStorageMultisample_RETURN
#define glRenderbufferStorageMultisample_RETURN void
#define glRenderbufferStorageMultisample_ARG_NAMES target, samples, internalformat, width, height
#define glRenderbufferStorageMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageMultisample_ARG_NAMES_TAIL , target, samples, internalformat, width, height
#define glRenderbufferStorageMultisample_ARG_EXPAND_TAIL , GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glRenderbufferStorageMultisample(_target, _samples, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glRenderbufferStorageMultisample_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRenderbufferStorageMultisample(dst, _target, _samples, _internalformat, _width, _height), NULL); \
    });
#define call_glRenderbufferStorageMultisample(packed, ret_v) do { \
    glRenderbufferStorageMultisample_PACKED *unpacked = (glRenderbufferStorageMultisample_PACKED *)packed; \
    glRenderbufferStorageMultisample_ARGS *args = (glRenderbufferStorageMultisample_ARGS *)&unpacked->args; \
    glRenderbufferStorageMultisample(args->target, args->samples, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageMultisample(glRenderbufferStorageMultisample_ARG_EXPAND);
packed_call_t *pack_glRenderbufferStorageMultisample(glRenderbufferStorageMultisample_PACKED *_dst glRenderbufferStorageMultisample_ARG_EXPAND_TAIL);
typedef void (*glRenderbufferStorageMultisample_PTR)(glRenderbufferStorageMultisample_ARG_EXPAND);
#endif
#ifndef glRenderbufferStorageMultisampleCoverageNV_RETURN
#define glRenderbufferStorageMultisampleCoverageNV_RETURN void
#define glRenderbufferStorageMultisampleCoverageNV_ARG_NAMES target, coverageSamples, colorSamples, internalformat, width, height
#define glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageMultisampleCoverageNV_ARG_NAMES_TAIL , target, coverageSamples, colorSamples, internalformat, width, height
#define glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND_TAIL , GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glRenderbufferStorageMultisampleCoverageNV(_target, _coverageSamples, _colorSamples, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glRenderbufferStorageMultisampleCoverageNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRenderbufferStorageMultisampleCoverageNV(dst, _target, _coverageSamples, _colorSamples, _internalformat, _width, _height), NULL); \
    });
#define call_glRenderbufferStorageMultisampleCoverageNV(packed, ret_v) do { \
    glRenderbufferStorageMultisampleCoverageNV_PACKED *unpacked = (glRenderbufferStorageMultisampleCoverageNV_PACKED *)packed; \
    glRenderbufferStorageMultisampleCoverageNV_ARGS *args = (glRenderbufferStorageMultisampleCoverageNV_ARGS *)&unpacked->args; \
    glRenderbufferStorageMultisampleCoverageNV(args->target, args->coverageSamples, args->colorSamples, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageMultisampleCoverageNV(glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND);
packed_call_t *pack_glRenderbufferStorageMultisampleCoverageNV(glRenderbufferStorageMultisampleCoverageNV_PACKED *_dst glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND_TAIL);
typedef void (*glRenderbufferStorageMultisampleCoverageNV_PTR)(glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND);
#endif
#ifndef glRenderbufferStorageMultisampleEXT_RETURN
#define glRenderbufferStorageMultisampleEXT_RETURN void
#define glRenderbufferStorageMultisampleEXT_ARG_NAMES target, samples, internalformat, width, height
#define glRenderbufferStorageMultisampleEXT_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageMultisampleEXT_ARG_NAMES_TAIL , target, samples, internalformat, width, height
#define glRenderbufferStorageMultisampleEXT_ARG_EXPAND_TAIL , GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glRenderbufferStorageMultisampleEXT(_target, _samples, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glRenderbufferStorageMultisampleEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRenderbufferStorageMultisampleEXT(dst, _target, _samples, _internalformat, _width, _height), NULL); \
    });
#define call_glRenderbufferStorageMultisampleEXT(packed, ret_v) do { \
    glRenderbufferStorageMultisampleEXT_PACKED *unpacked = (glRenderbufferStorageMultisampleEXT_PACKED *)packed; \
    glRenderbufferStorageMultisampleEXT_ARGS *args = (glRenderbufferStorageMultisampleEXT_ARGS *)&unpacked->args; \
    glRenderbufferStorageMultisampleEXT(args->target, args->samples, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageMultisampleEXT(glRenderbufferStorageMultisampleEXT_ARG_EXPAND);
packed_call_t *pack_glRenderbufferStorageMultisampleEXT(glRenderbufferStorageMultisampleEXT_PACKED *_dst glRenderbufferStorageMultisampleEXT_ARG_EXPAND_TAIL);
typedef void (*glRenderbufferStorageMultisampleEXT_PTR)(glRenderbufferStorageMultisampleEXT_ARG_EXPAND);
#endif
#ifndef glReplacementCodePointerSUN_RETURN
#define glReplacementCodePointerSUN_RETURN void
#define glReplacementCodePointerSUN_ARG_NAMES type, stride, pointer
#define glReplacementCodePointerSUN_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glReplacementCodePointerSUN_ARG_NAMES_TAIL , type, stride, pointer
#define glReplacementCodePointerSUN_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glReplacementCodePointerSUN(_type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodePointerSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodePointerSUN(dst, _type, _stride, _pointer), NULL); \
    });
#define call_glReplacementCodePointerSUN(packed, ret_v) do { \
    glReplacementCodePointerSUN_PACKED *unpacked = (glReplacementCodePointerSUN_PACKED *)packed; \
    glReplacementCodePointerSUN_ARGS *args = (glReplacementCodePointerSUN_ARGS *)&unpacked->args; \
    glReplacementCodePointerSUN(args->type, args->stride, args->pointer);; \
} while(0)
void glReplacementCodePointerSUN(glReplacementCodePointerSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodePointerSUN(glReplacementCodePointerSUN_PACKED *_dst glReplacementCodePointerSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodePointerSUN_PTR)(glReplacementCodePointerSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeubSUN_RETURN
#define glReplacementCodeubSUN_RETURN void
#define glReplacementCodeubSUN_ARG_NAMES code
#define glReplacementCodeubSUN_ARG_EXPAND GLubyte code
#define glReplacementCodeubSUN_ARG_NAMES_TAIL , code
#define glReplacementCodeubSUN_ARG_EXPAND_TAIL , GLubyte code
#define forward_glReplacementCodeubSUN(_code) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeubSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeubSUN(dst, _code), NULL); \
    });
#define call_glReplacementCodeubSUN(packed, ret_v) do { \
    glReplacementCodeubSUN_PACKED *unpacked = (glReplacementCodeubSUN_PACKED *)packed; \
    glReplacementCodeubSUN_ARGS *args = (glReplacementCodeubSUN_ARGS *)&unpacked->args; \
    glReplacementCodeubSUN(args->code);; \
} while(0)
void glReplacementCodeubSUN(glReplacementCodeubSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeubSUN(glReplacementCodeubSUN_PACKED *_dst glReplacementCodeubSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeubSUN_PTR)(glReplacementCodeubSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeubvSUN_RETURN
#define glReplacementCodeubvSUN_RETURN void
#define glReplacementCodeubvSUN_ARG_NAMES code
#define glReplacementCodeubvSUN_ARG_EXPAND const GLubyte * code
#define glReplacementCodeubvSUN_ARG_NAMES_TAIL , code
#define glReplacementCodeubvSUN_ARG_EXPAND_TAIL , const GLubyte * code
#define forward_glReplacementCodeubvSUN(_code) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeubvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeubvSUN(dst, _code), NULL); \
    });
#define call_glReplacementCodeubvSUN(packed, ret_v) do { \
    glReplacementCodeubvSUN_PACKED *unpacked = (glReplacementCodeubvSUN_PACKED *)packed; \
    glReplacementCodeubvSUN_ARGS *args = (glReplacementCodeubvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeubvSUN(args->code);; \
} while(0)
void glReplacementCodeubvSUN(glReplacementCodeubvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeubvSUN(glReplacementCodeubvSUN_PACKED *_dst glReplacementCodeubvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeubvSUN_PTR)(glReplacementCodeubvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiColor3fVertex3fSUN_RETURN
#define glReplacementCodeuiColor3fVertex3fSUN_RETURN void
#define glReplacementCodeuiColor3fVertex3fSUN_ARG_NAMES rc, r, g, b, x, y, z
#define glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiColor3fVertex3fSUN_ARG_NAMES_TAIL , rc, r, g, b, x, y, z
#define glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiColor3fVertex3fSUN(_rc, _r, _g, _b, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiColor3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiColor3fVertex3fSUN(dst, _rc, _r, _g, _b, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiColor3fVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiColor3fVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiColor3fVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiColor3fVertex3fSUN_ARGS *args = (glReplacementCodeuiColor3fVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiColor3fVertex3fSUN(args->rc, args->r, args->g, args->b, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiColor3fVertex3fSUN(glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiColor3fVertex3fSUN(glReplacementCodeuiColor3fVertex3fSUN_PACKED *_dst glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiColor3fVertex3fSUN_PTR)(glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiColor3fVertex3fvSUN_RETURN
#define glReplacementCodeuiColor3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiColor3fVertex3fvSUN_ARG_NAMES rc, c, v
#define glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * c, const GLfloat * v
#define glReplacementCodeuiColor3fVertex3fvSUN_ARG_NAMES_TAIL , rc, c, v
#define glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLfloat * c, const GLfloat * v
#define forward_glReplacementCodeuiColor3fVertex3fvSUN(_rc, _c, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiColor3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiColor3fVertex3fvSUN(dst, _rc, _c, _v), NULL); \
    });
#define call_glReplacementCodeuiColor3fVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiColor3fVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiColor3fVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiColor3fVertex3fvSUN_ARGS *args = (glReplacementCodeuiColor3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiColor3fVertex3fvSUN(args->rc, args->c, args->v);; \
} while(0)
void glReplacementCodeuiColor3fVertex3fvSUN(glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiColor3fVertex3fvSUN(glReplacementCodeuiColor3fVertex3fvSUN_PACKED *_dst glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiColor3fVertex3fvSUN_PTR)(glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiColor4fNormal3fVertex3fSUN_RETURN
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_NAMES rc, r, g, b, a, nx, ny, nz, x, y, z
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_NAMES_TAIL , rc, r, g, b, a, nx, ny, nz, x, y, z
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiColor4fNormal3fVertex3fSUN(_rc, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiColor4fNormal3fVertex3fSUN(dst, _rc, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARGS *args = (glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiColor4fNormal3fVertex3fSUN(args->rc, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiColor4fNormal3fVertex3fSUN(glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiColor4fNormal3fVertex3fSUN(glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED *_dst glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiColor4fNormal3fVertex3fSUN_PTR)(glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiColor4fNormal3fVertex3fvSUN_RETURN
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_NAMES rc, c, n, v
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_NAMES_TAIL , rc, c, n, v
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define forward_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(_rc, _c, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(dst, _rc, _c, _n, _v), NULL); \
    });
#define call_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARGS *args = (glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiColor4fNormal3fVertex3fvSUN(args->rc, args->c, args->n, args->v);; \
} while(0)
void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED *_dst glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiColor4ubVertex3fSUN_RETURN
#define glReplacementCodeuiColor4ubVertex3fSUN_RETURN void
#define glReplacementCodeuiColor4ubVertex3fSUN_ARG_NAMES rc, r, g, b, a, x, y, z
#define glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiColor4ubVertex3fSUN_ARG_NAMES_TAIL , rc, r, g, b, a, x, y, z
#define glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiColor4ubVertex3fSUN(_rc, _r, _g, _b, _a, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiColor4ubVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiColor4ubVertex3fSUN(dst, _rc, _r, _g, _b, _a, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiColor4ubVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiColor4ubVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiColor4ubVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiColor4ubVertex3fSUN_ARGS *args = (glReplacementCodeuiColor4ubVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiColor4ubVertex3fSUN(args->rc, args->r, args->g, args->b, args->a, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiColor4ubVertex3fSUN(glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiColor4ubVertex3fSUN(glReplacementCodeuiColor4ubVertex3fSUN_PACKED *_dst glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiColor4ubVertex3fSUN_PTR)(glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiColor4ubVertex3fvSUN_RETURN
#define glReplacementCodeuiColor4ubVertex3fvSUN_RETURN void
#define glReplacementCodeuiColor4ubVertex3fvSUN_ARG_NAMES rc, c, v
#define glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLubyte * c, const GLfloat * v
#define glReplacementCodeuiColor4ubVertex3fvSUN_ARG_NAMES_TAIL , rc, c, v
#define glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLubyte * c, const GLfloat * v
#define forward_glReplacementCodeuiColor4ubVertex3fvSUN(_rc, _c, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiColor4ubVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiColor4ubVertex3fvSUN(dst, _rc, _c, _v), NULL); \
    });
#define call_glReplacementCodeuiColor4ubVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiColor4ubVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiColor4ubVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiColor4ubVertex3fvSUN_ARGS *args = (glReplacementCodeuiColor4ubVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiColor4ubVertex3fvSUN(args->rc, args->c, args->v);; \
} while(0)
void glReplacementCodeuiColor4ubVertex3fvSUN(glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiColor4ubVertex3fvSUN(glReplacementCodeuiColor4ubVertex3fvSUN_PACKED *_dst glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiColor4ubVertex3fvSUN_PTR)(glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiNormal3fVertex3fSUN_RETURN
#define glReplacementCodeuiNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiNormal3fVertex3fSUN_ARG_NAMES rc, nx, ny, nz, x, y, z
#define glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiNormal3fVertex3fSUN_ARG_NAMES_TAIL , rc, nx, ny, nz, x, y, z
#define glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiNormal3fVertex3fSUN(_rc, _nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiNormal3fVertex3fSUN(dst, _rc, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiNormal3fVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiNormal3fVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiNormal3fVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiNormal3fVertex3fSUN_ARGS *args = (glReplacementCodeuiNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiNormal3fVertex3fSUN(args->rc, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiNormal3fVertex3fSUN(glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiNormal3fVertex3fSUN(glReplacementCodeuiNormal3fVertex3fSUN_PACKED *_dst glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiNormal3fVertex3fSUN_PTR)(glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiNormal3fVertex3fvSUN_RETURN
#define glReplacementCodeuiNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiNormal3fVertex3fvSUN_ARG_NAMES rc, n, v
#define glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiNormal3fVertex3fvSUN_ARG_NAMES_TAIL , rc, n, v
#define glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLfloat * n, const GLfloat * v
#define forward_glReplacementCodeuiNormal3fVertex3fvSUN(_rc, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiNormal3fVertex3fvSUN(dst, _rc, _n, _v), NULL); \
    });
#define call_glReplacementCodeuiNormal3fVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiNormal3fVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiNormal3fVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiNormal3fVertex3fvSUN_ARGS *args = (glReplacementCodeuiNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiNormal3fVertex3fvSUN(args->rc, args->n, args->v);; \
} while(0)
void glReplacementCodeuiNormal3fVertex3fvSUN(glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiNormal3fVertex3fvSUN(glReplacementCodeuiNormal3fVertex3fvSUN_PACKED *_dst glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiSUN_RETURN
#define glReplacementCodeuiSUN_RETURN void
#define glReplacementCodeuiSUN_ARG_NAMES code
#define glReplacementCodeuiSUN_ARG_EXPAND GLuint code
#define glReplacementCodeuiSUN_ARG_NAMES_TAIL , code
#define glReplacementCodeuiSUN_ARG_EXPAND_TAIL , GLuint code
#define forward_glReplacementCodeuiSUN(_code) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiSUN(dst, _code), NULL); \
    });
#define call_glReplacementCodeuiSUN(packed, ret_v) do { \
    glReplacementCodeuiSUN_PACKED *unpacked = (glReplacementCodeuiSUN_PACKED *)packed; \
    glReplacementCodeuiSUN_ARGS *args = (glReplacementCodeuiSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiSUN(args->code);; \
} while(0)
void glReplacementCodeuiSUN(glReplacementCodeuiSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiSUN(glReplacementCodeuiSUN_PACKED *_dst glReplacementCodeuiSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiSUN_PTR)(glReplacementCodeuiSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_RETURN
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_NAMES rc, s, t, r, g, b, a, nx, ny, nz, x, y, z
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_NAMES_TAIL , rc, s, t, r, g, b, a, nx, ny, nz, x, y, z
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(_rc, _s, _t, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(dst, _rc, _s, _t, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARGS *args = (glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(args->rc, args->s, args->t, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *_dst glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PTR)(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_NAMES rc, tc, c, n, v
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_NAMES_TAIL , rc, tc, c, n, v
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define forward_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(_rc, _tc, _c, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(dst, _rc, _tc, _c, _n, _v), NULL); \
    });
#define call_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS *args = (glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(args->rc, args->tc, args->c, args->n, args->v);; \
} while(0)
void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *_dst glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_RETURN
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_NAMES rc, s, t, nx, ny, nz, x, y, z
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_NAMES_TAIL , rc, s, t, nx, ny, nz, x, y, z
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(_rc, _s, _t, _nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(dst, _rc, _s, _t, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARGS *args = (glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(args->rc, args->s, args->t, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED *_dst glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PTR)(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_RETURN
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_NAMES rc, tc, n, v
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_NAMES_TAIL , rc, tc, n, v
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v
#define forward_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(_rc, _tc, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(dst, _rc, _tc, _n, _v), NULL); \
    });
#define call_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARGS *args = (glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(args->rc, args->tc, args->n, args->v);; \
} while(0)
void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED *_dst glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiTexCoord2fVertex3fSUN_RETURN
#define glReplacementCodeuiTexCoord2fVertex3fSUN_RETURN void
#define glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_NAMES rc, s, t, x, y, z
#define glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_NAMES_TAIL , rc, s, t, x, y, z
#define glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiTexCoord2fVertex3fSUN(_rc, _s, _t, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiTexCoord2fVertex3fSUN(dst, _rc, _s, _t, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiTexCoord2fVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiTexCoord2fVertex3fSUN_ARGS *args = (glReplacementCodeuiTexCoord2fVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fVertex3fSUN(args->rc, args->s, args->t, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiTexCoord2fVertex3fSUN(glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiTexCoord2fVertex3fSUN(glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED *_dst glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiTexCoord2fVertex3fSUN_PTR)(glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiTexCoord2fVertex3fvSUN_RETURN
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_RETURN void
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_NAMES rc, tc, v
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * tc, const GLfloat * v
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_NAMES_TAIL , rc, tc, v
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLfloat * tc, const GLfloat * v
#define forward_glReplacementCodeuiTexCoord2fVertex3fvSUN(_rc, _tc, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiTexCoord2fVertex3fvSUN(dst, _rc, _tc, _v), NULL); \
    });
#define call_glReplacementCodeuiTexCoord2fVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiTexCoord2fVertex3fvSUN_ARGS *args = (glReplacementCodeuiTexCoord2fVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fVertex3fvSUN(args->rc, args->tc, args->v);; \
} while(0)
void glReplacementCodeuiTexCoord2fVertex3fvSUN(glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiTexCoord2fVertex3fvSUN(glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED *_dst glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiTexCoord2fVertex3fvSUN_PTR)(glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiVertex3fSUN_RETURN
#define glReplacementCodeuiVertex3fSUN_RETURN void
#define glReplacementCodeuiVertex3fSUN_ARG_NAMES rc, x, y, z
#define glReplacementCodeuiVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiVertex3fSUN_ARG_NAMES_TAIL , rc, x, y, z
#define glReplacementCodeuiVertex3fSUN_ARG_EXPAND_TAIL , GLuint rc, GLfloat x, GLfloat y, GLfloat z
#define forward_glReplacementCodeuiVertex3fSUN(_rc, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiVertex3fSUN(dst, _rc, _x, _y, _z), NULL); \
    });
#define call_glReplacementCodeuiVertex3fSUN(packed, ret_v) do { \
    glReplacementCodeuiVertex3fSUN_PACKED *unpacked = (glReplacementCodeuiVertex3fSUN_PACKED *)packed; \
    glReplacementCodeuiVertex3fSUN_ARGS *args = (glReplacementCodeuiVertex3fSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiVertex3fSUN(args->rc, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiVertex3fSUN(glReplacementCodeuiVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiVertex3fSUN(glReplacementCodeuiVertex3fSUN_PACKED *_dst glReplacementCodeuiVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiVertex3fSUN_PTR)(glReplacementCodeuiVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuiVertex3fvSUN_RETURN
#define glReplacementCodeuiVertex3fvSUN_RETURN void
#define glReplacementCodeuiVertex3fvSUN_ARG_NAMES rc, v
#define glReplacementCodeuiVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * v
#define glReplacementCodeuiVertex3fvSUN_ARG_NAMES_TAIL , rc, v
#define glReplacementCodeuiVertex3fvSUN_ARG_EXPAND_TAIL , const GLuint * rc, const GLfloat * v
#define forward_glReplacementCodeuiVertex3fvSUN(_rc, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuiVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuiVertex3fvSUN(dst, _rc, _v), NULL); \
    });
#define call_glReplacementCodeuiVertex3fvSUN(packed, ret_v) do { \
    glReplacementCodeuiVertex3fvSUN_PACKED *unpacked = (glReplacementCodeuiVertex3fvSUN_PACKED *)packed; \
    glReplacementCodeuiVertex3fvSUN_ARGS *args = (glReplacementCodeuiVertex3fvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuiVertex3fvSUN(args->rc, args->v);; \
} while(0)
void glReplacementCodeuiVertex3fvSUN(glReplacementCodeuiVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuiVertex3fvSUN(glReplacementCodeuiVertex3fvSUN_PACKED *_dst glReplacementCodeuiVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuiVertex3fvSUN_PTR)(glReplacementCodeuiVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeuivSUN_RETURN
#define glReplacementCodeuivSUN_RETURN void
#define glReplacementCodeuivSUN_ARG_NAMES code
#define glReplacementCodeuivSUN_ARG_EXPAND const GLuint * code
#define glReplacementCodeuivSUN_ARG_NAMES_TAIL , code
#define glReplacementCodeuivSUN_ARG_EXPAND_TAIL , const GLuint * code
#define forward_glReplacementCodeuivSUN(_code) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeuivSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeuivSUN(dst, _code), NULL); \
    });
#define call_glReplacementCodeuivSUN(packed, ret_v) do { \
    glReplacementCodeuivSUN_PACKED *unpacked = (glReplacementCodeuivSUN_PACKED *)packed; \
    glReplacementCodeuivSUN_ARGS *args = (glReplacementCodeuivSUN_ARGS *)&unpacked->args; \
    glReplacementCodeuivSUN(args->code);; \
} while(0)
void glReplacementCodeuivSUN(glReplacementCodeuivSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeuivSUN(glReplacementCodeuivSUN_PACKED *_dst glReplacementCodeuivSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeuivSUN_PTR)(glReplacementCodeuivSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeusSUN_RETURN
#define glReplacementCodeusSUN_RETURN void
#define glReplacementCodeusSUN_ARG_NAMES code
#define glReplacementCodeusSUN_ARG_EXPAND GLushort code
#define glReplacementCodeusSUN_ARG_NAMES_TAIL , code
#define glReplacementCodeusSUN_ARG_EXPAND_TAIL , GLushort code
#define forward_glReplacementCodeusSUN(_code) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeusSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeusSUN(dst, _code), NULL); \
    });
#define call_glReplacementCodeusSUN(packed, ret_v) do { \
    glReplacementCodeusSUN_PACKED *unpacked = (glReplacementCodeusSUN_PACKED *)packed; \
    glReplacementCodeusSUN_ARGS *args = (glReplacementCodeusSUN_ARGS *)&unpacked->args; \
    glReplacementCodeusSUN(args->code);; \
} while(0)
void glReplacementCodeusSUN(glReplacementCodeusSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeusSUN(glReplacementCodeusSUN_PACKED *_dst glReplacementCodeusSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeusSUN_PTR)(glReplacementCodeusSUN_ARG_EXPAND);
#endif
#ifndef glReplacementCodeusvSUN_RETURN
#define glReplacementCodeusvSUN_RETURN void
#define glReplacementCodeusvSUN_ARG_NAMES code
#define glReplacementCodeusvSUN_ARG_EXPAND const GLushort * code
#define glReplacementCodeusvSUN_ARG_NAMES_TAIL , code
#define glReplacementCodeusvSUN_ARG_EXPAND_TAIL , const GLushort * code
#define forward_glReplacementCodeusvSUN(_code) \
    ({ \
        void *dst = remote_dma(sizeof(glReplacementCodeusvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glReplacementCodeusvSUN(dst, _code), NULL); \
    });
#define call_glReplacementCodeusvSUN(packed, ret_v) do { \
    glReplacementCodeusvSUN_PACKED *unpacked = (glReplacementCodeusvSUN_PACKED *)packed; \
    glReplacementCodeusvSUN_ARGS *args = (glReplacementCodeusvSUN_ARGS *)&unpacked->args; \
    glReplacementCodeusvSUN(args->code);; \
} while(0)
void glReplacementCodeusvSUN(glReplacementCodeusvSUN_ARG_EXPAND);
packed_call_t *pack_glReplacementCodeusvSUN(glReplacementCodeusvSUN_PACKED *_dst glReplacementCodeusvSUN_ARG_EXPAND_TAIL);
typedef void (*glReplacementCodeusvSUN_PTR)(glReplacementCodeusvSUN_ARG_EXPAND);
#endif
#ifndef glRequestResidentProgramsNV_RETURN
#define glRequestResidentProgramsNV_RETURN void
#define glRequestResidentProgramsNV_ARG_NAMES n, programs
#define glRequestResidentProgramsNV_ARG_EXPAND GLsizei n, const GLuint * programs
#define glRequestResidentProgramsNV_ARG_NAMES_TAIL , n, programs
#define glRequestResidentProgramsNV_ARG_EXPAND_TAIL , GLsizei n, const GLuint * programs
#define forward_glRequestResidentProgramsNV(_n, _programs) \
    ({ \
        void *dst = remote_dma(sizeof(glRequestResidentProgramsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRequestResidentProgramsNV(dst, _n, _programs), NULL); \
    });
#define call_glRequestResidentProgramsNV(packed, ret_v) do { \
    glRequestResidentProgramsNV_PACKED *unpacked = (glRequestResidentProgramsNV_PACKED *)packed; \
    glRequestResidentProgramsNV_ARGS *args = (glRequestResidentProgramsNV_ARGS *)&unpacked->args; \
    glRequestResidentProgramsNV(args->n, args->programs);; \
} while(0)
void glRequestResidentProgramsNV(glRequestResidentProgramsNV_ARG_EXPAND);
packed_call_t *pack_glRequestResidentProgramsNV(glRequestResidentProgramsNV_PACKED *_dst glRequestResidentProgramsNV_ARG_EXPAND_TAIL);
typedef void (*glRequestResidentProgramsNV_PTR)(glRequestResidentProgramsNV_ARG_EXPAND);
#endif
#ifndef glResetHistogram_RETURN
#define glResetHistogram_RETURN void
#define glResetHistogram_ARG_NAMES target
#define glResetHistogram_ARG_EXPAND GLenum target
#define glResetHistogram_ARG_NAMES_TAIL , target
#define glResetHistogram_ARG_EXPAND_TAIL , GLenum target
#define forward_glResetHistogram(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glResetHistogram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glResetHistogram(dst, _target), NULL); \
    });
#define call_glResetHistogram(packed, ret_v) do { \
    glResetHistogram_PACKED *unpacked = (glResetHistogram_PACKED *)packed; \
    glResetHistogram_ARGS *args = (glResetHistogram_ARGS *)&unpacked->args; \
    glResetHistogram(args->target);; \
} while(0)
void glResetHistogram(glResetHistogram_ARG_EXPAND);
packed_call_t *pack_glResetHistogram(glResetHistogram_PACKED *_dst glResetHistogram_ARG_EXPAND_TAIL);
typedef void (*glResetHistogram_PTR)(glResetHistogram_ARG_EXPAND);
#endif
#ifndef glResetHistogramEXT_RETURN
#define glResetHistogramEXT_RETURN void
#define glResetHistogramEXT_ARG_NAMES target
#define glResetHistogramEXT_ARG_EXPAND GLenum target
#define glResetHistogramEXT_ARG_NAMES_TAIL , target
#define glResetHistogramEXT_ARG_EXPAND_TAIL , GLenum target
#define forward_glResetHistogramEXT(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glResetHistogramEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glResetHistogramEXT(dst, _target), NULL); \
    });
#define call_glResetHistogramEXT(packed, ret_v) do { \
    glResetHistogramEXT_PACKED *unpacked = (glResetHistogramEXT_PACKED *)packed; \
    glResetHistogramEXT_ARGS *args = (glResetHistogramEXT_ARGS *)&unpacked->args; \
    glResetHistogramEXT(args->target);; \
} while(0)
void glResetHistogramEXT(glResetHistogramEXT_ARG_EXPAND);
packed_call_t *pack_glResetHistogramEXT(glResetHistogramEXT_PACKED *_dst glResetHistogramEXT_ARG_EXPAND_TAIL);
typedef void (*glResetHistogramEXT_PTR)(glResetHistogramEXT_ARG_EXPAND);
#endif
#ifndef glResetMinmax_RETURN
#define glResetMinmax_RETURN void
#define glResetMinmax_ARG_NAMES target
#define glResetMinmax_ARG_EXPAND GLenum target
#define glResetMinmax_ARG_NAMES_TAIL , target
#define glResetMinmax_ARG_EXPAND_TAIL , GLenum target
#define forward_glResetMinmax(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glResetMinmax_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glResetMinmax(dst, _target), NULL); \
    });
#define call_glResetMinmax(packed, ret_v) do { \
    glResetMinmax_PACKED *unpacked = (glResetMinmax_PACKED *)packed; \
    glResetMinmax_ARGS *args = (glResetMinmax_ARGS *)&unpacked->args; \
    glResetMinmax(args->target);; \
} while(0)
void glResetMinmax(glResetMinmax_ARG_EXPAND);
packed_call_t *pack_glResetMinmax(glResetMinmax_PACKED *_dst glResetMinmax_ARG_EXPAND_TAIL);
typedef void (*glResetMinmax_PTR)(glResetMinmax_ARG_EXPAND);
#endif
#ifndef glResetMinmaxEXT_RETURN
#define glResetMinmaxEXT_RETURN void
#define glResetMinmaxEXT_ARG_NAMES target
#define glResetMinmaxEXT_ARG_EXPAND GLenum target
#define glResetMinmaxEXT_ARG_NAMES_TAIL , target
#define glResetMinmaxEXT_ARG_EXPAND_TAIL , GLenum target
#define forward_glResetMinmaxEXT(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glResetMinmaxEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glResetMinmaxEXT(dst, _target), NULL); \
    });
#define call_glResetMinmaxEXT(packed, ret_v) do { \
    glResetMinmaxEXT_PACKED *unpacked = (glResetMinmaxEXT_PACKED *)packed; \
    glResetMinmaxEXT_ARGS *args = (glResetMinmaxEXT_ARGS *)&unpacked->args; \
    glResetMinmaxEXT(args->target);; \
} while(0)
void glResetMinmaxEXT(glResetMinmaxEXT_ARG_EXPAND);
packed_call_t *pack_glResetMinmaxEXT(glResetMinmaxEXT_PACKED *_dst glResetMinmaxEXT_ARG_EXPAND_TAIL);
typedef void (*glResetMinmaxEXT_PTR)(glResetMinmaxEXT_ARG_EXPAND);
#endif
#ifndef glResizeBuffersMESA_RETURN
#define glResizeBuffersMESA_RETURN void
#define glResizeBuffersMESA_ARG_NAMES 
#define glResizeBuffersMESA_ARG_EXPAND 
#define glResizeBuffersMESA_ARG_NAMES_TAIL 
#define glResizeBuffersMESA_ARG_EXPAND_TAIL 
#define forward_glResizeBuffersMESA() \
    ({ \
        void *dst = remote_dma(sizeof(glResizeBuffersMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glResizeBuffersMESA(dst), NULL); \
    });
#define call_glResizeBuffersMESA(packed, ret_v) do { \
    glResizeBuffersMESA();; \
} while(0)
void glResizeBuffersMESA(glResizeBuffersMESA_ARG_EXPAND);
packed_call_t *pack_glResizeBuffersMESA(glResizeBuffersMESA_PACKED *_dst glResizeBuffersMESA_ARG_EXPAND_TAIL);
typedef void (*glResizeBuffersMESA_PTR)(glResizeBuffersMESA_ARG_EXPAND);
#endif
#ifndef glResumeTransformFeedback_RETURN
#define glResumeTransformFeedback_RETURN void
#define glResumeTransformFeedback_ARG_NAMES 
#define glResumeTransformFeedback_ARG_EXPAND 
#define glResumeTransformFeedback_ARG_NAMES_TAIL 
#define glResumeTransformFeedback_ARG_EXPAND_TAIL 
#define forward_glResumeTransformFeedback() \
    ({ \
        void *dst = remote_dma(sizeof(glResumeTransformFeedback_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glResumeTransformFeedback(dst), NULL); \
    });
#define call_glResumeTransformFeedback(packed, ret_v) do { \
    glResumeTransformFeedback();; \
} while(0)
void glResumeTransformFeedback(glResumeTransformFeedback_ARG_EXPAND);
packed_call_t *pack_glResumeTransformFeedback(glResumeTransformFeedback_PACKED *_dst glResumeTransformFeedback_ARG_EXPAND_TAIL);
typedef void (*glResumeTransformFeedback_PTR)(glResumeTransformFeedback_ARG_EXPAND);
#endif
#ifndef glResumeTransformFeedbackNV_RETURN
#define glResumeTransformFeedbackNV_RETURN void
#define glResumeTransformFeedbackNV_ARG_NAMES 
#define glResumeTransformFeedbackNV_ARG_EXPAND 
#define glResumeTransformFeedbackNV_ARG_NAMES_TAIL 
#define glResumeTransformFeedbackNV_ARG_EXPAND_TAIL 
#define forward_glResumeTransformFeedbackNV() \
    ({ \
        void *dst = remote_dma(sizeof(glResumeTransformFeedbackNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glResumeTransformFeedbackNV(dst), NULL); \
    });
#define call_glResumeTransformFeedbackNV(packed, ret_v) do { \
    glResumeTransformFeedbackNV();; \
} while(0)
void glResumeTransformFeedbackNV(glResumeTransformFeedbackNV_ARG_EXPAND);
packed_call_t *pack_glResumeTransformFeedbackNV(glResumeTransformFeedbackNV_PACKED *_dst glResumeTransformFeedbackNV_ARG_EXPAND_TAIL);
typedef void (*glResumeTransformFeedbackNV_PTR)(glResumeTransformFeedbackNV_ARG_EXPAND);
#endif
#ifndef glRotated_RETURN
#define glRotated_RETURN void
#define glRotated_ARG_NAMES angle, x, y, z
#define glRotated_ARG_EXPAND GLdouble angle, GLdouble x, GLdouble y, GLdouble z
#define glRotated_ARG_NAMES_TAIL , angle, x, y, z
#define glRotated_ARG_EXPAND_TAIL , GLdouble angle, GLdouble x, GLdouble y, GLdouble z
#define forward_glRotated(_angle, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRotated_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRotated(dst, _angle, _x, _y, _z), NULL); \
    });
#define call_glRotated(packed, ret_v) do { \
    glRotated_PACKED *unpacked = (glRotated_PACKED *)packed; \
    glRotated_ARGS *args = (glRotated_ARGS *)&unpacked->args; \
    glRotated(args->angle, args->x, args->y, args->z);; \
} while(0)
void glRotated(glRotated_ARG_EXPAND);
packed_call_t *pack_glRotated(glRotated_PACKED *_dst glRotated_ARG_EXPAND_TAIL);
typedef void (*glRotated_PTR)(glRotated_ARG_EXPAND);
#endif
#ifndef glRotatef_RETURN
#define glRotatef_RETURN void
#define glRotatef_ARG_NAMES angle, x, y, z
#define glRotatef_ARG_EXPAND GLfloat angle, GLfloat x, GLfloat y, GLfloat z
#define glRotatef_ARG_NAMES_TAIL , angle, x, y, z
#define glRotatef_ARG_EXPAND_TAIL , GLfloat angle, GLfloat x, GLfloat y, GLfloat z
#define forward_glRotatef(_angle, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRotatef_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRotatef(dst, _angle, _x, _y, _z), NULL); \
    });
#define call_glRotatef(packed, ret_v) do { \
    glRotatef_PACKED *unpacked = (glRotatef_PACKED *)packed; \
    glRotatef_ARGS *args = (glRotatef_ARGS *)&unpacked->args; \
    glRotatef(args->angle, args->x, args->y, args->z);; \
} while(0)
void glRotatef(glRotatef_ARG_EXPAND);
packed_call_t *pack_glRotatef(glRotatef_PACKED *_dst glRotatef_ARG_EXPAND_TAIL);
typedef void (*glRotatef_PTR)(glRotatef_ARG_EXPAND);
#endif
#ifndef glRotatexOES_RETURN
#define glRotatexOES_RETURN void
#define glRotatexOES_ARG_NAMES angle, x, y, z
#define glRotatexOES_ARG_EXPAND GLfixed angle, GLfixed x, GLfixed y, GLfixed z
#define glRotatexOES_ARG_NAMES_TAIL , angle, x, y, z
#define glRotatexOES_ARG_EXPAND_TAIL , GLfixed angle, GLfixed x, GLfixed y, GLfixed z
#define forward_glRotatexOES(_angle, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glRotatexOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glRotatexOES(dst, _angle, _x, _y, _z), NULL); \
    });
#define call_glRotatexOES(packed, ret_v) do { \
    glRotatexOES_PACKED *unpacked = (glRotatexOES_PACKED *)packed; \
    glRotatexOES_ARGS *args = (glRotatexOES_ARGS *)&unpacked->args; \
    glRotatexOES(args->angle, args->x, args->y, args->z);; \
} while(0)
void glRotatexOES(glRotatexOES_ARG_EXPAND);
packed_call_t *pack_glRotatexOES(glRotatexOES_PACKED *_dst glRotatexOES_ARG_EXPAND_TAIL);
typedef void (*glRotatexOES_PTR)(glRotatexOES_ARG_EXPAND);
#endif
#ifndef glSampleCoverage_RETURN
#define glSampleCoverage_RETURN void
#define glSampleCoverage_ARG_NAMES value, invert
#define glSampleCoverage_ARG_EXPAND GLfloat value, GLboolean invert
#define glSampleCoverage_ARG_NAMES_TAIL , value, invert
#define glSampleCoverage_ARG_EXPAND_TAIL , GLfloat value, GLboolean invert
#define forward_glSampleCoverage(_value, _invert) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleCoverage_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleCoverage(dst, _value, _invert), NULL); \
    });
#define call_glSampleCoverage(packed, ret_v) do { \
    glSampleCoverage_PACKED *unpacked = (glSampleCoverage_PACKED *)packed; \
    glSampleCoverage_ARGS *args = (glSampleCoverage_ARGS *)&unpacked->args; \
    glSampleCoverage(args->value, args->invert);; \
} while(0)
void glSampleCoverage(glSampleCoverage_ARG_EXPAND);
packed_call_t *pack_glSampleCoverage(glSampleCoverage_PACKED *_dst glSampleCoverage_ARG_EXPAND_TAIL);
typedef void (*glSampleCoverage_PTR)(glSampleCoverage_ARG_EXPAND);
#endif
#ifndef glSampleCoverageARB_RETURN
#define glSampleCoverageARB_RETURN void
#define glSampleCoverageARB_ARG_NAMES value, invert
#define glSampleCoverageARB_ARG_EXPAND GLfloat value, GLboolean invert
#define glSampleCoverageARB_ARG_NAMES_TAIL , value, invert
#define glSampleCoverageARB_ARG_EXPAND_TAIL , GLfloat value, GLboolean invert
#define forward_glSampleCoverageARB(_value, _invert) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleCoverageARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleCoverageARB(dst, _value, _invert), NULL); \
    });
#define call_glSampleCoverageARB(packed, ret_v) do { \
    glSampleCoverageARB_PACKED *unpacked = (glSampleCoverageARB_PACKED *)packed; \
    glSampleCoverageARB_ARGS *args = (glSampleCoverageARB_ARGS *)&unpacked->args; \
    glSampleCoverageARB(args->value, args->invert);; \
} while(0)
void glSampleCoverageARB(glSampleCoverageARB_ARG_EXPAND);
packed_call_t *pack_glSampleCoverageARB(glSampleCoverageARB_PACKED *_dst glSampleCoverageARB_ARG_EXPAND_TAIL);
typedef void (*glSampleCoverageARB_PTR)(glSampleCoverageARB_ARG_EXPAND);
#endif
#ifndef glSampleCoverageOES_RETURN
#define glSampleCoverageOES_RETURN void
#define glSampleCoverageOES_ARG_NAMES value, invert
#define glSampleCoverageOES_ARG_EXPAND GLfixed value, GLboolean invert
#define glSampleCoverageOES_ARG_NAMES_TAIL , value, invert
#define glSampleCoverageOES_ARG_EXPAND_TAIL , GLfixed value, GLboolean invert
#define forward_glSampleCoverageOES(_value, _invert) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleCoverageOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleCoverageOES(dst, _value, _invert), NULL); \
    });
#define call_glSampleCoverageOES(packed, ret_v) do { \
    glSampleCoverageOES_PACKED *unpacked = (glSampleCoverageOES_PACKED *)packed; \
    glSampleCoverageOES_ARGS *args = (glSampleCoverageOES_ARGS *)&unpacked->args; \
    glSampleCoverageOES(args->value, args->invert);; \
} while(0)
void glSampleCoverageOES(glSampleCoverageOES_ARG_EXPAND);
packed_call_t *pack_glSampleCoverageOES(glSampleCoverageOES_PACKED *_dst glSampleCoverageOES_ARG_EXPAND_TAIL);
typedef void (*glSampleCoverageOES_PTR)(glSampleCoverageOES_ARG_EXPAND);
#endif
#ifndef glSampleMapATI_RETURN
#define glSampleMapATI_RETURN void
#define glSampleMapATI_ARG_NAMES dst, interp, swizzle
#define glSampleMapATI_ARG_EXPAND GLuint dst, GLuint interp, GLenum swizzle
#define glSampleMapATI_ARG_NAMES_TAIL , dst, interp, swizzle
#define glSampleMapATI_ARG_EXPAND_TAIL , GLuint dst, GLuint interp, GLenum swizzle
#define forward_glSampleMapATI(_dst, _interp, _swizzle) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleMapATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleMapATI(dst, _dst, _interp, _swizzle), NULL); \
    });
#define call_glSampleMapATI(packed, ret_v) do { \
    glSampleMapATI_PACKED *unpacked = (glSampleMapATI_PACKED *)packed; \
    glSampleMapATI_ARGS *args = (glSampleMapATI_ARGS *)&unpacked->args; \
    glSampleMapATI(args->dst, args->interp, args->swizzle);; \
} while(0)
void glSampleMapATI(glSampleMapATI_ARG_EXPAND);
packed_call_t *pack_glSampleMapATI(glSampleMapATI_PACKED *_dst glSampleMapATI_ARG_EXPAND_TAIL);
typedef void (*glSampleMapATI_PTR)(glSampleMapATI_ARG_EXPAND);
#endif
#ifndef glSampleMaskEXT_RETURN
#define glSampleMaskEXT_RETURN void
#define glSampleMaskEXT_ARG_NAMES value, invert
#define glSampleMaskEXT_ARG_EXPAND GLclampf value, GLboolean invert
#define glSampleMaskEXT_ARG_NAMES_TAIL , value, invert
#define glSampleMaskEXT_ARG_EXPAND_TAIL , GLclampf value, GLboolean invert
#define forward_glSampleMaskEXT(_value, _invert) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleMaskEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleMaskEXT(dst, _value, _invert), NULL); \
    });
#define call_glSampleMaskEXT(packed, ret_v) do { \
    glSampleMaskEXT_PACKED *unpacked = (glSampleMaskEXT_PACKED *)packed; \
    glSampleMaskEXT_ARGS *args = (glSampleMaskEXT_ARGS *)&unpacked->args; \
    glSampleMaskEXT(args->value, args->invert);; \
} while(0)
void glSampleMaskEXT(glSampleMaskEXT_ARG_EXPAND);
packed_call_t *pack_glSampleMaskEXT(glSampleMaskEXT_PACKED *_dst glSampleMaskEXT_ARG_EXPAND_TAIL);
typedef void (*glSampleMaskEXT_PTR)(glSampleMaskEXT_ARG_EXPAND);
#endif
#ifndef glSampleMaskIndexedNV_RETURN
#define glSampleMaskIndexedNV_RETURN void
#define glSampleMaskIndexedNV_ARG_NAMES index, mask
#define glSampleMaskIndexedNV_ARG_EXPAND GLuint index, GLbitfield mask
#define glSampleMaskIndexedNV_ARG_NAMES_TAIL , index, mask
#define glSampleMaskIndexedNV_ARG_EXPAND_TAIL , GLuint index, GLbitfield mask
#define forward_glSampleMaskIndexedNV(_index, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleMaskIndexedNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleMaskIndexedNV(dst, _index, _mask), NULL); \
    });
#define call_glSampleMaskIndexedNV(packed, ret_v) do { \
    glSampleMaskIndexedNV_PACKED *unpacked = (glSampleMaskIndexedNV_PACKED *)packed; \
    glSampleMaskIndexedNV_ARGS *args = (glSampleMaskIndexedNV_ARGS *)&unpacked->args; \
    glSampleMaskIndexedNV(args->index, args->mask);; \
} while(0)
void glSampleMaskIndexedNV(glSampleMaskIndexedNV_ARG_EXPAND);
packed_call_t *pack_glSampleMaskIndexedNV(glSampleMaskIndexedNV_PACKED *_dst glSampleMaskIndexedNV_ARG_EXPAND_TAIL);
typedef void (*glSampleMaskIndexedNV_PTR)(glSampleMaskIndexedNV_ARG_EXPAND);
#endif
#ifndef glSampleMaskSGIS_RETURN
#define glSampleMaskSGIS_RETURN void
#define glSampleMaskSGIS_ARG_NAMES value, invert
#define glSampleMaskSGIS_ARG_EXPAND GLclampf value, GLboolean invert
#define glSampleMaskSGIS_ARG_NAMES_TAIL , value, invert
#define glSampleMaskSGIS_ARG_EXPAND_TAIL , GLclampf value, GLboolean invert
#define forward_glSampleMaskSGIS(_value, _invert) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleMaskSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleMaskSGIS(dst, _value, _invert), NULL); \
    });
#define call_glSampleMaskSGIS(packed, ret_v) do { \
    glSampleMaskSGIS_PACKED *unpacked = (glSampleMaskSGIS_PACKED *)packed; \
    glSampleMaskSGIS_ARGS *args = (glSampleMaskSGIS_ARGS *)&unpacked->args; \
    glSampleMaskSGIS(args->value, args->invert);; \
} while(0)
void glSampleMaskSGIS(glSampleMaskSGIS_ARG_EXPAND);
packed_call_t *pack_glSampleMaskSGIS(glSampleMaskSGIS_PACKED *_dst glSampleMaskSGIS_ARG_EXPAND_TAIL);
typedef void (*glSampleMaskSGIS_PTR)(glSampleMaskSGIS_ARG_EXPAND);
#endif
#ifndef glSampleMaski_RETURN
#define glSampleMaski_RETURN void
#define glSampleMaski_ARG_NAMES index, mask
#define glSampleMaski_ARG_EXPAND GLuint index, GLbitfield mask
#define glSampleMaski_ARG_NAMES_TAIL , index, mask
#define glSampleMaski_ARG_EXPAND_TAIL , GLuint index, GLbitfield mask
#define forward_glSampleMaski(_index, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glSampleMaski_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSampleMaski(dst, _index, _mask), NULL); \
    });
#define call_glSampleMaski(packed, ret_v) do { \
    glSampleMaski_PACKED *unpacked = (glSampleMaski_PACKED *)packed; \
    glSampleMaski_ARGS *args = (glSampleMaski_ARGS *)&unpacked->args; \
    glSampleMaski(args->index, args->mask);; \
} while(0)
void glSampleMaski(glSampleMaski_ARG_EXPAND);
packed_call_t *pack_glSampleMaski(glSampleMaski_PACKED *_dst glSampleMaski_ARG_EXPAND_TAIL);
typedef void (*glSampleMaski_PTR)(glSampleMaski_ARG_EXPAND);
#endif
#ifndef glSamplePatternEXT_RETURN
#define glSamplePatternEXT_RETURN void
#define glSamplePatternEXT_ARG_NAMES pattern
#define glSamplePatternEXT_ARG_EXPAND GLenum pattern
#define glSamplePatternEXT_ARG_NAMES_TAIL , pattern
#define glSamplePatternEXT_ARG_EXPAND_TAIL , GLenum pattern
#define forward_glSamplePatternEXT(_pattern) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplePatternEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplePatternEXT(dst, _pattern), NULL); \
    });
#define call_glSamplePatternEXT(packed, ret_v) do { \
    glSamplePatternEXT_PACKED *unpacked = (glSamplePatternEXT_PACKED *)packed; \
    glSamplePatternEXT_ARGS *args = (glSamplePatternEXT_ARGS *)&unpacked->args; \
    glSamplePatternEXT(args->pattern);; \
} while(0)
void glSamplePatternEXT(glSamplePatternEXT_ARG_EXPAND);
packed_call_t *pack_glSamplePatternEXT(glSamplePatternEXT_PACKED *_dst glSamplePatternEXT_ARG_EXPAND_TAIL);
typedef void (*glSamplePatternEXT_PTR)(glSamplePatternEXT_ARG_EXPAND);
#endif
#ifndef glSamplePatternSGIS_RETURN
#define glSamplePatternSGIS_RETURN void
#define glSamplePatternSGIS_ARG_NAMES pattern
#define glSamplePatternSGIS_ARG_EXPAND GLenum pattern
#define glSamplePatternSGIS_ARG_NAMES_TAIL , pattern
#define glSamplePatternSGIS_ARG_EXPAND_TAIL , GLenum pattern
#define forward_glSamplePatternSGIS(_pattern) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplePatternSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplePatternSGIS(dst, _pattern), NULL); \
    });
#define call_glSamplePatternSGIS(packed, ret_v) do { \
    glSamplePatternSGIS_PACKED *unpacked = (glSamplePatternSGIS_PACKED *)packed; \
    glSamplePatternSGIS_ARGS *args = (glSamplePatternSGIS_ARGS *)&unpacked->args; \
    glSamplePatternSGIS(args->pattern);; \
} while(0)
void glSamplePatternSGIS(glSamplePatternSGIS_ARG_EXPAND);
packed_call_t *pack_glSamplePatternSGIS(glSamplePatternSGIS_PACKED *_dst glSamplePatternSGIS_ARG_EXPAND_TAIL);
typedef void (*glSamplePatternSGIS_PTR)(glSamplePatternSGIS_ARG_EXPAND);
#endif
#ifndef glSamplerParameterIiv_RETURN
#define glSamplerParameterIiv_RETURN void
#define glSamplerParameterIiv_ARG_NAMES sampler, pname, param
#define glSamplerParameterIiv_ARG_EXPAND GLuint sampler, GLenum pname, const GLint * param
#define glSamplerParameterIiv_ARG_NAMES_TAIL , sampler, pname, param
#define glSamplerParameterIiv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, const GLint * param
#define forward_glSamplerParameterIiv(_sampler, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplerParameterIiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplerParameterIiv(dst, _sampler, _pname, _param), NULL); \
    });
#define call_glSamplerParameterIiv(packed, ret_v) do { \
    glSamplerParameterIiv_PACKED *unpacked = (glSamplerParameterIiv_PACKED *)packed; \
    glSamplerParameterIiv_ARGS *args = (glSamplerParameterIiv_ARGS *)&unpacked->args; \
    glSamplerParameterIiv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterIiv(glSamplerParameterIiv_ARG_EXPAND);
packed_call_t *pack_glSamplerParameterIiv(glSamplerParameterIiv_PACKED *_dst glSamplerParameterIiv_ARG_EXPAND_TAIL);
typedef void (*glSamplerParameterIiv_PTR)(glSamplerParameterIiv_ARG_EXPAND);
#endif
#ifndef glSamplerParameterIuiv_RETURN
#define glSamplerParameterIuiv_RETURN void
#define glSamplerParameterIuiv_ARG_NAMES sampler, pname, param
#define glSamplerParameterIuiv_ARG_EXPAND GLuint sampler, GLenum pname, const GLuint * param
#define glSamplerParameterIuiv_ARG_NAMES_TAIL , sampler, pname, param
#define glSamplerParameterIuiv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, const GLuint * param
#define forward_glSamplerParameterIuiv(_sampler, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplerParameterIuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplerParameterIuiv(dst, _sampler, _pname, _param), NULL); \
    });
#define call_glSamplerParameterIuiv(packed, ret_v) do { \
    glSamplerParameterIuiv_PACKED *unpacked = (glSamplerParameterIuiv_PACKED *)packed; \
    glSamplerParameterIuiv_ARGS *args = (glSamplerParameterIuiv_ARGS *)&unpacked->args; \
    glSamplerParameterIuiv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterIuiv(glSamplerParameterIuiv_ARG_EXPAND);
packed_call_t *pack_glSamplerParameterIuiv(glSamplerParameterIuiv_PACKED *_dst glSamplerParameterIuiv_ARG_EXPAND_TAIL);
typedef void (*glSamplerParameterIuiv_PTR)(glSamplerParameterIuiv_ARG_EXPAND);
#endif
#ifndef glSamplerParameterf_RETURN
#define glSamplerParameterf_RETURN void
#define glSamplerParameterf_ARG_NAMES sampler, pname, param
#define glSamplerParameterf_ARG_EXPAND GLuint sampler, GLenum pname, GLfloat param
#define glSamplerParameterf_ARG_NAMES_TAIL , sampler, pname, param
#define glSamplerParameterf_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, GLfloat param
#define forward_glSamplerParameterf(_sampler, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplerParameterf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplerParameterf(dst, _sampler, _pname, _param), NULL); \
    });
#define call_glSamplerParameterf(packed, ret_v) do { \
    glSamplerParameterf_PACKED *unpacked = (glSamplerParameterf_PACKED *)packed; \
    glSamplerParameterf_ARGS *args = (glSamplerParameterf_ARGS *)&unpacked->args; \
    glSamplerParameterf(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterf(glSamplerParameterf_ARG_EXPAND);
packed_call_t *pack_glSamplerParameterf(glSamplerParameterf_PACKED *_dst glSamplerParameterf_ARG_EXPAND_TAIL);
typedef void (*glSamplerParameterf_PTR)(glSamplerParameterf_ARG_EXPAND);
#endif
#ifndef glSamplerParameterfv_RETURN
#define glSamplerParameterfv_RETURN void
#define glSamplerParameterfv_ARG_NAMES sampler, pname, param
#define glSamplerParameterfv_ARG_EXPAND GLuint sampler, GLenum pname, const GLfloat * param
#define glSamplerParameterfv_ARG_NAMES_TAIL , sampler, pname, param
#define glSamplerParameterfv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, const GLfloat * param
#define forward_glSamplerParameterfv(_sampler, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplerParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplerParameterfv(dst, _sampler, _pname, _param), NULL); \
    });
#define call_glSamplerParameterfv(packed, ret_v) do { \
    glSamplerParameterfv_PACKED *unpacked = (glSamplerParameterfv_PACKED *)packed; \
    glSamplerParameterfv_ARGS *args = (glSamplerParameterfv_ARGS *)&unpacked->args; \
    glSamplerParameterfv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterfv(glSamplerParameterfv_ARG_EXPAND);
packed_call_t *pack_glSamplerParameterfv(glSamplerParameterfv_PACKED *_dst glSamplerParameterfv_ARG_EXPAND_TAIL);
typedef void (*glSamplerParameterfv_PTR)(glSamplerParameterfv_ARG_EXPAND);
#endif
#ifndef glSamplerParameteri_RETURN
#define glSamplerParameteri_RETURN void
#define glSamplerParameteri_ARG_NAMES sampler, pname, param
#define glSamplerParameteri_ARG_EXPAND GLuint sampler, GLenum pname, GLint param
#define glSamplerParameteri_ARG_NAMES_TAIL , sampler, pname, param
#define glSamplerParameteri_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, GLint param
#define forward_glSamplerParameteri(_sampler, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplerParameteri_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplerParameteri(dst, _sampler, _pname, _param), NULL); \
    });
#define call_glSamplerParameteri(packed, ret_v) do { \
    glSamplerParameteri_PACKED *unpacked = (glSamplerParameteri_PACKED *)packed; \
    glSamplerParameteri_ARGS *args = (glSamplerParameteri_ARGS *)&unpacked->args; \
    glSamplerParameteri(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameteri(glSamplerParameteri_ARG_EXPAND);
packed_call_t *pack_glSamplerParameteri(glSamplerParameteri_PACKED *_dst glSamplerParameteri_ARG_EXPAND_TAIL);
typedef void (*glSamplerParameteri_PTR)(glSamplerParameteri_ARG_EXPAND);
#endif
#ifndef glSamplerParameteriv_RETURN
#define glSamplerParameteriv_RETURN void
#define glSamplerParameteriv_ARG_NAMES sampler, pname, param
#define glSamplerParameteriv_ARG_EXPAND GLuint sampler, GLenum pname, const GLint * param
#define glSamplerParameteriv_ARG_NAMES_TAIL , sampler, pname, param
#define glSamplerParameteriv_ARG_EXPAND_TAIL , GLuint sampler, GLenum pname, const GLint * param
#define forward_glSamplerParameteriv(_sampler, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSamplerParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSamplerParameteriv(dst, _sampler, _pname, _param), NULL); \
    });
#define call_glSamplerParameteriv(packed, ret_v) do { \
    glSamplerParameteriv_PACKED *unpacked = (glSamplerParameteriv_PACKED *)packed; \
    glSamplerParameteriv_ARGS *args = (glSamplerParameteriv_ARGS *)&unpacked->args; \
    glSamplerParameteriv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameteriv(glSamplerParameteriv_ARG_EXPAND);
packed_call_t *pack_glSamplerParameteriv(glSamplerParameteriv_PACKED *_dst glSamplerParameteriv_ARG_EXPAND_TAIL);
typedef void (*glSamplerParameteriv_PTR)(glSamplerParameteriv_ARG_EXPAND);
#endif
#ifndef glScaled_RETURN
#define glScaled_RETURN void
#define glScaled_ARG_NAMES x, y, z
#define glScaled_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glScaled_ARG_NAMES_TAIL , x, y, z
#define glScaled_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z
#define forward_glScaled(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glScaled_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glScaled(dst, _x, _y, _z), NULL); \
    });
#define call_glScaled(packed, ret_v) do { \
    glScaled_PACKED *unpacked = (glScaled_PACKED *)packed; \
    glScaled_ARGS *args = (glScaled_ARGS *)&unpacked->args; \
    glScaled(args->x, args->y, args->z);; \
} while(0)
void glScaled(glScaled_ARG_EXPAND);
packed_call_t *pack_glScaled(glScaled_PACKED *_dst glScaled_ARG_EXPAND_TAIL);
typedef void (*glScaled_PTR)(glScaled_ARG_EXPAND);
#endif
#ifndef glScalef_RETURN
#define glScalef_RETURN void
#define glScalef_ARG_NAMES x, y, z
#define glScalef_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glScalef_ARG_NAMES_TAIL , x, y, z
#define glScalef_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z
#define forward_glScalef(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glScalef_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glScalef(dst, _x, _y, _z), NULL); \
    });
#define call_glScalef(packed, ret_v) do { \
    glScalef_PACKED *unpacked = (glScalef_PACKED *)packed; \
    glScalef_ARGS *args = (glScalef_ARGS *)&unpacked->args; \
    glScalef(args->x, args->y, args->z);; \
} while(0)
void glScalef(glScalef_ARG_EXPAND);
packed_call_t *pack_glScalef(glScalef_PACKED *_dst glScalef_ARG_EXPAND_TAIL);
typedef void (*glScalef_PTR)(glScalef_ARG_EXPAND);
#endif
#ifndef glScalexOES_RETURN
#define glScalexOES_RETURN void
#define glScalexOES_ARG_NAMES x, y, z
#define glScalexOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glScalexOES_ARG_NAMES_TAIL , x, y, z
#define glScalexOES_ARG_EXPAND_TAIL , GLfixed x, GLfixed y, GLfixed z
#define forward_glScalexOES(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glScalexOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glScalexOES(dst, _x, _y, _z), NULL); \
    });
#define call_glScalexOES(packed, ret_v) do { \
    glScalexOES_PACKED *unpacked = (glScalexOES_PACKED *)packed; \
    glScalexOES_ARGS *args = (glScalexOES_ARGS *)&unpacked->args; \
    glScalexOES(args->x, args->y, args->z);; \
} while(0)
void glScalexOES(glScalexOES_ARG_EXPAND);
packed_call_t *pack_glScalexOES(glScalexOES_PACKED *_dst glScalexOES_ARG_EXPAND_TAIL);
typedef void (*glScalexOES_PTR)(glScalexOES_ARG_EXPAND);
#endif
#ifndef glScissor_RETURN
#define glScissor_RETURN void
#define glScissor_ARG_NAMES x, y, width, height
#define glScissor_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height
#define glScissor_ARG_NAMES_TAIL , x, y, width, height
#define glScissor_ARG_EXPAND_TAIL , GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glScissor(_x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glScissor_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glScissor(dst, _x, _y, _width, _height), NULL); \
    });
#define call_glScissor(packed, ret_v) do { \
    glScissor_PACKED *unpacked = (glScissor_PACKED *)packed; \
    glScissor_ARGS *args = (glScissor_ARGS *)&unpacked->args; \
    glScissor(args->x, args->y, args->width, args->height);; \
} while(0)
void glScissor(glScissor_ARG_EXPAND);
packed_call_t *pack_glScissor(glScissor_PACKED *_dst glScissor_ARG_EXPAND_TAIL);
typedef void (*glScissor_PTR)(glScissor_ARG_EXPAND);
#endif
#ifndef glScissorArrayv_RETURN
#define glScissorArrayv_RETURN void
#define glScissorArrayv_ARG_NAMES first, count, v
#define glScissorArrayv_ARG_EXPAND GLuint first, GLsizei count, const GLint * v
#define glScissorArrayv_ARG_NAMES_TAIL , first, count, v
#define glScissorArrayv_ARG_EXPAND_TAIL , GLuint first, GLsizei count, const GLint * v
#define forward_glScissorArrayv(_first, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glScissorArrayv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glScissorArrayv(dst, _first, _count, _v), NULL); \
    });
#define call_glScissorArrayv(packed, ret_v) do { \
    glScissorArrayv_PACKED *unpacked = (glScissorArrayv_PACKED *)packed; \
    glScissorArrayv_ARGS *args = (glScissorArrayv_ARGS *)&unpacked->args; \
    glScissorArrayv(args->first, args->count, args->v);; \
} while(0)
void glScissorArrayv(glScissorArrayv_ARG_EXPAND);
packed_call_t *pack_glScissorArrayv(glScissorArrayv_PACKED *_dst glScissorArrayv_ARG_EXPAND_TAIL);
typedef void (*glScissorArrayv_PTR)(glScissorArrayv_ARG_EXPAND);
#endif
#ifndef glScissorIndexed_RETURN
#define glScissorIndexed_RETURN void
#define glScissorIndexed_ARG_NAMES index, left, bottom, width, height
#define glScissorIndexed_ARG_EXPAND GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height
#define glScissorIndexed_ARG_NAMES_TAIL , index, left, bottom, width, height
#define glScissorIndexed_ARG_EXPAND_TAIL , GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height
#define forward_glScissorIndexed(_index, _left, _bottom, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glScissorIndexed_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glScissorIndexed(dst, _index, _left, _bottom, _width, _height), NULL); \
    });
#define call_glScissorIndexed(packed, ret_v) do { \
    glScissorIndexed_PACKED *unpacked = (glScissorIndexed_PACKED *)packed; \
    glScissorIndexed_ARGS *args = (glScissorIndexed_ARGS *)&unpacked->args; \
    glScissorIndexed(args->index, args->left, args->bottom, args->width, args->height);; \
} while(0)
void glScissorIndexed(glScissorIndexed_ARG_EXPAND);
packed_call_t *pack_glScissorIndexed(glScissorIndexed_PACKED *_dst glScissorIndexed_ARG_EXPAND_TAIL);
typedef void (*glScissorIndexed_PTR)(glScissorIndexed_ARG_EXPAND);
#endif
#ifndef glScissorIndexedv_RETURN
#define glScissorIndexedv_RETURN void
#define glScissorIndexedv_ARG_NAMES index, v
#define glScissorIndexedv_ARG_EXPAND GLuint index, const GLint * v
#define glScissorIndexedv_ARG_NAMES_TAIL , index, v
#define glScissorIndexedv_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glScissorIndexedv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glScissorIndexedv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glScissorIndexedv(dst, _index, _v), NULL); \
    });
#define call_glScissorIndexedv(packed, ret_v) do { \
    glScissorIndexedv_PACKED *unpacked = (glScissorIndexedv_PACKED *)packed; \
    glScissorIndexedv_ARGS *args = (glScissorIndexedv_ARGS *)&unpacked->args; \
    glScissorIndexedv(args->index, args->v);; \
} while(0)
void glScissorIndexedv(glScissorIndexedv_ARG_EXPAND);
packed_call_t *pack_glScissorIndexedv(glScissorIndexedv_PACKED *_dst glScissorIndexedv_ARG_EXPAND_TAIL);
typedef void (*glScissorIndexedv_PTR)(glScissorIndexedv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3b_RETURN
#define glSecondaryColor3b_RETURN void
#define glSecondaryColor3b_ARG_NAMES red, green, blue
#define glSecondaryColor3b_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue
#define glSecondaryColor3b_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3b_ARG_EXPAND_TAIL , GLbyte red, GLbyte green, GLbyte blue
#define forward_glSecondaryColor3b(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3b_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3b(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3b(packed, ret_v) do { \
    glSecondaryColor3b_PACKED *unpacked = (glSecondaryColor3b_PACKED *)packed; \
    glSecondaryColor3b_ARGS *args = (glSecondaryColor3b_ARGS *)&unpacked->args; \
    glSecondaryColor3b(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3b(glSecondaryColor3b_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3b(glSecondaryColor3b_PACKED *_dst glSecondaryColor3b_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3b_PTR)(glSecondaryColor3b_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3bEXT_RETURN
#define glSecondaryColor3bEXT_RETURN void
#define glSecondaryColor3bEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3bEXT_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue
#define glSecondaryColor3bEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3bEXT_ARG_EXPAND_TAIL , GLbyte red, GLbyte green, GLbyte blue
#define forward_glSecondaryColor3bEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3bEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3bEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3bEXT(packed, ret_v) do { \
    glSecondaryColor3bEXT_PACKED *unpacked = (glSecondaryColor3bEXT_PACKED *)packed; \
    glSecondaryColor3bEXT_ARGS *args = (glSecondaryColor3bEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3bEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3bEXT(glSecondaryColor3bEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3bEXT(glSecondaryColor3bEXT_PACKED *_dst glSecondaryColor3bEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3bEXT_PTR)(glSecondaryColor3bEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3bv_RETURN
#define glSecondaryColor3bv_RETURN void
#define glSecondaryColor3bv_ARG_NAMES v
#define glSecondaryColor3bv_ARG_EXPAND const GLbyte * v
#define glSecondaryColor3bv_ARG_NAMES_TAIL , v
#define glSecondaryColor3bv_ARG_EXPAND_TAIL , const GLbyte * v
#define forward_glSecondaryColor3bv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3bv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3bv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3bv(packed, ret_v) do { \
    glSecondaryColor3bv_PACKED *unpacked = (glSecondaryColor3bv_PACKED *)packed; \
    glSecondaryColor3bv_ARGS *args = (glSecondaryColor3bv_ARGS *)&unpacked->args; \
    glSecondaryColor3bv(args->v);; \
} while(0)
void glSecondaryColor3bv(glSecondaryColor3bv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3bv(glSecondaryColor3bv_PACKED *_dst glSecondaryColor3bv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3bv_PTR)(glSecondaryColor3bv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3bvEXT_RETURN
#define glSecondaryColor3bvEXT_RETURN void
#define glSecondaryColor3bvEXT_ARG_NAMES v
#define glSecondaryColor3bvEXT_ARG_EXPAND const GLbyte * v
#define glSecondaryColor3bvEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3bvEXT_ARG_EXPAND_TAIL , const GLbyte * v
#define forward_glSecondaryColor3bvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3bvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3bvEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3bvEXT(packed, ret_v) do { \
    glSecondaryColor3bvEXT_PACKED *unpacked = (glSecondaryColor3bvEXT_PACKED *)packed; \
    glSecondaryColor3bvEXT_ARGS *args = (glSecondaryColor3bvEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3bvEXT(args->v);; \
} while(0)
void glSecondaryColor3bvEXT(glSecondaryColor3bvEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3bvEXT(glSecondaryColor3bvEXT_PACKED *_dst glSecondaryColor3bvEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3bvEXT_PTR)(glSecondaryColor3bvEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3d_RETURN
#define glSecondaryColor3d_RETURN void
#define glSecondaryColor3d_ARG_NAMES red, green, blue
#define glSecondaryColor3d_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue
#define glSecondaryColor3d_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3d_ARG_EXPAND_TAIL , GLdouble red, GLdouble green, GLdouble blue
#define forward_glSecondaryColor3d(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3d(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3d(packed, ret_v) do { \
    glSecondaryColor3d_PACKED *unpacked = (glSecondaryColor3d_PACKED *)packed; \
    glSecondaryColor3d_ARGS *args = (glSecondaryColor3d_ARGS *)&unpacked->args; \
    glSecondaryColor3d(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3d(glSecondaryColor3d_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3d(glSecondaryColor3d_PACKED *_dst glSecondaryColor3d_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3d_PTR)(glSecondaryColor3d_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3dEXT_RETURN
#define glSecondaryColor3dEXT_RETURN void
#define glSecondaryColor3dEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3dEXT_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue
#define glSecondaryColor3dEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3dEXT_ARG_EXPAND_TAIL , GLdouble red, GLdouble green, GLdouble blue
#define forward_glSecondaryColor3dEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3dEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3dEXT(packed, ret_v) do { \
    glSecondaryColor3dEXT_PACKED *unpacked = (glSecondaryColor3dEXT_PACKED *)packed; \
    glSecondaryColor3dEXT_ARGS *args = (glSecondaryColor3dEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3dEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3dEXT(glSecondaryColor3dEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3dEXT(glSecondaryColor3dEXT_PACKED *_dst glSecondaryColor3dEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3dEXT_PTR)(glSecondaryColor3dEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3dv_RETURN
#define glSecondaryColor3dv_RETURN void
#define glSecondaryColor3dv_ARG_NAMES v
#define glSecondaryColor3dv_ARG_EXPAND const GLdouble * v
#define glSecondaryColor3dv_ARG_NAMES_TAIL , v
#define glSecondaryColor3dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glSecondaryColor3dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3dv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3dv(packed, ret_v) do { \
    glSecondaryColor3dv_PACKED *unpacked = (glSecondaryColor3dv_PACKED *)packed; \
    glSecondaryColor3dv_ARGS *args = (glSecondaryColor3dv_ARGS *)&unpacked->args; \
    glSecondaryColor3dv(args->v);; \
} while(0)
void glSecondaryColor3dv(glSecondaryColor3dv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3dv(glSecondaryColor3dv_PACKED *_dst glSecondaryColor3dv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3dv_PTR)(glSecondaryColor3dv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3dvEXT_RETURN
#define glSecondaryColor3dvEXT_RETURN void
#define glSecondaryColor3dvEXT_ARG_NAMES v
#define glSecondaryColor3dvEXT_ARG_EXPAND const GLdouble * v
#define glSecondaryColor3dvEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3dvEXT_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glSecondaryColor3dvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3dvEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3dvEXT(packed, ret_v) do { \
    glSecondaryColor3dvEXT_PACKED *unpacked = (glSecondaryColor3dvEXT_PACKED *)packed; \
    glSecondaryColor3dvEXT_ARGS *args = (glSecondaryColor3dvEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3dvEXT(args->v);; \
} while(0)
void glSecondaryColor3dvEXT(glSecondaryColor3dvEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3dvEXT(glSecondaryColor3dvEXT_PACKED *_dst glSecondaryColor3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3dvEXT_PTR)(glSecondaryColor3dvEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3f_RETURN
#define glSecondaryColor3f_RETURN void
#define glSecondaryColor3f_ARG_NAMES red, green, blue
#define glSecondaryColor3f_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue
#define glSecondaryColor3f_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3f_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue
#define forward_glSecondaryColor3f(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3f(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3f(packed, ret_v) do { \
    glSecondaryColor3f_PACKED *unpacked = (glSecondaryColor3f_PACKED *)packed; \
    glSecondaryColor3f_ARGS *args = (glSecondaryColor3f_ARGS *)&unpacked->args; \
    glSecondaryColor3f(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3f(glSecondaryColor3f_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3f(glSecondaryColor3f_PACKED *_dst glSecondaryColor3f_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3f_PTR)(glSecondaryColor3f_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3fEXT_RETURN
#define glSecondaryColor3fEXT_RETURN void
#define glSecondaryColor3fEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3fEXT_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue
#define glSecondaryColor3fEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3fEXT_ARG_EXPAND_TAIL , GLfloat red, GLfloat green, GLfloat blue
#define forward_glSecondaryColor3fEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3fEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3fEXT(packed, ret_v) do { \
    glSecondaryColor3fEXT_PACKED *unpacked = (glSecondaryColor3fEXT_PACKED *)packed; \
    glSecondaryColor3fEXT_ARGS *args = (glSecondaryColor3fEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3fEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3fEXT(glSecondaryColor3fEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3fEXT(glSecondaryColor3fEXT_PACKED *_dst glSecondaryColor3fEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3fEXT_PTR)(glSecondaryColor3fEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3fv_RETURN
#define glSecondaryColor3fv_RETURN void
#define glSecondaryColor3fv_ARG_NAMES v
#define glSecondaryColor3fv_ARG_EXPAND const GLfloat * v
#define glSecondaryColor3fv_ARG_NAMES_TAIL , v
#define glSecondaryColor3fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glSecondaryColor3fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3fv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3fv(packed, ret_v) do { \
    glSecondaryColor3fv_PACKED *unpacked = (glSecondaryColor3fv_PACKED *)packed; \
    glSecondaryColor3fv_ARGS *args = (glSecondaryColor3fv_ARGS *)&unpacked->args; \
    glSecondaryColor3fv(args->v);; \
} while(0)
void glSecondaryColor3fv(glSecondaryColor3fv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3fv(glSecondaryColor3fv_PACKED *_dst glSecondaryColor3fv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3fv_PTR)(glSecondaryColor3fv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3fvEXT_RETURN
#define glSecondaryColor3fvEXT_RETURN void
#define glSecondaryColor3fvEXT_ARG_NAMES v
#define glSecondaryColor3fvEXT_ARG_EXPAND const GLfloat * v
#define glSecondaryColor3fvEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3fvEXT_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glSecondaryColor3fvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3fvEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3fvEXT(packed, ret_v) do { \
    glSecondaryColor3fvEXT_PACKED *unpacked = (glSecondaryColor3fvEXT_PACKED *)packed; \
    glSecondaryColor3fvEXT_ARGS *args = (glSecondaryColor3fvEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3fvEXT(args->v);; \
} while(0)
void glSecondaryColor3fvEXT(glSecondaryColor3fvEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3fvEXT(glSecondaryColor3fvEXT_PACKED *_dst glSecondaryColor3fvEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3fvEXT_PTR)(glSecondaryColor3fvEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3hNV_RETURN
#define glSecondaryColor3hNV_RETURN void
#define glSecondaryColor3hNV_ARG_NAMES red, green, blue
#define glSecondaryColor3hNV_ARG_EXPAND GLhalfNV red, GLhalfNV green, GLhalfNV blue
#define glSecondaryColor3hNV_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3hNV_ARG_EXPAND_TAIL , GLhalfNV red, GLhalfNV green, GLhalfNV blue
#define forward_glSecondaryColor3hNV(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3hNV(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3hNV(packed, ret_v) do { \
    glSecondaryColor3hNV_PACKED *unpacked = (glSecondaryColor3hNV_PACKED *)packed; \
    glSecondaryColor3hNV_ARGS *args = (glSecondaryColor3hNV_ARGS *)&unpacked->args; \
    glSecondaryColor3hNV(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3hNV(glSecondaryColor3hNV_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3hNV(glSecondaryColor3hNV_PACKED *_dst glSecondaryColor3hNV_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3hNV_PTR)(glSecondaryColor3hNV_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3hvNV_RETURN
#define glSecondaryColor3hvNV_RETURN void
#define glSecondaryColor3hvNV_ARG_NAMES v
#define glSecondaryColor3hvNV_ARG_EXPAND const GLhalfNV * v
#define glSecondaryColor3hvNV_ARG_NAMES_TAIL , v
#define glSecondaryColor3hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glSecondaryColor3hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3hvNV(dst, _v), NULL); \
    });
#define call_glSecondaryColor3hvNV(packed, ret_v) do { \
    glSecondaryColor3hvNV_PACKED *unpacked = (glSecondaryColor3hvNV_PACKED *)packed; \
    glSecondaryColor3hvNV_ARGS *args = (glSecondaryColor3hvNV_ARGS *)&unpacked->args; \
    glSecondaryColor3hvNV(args->v);; \
} while(0)
void glSecondaryColor3hvNV(glSecondaryColor3hvNV_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3hvNV(glSecondaryColor3hvNV_PACKED *_dst glSecondaryColor3hvNV_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3hvNV_PTR)(glSecondaryColor3hvNV_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3i_RETURN
#define glSecondaryColor3i_RETURN void
#define glSecondaryColor3i_ARG_NAMES red, green, blue
#define glSecondaryColor3i_ARG_EXPAND GLint red, GLint green, GLint blue
#define glSecondaryColor3i_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3i_ARG_EXPAND_TAIL , GLint red, GLint green, GLint blue
#define forward_glSecondaryColor3i(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3i(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3i(packed, ret_v) do { \
    glSecondaryColor3i_PACKED *unpacked = (glSecondaryColor3i_PACKED *)packed; \
    glSecondaryColor3i_ARGS *args = (glSecondaryColor3i_ARGS *)&unpacked->args; \
    glSecondaryColor3i(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3i(glSecondaryColor3i_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3i(glSecondaryColor3i_PACKED *_dst glSecondaryColor3i_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3i_PTR)(glSecondaryColor3i_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3iEXT_RETURN
#define glSecondaryColor3iEXT_RETURN void
#define glSecondaryColor3iEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3iEXT_ARG_EXPAND GLint red, GLint green, GLint blue
#define glSecondaryColor3iEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3iEXT_ARG_EXPAND_TAIL , GLint red, GLint green, GLint blue
#define forward_glSecondaryColor3iEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3iEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3iEXT(packed, ret_v) do { \
    glSecondaryColor3iEXT_PACKED *unpacked = (glSecondaryColor3iEXT_PACKED *)packed; \
    glSecondaryColor3iEXT_ARGS *args = (glSecondaryColor3iEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3iEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3iEXT(glSecondaryColor3iEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3iEXT(glSecondaryColor3iEXT_PACKED *_dst glSecondaryColor3iEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3iEXT_PTR)(glSecondaryColor3iEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3iv_RETURN
#define glSecondaryColor3iv_RETURN void
#define glSecondaryColor3iv_ARG_NAMES v
#define glSecondaryColor3iv_ARG_EXPAND const GLint * v
#define glSecondaryColor3iv_ARG_NAMES_TAIL , v
#define glSecondaryColor3iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glSecondaryColor3iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3iv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3iv(packed, ret_v) do { \
    glSecondaryColor3iv_PACKED *unpacked = (glSecondaryColor3iv_PACKED *)packed; \
    glSecondaryColor3iv_ARGS *args = (glSecondaryColor3iv_ARGS *)&unpacked->args; \
    glSecondaryColor3iv(args->v);; \
} while(0)
void glSecondaryColor3iv(glSecondaryColor3iv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3iv(glSecondaryColor3iv_PACKED *_dst glSecondaryColor3iv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3iv_PTR)(glSecondaryColor3iv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3ivEXT_RETURN
#define glSecondaryColor3ivEXT_RETURN void
#define glSecondaryColor3ivEXT_ARG_NAMES v
#define glSecondaryColor3ivEXT_ARG_EXPAND const GLint * v
#define glSecondaryColor3ivEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3ivEXT_ARG_EXPAND_TAIL , const GLint * v
#define forward_glSecondaryColor3ivEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3ivEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3ivEXT(packed, ret_v) do { \
    glSecondaryColor3ivEXT_PACKED *unpacked = (glSecondaryColor3ivEXT_PACKED *)packed; \
    glSecondaryColor3ivEXT_ARGS *args = (glSecondaryColor3ivEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3ivEXT(args->v);; \
} while(0)
void glSecondaryColor3ivEXT(glSecondaryColor3ivEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3ivEXT(glSecondaryColor3ivEXT_PACKED *_dst glSecondaryColor3ivEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3ivEXT_PTR)(glSecondaryColor3ivEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3s_RETURN
#define glSecondaryColor3s_RETURN void
#define glSecondaryColor3s_ARG_NAMES red, green, blue
#define glSecondaryColor3s_ARG_EXPAND GLshort red, GLshort green, GLshort blue
#define glSecondaryColor3s_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3s_ARG_EXPAND_TAIL , GLshort red, GLshort green, GLshort blue
#define forward_glSecondaryColor3s(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3s(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3s(packed, ret_v) do { \
    glSecondaryColor3s_PACKED *unpacked = (glSecondaryColor3s_PACKED *)packed; \
    glSecondaryColor3s_ARGS *args = (glSecondaryColor3s_ARGS *)&unpacked->args; \
    glSecondaryColor3s(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3s(glSecondaryColor3s_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3s(glSecondaryColor3s_PACKED *_dst glSecondaryColor3s_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3s_PTR)(glSecondaryColor3s_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3sEXT_RETURN
#define glSecondaryColor3sEXT_RETURN void
#define glSecondaryColor3sEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3sEXT_ARG_EXPAND GLshort red, GLshort green, GLshort blue
#define glSecondaryColor3sEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3sEXT_ARG_EXPAND_TAIL , GLshort red, GLshort green, GLshort blue
#define forward_glSecondaryColor3sEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3sEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3sEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3sEXT(packed, ret_v) do { \
    glSecondaryColor3sEXT_PACKED *unpacked = (glSecondaryColor3sEXT_PACKED *)packed; \
    glSecondaryColor3sEXT_ARGS *args = (glSecondaryColor3sEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3sEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3sEXT(glSecondaryColor3sEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3sEXT(glSecondaryColor3sEXT_PACKED *_dst glSecondaryColor3sEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3sEXT_PTR)(glSecondaryColor3sEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3sv_RETURN
#define glSecondaryColor3sv_RETURN void
#define glSecondaryColor3sv_ARG_NAMES v
#define glSecondaryColor3sv_ARG_EXPAND const GLshort * v
#define glSecondaryColor3sv_ARG_NAMES_TAIL , v
#define glSecondaryColor3sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glSecondaryColor3sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3sv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3sv(packed, ret_v) do { \
    glSecondaryColor3sv_PACKED *unpacked = (glSecondaryColor3sv_PACKED *)packed; \
    glSecondaryColor3sv_ARGS *args = (glSecondaryColor3sv_ARGS *)&unpacked->args; \
    glSecondaryColor3sv(args->v);; \
} while(0)
void glSecondaryColor3sv(glSecondaryColor3sv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3sv(glSecondaryColor3sv_PACKED *_dst glSecondaryColor3sv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3sv_PTR)(glSecondaryColor3sv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3svEXT_RETURN
#define glSecondaryColor3svEXT_RETURN void
#define glSecondaryColor3svEXT_ARG_NAMES v
#define glSecondaryColor3svEXT_ARG_EXPAND const GLshort * v
#define glSecondaryColor3svEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3svEXT_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glSecondaryColor3svEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3svEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3svEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3svEXT(packed, ret_v) do { \
    glSecondaryColor3svEXT_PACKED *unpacked = (glSecondaryColor3svEXT_PACKED *)packed; \
    glSecondaryColor3svEXT_ARGS *args = (glSecondaryColor3svEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3svEXT(args->v);; \
} while(0)
void glSecondaryColor3svEXT(glSecondaryColor3svEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3svEXT(glSecondaryColor3svEXT_PACKED *_dst glSecondaryColor3svEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3svEXT_PTR)(glSecondaryColor3svEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3ub_RETURN
#define glSecondaryColor3ub_RETURN void
#define glSecondaryColor3ub_ARG_NAMES red, green, blue
#define glSecondaryColor3ub_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue
#define glSecondaryColor3ub_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3ub_ARG_EXPAND_TAIL , GLubyte red, GLubyte green, GLubyte blue
#define forward_glSecondaryColor3ub(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3ub_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3ub(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3ub(packed, ret_v) do { \
    glSecondaryColor3ub_PACKED *unpacked = (glSecondaryColor3ub_PACKED *)packed; \
    glSecondaryColor3ub_ARGS *args = (glSecondaryColor3ub_ARGS *)&unpacked->args; \
    glSecondaryColor3ub(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3ub(glSecondaryColor3ub_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3ub(glSecondaryColor3ub_PACKED *_dst glSecondaryColor3ub_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3ub_PTR)(glSecondaryColor3ub_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3ubEXT_RETURN
#define glSecondaryColor3ubEXT_RETURN void
#define glSecondaryColor3ubEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3ubEXT_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue
#define glSecondaryColor3ubEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3ubEXT_ARG_EXPAND_TAIL , GLubyte red, GLubyte green, GLubyte blue
#define forward_glSecondaryColor3ubEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3ubEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3ubEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3ubEXT(packed, ret_v) do { \
    glSecondaryColor3ubEXT_PACKED *unpacked = (glSecondaryColor3ubEXT_PACKED *)packed; \
    glSecondaryColor3ubEXT_ARGS *args = (glSecondaryColor3ubEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3ubEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3ubEXT(glSecondaryColor3ubEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3ubEXT(glSecondaryColor3ubEXT_PACKED *_dst glSecondaryColor3ubEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3ubEXT_PTR)(glSecondaryColor3ubEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3ubv_RETURN
#define glSecondaryColor3ubv_RETURN void
#define glSecondaryColor3ubv_ARG_NAMES v
#define glSecondaryColor3ubv_ARG_EXPAND const GLubyte * v
#define glSecondaryColor3ubv_ARG_NAMES_TAIL , v
#define glSecondaryColor3ubv_ARG_EXPAND_TAIL , const GLubyte * v
#define forward_glSecondaryColor3ubv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3ubv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3ubv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3ubv(packed, ret_v) do { \
    glSecondaryColor3ubv_PACKED *unpacked = (glSecondaryColor3ubv_PACKED *)packed; \
    glSecondaryColor3ubv_ARGS *args = (glSecondaryColor3ubv_ARGS *)&unpacked->args; \
    glSecondaryColor3ubv(args->v);; \
} while(0)
void glSecondaryColor3ubv(glSecondaryColor3ubv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3ubv(glSecondaryColor3ubv_PACKED *_dst glSecondaryColor3ubv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3ubv_PTR)(glSecondaryColor3ubv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3ubvEXT_RETURN
#define glSecondaryColor3ubvEXT_RETURN void
#define glSecondaryColor3ubvEXT_ARG_NAMES v
#define glSecondaryColor3ubvEXT_ARG_EXPAND const GLubyte * v
#define glSecondaryColor3ubvEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3ubvEXT_ARG_EXPAND_TAIL , const GLubyte * v
#define forward_glSecondaryColor3ubvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3ubvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3ubvEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3ubvEXT(packed, ret_v) do { \
    glSecondaryColor3ubvEXT_PACKED *unpacked = (glSecondaryColor3ubvEXT_PACKED *)packed; \
    glSecondaryColor3ubvEXT_ARGS *args = (glSecondaryColor3ubvEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3ubvEXT(args->v);; \
} while(0)
void glSecondaryColor3ubvEXT(glSecondaryColor3ubvEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3ubvEXT(glSecondaryColor3ubvEXT_PACKED *_dst glSecondaryColor3ubvEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3ubvEXT_PTR)(glSecondaryColor3ubvEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3ui_RETURN
#define glSecondaryColor3ui_RETURN void
#define glSecondaryColor3ui_ARG_NAMES red, green, blue
#define glSecondaryColor3ui_ARG_EXPAND GLuint red, GLuint green, GLuint blue
#define glSecondaryColor3ui_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3ui_ARG_EXPAND_TAIL , GLuint red, GLuint green, GLuint blue
#define forward_glSecondaryColor3ui(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3ui(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3ui(packed, ret_v) do { \
    glSecondaryColor3ui_PACKED *unpacked = (glSecondaryColor3ui_PACKED *)packed; \
    glSecondaryColor3ui_ARGS *args = (glSecondaryColor3ui_ARGS *)&unpacked->args; \
    glSecondaryColor3ui(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3ui(glSecondaryColor3ui_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3ui(glSecondaryColor3ui_PACKED *_dst glSecondaryColor3ui_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3ui_PTR)(glSecondaryColor3ui_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3uiEXT_RETURN
#define glSecondaryColor3uiEXT_RETURN void
#define glSecondaryColor3uiEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3uiEXT_ARG_EXPAND GLuint red, GLuint green, GLuint blue
#define glSecondaryColor3uiEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3uiEXT_ARG_EXPAND_TAIL , GLuint red, GLuint green, GLuint blue
#define forward_glSecondaryColor3uiEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3uiEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3uiEXT(packed, ret_v) do { \
    glSecondaryColor3uiEXT_PACKED *unpacked = (glSecondaryColor3uiEXT_PACKED *)packed; \
    glSecondaryColor3uiEXT_ARGS *args = (glSecondaryColor3uiEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3uiEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3uiEXT(glSecondaryColor3uiEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3uiEXT(glSecondaryColor3uiEXT_PACKED *_dst glSecondaryColor3uiEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3uiEXT_PTR)(glSecondaryColor3uiEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3uiv_RETURN
#define glSecondaryColor3uiv_RETURN void
#define glSecondaryColor3uiv_ARG_NAMES v
#define glSecondaryColor3uiv_ARG_EXPAND const GLuint * v
#define glSecondaryColor3uiv_ARG_NAMES_TAIL , v
#define glSecondaryColor3uiv_ARG_EXPAND_TAIL , const GLuint * v
#define forward_glSecondaryColor3uiv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3uiv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3uiv(packed, ret_v) do { \
    glSecondaryColor3uiv_PACKED *unpacked = (glSecondaryColor3uiv_PACKED *)packed; \
    glSecondaryColor3uiv_ARGS *args = (glSecondaryColor3uiv_ARGS *)&unpacked->args; \
    glSecondaryColor3uiv(args->v);; \
} while(0)
void glSecondaryColor3uiv(glSecondaryColor3uiv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3uiv(glSecondaryColor3uiv_PACKED *_dst glSecondaryColor3uiv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3uiv_PTR)(glSecondaryColor3uiv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3uivEXT_RETURN
#define glSecondaryColor3uivEXT_RETURN void
#define glSecondaryColor3uivEXT_ARG_NAMES v
#define glSecondaryColor3uivEXT_ARG_EXPAND const GLuint * v
#define glSecondaryColor3uivEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3uivEXT_ARG_EXPAND_TAIL , const GLuint * v
#define forward_glSecondaryColor3uivEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3uivEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3uivEXT(packed, ret_v) do { \
    glSecondaryColor3uivEXT_PACKED *unpacked = (glSecondaryColor3uivEXT_PACKED *)packed; \
    glSecondaryColor3uivEXT_ARGS *args = (glSecondaryColor3uivEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3uivEXT(args->v);; \
} while(0)
void glSecondaryColor3uivEXT(glSecondaryColor3uivEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3uivEXT(glSecondaryColor3uivEXT_PACKED *_dst glSecondaryColor3uivEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3uivEXT_PTR)(glSecondaryColor3uivEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3us_RETURN
#define glSecondaryColor3us_RETURN void
#define glSecondaryColor3us_ARG_NAMES red, green, blue
#define glSecondaryColor3us_ARG_EXPAND GLushort red, GLushort green, GLushort blue
#define glSecondaryColor3us_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3us_ARG_EXPAND_TAIL , GLushort red, GLushort green, GLushort blue
#define forward_glSecondaryColor3us(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3us_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3us(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3us(packed, ret_v) do { \
    glSecondaryColor3us_PACKED *unpacked = (glSecondaryColor3us_PACKED *)packed; \
    glSecondaryColor3us_ARGS *args = (glSecondaryColor3us_ARGS *)&unpacked->args; \
    glSecondaryColor3us(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3us(glSecondaryColor3us_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3us(glSecondaryColor3us_PACKED *_dst glSecondaryColor3us_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3us_PTR)(glSecondaryColor3us_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3usEXT_RETURN
#define glSecondaryColor3usEXT_RETURN void
#define glSecondaryColor3usEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3usEXT_ARG_EXPAND GLushort red, GLushort green, GLushort blue
#define glSecondaryColor3usEXT_ARG_NAMES_TAIL , red, green, blue
#define glSecondaryColor3usEXT_ARG_EXPAND_TAIL , GLushort red, GLushort green, GLushort blue
#define forward_glSecondaryColor3usEXT(_red, _green, _blue) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3usEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3usEXT(dst, _red, _green, _blue), NULL); \
    });
#define call_glSecondaryColor3usEXT(packed, ret_v) do { \
    glSecondaryColor3usEXT_PACKED *unpacked = (glSecondaryColor3usEXT_PACKED *)packed; \
    glSecondaryColor3usEXT_ARGS *args = (glSecondaryColor3usEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3usEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3usEXT(glSecondaryColor3usEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3usEXT(glSecondaryColor3usEXT_PACKED *_dst glSecondaryColor3usEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3usEXT_PTR)(glSecondaryColor3usEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3usv_RETURN
#define glSecondaryColor3usv_RETURN void
#define glSecondaryColor3usv_ARG_NAMES v
#define glSecondaryColor3usv_ARG_EXPAND const GLushort * v
#define glSecondaryColor3usv_ARG_NAMES_TAIL , v
#define glSecondaryColor3usv_ARG_EXPAND_TAIL , const GLushort * v
#define forward_glSecondaryColor3usv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3usv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3usv(dst, _v), NULL); \
    });
#define call_glSecondaryColor3usv(packed, ret_v) do { \
    glSecondaryColor3usv_PACKED *unpacked = (glSecondaryColor3usv_PACKED *)packed; \
    glSecondaryColor3usv_ARGS *args = (glSecondaryColor3usv_ARGS *)&unpacked->args; \
    glSecondaryColor3usv(args->v);; \
} while(0)
void glSecondaryColor3usv(glSecondaryColor3usv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3usv(glSecondaryColor3usv_PACKED *_dst glSecondaryColor3usv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3usv_PTR)(glSecondaryColor3usv_ARG_EXPAND);
#endif
#ifndef glSecondaryColor3usvEXT_RETURN
#define glSecondaryColor3usvEXT_RETURN void
#define glSecondaryColor3usvEXT_ARG_NAMES v
#define glSecondaryColor3usvEXT_ARG_EXPAND const GLushort * v
#define glSecondaryColor3usvEXT_ARG_NAMES_TAIL , v
#define glSecondaryColor3usvEXT_ARG_EXPAND_TAIL , const GLushort * v
#define forward_glSecondaryColor3usvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColor3usvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColor3usvEXT(dst, _v), NULL); \
    });
#define call_glSecondaryColor3usvEXT(packed, ret_v) do { \
    glSecondaryColor3usvEXT_PACKED *unpacked = (glSecondaryColor3usvEXT_PACKED *)packed; \
    glSecondaryColor3usvEXT_ARGS *args = (glSecondaryColor3usvEXT_ARGS *)&unpacked->args; \
    glSecondaryColor3usvEXT(args->v);; \
} while(0)
void glSecondaryColor3usvEXT(glSecondaryColor3usvEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColor3usvEXT(glSecondaryColor3usvEXT_PACKED *_dst glSecondaryColor3usvEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColor3usvEXT_PTR)(glSecondaryColor3usvEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColorFormatNV_RETURN
#define glSecondaryColorFormatNV_RETURN void
#define glSecondaryColorFormatNV_ARG_NAMES size, type, stride
#define glSecondaryColorFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glSecondaryColorFormatNV_ARG_NAMES_TAIL , size, type, stride
#define glSecondaryColorFormatNV_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride
#define forward_glSecondaryColorFormatNV(_size, _type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColorFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColorFormatNV(dst, _size, _type, _stride), NULL); \
    });
#define call_glSecondaryColorFormatNV(packed, ret_v) do { \
    glSecondaryColorFormatNV_PACKED *unpacked = (glSecondaryColorFormatNV_PACKED *)packed; \
    glSecondaryColorFormatNV_ARGS *args = (glSecondaryColorFormatNV_ARGS *)&unpacked->args; \
    glSecondaryColorFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glSecondaryColorFormatNV(glSecondaryColorFormatNV_ARG_EXPAND);
packed_call_t *pack_glSecondaryColorFormatNV(glSecondaryColorFormatNV_PACKED *_dst glSecondaryColorFormatNV_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColorFormatNV_PTR)(glSecondaryColorFormatNV_ARG_EXPAND);
#endif
#ifndef glSecondaryColorP3ui_RETURN
#define glSecondaryColorP3ui_RETURN void
#define glSecondaryColorP3ui_ARG_NAMES type, color
#define glSecondaryColorP3ui_ARG_EXPAND GLenum type, GLuint color
#define glSecondaryColorP3ui_ARG_NAMES_TAIL , type, color
#define glSecondaryColorP3ui_ARG_EXPAND_TAIL , GLenum type, GLuint color
#define forward_glSecondaryColorP3ui(_type, _color) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColorP3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColorP3ui(dst, _type, _color), NULL); \
    });
#define call_glSecondaryColorP3ui(packed, ret_v) do { \
    glSecondaryColorP3ui_PACKED *unpacked = (glSecondaryColorP3ui_PACKED *)packed; \
    glSecondaryColorP3ui_ARGS *args = (glSecondaryColorP3ui_ARGS *)&unpacked->args; \
    glSecondaryColorP3ui(args->type, args->color);; \
} while(0)
void glSecondaryColorP3ui(glSecondaryColorP3ui_ARG_EXPAND);
packed_call_t *pack_glSecondaryColorP3ui(glSecondaryColorP3ui_PACKED *_dst glSecondaryColorP3ui_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColorP3ui_PTR)(glSecondaryColorP3ui_ARG_EXPAND);
#endif
#ifndef glSecondaryColorP3uiv_RETURN
#define glSecondaryColorP3uiv_RETURN void
#define glSecondaryColorP3uiv_ARG_NAMES type, color
#define glSecondaryColorP3uiv_ARG_EXPAND GLenum type, const GLuint * color
#define glSecondaryColorP3uiv_ARG_NAMES_TAIL , type, color
#define glSecondaryColorP3uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * color
#define forward_glSecondaryColorP3uiv(_type, _color) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColorP3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColorP3uiv(dst, _type, _color), NULL); \
    });
#define call_glSecondaryColorP3uiv(packed, ret_v) do { \
    glSecondaryColorP3uiv_PACKED *unpacked = (glSecondaryColorP3uiv_PACKED *)packed; \
    glSecondaryColorP3uiv_ARGS *args = (glSecondaryColorP3uiv_ARGS *)&unpacked->args; \
    glSecondaryColorP3uiv(args->type, args->color);; \
} while(0)
void glSecondaryColorP3uiv(glSecondaryColorP3uiv_ARG_EXPAND);
packed_call_t *pack_glSecondaryColorP3uiv(glSecondaryColorP3uiv_PACKED *_dst glSecondaryColorP3uiv_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColorP3uiv_PTR)(glSecondaryColorP3uiv_ARG_EXPAND);
#endif
#ifndef glSecondaryColorPointer_RETURN
#define glSecondaryColorPointer_RETURN void
#define glSecondaryColorPointer_ARG_NAMES size, type, stride, pointer
#define glSecondaryColorPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glSecondaryColorPointer_ARG_NAMES_TAIL , size, type, stride, pointer
#define glSecondaryColorPointer_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glSecondaryColorPointer(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColorPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColorPointer(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glSecondaryColorPointer(packed, ret_v) do { \
    glSecondaryColorPointer_PACKED *unpacked = (glSecondaryColorPointer_PACKED *)packed; \
    glSecondaryColorPointer_ARGS *args = (glSecondaryColorPointer_ARGS *)&unpacked->args; \
    glSecondaryColorPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glSecondaryColorPointer(glSecondaryColorPointer_ARG_EXPAND);
packed_call_t *pack_glSecondaryColorPointer(glSecondaryColorPointer_PACKED *_dst glSecondaryColorPointer_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColorPointer_PTR)(glSecondaryColorPointer_ARG_EXPAND);
#endif
#ifndef glSecondaryColorPointerEXT_RETURN
#define glSecondaryColorPointerEXT_RETURN void
#define glSecondaryColorPointerEXT_ARG_NAMES size, type, stride, pointer
#define glSecondaryColorPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glSecondaryColorPointerEXT_ARG_NAMES_TAIL , size, type, stride, pointer
#define glSecondaryColorPointerEXT_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glSecondaryColorPointerEXT(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColorPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColorPointerEXT(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glSecondaryColorPointerEXT(packed, ret_v) do { \
    glSecondaryColorPointerEXT_PACKED *unpacked = (glSecondaryColorPointerEXT_PACKED *)packed; \
    glSecondaryColorPointerEXT_ARGS *args = (glSecondaryColorPointerEXT_ARGS *)&unpacked->args; \
    glSecondaryColorPointerEXT(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glSecondaryColorPointerEXT(glSecondaryColorPointerEXT_ARG_EXPAND);
packed_call_t *pack_glSecondaryColorPointerEXT(glSecondaryColorPointerEXT_PACKED *_dst glSecondaryColorPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColorPointerEXT_PTR)(glSecondaryColorPointerEXT_ARG_EXPAND);
#endif
#ifndef glSecondaryColorPointerListIBM_RETURN
#define glSecondaryColorPointerListIBM_RETURN void
#define glSecondaryColorPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glSecondaryColorPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glSecondaryColorPointerListIBM_ARG_NAMES_TAIL , size, type, stride, pointer, ptrstride
#define glSecondaryColorPointerListIBM_ARG_EXPAND_TAIL , GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define forward_glSecondaryColorPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glSecondaryColorPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSecondaryColorPointerListIBM(dst, _size, _type, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glSecondaryColorPointerListIBM(packed, ret_v) do { \
    glSecondaryColorPointerListIBM_PACKED *unpacked = (glSecondaryColorPointerListIBM_PACKED *)packed; \
    glSecondaryColorPointerListIBM_ARGS *args = (glSecondaryColorPointerListIBM_ARGS *)&unpacked->args; \
    glSecondaryColorPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glSecondaryColorPointerListIBM(glSecondaryColorPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glSecondaryColorPointerListIBM(glSecondaryColorPointerListIBM_PACKED *_dst glSecondaryColorPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glSecondaryColorPointerListIBM_PTR)(glSecondaryColorPointerListIBM_ARG_EXPAND);
#endif
#ifndef glSelectBuffer_RETURN
#define glSelectBuffer_RETURN void
#define glSelectBuffer_ARG_NAMES size, buffer
#define glSelectBuffer_ARG_EXPAND GLsizei size, GLuint * buffer
#define glSelectBuffer_ARG_NAMES_TAIL , size, buffer
#define glSelectBuffer_ARG_EXPAND_TAIL , GLsizei size, GLuint * buffer
#define forward_glSelectBuffer(_size, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glSelectBuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSelectBuffer(dst, _size, _buffer), NULL); \
    });
#define call_glSelectBuffer(packed, ret_v) do { \
    glSelectBuffer_PACKED *unpacked = (glSelectBuffer_PACKED *)packed; \
    glSelectBuffer_ARGS *args = (glSelectBuffer_ARGS *)&unpacked->args; \
    glSelectBuffer(args->size, args->buffer);; \
} while(0)
void glSelectBuffer(glSelectBuffer_ARG_EXPAND);
packed_call_t *pack_glSelectBuffer(glSelectBuffer_PACKED *_dst glSelectBuffer_ARG_EXPAND_TAIL);
typedef void (*glSelectBuffer_PTR)(glSelectBuffer_ARG_EXPAND);
#endif
#ifndef glSelectPerfMonitorCountersAMD_RETURN
#define glSelectPerfMonitorCountersAMD_RETURN void
#define glSelectPerfMonitorCountersAMD_ARG_NAMES monitor, enable, group, numCounters, counterList
#define glSelectPerfMonitorCountersAMD_ARG_EXPAND GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList
#define glSelectPerfMonitorCountersAMD_ARG_NAMES_TAIL , monitor, enable, group, numCounters, counterList
#define glSelectPerfMonitorCountersAMD_ARG_EXPAND_TAIL , GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList
#define forward_glSelectPerfMonitorCountersAMD(_monitor, _enable, _group, _numCounters, _counterList) \
    ({ \
        void *dst = remote_dma(sizeof(glSelectPerfMonitorCountersAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSelectPerfMonitorCountersAMD(dst, _monitor, _enable, _group, _numCounters, _counterList), NULL); \
    });
#define call_glSelectPerfMonitorCountersAMD(packed, ret_v) do { \
    glSelectPerfMonitorCountersAMD_PACKED *unpacked = (glSelectPerfMonitorCountersAMD_PACKED *)packed; \
    glSelectPerfMonitorCountersAMD_ARGS *args = (glSelectPerfMonitorCountersAMD_ARGS *)&unpacked->args; \
    glSelectPerfMonitorCountersAMD(args->monitor, args->enable, args->group, args->numCounters, args->counterList);; \
} while(0)
void glSelectPerfMonitorCountersAMD(glSelectPerfMonitorCountersAMD_ARG_EXPAND);
packed_call_t *pack_glSelectPerfMonitorCountersAMD(glSelectPerfMonitorCountersAMD_PACKED *_dst glSelectPerfMonitorCountersAMD_ARG_EXPAND_TAIL);
typedef void (*glSelectPerfMonitorCountersAMD_PTR)(glSelectPerfMonitorCountersAMD_ARG_EXPAND);
#endif
#ifndef glSeparableFilter2D_RETURN
#define glSeparableFilter2D_RETURN void
#define glSeparableFilter2D_ARG_NAMES target, internalformat, width, height, format, type, row, column
#define glSeparableFilter2D_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column
#define glSeparableFilter2D_ARG_NAMES_TAIL , target, internalformat, width, height, format, type, row, column
#define glSeparableFilter2D_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column
#define forward_glSeparableFilter2D(_target, _internalformat, _width, _height, _format, _type, _row, _column) \
    ({ \
        void *dst = remote_dma(sizeof(glSeparableFilter2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSeparableFilter2D(dst, _target, _internalformat, _width, _height, _format, _type, _row, _column), NULL); \
    });
#define call_glSeparableFilter2D(packed, ret_v) do { \
    glSeparableFilter2D_PACKED *unpacked = (glSeparableFilter2D_PACKED *)packed; \
    glSeparableFilter2D_ARGS *args = (glSeparableFilter2D_ARGS *)&unpacked->args; \
    glSeparableFilter2D(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->row, args->column);; \
} while(0)
void glSeparableFilter2D(glSeparableFilter2D_ARG_EXPAND);
packed_call_t *pack_glSeparableFilter2D(glSeparableFilter2D_PACKED *_dst glSeparableFilter2D_ARG_EXPAND_TAIL);
typedef void (*glSeparableFilter2D_PTR)(glSeparableFilter2D_ARG_EXPAND);
#endif
#ifndef glSeparableFilter2DEXT_RETURN
#define glSeparableFilter2DEXT_RETURN void
#define glSeparableFilter2DEXT_ARG_NAMES target, internalformat, width, height, format, type, row, column
#define glSeparableFilter2DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column
#define glSeparableFilter2DEXT_ARG_NAMES_TAIL , target, internalformat, width, height, format, type, row, column
#define glSeparableFilter2DEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column
#define forward_glSeparableFilter2DEXT(_target, _internalformat, _width, _height, _format, _type, _row, _column) \
    ({ \
        void *dst = remote_dma(sizeof(glSeparableFilter2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSeparableFilter2DEXT(dst, _target, _internalformat, _width, _height, _format, _type, _row, _column), NULL); \
    });
#define call_glSeparableFilter2DEXT(packed, ret_v) do { \
    glSeparableFilter2DEXT_PACKED *unpacked = (glSeparableFilter2DEXT_PACKED *)packed; \
    glSeparableFilter2DEXT_ARGS *args = (glSeparableFilter2DEXT_ARGS *)&unpacked->args; \
    glSeparableFilter2DEXT(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->row, args->column);; \
} while(0)
void glSeparableFilter2DEXT(glSeparableFilter2DEXT_ARG_EXPAND);
packed_call_t *pack_glSeparableFilter2DEXT(glSeparableFilter2DEXT_PACKED *_dst glSeparableFilter2DEXT_ARG_EXPAND_TAIL);
typedef void (*glSeparableFilter2DEXT_PTR)(glSeparableFilter2DEXT_ARG_EXPAND);
#endif
#ifndef glSetFenceAPPLE_RETURN
#define glSetFenceAPPLE_RETURN void
#define glSetFenceAPPLE_ARG_NAMES fence
#define glSetFenceAPPLE_ARG_EXPAND GLuint fence
#define glSetFenceAPPLE_ARG_NAMES_TAIL , fence
#define glSetFenceAPPLE_ARG_EXPAND_TAIL , GLuint fence
#define forward_glSetFenceAPPLE(_fence) \
    ({ \
        void *dst = remote_dma(sizeof(glSetFenceAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSetFenceAPPLE(dst, _fence), NULL); \
    });
#define call_glSetFenceAPPLE(packed, ret_v) do { \
    glSetFenceAPPLE_PACKED *unpacked = (glSetFenceAPPLE_PACKED *)packed; \
    glSetFenceAPPLE_ARGS *args = (glSetFenceAPPLE_ARGS *)&unpacked->args; \
    glSetFenceAPPLE(args->fence);; \
} while(0)
void glSetFenceAPPLE(glSetFenceAPPLE_ARG_EXPAND);
packed_call_t *pack_glSetFenceAPPLE(glSetFenceAPPLE_PACKED *_dst glSetFenceAPPLE_ARG_EXPAND_TAIL);
typedef void (*glSetFenceAPPLE_PTR)(glSetFenceAPPLE_ARG_EXPAND);
#endif
#ifndef glSetFenceNV_RETURN
#define glSetFenceNV_RETURN void
#define glSetFenceNV_ARG_NAMES fence, condition
#define glSetFenceNV_ARG_EXPAND GLuint fence, GLenum condition
#define glSetFenceNV_ARG_NAMES_TAIL , fence, condition
#define glSetFenceNV_ARG_EXPAND_TAIL , GLuint fence, GLenum condition
#define forward_glSetFenceNV(_fence, _condition) \
    ({ \
        void *dst = remote_dma(sizeof(glSetFenceNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSetFenceNV(dst, _fence, _condition), NULL); \
    });
#define call_glSetFenceNV(packed, ret_v) do { \
    glSetFenceNV_PACKED *unpacked = (glSetFenceNV_PACKED *)packed; \
    glSetFenceNV_ARGS *args = (glSetFenceNV_ARGS *)&unpacked->args; \
    glSetFenceNV(args->fence, args->condition);; \
} while(0)
void glSetFenceNV(glSetFenceNV_ARG_EXPAND);
packed_call_t *pack_glSetFenceNV(glSetFenceNV_PACKED *_dst glSetFenceNV_ARG_EXPAND_TAIL);
typedef void (*glSetFenceNV_PTR)(glSetFenceNV_ARG_EXPAND);
#endif
#ifndef glSetFragmentShaderConstantATI_RETURN
#define glSetFragmentShaderConstantATI_RETURN void
#define glSetFragmentShaderConstantATI_ARG_NAMES dst, value
#define glSetFragmentShaderConstantATI_ARG_EXPAND GLuint dst, const GLfloat * value
#define glSetFragmentShaderConstantATI_ARG_NAMES_TAIL , dst, value
#define glSetFragmentShaderConstantATI_ARG_EXPAND_TAIL , GLuint dst, const GLfloat * value
#define forward_glSetFragmentShaderConstantATI(_dst, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glSetFragmentShaderConstantATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSetFragmentShaderConstantATI(dst, _dst, _value), NULL); \
    });
#define call_glSetFragmentShaderConstantATI(packed, ret_v) do { \
    glSetFragmentShaderConstantATI_PACKED *unpacked = (glSetFragmentShaderConstantATI_PACKED *)packed; \
    glSetFragmentShaderConstantATI_ARGS *args = (glSetFragmentShaderConstantATI_ARGS *)&unpacked->args; \
    glSetFragmentShaderConstantATI(args->dst, args->value);; \
} while(0)
void glSetFragmentShaderConstantATI(glSetFragmentShaderConstantATI_ARG_EXPAND);
packed_call_t *pack_glSetFragmentShaderConstantATI(glSetFragmentShaderConstantATI_PACKED *_dst glSetFragmentShaderConstantATI_ARG_EXPAND_TAIL);
typedef void (*glSetFragmentShaderConstantATI_PTR)(glSetFragmentShaderConstantATI_ARG_EXPAND);
#endif
#ifndef glSetInvariantEXT_RETURN
#define glSetInvariantEXT_RETURN void
#define glSetInvariantEXT_ARG_NAMES id, type, addr
#define glSetInvariantEXT_ARG_EXPAND GLuint id, GLenum type, const GLvoid * addr
#define glSetInvariantEXT_ARG_NAMES_TAIL , id, type, addr
#define glSetInvariantEXT_ARG_EXPAND_TAIL , GLuint id, GLenum type, const GLvoid * addr
#define forward_glSetInvariantEXT(_id, _type, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glSetInvariantEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSetInvariantEXT(dst, _id, _type, _addr), NULL); \
    });
#define call_glSetInvariantEXT(packed, ret_v) do { \
    glSetInvariantEXT_PACKED *unpacked = (glSetInvariantEXT_PACKED *)packed; \
    glSetInvariantEXT_ARGS *args = (glSetInvariantEXT_ARGS *)&unpacked->args; \
    glSetInvariantEXT(args->id, args->type, args->addr);; \
} while(0)
void glSetInvariantEXT(glSetInvariantEXT_ARG_EXPAND);
packed_call_t *pack_glSetInvariantEXT(glSetInvariantEXT_PACKED *_dst glSetInvariantEXT_ARG_EXPAND_TAIL);
typedef void (*glSetInvariantEXT_PTR)(glSetInvariantEXT_ARG_EXPAND);
#endif
#ifndef glSetLocalConstantEXT_RETURN
#define glSetLocalConstantEXT_RETURN void
#define glSetLocalConstantEXT_ARG_NAMES id, type, addr
#define glSetLocalConstantEXT_ARG_EXPAND GLuint id, GLenum type, const GLvoid * addr
#define glSetLocalConstantEXT_ARG_NAMES_TAIL , id, type, addr
#define glSetLocalConstantEXT_ARG_EXPAND_TAIL , GLuint id, GLenum type, const GLvoid * addr
#define forward_glSetLocalConstantEXT(_id, _type, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glSetLocalConstantEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSetLocalConstantEXT(dst, _id, _type, _addr), NULL); \
    });
#define call_glSetLocalConstantEXT(packed, ret_v) do { \
    glSetLocalConstantEXT_PACKED *unpacked = (glSetLocalConstantEXT_PACKED *)packed; \
    glSetLocalConstantEXT_ARGS *args = (glSetLocalConstantEXT_ARGS *)&unpacked->args; \
    glSetLocalConstantEXT(args->id, args->type, args->addr);; \
} while(0)
void glSetLocalConstantEXT(glSetLocalConstantEXT_ARG_EXPAND);
packed_call_t *pack_glSetLocalConstantEXT(glSetLocalConstantEXT_PACKED *_dst glSetLocalConstantEXT_ARG_EXPAND_TAIL);
typedef void (*glSetLocalConstantEXT_PTR)(glSetLocalConstantEXT_ARG_EXPAND);
#endif
#ifndef glSetMultisamplefvAMD_RETURN
#define glSetMultisamplefvAMD_RETURN void
#define glSetMultisamplefvAMD_ARG_NAMES pname, index, val
#define glSetMultisamplefvAMD_ARG_EXPAND GLenum pname, GLuint index, const GLfloat * val
#define glSetMultisamplefvAMD_ARG_NAMES_TAIL , pname, index, val
#define glSetMultisamplefvAMD_ARG_EXPAND_TAIL , GLenum pname, GLuint index, const GLfloat * val
#define forward_glSetMultisamplefvAMD(_pname, _index, _val) \
    ({ \
        void *dst = remote_dma(sizeof(glSetMultisamplefvAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSetMultisamplefvAMD(dst, _pname, _index, _val), NULL); \
    });
#define call_glSetMultisamplefvAMD(packed, ret_v) do { \
    glSetMultisamplefvAMD_PACKED *unpacked = (glSetMultisamplefvAMD_PACKED *)packed; \
    glSetMultisamplefvAMD_ARGS *args = (glSetMultisamplefvAMD_ARGS *)&unpacked->args; \
    glSetMultisamplefvAMD(args->pname, args->index, args->val);; \
} while(0)
void glSetMultisamplefvAMD(glSetMultisamplefvAMD_ARG_EXPAND);
packed_call_t *pack_glSetMultisamplefvAMD(glSetMultisamplefvAMD_PACKED *_dst glSetMultisamplefvAMD_ARG_EXPAND_TAIL);
typedef void (*glSetMultisamplefvAMD_PTR)(glSetMultisamplefvAMD_ARG_EXPAND);
#endif
#ifndef glShadeModel_RETURN
#define glShadeModel_RETURN void
#define glShadeModel_ARG_NAMES mode
#define glShadeModel_ARG_EXPAND GLenum mode
#define glShadeModel_ARG_NAMES_TAIL , mode
#define glShadeModel_ARG_EXPAND_TAIL , GLenum mode
#define forward_glShadeModel(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glShadeModel_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShadeModel(dst, _mode), NULL); \
    });
#define call_glShadeModel(packed, ret_v) do { \
    glShadeModel_PACKED *unpacked = (glShadeModel_PACKED *)packed; \
    glShadeModel_ARGS *args = (glShadeModel_ARGS *)&unpacked->args; \
    glShadeModel(args->mode);; \
} while(0)
void glShadeModel(glShadeModel_ARG_EXPAND);
packed_call_t *pack_glShadeModel(glShadeModel_PACKED *_dst glShadeModel_ARG_EXPAND_TAIL);
typedef void (*glShadeModel_PTR)(glShadeModel_ARG_EXPAND);
#endif
#ifndef glShaderBinary_RETURN
#define glShaderBinary_RETURN void
#define glShaderBinary_ARG_NAMES count, shaders, binaryformat, binary, length
#define glShaderBinary_ARG_EXPAND GLsizei count, const GLuint * shaders, GLenum binaryformat, const GLvoid * binary, GLsizei length
#define glShaderBinary_ARG_NAMES_TAIL , count, shaders, binaryformat, binary, length
#define glShaderBinary_ARG_EXPAND_TAIL , GLsizei count, const GLuint * shaders, GLenum binaryformat, const GLvoid * binary, GLsizei length
#define forward_glShaderBinary(_count, _shaders, _binaryformat, _binary, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glShaderBinary_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShaderBinary(dst, _count, _shaders, _binaryformat, _binary, _length), NULL); \
    });
#define call_glShaderBinary(packed, ret_v) do { \
    glShaderBinary_PACKED *unpacked = (glShaderBinary_PACKED *)packed; \
    glShaderBinary_ARGS *args = (glShaderBinary_ARGS *)&unpacked->args; \
    glShaderBinary(args->count, args->shaders, args->binaryformat, args->binary, args->length);; \
} while(0)
void glShaderBinary(glShaderBinary_ARG_EXPAND);
packed_call_t *pack_glShaderBinary(glShaderBinary_PACKED *_dst glShaderBinary_ARG_EXPAND_TAIL);
typedef void (*glShaderBinary_PTR)(glShaderBinary_ARG_EXPAND);
#endif
#ifndef glShaderOp1EXT_RETURN
#define glShaderOp1EXT_RETURN void
#define glShaderOp1EXT_ARG_NAMES op, res, arg1
#define glShaderOp1EXT_ARG_EXPAND GLenum op, GLuint res, GLuint arg1
#define glShaderOp1EXT_ARG_NAMES_TAIL , op, res, arg1
#define glShaderOp1EXT_ARG_EXPAND_TAIL , GLenum op, GLuint res, GLuint arg1
#define forward_glShaderOp1EXT(_op, _res, _arg1) \
    ({ \
        void *dst = remote_dma(sizeof(glShaderOp1EXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShaderOp1EXT(dst, _op, _res, _arg1), NULL); \
    });
#define call_glShaderOp1EXT(packed, ret_v) do { \
    glShaderOp1EXT_PACKED *unpacked = (glShaderOp1EXT_PACKED *)packed; \
    glShaderOp1EXT_ARGS *args = (glShaderOp1EXT_ARGS *)&unpacked->args; \
    glShaderOp1EXT(args->op, args->res, args->arg1);; \
} while(0)
void glShaderOp1EXT(glShaderOp1EXT_ARG_EXPAND);
packed_call_t *pack_glShaderOp1EXT(glShaderOp1EXT_PACKED *_dst glShaderOp1EXT_ARG_EXPAND_TAIL);
typedef void (*glShaderOp1EXT_PTR)(glShaderOp1EXT_ARG_EXPAND);
#endif
#ifndef glShaderOp2EXT_RETURN
#define glShaderOp2EXT_RETURN void
#define glShaderOp2EXT_ARG_NAMES op, res, arg1, arg2
#define glShaderOp2EXT_ARG_EXPAND GLenum op, GLuint res, GLuint arg1, GLuint arg2
#define glShaderOp2EXT_ARG_NAMES_TAIL , op, res, arg1, arg2
#define glShaderOp2EXT_ARG_EXPAND_TAIL , GLenum op, GLuint res, GLuint arg1, GLuint arg2
#define forward_glShaderOp2EXT(_op, _res, _arg1, _arg2) \
    ({ \
        void *dst = remote_dma(sizeof(glShaderOp2EXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShaderOp2EXT(dst, _op, _res, _arg1, _arg2), NULL); \
    });
#define call_glShaderOp2EXT(packed, ret_v) do { \
    glShaderOp2EXT_PACKED *unpacked = (glShaderOp2EXT_PACKED *)packed; \
    glShaderOp2EXT_ARGS *args = (glShaderOp2EXT_ARGS *)&unpacked->args; \
    glShaderOp2EXT(args->op, args->res, args->arg1, args->arg2);; \
} while(0)
void glShaderOp2EXT(glShaderOp2EXT_ARG_EXPAND);
packed_call_t *pack_glShaderOp2EXT(glShaderOp2EXT_PACKED *_dst glShaderOp2EXT_ARG_EXPAND_TAIL);
typedef void (*glShaderOp2EXT_PTR)(glShaderOp2EXT_ARG_EXPAND);
#endif
#ifndef glShaderOp3EXT_RETURN
#define glShaderOp3EXT_RETURN void
#define glShaderOp3EXT_ARG_NAMES op, res, arg1, arg2, arg3
#define glShaderOp3EXT_ARG_EXPAND GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3
#define glShaderOp3EXT_ARG_NAMES_TAIL , op, res, arg1, arg2, arg3
#define glShaderOp3EXT_ARG_EXPAND_TAIL , GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3
#define forward_glShaderOp3EXT(_op, _res, _arg1, _arg2, _arg3) \
    ({ \
        void *dst = remote_dma(sizeof(glShaderOp3EXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShaderOp3EXT(dst, _op, _res, _arg1, _arg2, _arg3), NULL); \
    });
#define call_glShaderOp3EXT(packed, ret_v) do { \
    glShaderOp3EXT_PACKED *unpacked = (glShaderOp3EXT_PACKED *)packed; \
    glShaderOp3EXT_ARGS *args = (glShaderOp3EXT_ARGS *)&unpacked->args; \
    glShaderOp3EXT(args->op, args->res, args->arg1, args->arg2, args->arg3);; \
} while(0)
void glShaderOp3EXT(glShaderOp3EXT_ARG_EXPAND);
packed_call_t *pack_glShaderOp3EXT(glShaderOp3EXT_PACKED *_dst glShaderOp3EXT_ARG_EXPAND_TAIL);
typedef void (*glShaderOp3EXT_PTR)(glShaderOp3EXT_ARG_EXPAND);
#endif
#ifndef glShaderSource_RETURN
#define glShaderSource_RETURN void
#define glShaderSource_ARG_NAMES shader, count, string, length
#define glShaderSource_ARG_EXPAND GLuint shader, GLsizei count, const GLchar * const * string, const GLint * length
#define glShaderSource_ARG_NAMES_TAIL , shader, count, string, length
#define glShaderSource_ARG_EXPAND_TAIL , GLuint shader, GLsizei count, const GLchar * const * string, const GLint * length
#define forward_glShaderSource(_shader, _count, _string, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glShaderSource_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShaderSource(dst, _shader, _count, _string, _length), NULL); \
    });
#define call_glShaderSource(packed, ret_v) do { \
    glShaderSource_PACKED *unpacked = (glShaderSource_PACKED *)packed; \
    glShaderSource_ARGS *args = (glShaderSource_ARGS *)&unpacked->args; \
    glShaderSource(args->shader, args->count, args->string, args->length);; \
} while(0)
void glShaderSource(glShaderSource_ARG_EXPAND);
packed_call_t *pack_glShaderSource(glShaderSource_PACKED *_dst glShaderSource_ARG_EXPAND_TAIL);
typedef void (*glShaderSource_PTR)(glShaderSource_ARG_EXPAND);
#endif
#ifndef glShaderSourceARB_RETURN
#define glShaderSourceARB_RETURN void
#define glShaderSourceARB_ARG_NAMES shaderObj, count, string, length
#define glShaderSourceARB_ARG_EXPAND GLhandleARB shaderObj, GLsizei count, const GLcharARB * string, const GLint * length
#define glShaderSourceARB_ARG_NAMES_TAIL , shaderObj, count, string, length
#define glShaderSourceARB_ARG_EXPAND_TAIL , GLhandleARB shaderObj, GLsizei count, const GLcharARB * string, const GLint * length
#define forward_glShaderSourceARB(_shaderObj, _count, _string, _length) \
    ({ \
        void *dst = remote_dma(sizeof(glShaderSourceARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShaderSourceARB(dst, _shaderObj, _count, _string, _length), NULL); \
    });
#define call_glShaderSourceARB(packed, ret_v) do { \
    glShaderSourceARB_PACKED *unpacked = (glShaderSourceARB_PACKED *)packed; \
    glShaderSourceARB_ARGS *args = (glShaderSourceARB_ARGS *)&unpacked->args; \
    glShaderSourceARB(args->shaderObj, args->count, args->string, args->length);; \
} while(0)
void glShaderSourceARB(glShaderSourceARB_ARG_EXPAND);
packed_call_t *pack_glShaderSourceARB(glShaderSourceARB_PACKED *_dst glShaderSourceARB_ARG_EXPAND_TAIL);
typedef void (*glShaderSourceARB_PTR)(glShaderSourceARB_ARG_EXPAND);
#endif
#ifndef glShaderStorageBlockBinding_RETURN
#define glShaderStorageBlockBinding_RETURN void
#define glShaderStorageBlockBinding_ARG_NAMES program, storageBlockIndex, storageBlockBinding
#define glShaderStorageBlockBinding_ARG_EXPAND GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding
#define glShaderStorageBlockBinding_ARG_NAMES_TAIL , program, storageBlockIndex, storageBlockBinding
#define glShaderStorageBlockBinding_ARG_EXPAND_TAIL , GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding
#define forward_glShaderStorageBlockBinding(_program, _storageBlockIndex, _storageBlockBinding) \
    ({ \
        void *dst = remote_dma(sizeof(glShaderStorageBlockBinding_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glShaderStorageBlockBinding(dst, _program, _storageBlockIndex, _storageBlockBinding), NULL); \
    });
#define call_glShaderStorageBlockBinding(packed, ret_v) do { \
    glShaderStorageBlockBinding_PACKED *unpacked = (glShaderStorageBlockBinding_PACKED *)packed; \
    glShaderStorageBlockBinding_ARGS *args = (glShaderStorageBlockBinding_ARGS *)&unpacked->args; \
    glShaderStorageBlockBinding(args->program, args->storageBlockIndex, args->storageBlockBinding);; \
} while(0)
void glShaderStorageBlockBinding(glShaderStorageBlockBinding_ARG_EXPAND);
packed_call_t *pack_glShaderStorageBlockBinding(glShaderStorageBlockBinding_PACKED *_dst glShaderStorageBlockBinding_ARG_EXPAND_TAIL);
typedef void (*glShaderStorageBlockBinding_PTR)(glShaderStorageBlockBinding_ARG_EXPAND);
#endif
#ifndef glSharpenTexFuncSGIS_RETURN
#define glSharpenTexFuncSGIS_RETURN void
#define glSharpenTexFuncSGIS_ARG_NAMES target, n, points
#define glSharpenTexFuncSGIS_ARG_EXPAND GLenum target, GLsizei n, const GLfloat * points
#define glSharpenTexFuncSGIS_ARG_NAMES_TAIL , target, n, points
#define glSharpenTexFuncSGIS_ARG_EXPAND_TAIL , GLenum target, GLsizei n, const GLfloat * points
#define forward_glSharpenTexFuncSGIS(_target, _n, _points) \
    ({ \
        void *dst = remote_dma(sizeof(glSharpenTexFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSharpenTexFuncSGIS(dst, _target, _n, _points), NULL); \
    });
#define call_glSharpenTexFuncSGIS(packed, ret_v) do { \
    glSharpenTexFuncSGIS_PACKED *unpacked = (glSharpenTexFuncSGIS_PACKED *)packed; \
    glSharpenTexFuncSGIS_ARGS *args = (glSharpenTexFuncSGIS_ARGS *)&unpacked->args; \
    glSharpenTexFuncSGIS(args->target, args->n, args->points);; \
} while(0)
void glSharpenTexFuncSGIS(glSharpenTexFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glSharpenTexFuncSGIS(glSharpenTexFuncSGIS_PACKED *_dst glSharpenTexFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glSharpenTexFuncSGIS_PTR)(glSharpenTexFuncSGIS_ARG_EXPAND);
#endif
#ifndef glSpriteParameterfSGIX_RETURN
#define glSpriteParameterfSGIX_RETURN void
#define glSpriteParameterfSGIX_ARG_NAMES pname, param
#define glSpriteParameterfSGIX_ARG_EXPAND GLenum pname, GLfloat param
#define glSpriteParameterfSGIX_ARG_NAMES_TAIL , pname, param
#define glSpriteParameterfSGIX_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glSpriteParameterfSGIX(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSpriteParameterfSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSpriteParameterfSGIX(dst, _pname, _param), NULL); \
    });
#define call_glSpriteParameterfSGIX(packed, ret_v) do { \
    glSpriteParameterfSGIX_PACKED *unpacked = (glSpriteParameterfSGIX_PACKED *)packed; \
    glSpriteParameterfSGIX_ARGS *args = (glSpriteParameterfSGIX_ARGS *)&unpacked->args; \
    glSpriteParameterfSGIX(args->pname, args->param);; \
} while(0)
void glSpriteParameterfSGIX(glSpriteParameterfSGIX_ARG_EXPAND);
packed_call_t *pack_glSpriteParameterfSGIX(glSpriteParameterfSGIX_PACKED *_dst glSpriteParameterfSGIX_ARG_EXPAND_TAIL);
typedef void (*glSpriteParameterfSGIX_PTR)(glSpriteParameterfSGIX_ARG_EXPAND);
#endif
#ifndef glSpriteParameterfvSGIX_RETURN
#define glSpriteParameterfvSGIX_RETURN void
#define glSpriteParameterfvSGIX_ARG_NAMES pname, params
#define glSpriteParameterfvSGIX_ARG_EXPAND GLenum pname, const GLfloat * params
#define glSpriteParameterfvSGIX_ARG_NAMES_TAIL , pname, params
#define glSpriteParameterfvSGIX_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * params
#define forward_glSpriteParameterfvSGIX(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glSpriteParameterfvSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSpriteParameterfvSGIX(dst, _pname, _params), NULL); \
    });
#define call_glSpriteParameterfvSGIX(packed, ret_v) do { \
    glSpriteParameterfvSGIX_PACKED *unpacked = (glSpriteParameterfvSGIX_PACKED *)packed; \
    glSpriteParameterfvSGIX_ARGS *args = (glSpriteParameterfvSGIX_ARGS *)&unpacked->args; \
    glSpriteParameterfvSGIX(args->pname, args->params);; \
} while(0)
void glSpriteParameterfvSGIX(glSpriteParameterfvSGIX_ARG_EXPAND);
packed_call_t *pack_glSpriteParameterfvSGIX(glSpriteParameterfvSGIX_PACKED *_dst glSpriteParameterfvSGIX_ARG_EXPAND_TAIL);
typedef void (*glSpriteParameterfvSGIX_PTR)(glSpriteParameterfvSGIX_ARG_EXPAND);
#endif
#ifndef glSpriteParameteriSGIX_RETURN
#define glSpriteParameteriSGIX_RETURN void
#define glSpriteParameteriSGIX_ARG_NAMES pname, param
#define glSpriteParameteriSGIX_ARG_EXPAND GLenum pname, GLint param
#define glSpriteParameteriSGIX_ARG_NAMES_TAIL , pname, param
#define glSpriteParameteriSGIX_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glSpriteParameteriSGIX(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glSpriteParameteriSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSpriteParameteriSGIX(dst, _pname, _param), NULL); \
    });
#define call_glSpriteParameteriSGIX(packed, ret_v) do { \
    glSpriteParameteriSGIX_PACKED *unpacked = (glSpriteParameteriSGIX_PACKED *)packed; \
    glSpriteParameteriSGIX_ARGS *args = (glSpriteParameteriSGIX_ARGS *)&unpacked->args; \
    glSpriteParameteriSGIX(args->pname, args->param);; \
} while(0)
void glSpriteParameteriSGIX(glSpriteParameteriSGIX_ARG_EXPAND);
packed_call_t *pack_glSpriteParameteriSGIX(glSpriteParameteriSGIX_PACKED *_dst glSpriteParameteriSGIX_ARG_EXPAND_TAIL);
typedef void (*glSpriteParameteriSGIX_PTR)(glSpriteParameteriSGIX_ARG_EXPAND);
#endif
#ifndef glSpriteParameterivSGIX_RETURN
#define glSpriteParameterivSGIX_RETURN void
#define glSpriteParameterivSGIX_ARG_NAMES pname, params
#define glSpriteParameterivSGIX_ARG_EXPAND GLenum pname, const GLint * params
#define glSpriteParameterivSGIX_ARG_NAMES_TAIL , pname, params
#define glSpriteParameterivSGIX_ARG_EXPAND_TAIL , GLenum pname, const GLint * params
#define forward_glSpriteParameterivSGIX(_pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glSpriteParameterivSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSpriteParameterivSGIX(dst, _pname, _params), NULL); \
    });
#define call_glSpriteParameterivSGIX(packed, ret_v) do { \
    glSpriteParameterivSGIX_PACKED *unpacked = (glSpriteParameterivSGIX_PACKED *)packed; \
    glSpriteParameterivSGIX_ARGS *args = (glSpriteParameterivSGIX_ARGS *)&unpacked->args; \
    glSpriteParameterivSGIX(args->pname, args->params);; \
} while(0)
void glSpriteParameterivSGIX(glSpriteParameterivSGIX_ARG_EXPAND);
packed_call_t *pack_glSpriteParameterivSGIX(glSpriteParameterivSGIX_PACKED *_dst glSpriteParameterivSGIX_ARG_EXPAND_TAIL);
typedef void (*glSpriteParameterivSGIX_PTR)(glSpriteParameterivSGIX_ARG_EXPAND);
#endif
#ifndef glStartInstrumentsSGIX_RETURN
#define glStartInstrumentsSGIX_RETURN void
#define glStartInstrumentsSGIX_ARG_NAMES 
#define glStartInstrumentsSGIX_ARG_EXPAND 
#define glStartInstrumentsSGIX_ARG_NAMES_TAIL 
#define glStartInstrumentsSGIX_ARG_EXPAND_TAIL 
#define forward_glStartInstrumentsSGIX() \
    ({ \
        void *dst = remote_dma(sizeof(glStartInstrumentsSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStartInstrumentsSGIX(dst), NULL); \
    });
#define call_glStartInstrumentsSGIX(packed, ret_v) do { \
    glStartInstrumentsSGIX();; \
} while(0)
void glStartInstrumentsSGIX(glStartInstrumentsSGIX_ARG_EXPAND);
packed_call_t *pack_glStartInstrumentsSGIX(glStartInstrumentsSGIX_PACKED *_dst glStartInstrumentsSGIX_ARG_EXPAND_TAIL);
typedef void (*glStartInstrumentsSGIX_PTR)(glStartInstrumentsSGIX_ARG_EXPAND);
#endif
#ifndef glStencilClearTagEXT_RETURN
#define glStencilClearTagEXT_RETURN void
#define glStencilClearTagEXT_ARG_NAMES stencilTagBits, stencilClearTag
#define glStencilClearTagEXT_ARG_EXPAND GLsizei stencilTagBits, GLuint stencilClearTag
#define glStencilClearTagEXT_ARG_NAMES_TAIL , stencilTagBits, stencilClearTag
#define glStencilClearTagEXT_ARG_EXPAND_TAIL , GLsizei stencilTagBits, GLuint stencilClearTag
#define forward_glStencilClearTagEXT(_stencilTagBits, _stencilClearTag) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilClearTagEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilClearTagEXT(dst, _stencilTagBits, _stencilClearTag), NULL); \
    });
#define call_glStencilClearTagEXT(packed, ret_v) do { \
    glStencilClearTagEXT_PACKED *unpacked = (glStencilClearTagEXT_PACKED *)packed; \
    glStencilClearTagEXT_ARGS *args = (glStencilClearTagEXT_ARGS *)&unpacked->args; \
    glStencilClearTagEXT(args->stencilTagBits, args->stencilClearTag);; \
} while(0)
void glStencilClearTagEXT(glStencilClearTagEXT_ARG_EXPAND);
packed_call_t *pack_glStencilClearTagEXT(glStencilClearTagEXT_PACKED *_dst glStencilClearTagEXT_ARG_EXPAND_TAIL);
typedef void (*glStencilClearTagEXT_PTR)(glStencilClearTagEXT_ARG_EXPAND);
#endif
#ifndef glStencilFillPathInstancedNV_RETURN
#define glStencilFillPathInstancedNV_RETURN void
#define glStencilFillPathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues
#define glStencilFillPathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues
#define glStencilFillPathInstancedNV_ARG_NAMES_TAIL , numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues
#define glStencilFillPathInstancedNV_ARG_EXPAND_TAIL , GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues
#define forward_glStencilFillPathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _fillMode, _mask, _transformType, _transformValues) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilFillPathInstancedNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilFillPathInstancedNV(dst, _numPaths, _pathNameType, _paths, _pathBase, _fillMode, _mask, _transformType, _transformValues), NULL); \
    });
#define call_glStencilFillPathInstancedNV(packed, ret_v) do { \
    glStencilFillPathInstancedNV_PACKED *unpacked = (glStencilFillPathInstancedNV_PACKED *)packed; \
    glStencilFillPathInstancedNV_ARGS *args = (glStencilFillPathInstancedNV_ARGS *)&unpacked->args; \
    glStencilFillPathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->fillMode, args->mask, args->transformType, args->transformValues);; \
} while(0)
void glStencilFillPathInstancedNV(glStencilFillPathInstancedNV_ARG_EXPAND);
packed_call_t *pack_glStencilFillPathInstancedNV(glStencilFillPathInstancedNV_PACKED *_dst glStencilFillPathInstancedNV_ARG_EXPAND_TAIL);
typedef void (*glStencilFillPathInstancedNV_PTR)(glStencilFillPathInstancedNV_ARG_EXPAND);
#endif
#ifndef glStencilFillPathNV_RETURN
#define glStencilFillPathNV_RETURN void
#define glStencilFillPathNV_ARG_NAMES path, fillMode, mask
#define glStencilFillPathNV_ARG_EXPAND GLuint path, GLenum fillMode, GLuint mask
#define glStencilFillPathNV_ARG_NAMES_TAIL , path, fillMode, mask
#define glStencilFillPathNV_ARG_EXPAND_TAIL , GLuint path, GLenum fillMode, GLuint mask
#define forward_glStencilFillPathNV(_path, _fillMode, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilFillPathNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilFillPathNV(dst, _path, _fillMode, _mask), NULL); \
    });
#define call_glStencilFillPathNV(packed, ret_v) do { \
    glStencilFillPathNV_PACKED *unpacked = (glStencilFillPathNV_PACKED *)packed; \
    glStencilFillPathNV_ARGS *args = (glStencilFillPathNV_ARGS *)&unpacked->args; \
    glStencilFillPathNV(args->path, args->fillMode, args->mask);; \
} while(0)
void glStencilFillPathNV(glStencilFillPathNV_ARG_EXPAND);
packed_call_t *pack_glStencilFillPathNV(glStencilFillPathNV_PACKED *_dst glStencilFillPathNV_ARG_EXPAND_TAIL);
typedef void (*glStencilFillPathNV_PTR)(glStencilFillPathNV_ARG_EXPAND);
#endif
#ifndef glStencilFunc_RETURN
#define glStencilFunc_RETURN void
#define glStencilFunc_ARG_NAMES func, ref, mask
#define glStencilFunc_ARG_EXPAND GLenum func, GLint ref, GLuint mask
#define glStencilFunc_ARG_NAMES_TAIL , func, ref, mask
#define glStencilFunc_ARG_EXPAND_TAIL , GLenum func, GLint ref, GLuint mask
#define forward_glStencilFunc(_func, _ref, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilFunc_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilFunc(dst, _func, _ref, _mask), NULL); \
    });
#define call_glStencilFunc(packed, ret_v) do { \
    glStencilFunc_PACKED *unpacked = (glStencilFunc_PACKED *)packed; \
    glStencilFunc_ARGS *args = (glStencilFunc_ARGS *)&unpacked->args; \
    glStencilFunc(args->func, args->ref, args->mask);; \
} while(0)
void glStencilFunc(glStencilFunc_ARG_EXPAND);
packed_call_t *pack_glStencilFunc(glStencilFunc_PACKED *_dst glStencilFunc_ARG_EXPAND_TAIL);
typedef void (*glStencilFunc_PTR)(glStencilFunc_ARG_EXPAND);
#endif
#ifndef glStencilFuncSeparate_RETURN
#define glStencilFuncSeparate_RETURN void
#define glStencilFuncSeparate_ARG_NAMES face, func, ref, mask
#define glStencilFuncSeparate_ARG_EXPAND GLenum face, GLenum func, GLint ref, GLuint mask
#define glStencilFuncSeparate_ARG_NAMES_TAIL , face, func, ref, mask
#define glStencilFuncSeparate_ARG_EXPAND_TAIL , GLenum face, GLenum func, GLint ref, GLuint mask
#define forward_glStencilFuncSeparate(_face, _func, _ref, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilFuncSeparate_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilFuncSeparate(dst, _face, _func, _ref, _mask), NULL); \
    });
#define call_glStencilFuncSeparate(packed, ret_v) do { \
    glStencilFuncSeparate_PACKED *unpacked = (glStencilFuncSeparate_PACKED *)packed; \
    glStencilFuncSeparate_ARGS *args = (glStencilFuncSeparate_ARGS *)&unpacked->args; \
    glStencilFuncSeparate(args->face, args->func, args->ref, args->mask);; \
} while(0)
void glStencilFuncSeparate(glStencilFuncSeparate_ARG_EXPAND);
packed_call_t *pack_glStencilFuncSeparate(glStencilFuncSeparate_PACKED *_dst glStencilFuncSeparate_ARG_EXPAND_TAIL);
typedef void (*glStencilFuncSeparate_PTR)(glStencilFuncSeparate_ARG_EXPAND);
#endif
#ifndef glStencilFuncSeparateATI_RETURN
#define glStencilFuncSeparateATI_RETURN void
#define glStencilFuncSeparateATI_ARG_NAMES frontfunc, backfunc, ref, mask
#define glStencilFuncSeparateATI_ARG_EXPAND GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask
#define glStencilFuncSeparateATI_ARG_NAMES_TAIL , frontfunc, backfunc, ref, mask
#define glStencilFuncSeparateATI_ARG_EXPAND_TAIL , GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask
#define forward_glStencilFuncSeparateATI(_frontfunc, _backfunc, _ref, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilFuncSeparateATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilFuncSeparateATI(dst, _frontfunc, _backfunc, _ref, _mask), NULL); \
    });
#define call_glStencilFuncSeparateATI(packed, ret_v) do { \
    glStencilFuncSeparateATI_PACKED *unpacked = (glStencilFuncSeparateATI_PACKED *)packed; \
    glStencilFuncSeparateATI_ARGS *args = (glStencilFuncSeparateATI_ARGS *)&unpacked->args; \
    glStencilFuncSeparateATI(args->frontfunc, args->backfunc, args->ref, args->mask);; \
} while(0)
void glStencilFuncSeparateATI(glStencilFuncSeparateATI_ARG_EXPAND);
packed_call_t *pack_glStencilFuncSeparateATI(glStencilFuncSeparateATI_PACKED *_dst glStencilFuncSeparateATI_ARG_EXPAND_TAIL);
typedef void (*glStencilFuncSeparateATI_PTR)(glStencilFuncSeparateATI_ARG_EXPAND);
#endif
#ifndef glStencilMask_RETURN
#define glStencilMask_RETURN void
#define glStencilMask_ARG_NAMES mask
#define glStencilMask_ARG_EXPAND GLuint mask
#define glStencilMask_ARG_NAMES_TAIL , mask
#define glStencilMask_ARG_EXPAND_TAIL , GLuint mask
#define forward_glStencilMask(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilMask_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilMask(dst, _mask), NULL); \
    });
#define call_glStencilMask(packed, ret_v) do { \
    glStencilMask_PACKED *unpacked = (glStencilMask_PACKED *)packed; \
    glStencilMask_ARGS *args = (glStencilMask_ARGS *)&unpacked->args; \
    glStencilMask(args->mask);; \
} while(0)
void glStencilMask(glStencilMask_ARG_EXPAND);
packed_call_t *pack_glStencilMask(glStencilMask_PACKED *_dst glStencilMask_ARG_EXPAND_TAIL);
typedef void (*glStencilMask_PTR)(glStencilMask_ARG_EXPAND);
#endif
#ifndef glStencilMaskSeparate_RETURN
#define glStencilMaskSeparate_RETURN void
#define glStencilMaskSeparate_ARG_NAMES face, mask
#define glStencilMaskSeparate_ARG_EXPAND GLenum face, GLuint mask
#define glStencilMaskSeparate_ARG_NAMES_TAIL , face, mask
#define glStencilMaskSeparate_ARG_EXPAND_TAIL , GLenum face, GLuint mask
#define forward_glStencilMaskSeparate(_face, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilMaskSeparate_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilMaskSeparate(dst, _face, _mask), NULL); \
    });
#define call_glStencilMaskSeparate(packed, ret_v) do { \
    glStencilMaskSeparate_PACKED *unpacked = (glStencilMaskSeparate_PACKED *)packed; \
    glStencilMaskSeparate_ARGS *args = (glStencilMaskSeparate_ARGS *)&unpacked->args; \
    glStencilMaskSeparate(args->face, args->mask);; \
} while(0)
void glStencilMaskSeparate(glStencilMaskSeparate_ARG_EXPAND);
packed_call_t *pack_glStencilMaskSeparate(glStencilMaskSeparate_PACKED *_dst glStencilMaskSeparate_ARG_EXPAND_TAIL);
typedef void (*glStencilMaskSeparate_PTR)(glStencilMaskSeparate_ARG_EXPAND);
#endif
#ifndef glStencilOp_RETURN
#define glStencilOp_RETURN void
#define glStencilOp_ARG_NAMES fail, zfail, zpass
#define glStencilOp_ARG_EXPAND GLenum fail, GLenum zfail, GLenum zpass
#define glStencilOp_ARG_NAMES_TAIL , fail, zfail, zpass
#define glStencilOp_ARG_EXPAND_TAIL , GLenum fail, GLenum zfail, GLenum zpass
#define forward_glStencilOp(_fail, _zfail, _zpass) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilOp_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilOp(dst, _fail, _zfail, _zpass), NULL); \
    });
#define call_glStencilOp(packed, ret_v) do { \
    glStencilOp_PACKED *unpacked = (glStencilOp_PACKED *)packed; \
    glStencilOp_ARGS *args = (glStencilOp_ARGS *)&unpacked->args; \
    glStencilOp(args->fail, args->zfail, args->zpass);; \
} while(0)
void glStencilOp(glStencilOp_ARG_EXPAND);
packed_call_t *pack_glStencilOp(glStencilOp_PACKED *_dst glStencilOp_ARG_EXPAND_TAIL);
typedef void (*glStencilOp_PTR)(glStencilOp_ARG_EXPAND);
#endif
#ifndef glStencilOpSeparate_RETURN
#define glStencilOpSeparate_RETURN void
#define glStencilOpSeparate_ARG_NAMES face, sfail, dpfail, dppass
#define glStencilOpSeparate_ARG_EXPAND GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass
#define glStencilOpSeparate_ARG_NAMES_TAIL , face, sfail, dpfail, dppass
#define glStencilOpSeparate_ARG_EXPAND_TAIL , GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass
#define forward_glStencilOpSeparate(_face, _sfail, _dpfail, _dppass) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilOpSeparate_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilOpSeparate(dst, _face, _sfail, _dpfail, _dppass), NULL); \
    });
#define call_glStencilOpSeparate(packed, ret_v) do { \
    glStencilOpSeparate_PACKED *unpacked = (glStencilOpSeparate_PACKED *)packed; \
    glStencilOpSeparate_ARGS *args = (glStencilOpSeparate_ARGS *)&unpacked->args; \
    glStencilOpSeparate(args->face, args->sfail, args->dpfail, args->dppass);; \
} while(0)
void glStencilOpSeparate(glStencilOpSeparate_ARG_EXPAND);
packed_call_t *pack_glStencilOpSeparate(glStencilOpSeparate_PACKED *_dst glStencilOpSeparate_ARG_EXPAND_TAIL);
typedef void (*glStencilOpSeparate_PTR)(glStencilOpSeparate_ARG_EXPAND);
#endif
#ifndef glStencilOpSeparateATI_RETURN
#define glStencilOpSeparateATI_RETURN void
#define glStencilOpSeparateATI_ARG_NAMES face, sfail, dpfail, dppass
#define glStencilOpSeparateATI_ARG_EXPAND GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass
#define glStencilOpSeparateATI_ARG_NAMES_TAIL , face, sfail, dpfail, dppass
#define glStencilOpSeparateATI_ARG_EXPAND_TAIL , GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass
#define forward_glStencilOpSeparateATI(_face, _sfail, _dpfail, _dppass) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilOpSeparateATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilOpSeparateATI(dst, _face, _sfail, _dpfail, _dppass), NULL); \
    });
#define call_glStencilOpSeparateATI(packed, ret_v) do { \
    glStencilOpSeparateATI_PACKED *unpacked = (glStencilOpSeparateATI_PACKED *)packed; \
    glStencilOpSeparateATI_ARGS *args = (glStencilOpSeparateATI_ARGS *)&unpacked->args; \
    glStencilOpSeparateATI(args->face, args->sfail, args->dpfail, args->dppass);; \
} while(0)
void glStencilOpSeparateATI(glStencilOpSeparateATI_ARG_EXPAND);
packed_call_t *pack_glStencilOpSeparateATI(glStencilOpSeparateATI_PACKED *_dst glStencilOpSeparateATI_ARG_EXPAND_TAIL);
typedef void (*glStencilOpSeparateATI_PTR)(glStencilOpSeparateATI_ARG_EXPAND);
#endif
#ifndef glStencilOpValueAMD_RETURN
#define glStencilOpValueAMD_RETURN void
#define glStencilOpValueAMD_ARG_NAMES face, value
#define glStencilOpValueAMD_ARG_EXPAND GLenum face, GLuint value
#define glStencilOpValueAMD_ARG_NAMES_TAIL , face, value
#define glStencilOpValueAMD_ARG_EXPAND_TAIL , GLenum face, GLuint value
#define forward_glStencilOpValueAMD(_face, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilOpValueAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilOpValueAMD(dst, _face, _value), NULL); \
    });
#define call_glStencilOpValueAMD(packed, ret_v) do { \
    glStencilOpValueAMD_PACKED *unpacked = (glStencilOpValueAMD_PACKED *)packed; \
    glStencilOpValueAMD_ARGS *args = (glStencilOpValueAMD_ARGS *)&unpacked->args; \
    glStencilOpValueAMD(args->face, args->value);; \
} while(0)
void glStencilOpValueAMD(glStencilOpValueAMD_ARG_EXPAND);
packed_call_t *pack_glStencilOpValueAMD(glStencilOpValueAMD_PACKED *_dst glStencilOpValueAMD_ARG_EXPAND_TAIL);
typedef void (*glStencilOpValueAMD_PTR)(glStencilOpValueAMD_ARG_EXPAND);
#endif
#ifndef glStencilStrokePathInstancedNV_RETURN
#define glStencilStrokePathInstancedNV_RETURN void
#define glStencilStrokePathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues
#define glStencilStrokePathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues
#define glStencilStrokePathInstancedNV_ARG_NAMES_TAIL , numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues
#define glStencilStrokePathInstancedNV_ARG_EXPAND_TAIL , GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues
#define forward_glStencilStrokePathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _reference, _mask, _transformType, _transformValues) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilStrokePathInstancedNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilStrokePathInstancedNV(dst, _numPaths, _pathNameType, _paths, _pathBase, _reference, _mask, _transformType, _transformValues), NULL); \
    });
#define call_glStencilStrokePathInstancedNV(packed, ret_v) do { \
    glStencilStrokePathInstancedNV_PACKED *unpacked = (glStencilStrokePathInstancedNV_PACKED *)packed; \
    glStencilStrokePathInstancedNV_ARGS *args = (glStencilStrokePathInstancedNV_ARGS *)&unpacked->args; \
    glStencilStrokePathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->reference, args->mask, args->transformType, args->transformValues);; \
} while(0)
void glStencilStrokePathInstancedNV(glStencilStrokePathInstancedNV_ARG_EXPAND);
packed_call_t *pack_glStencilStrokePathInstancedNV(glStencilStrokePathInstancedNV_PACKED *_dst glStencilStrokePathInstancedNV_ARG_EXPAND_TAIL);
typedef void (*glStencilStrokePathInstancedNV_PTR)(glStencilStrokePathInstancedNV_ARG_EXPAND);
#endif
#ifndef glStencilStrokePathNV_RETURN
#define glStencilStrokePathNV_RETURN void
#define glStencilStrokePathNV_ARG_NAMES path, reference, mask
#define glStencilStrokePathNV_ARG_EXPAND GLuint path, GLint reference, GLuint mask
#define glStencilStrokePathNV_ARG_NAMES_TAIL , path, reference, mask
#define glStencilStrokePathNV_ARG_EXPAND_TAIL , GLuint path, GLint reference, GLuint mask
#define forward_glStencilStrokePathNV(_path, _reference, _mask) \
    ({ \
        void *dst = remote_dma(sizeof(glStencilStrokePathNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStencilStrokePathNV(dst, _path, _reference, _mask), NULL); \
    });
#define call_glStencilStrokePathNV(packed, ret_v) do { \
    glStencilStrokePathNV_PACKED *unpacked = (glStencilStrokePathNV_PACKED *)packed; \
    glStencilStrokePathNV_ARGS *args = (glStencilStrokePathNV_ARGS *)&unpacked->args; \
    glStencilStrokePathNV(args->path, args->reference, args->mask);; \
} while(0)
void glStencilStrokePathNV(glStencilStrokePathNV_ARG_EXPAND);
packed_call_t *pack_glStencilStrokePathNV(glStencilStrokePathNV_PACKED *_dst glStencilStrokePathNV_ARG_EXPAND_TAIL);
typedef void (*glStencilStrokePathNV_PTR)(glStencilStrokePathNV_ARG_EXPAND);
#endif
#ifndef glStopInstrumentsSGIX_RETURN
#define glStopInstrumentsSGIX_RETURN void
#define glStopInstrumentsSGIX_ARG_NAMES marker
#define glStopInstrumentsSGIX_ARG_EXPAND GLint marker
#define glStopInstrumentsSGIX_ARG_NAMES_TAIL , marker
#define glStopInstrumentsSGIX_ARG_EXPAND_TAIL , GLint marker
#define forward_glStopInstrumentsSGIX(_marker) \
    ({ \
        void *dst = remote_dma(sizeof(glStopInstrumentsSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStopInstrumentsSGIX(dst, _marker), NULL); \
    });
#define call_glStopInstrumentsSGIX(packed, ret_v) do { \
    glStopInstrumentsSGIX_PACKED *unpacked = (glStopInstrumentsSGIX_PACKED *)packed; \
    glStopInstrumentsSGIX_ARGS *args = (glStopInstrumentsSGIX_ARGS *)&unpacked->args; \
    glStopInstrumentsSGIX(args->marker);; \
} while(0)
void glStopInstrumentsSGIX(glStopInstrumentsSGIX_ARG_EXPAND);
packed_call_t *pack_glStopInstrumentsSGIX(glStopInstrumentsSGIX_PACKED *_dst glStopInstrumentsSGIX_ARG_EXPAND_TAIL);
typedef void (*glStopInstrumentsSGIX_PTR)(glStopInstrumentsSGIX_ARG_EXPAND);
#endif
#ifndef glStringMarkerGREMEDY_RETURN
#define glStringMarkerGREMEDY_RETURN void
#define glStringMarkerGREMEDY_ARG_NAMES len, string
#define glStringMarkerGREMEDY_ARG_EXPAND GLsizei len, const GLvoid * string
#define glStringMarkerGREMEDY_ARG_NAMES_TAIL , len, string
#define glStringMarkerGREMEDY_ARG_EXPAND_TAIL , GLsizei len, const GLvoid * string
#define forward_glStringMarkerGREMEDY(_len, _string) \
    ({ \
        void *dst = remote_dma(sizeof(glStringMarkerGREMEDY_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glStringMarkerGREMEDY(dst, _len, _string), NULL); \
    });
#define call_glStringMarkerGREMEDY(packed, ret_v) do { \
    glStringMarkerGREMEDY_PACKED *unpacked = (glStringMarkerGREMEDY_PACKED *)packed; \
    glStringMarkerGREMEDY_ARGS *args = (glStringMarkerGREMEDY_ARGS *)&unpacked->args; \
    glStringMarkerGREMEDY(args->len, args->string);; \
} while(0)
void glStringMarkerGREMEDY(glStringMarkerGREMEDY_ARG_EXPAND);
packed_call_t *pack_glStringMarkerGREMEDY(glStringMarkerGREMEDY_PACKED *_dst glStringMarkerGREMEDY_ARG_EXPAND_TAIL);
typedef void (*glStringMarkerGREMEDY_PTR)(glStringMarkerGREMEDY_ARG_EXPAND);
#endif
#ifndef glSwizzleEXT_RETURN
#define glSwizzleEXT_RETURN void
#define glSwizzleEXT_ARG_NAMES res, in, outX, outY, outZ, outW
#define glSwizzleEXT_ARG_EXPAND GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW
#define glSwizzleEXT_ARG_NAMES_TAIL , res, in, outX, outY, outZ, outW
#define glSwizzleEXT_ARG_EXPAND_TAIL , GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW
#define forward_glSwizzleEXT(_res, _in, _outX, _outY, _outZ, _outW) \
    ({ \
        void *dst = remote_dma(sizeof(glSwizzleEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSwizzleEXT(dst, _res, _in, _outX, _outY, _outZ, _outW), NULL); \
    });
#define call_glSwizzleEXT(packed, ret_v) do { \
    glSwizzleEXT_PACKED *unpacked = (glSwizzleEXT_PACKED *)packed; \
    glSwizzleEXT_ARGS *args = (glSwizzleEXT_ARGS *)&unpacked->args; \
    glSwizzleEXT(args->res, args->in, args->outX, args->outY, args->outZ, args->outW);; \
} while(0)
void glSwizzleEXT(glSwizzleEXT_ARG_EXPAND);
packed_call_t *pack_glSwizzleEXT(glSwizzleEXT_PACKED *_dst glSwizzleEXT_ARG_EXPAND_TAIL);
typedef void (*glSwizzleEXT_PTR)(glSwizzleEXT_ARG_EXPAND);
#endif
#ifndef glSyncTextureINTEL_RETURN
#define glSyncTextureINTEL_RETURN void
#define glSyncTextureINTEL_ARG_NAMES texture
#define glSyncTextureINTEL_ARG_EXPAND GLuint texture
#define glSyncTextureINTEL_ARG_NAMES_TAIL , texture
#define glSyncTextureINTEL_ARG_EXPAND_TAIL , GLuint texture
#define forward_glSyncTextureINTEL(_texture) \
    ({ \
        void *dst = remote_dma(sizeof(glSyncTextureINTEL_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glSyncTextureINTEL(dst, _texture), NULL); \
    });
#define call_glSyncTextureINTEL(packed, ret_v) do { \
    glSyncTextureINTEL_PACKED *unpacked = (glSyncTextureINTEL_PACKED *)packed; \
    glSyncTextureINTEL_ARGS *args = (glSyncTextureINTEL_ARGS *)&unpacked->args; \
    glSyncTextureINTEL(args->texture);; \
} while(0)
void glSyncTextureINTEL(glSyncTextureINTEL_ARG_EXPAND);
packed_call_t *pack_glSyncTextureINTEL(glSyncTextureINTEL_PACKED *_dst glSyncTextureINTEL_ARG_EXPAND_TAIL);
typedef void (*glSyncTextureINTEL_PTR)(glSyncTextureINTEL_ARG_EXPAND);
#endif
#ifndef glTagSampleBufferSGIX_RETURN
#define glTagSampleBufferSGIX_RETURN void
#define glTagSampleBufferSGIX_ARG_NAMES 
#define glTagSampleBufferSGIX_ARG_EXPAND 
#define glTagSampleBufferSGIX_ARG_NAMES_TAIL 
#define glTagSampleBufferSGIX_ARG_EXPAND_TAIL 
#define forward_glTagSampleBufferSGIX() \
    ({ \
        void *dst = remote_dma(sizeof(glTagSampleBufferSGIX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTagSampleBufferSGIX(dst), NULL); \
    });
#define call_glTagSampleBufferSGIX(packed, ret_v) do { \
    glTagSampleBufferSGIX();; \
} while(0)
void glTagSampleBufferSGIX(glTagSampleBufferSGIX_ARG_EXPAND);
packed_call_t *pack_glTagSampleBufferSGIX(glTagSampleBufferSGIX_PACKED *_dst glTagSampleBufferSGIX_ARG_EXPAND_TAIL);
typedef void (*glTagSampleBufferSGIX_PTR)(glTagSampleBufferSGIX_ARG_EXPAND);
#endif
#ifndef glTangent3bEXT_RETURN
#define glTangent3bEXT_RETURN void
#define glTangent3bEXT_ARG_NAMES tx, ty, tz
#define glTangent3bEXT_ARG_EXPAND GLbyte tx, GLbyte ty, GLbyte tz
#define glTangent3bEXT_ARG_NAMES_TAIL , tx, ty, tz
#define glTangent3bEXT_ARG_EXPAND_TAIL , GLbyte tx, GLbyte ty, GLbyte tz
#define forward_glTangent3bEXT(_tx, _ty, _tz) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3bEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3bEXT(dst, _tx, _ty, _tz), NULL); \
    });
#define call_glTangent3bEXT(packed, ret_v) do { \
    glTangent3bEXT_PACKED *unpacked = (glTangent3bEXT_PACKED *)packed; \
    glTangent3bEXT_ARGS *args = (glTangent3bEXT_ARGS *)&unpacked->args; \
    glTangent3bEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3bEXT(glTangent3bEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3bEXT(glTangent3bEXT_PACKED *_dst glTangent3bEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3bEXT_PTR)(glTangent3bEXT_ARG_EXPAND);
#endif
#ifndef glTangent3bvEXT_RETURN
#define glTangent3bvEXT_RETURN void
#define glTangent3bvEXT_ARG_NAMES v
#define glTangent3bvEXT_ARG_EXPAND const GLbyte * v
#define glTangent3bvEXT_ARG_NAMES_TAIL , v
#define glTangent3bvEXT_ARG_EXPAND_TAIL , const GLbyte * v
#define forward_glTangent3bvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3bvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3bvEXT(dst, _v), NULL); \
    });
#define call_glTangent3bvEXT(packed, ret_v) do { \
    glTangent3bvEXT_PACKED *unpacked = (glTangent3bvEXT_PACKED *)packed; \
    glTangent3bvEXT_ARGS *args = (glTangent3bvEXT_ARGS *)&unpacked->args; \
    glTangent3bvEXT(args->v);; \
} while(0)
void glTangent3bvEXT(glTangent3bvEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3bvEXT(glTangent3bvEXT_PACKED *_dst glTangent3bvEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3bvEXT_PTR)(glTangent3bvEXT_ARG_EXPAND);
#endif
#ifndef glTangent3dEXT_RETURN
#define glTangent3dEXT_RETURN void
#define glTangent3dEXT_ARG_NAMES tx, ty, tz
#define glTangent3dEXT_ARG_EXPAND GLdouble tx, GLdouble ty, GLdouble tz
#define glTangent3dEXT_ARG_NAMES_TAIL , tx, ty, tz
#define glTangent3dEXT_ARG_EXPAND_TAIL , GLdouble tx, GLdouble ty, GLdouble tz
#define forward_glTangent3dEXT(_tx, _ty, _tz) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3dEXT(dst, _tx, _ty, _tz), NULL); \
    });
#define call_glTangent3dEXT(packed, ret_v) do { \
    glTangent3dEXT_PACKED *unpacked = (glTangent3dEXT_PACKED *)packed; \
    glTangent3dEXT_ARGS *args = (glTangent3dEXT_ARGS *)&unpacked->args; \
    glTangent3dEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3dEXT(glTangent3dEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3dEXT(glTangent3dEXT_PACKED *_dst glTangent3dEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3dEXT_PTR)(glTangent3dEXT_ARG_EXPAND);
#endif
#ifndef glTangent3dvEXT_RETURN
#define glTangent3dvEXT_RETURN void
#define glTangent3dvEXT_ARG_NAMES v
#define glTangent3dvEXT_ARG_EXPAND const GLdouble * v
#define glTangent3dvEXT_ARG_NAMES_TAIL , v
#define glTangent3dvEXT_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glTangent3dvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3dvEXT(dst, _v), NULL); \
    });
#define call_glTangent3dvEXT(packed, ret_v) do { \
    glTangent3dvEXT_PACKED *unpacked = (glTangent3dvEXT_PACKED *)packed; \
    glTangent3dvEXT_ARGS *args = (glTangent3dvEXT_ARGS *)&unpacked->args; \
    glTangent3dvEXT(args->v);; \
} while(0)
void glTangent3dvEXT(glTangent3dvEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3dvEXT(glTangent3dvEXT_PACKED *_dst glTangent3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3dvEXT_PTR)(glTangent3dvEXT_ARG_EXPAND);
#endif
#ifndef glTangent3fEXT_RETURN
#define glTangent3fEXT_RETURN void
#define glTangent3fEXT_ARG_NAMES tx, ty, tz
#define glTangent3fEXT_ARG_EXPAND GLfloat tx, GLfloat ty, GLfloat tz
#define glTangent3fEXT_ARG_NAMES_TAIL , tx, ty, tz
#define glTangent3fEXT_ARG_EXPAND_TAIL , GLfloat tx, GLfloat ty, GLfloat tz
#define forward_glTangent3fEXT(_tx, _ty, _tz) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3fEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3fEXT(dst, _tx, _ty, _tz), NULL); \
    });
#define call_glTangent3fEXT(packed, ret_v) do { \
    glTangent3fEXT_PACKED *unpacked = (glTangent3fEXT_PACKED *)packed; \
    glTangent3fEXT_ARGS *args = (glTangent3fEXT_ARGS *)&unpacked->args; \
    glTangent3fEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3fEXT(glTangent3fEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3fEXT(glTangent3fEXT_PACKED *_dst glTangent3fEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3fEXT_PTR)(glTangent3fEXT_ARG_EXPAND);
#endif
#ifndef glTangent3fvEXT_RETURN
#define glTangent3fvEXT_RETURN void
#define glTangent3fvEXT_ARG_NAMES v
#define glTangent3fvEXT_ARG_EXPAND const GLfloat * v
#define glTangent3fvEXT_ARG_NAMES_TAIL , v
#define glTangent3fvEXT_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glTangent3fvEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3fvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3fvEXT(dst, _v), NULL); \
    });
#define call_glTangent3fvEXT(packed, ret_v) do { \
    glTangent3fvEXT_PACKED *unpacked = (glTangent3fvEXT_PACKED *)packed; \
    glTangent3fvEXT_ARGS *args = (glTangent3fvEXT_ARGS *)&unpacked->args; \
    glTangent3fvEXT(args->v);; \
} while(0)
void glTangent3fvEXT(glTangent3fvEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3fvEXT(glTangent3fvEXT_PACKED *_dst glTangent3fvEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3fvEXT_PTR)(glTangent3fvEXT_ARG_EXPAND);
#endif
#ifndef glTangent3iEXT_RETURN
#define glTangent3iEXT_RETURN void
#define glTangent3iEXT_ARG_NAMES tx, ty, tz
#define glTangent3iEXT_ARG_EXPAND GLint tx, GLint ty, GLint tz
#define glTangent3iEXT_ARG_NAMES_TAIL , tx, ty, tz
#define glTangent3iEXT_ARG_EXPAND_TAIL , GLint tx, GLint ty, GLint tz
#define forward_glTangent3iEXT(_tx, _ty, _tz) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3iEXT(dst, _tx, _ty, _tz), NULL); \
    });
#define call_glTangent3iEXT(packed, ret_v) do { \
    glTangent3iEXT_PACKED *unpacked = (glTangent3iEXT_PACKED *)packed; \
    glTangent3iEXT_ARGS *args = (glTangent3iEXT_ARGS *)&unpacked->args; \
    glTangent3iEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3iEXT(glTangent3iEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3iEXT(glTangent3iEXT_PACKED *_dst glTangent3iEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3iEXT_PTR)(glTangent3iEXT_ARG_EXPAND);
#endif
#ifndef glTangent3ivEXT_RETURN
#define glTangent3ivEXT_RETURN void
#define glTangent3ivEXT_ARG_NAMES v
#define glTangent3ivEXT_ARG_EXPAND const GLint * v
#define glTangent3ivEXT_ARG_NAMES_TAIL , v
#define glTangent3ivEXT_ARG_EXPAND_TAIL , const GLint * v
#define forward_glTangent3ivEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3ivEXT(dst, _v), NULL); \
    });
#define call_glTangent3ivEXT(packed, ret_v) do { \
    glTangent3ivEXT_PACKED *unpacked = (glTangent3ivEXT_PACKED *)packed; \
    glTangent3ivEXT_ARGS *args = (glTangent3ivEXT_ARGS *)&unpacked->args; \
    glTangent3ivEXT(args->v);; \
} while(0)
void glTangent3ivEXT(glTangent3ivEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3ivEXT(glTangent3ivEXT_PACKED *_dst glTangent3ivEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3ivEXT_PTR)(glTangent3ivEXT_ARG_EXPAND);
#endif
#ifndef glTangent3sEXT_RETURN
#define glTangent3sEXT_RETURN void
#define glTangent3sEXT_ARG_NAMES tx, ty, tz
#define glTangent3sEXT_ARG_EXPAND GLshort tx, GLshort ty, GLshort tz
#define glTangent3sEXT_ARG_NAMES_TAIL , tx, ty, tz
#define glTangent3sEXT_ARG_EXPAND_TAIL , GLshort tx, GLshort ty, GLshort tz
#define forward_glTangent3sEXT(_tx, _ty, _tz) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3sEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3sEXT(dst, _tx, _ty, _tz), NULL); \
    });
#define call_glTangent3sEXT(packed, ret_v) do { \
    glTangent3sEXT_PACKED *unpacked = (glTangent3sEXT_PACKED *)packed; \
    glTangent3sEXT_ARGS *args = (glTangent3sEXT_ARGS *)&unpacked->args; \
    glTangent3sEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3sEXT(glTangent3sEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3sEXT(glTangent3sEXT_PACKED *_dst glTangent3sEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3sEXT_PTR)(glTangent3sEXT_ARG_EXPAND);
#endif
#ifndef glTangent3svEXT_RETURN
#define glTangent3svEXT_RETURN void
#define glTangent3svEXT_ARG_NAMES v
#define glTangent3svEXT_ARG_EXPAND const GLshort * v
#define glTangent3svEXT_ARG_NAMES_TAIL , v
#define glTangent3svEXT_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glTangent3svEXT(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTangent3svEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangent3svEXT(dst, _v), NULL); \
    });
#define call_glTangent3svEXT(packed, ret_v) do { \
    glTangent3svEXT_PACKED *unpacked = (glTangent3svEXT_PACKED *)packed; \
    glTangent3svEXT_ARGS *args = (glTangent3svEXT_ARGS *)&unpacked->args; \
    glTangent3svEXT(args->v);; \
} while(0)
void glTangent3svEXT(glTangent3svEXT_ARG_EXPAND);
packed_call_t *pack_glTangent3svEXT(glTangent3svEXT_PACKED *_dst glTangent3svEXT_ARG_EXPAND_TAIL);
typedef void (*glTangent3svEXT_PTR)(glTangent3svEXT_ARG_EXPAND);
#endif
#ifndef glTangentPointerEXT_RETURN
#define glTangentPointerEXT_RETURN void
#define glTangentPointerEXT_ARG_NAMES type, stride, pointer
#define glTangentPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glTangentPointerEXT_ARG_NAMES_TAIL , type, stride, pointer
#define glTangentPointerEXT_ARG_EXPAND_TAIL , GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glTangentPointerEXT(_type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glTangentPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTangentPointerEXT(dst, _type, _stride, _pointer), NULL); \
    });
#define call_glTangentPointerEXT(packed, ret_v) do { \
    glTangentPointerEXT_PACKED *unpacked = (glTangentPointerEXT_PACKED *)packed; \
    glTangentPointerEXT_ARGS *args = (glTangentPointerEXT_ARGS *)&unpacked->args; \
    glTangentPointerEXT(args->type, args->stride, args->pointer);; \
} while(0)
void glTangentPointerEXT(glTangentPointerEXT_ARG_EXPAND);
packed_call_t *pack_glTangentPointerEXT(glTangentPointerEXT_PACKED *_dst glTangentPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glTangentPointerEXT_PTR)(glTangentPointerEXT_ARG_EXPAND);
#endif
#ifndef glTbufferMask3DFX_RETURN
#define glTbufferMask3DFX_RETURN void
#define glTbufferMask3DFX_ARG_NAMES mask
#define glTbufferMask3DFX_ARG_EXPAND GLuint mask
#define glTbufferMask3DFX_ARG_NAMES_TAIL , mask
#define glTbufferMask3DFX_ARG_EXPAND_TAIL , GLuint mask
#define forward_glTbufferMask3DFX(_mask) \
    ({ \
        void *dst = remote_dma(sizeof(glTbufferMask3DFX_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTbufferMask3DFX(dst, _mask), NULL); \
    });
#define call_glTbufferMask3DFX(packed, ret_v) do { \
    glTbufferMask3DFX_PACKED *unpacked = (glTbufferMask3DFX_PACKED *)packed; \
    glTbufferMask3DFX_ARGS *args = (glTbufferMask3DFX_ARGS *)&unpacked->args; \
    glTbufferMask3DFX(args->mask);; \
} while(0)
void glTbufferMask3DFX(glTbufferMask3DFX_ARG_EXPAND);
packed_call_t *pack_glTbufferMask3DFX(glTbufferMask3DFX_PACKED *_dst glTbufferMask3DFX_ARG_EXPAND_TAIL);
typedef void (*glTbufferMask3DFX_PTR)(glTbufferMask3DFX_ARG_EXPAND);
#endif
#ifndef glTessellationFactorAMD_RETURN
#define glTessellationFactorAMD_RETURN void
#define glTessellationFactorAMD_ARG_NAMES factor
#define glTessellationFactorAMD_ARG_EXPAND GLfloat factor
#define glTessellationFactorAMD_ARG_NAMES_TAIL , factor
#define glTessellationFactorAMD_ARG_EXPAND_TAIL , GLfloat factor
#define forward_glTessellationFactorAMD(_factor) \
    ({ \
        void *dst = remote_dma(sizeof(glTessellationFactorAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTessellationFactorAMD(dst, _factor), NULL); \
    });
#define call_glTessellationFactorAMD(packed, ret_v) do { \
    glTessellationFactorAMD_PACKED *unpacked = (glTessellationFactorAMD_PACKED *)packed; \
    glTessellationFactorAMD_ARGS *args = (glTessellationFactorAMD_ARGS *)&unpacked->args; \
    glTessellationFactorAMD(args->factor);; \
} while(0)
void glTessellationFactorAMD(glTessellationFactorAMD_ARG_EXPAND);
packed_call_t *pack_glTessellationFactorAMD(glTessellationFactorAMD_PACKED *_dst glTessellationFactorAMD_ARG_EXPAND_TAIL);
typedef void (*glTessellationFactorAMD_PTR)(glTessellationFactorAMD_ARG_EXPAND);
#endif
#ifndef glTessellationModeAMD_RETURN
#define glTessellationModeAMD_RETURN void
#define glTessellationModeAMD_ARG_NAMES mode
#define glTessellationModeAMD_ARG_EXPAND GLenum mode
#define glTessellationModeAMD_ARG_NAMES_TAIL , mode
#define glTessellationModeAMD_ARG_EXPAND_TAIL , GLenum mode
#define forward_glTessellationModeAMD(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glTessellationModeAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTessellationModeAMD(dst, _mode), NULL); \
    });
#define call_glTessellationModeAMD(packed, ret_v) do { \
    glTessellationModeAMD_PACKED *unpacked = (glTessellationModeAMD_PACKED *)packed; \
    glTessellationModeAMD_ARGS *args = (glTessellationModeAMD_ARGS *)&unpacked->args; \
    glTessellationModeAMD(args->mode);; \
} while(0)
void glTessellationModeAMD(glTessellationModeAMD_ARG_EXPAND);
packed_call_t *pack_glTessellationModeAMD(glTessellationModeAMD_PACKED *_dst glTessellationModeAMD_ARG_EXPAND_TAIL);
typedef void (*glTessellationModeAMD_PTR)(glTessellationModeAMD_ARG_EXPAND);
#endif
#ifndef glTestFenceAPPLE_RETURN
#define glTestFenceAPPLE_RETURN GLboolean
#define glTestFenceAPPLE_ARG_NAMES fence
#define glTestFenceAPPLE_ARG_EXPAND GLuint fence
#define glTestFenceAPPLE_ARG_NAMES_TAIL , fence
#define glTestFenceAPPLE_ARG_EXPAND_TAIL , GLuint fence
#define forward_glTestFenceAPPLE(_fence) \
    ({ \
        void *dst = remote_dma(sizeof(glTestFenceAPPLE_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glTestFenceAPPLE(dst, _fence), &ret); \
        ret; \
    });
#define call_glTestFenceAPPLE(packed, ret_v) do { \
    glTestFenceAPPLE_PACKED *unpacked = (glTestFenceAPPLE_PACKED *)packed; \
    glTestFenceAPPLE_ARGS *args = (glTestFenceAPPLE_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glTestFenceAPPLE(args->fence);; \
    } else { \
        glTestFenceAPPLE(args->fence);; \
    } \
} while(0)
GLboolean glTestFenceAPPLE(glTestFenceAPPLE_ARG_EXPAND);
packed_call_t *pack_glTestFenceAPPLE(glTestFenceAPPLE_PACKED *_dst glTestFenceAPPLE_ARG_EXPAND_TAIL);
typedef GLboolean (*glTestFenceAPPLE_PTR)(glTestFenceAPPLE_ARG_EXPAND);
#endif
#ifndef glTestFenceNV_RETURN
#define glTestFenceNV_RETURN GLboolean
#define glTestFenceNV_ARG_NAMES fence
#define glTestFenceNV_ARG_EXPAND GLuint fence
#define glTestFenceNV_ARG_NAMES_TAIL , fence
#define glTestFenceNV_ARG_EXPAND_TAIL , GLuint fence
#define forward_glTestFenceNV(_fence) \
    ({ \
        void *dst = remote_dma(sizeof(glTestFenceNV_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glTestFenceNV(dst, _fence), &ret); \
        ret; \
    });
#define call_glTestFenceNV(packed, ret_v) do { \
    glTestFenceNV_PACKED *unpacked = (glTestFenceNV_PACKED *)packed; \
    glTestFenceNV_ARGS *args = (glTestFenceNV_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glTestFenceNV(args->fence);; \
    } else { \
        glTestFenceNV(args->fence);; \
    } \
} while(0)
GLboolean glTestFenceNV(glTestFenceNV_ARG_EXPAND);
packed_call_t *pack_glTestFenceNV(glTestFenceNV_PACKED *_dst glTestFenceNV_ARG_EXPAND_TAIL);
typedef GLboolean (*glTestFenceNV_PTR)(glTestFenceNV_ARG_EXPAND);
#endif
#ifndef glTestObjectAPPLE_RETURN
#define glTestObjectAPPLE_RETURN GLboolean
#define glTestObjectAPPLE_ARG_NAMES object, name
#define glTestObjectAPPLE_ARG_EXPAND GLenum object, GLuint name
#define glTestObjectAPPLE_ARG_NAMES_TAIL , object, name
#define glTestObjectAPPLE_ARG_EXPAND_TAIL , GLenum object, GLuint name
#define forward_glTestObjectAPPLE(_object, _name) \
    ({ \
        void *dst = remote_dma(sizeof(glTestObjectAPPLE_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glTestObjectAPPLE(dst, _object, _name), &ret); \
        ret; \
    });
#define call_glTestObjectAPPLE(packed, ret_v) do { \
    glTestObjectAPPLE_PACKED *unpacked = (glTestObjectAPPLE_PACKED *)packed; \
    glTestObjectAPPLE_ARGS *args = (glTestObjectAPPLE_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glTestObjectAPPLE(args->object, args->name);; \
    } else { \
        glTestObjectAPPLE(args->object, args->name);; \
    } \
} while(0)
GLboolean glTestObjectAPPLE(glTestObjectAPPLE_ARG_EXPAND);
packed_call_t *pack_glTestObjectAPPLE(glTestObjectAPPLE_PACKED *_dst glTestObjectAPPLE_ARG_EXPAND_TAIL);
typedef GLboolean (*glTestObjectAPPLE_PTR)(glTestObjectAPPLE_ARG_EXPAND);
#endif
#ifndef glTexBuffer_RETURN
#define glTexBuffer_RETURN void
#define glTexBuffer_ARG_NAMES target, internalformat, buffer
#define glTexBuffer_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer
#define glTexBuffer_ARG_NAMES_TAIL , target, internalformat, buffer
#define glTexBuffer_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLuint buffer
#define forward_glTexBuffer(_target, _internalformat, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glTexBuffer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexBuffer(dst, _target, _internalformat, _buffer), NULL); \
    });
#define call_glTexBuffer(packed, ret_v) do { \
    glTexBuffer_PACKED *unpacked = (glTexBuffer_PACKED *)packed; \
    glTexBuffer_ARGS *args = (glTexBuffer_ARGS *)&unpacked->args; \
    glTexBuffer(args->target, args->internalformat, args->buffer);; \
} while(0)
void glTexBuffer(glTexBuffer_ARG_EXPAND);
packed_call_t *pack_glTexBuffer(glTexBuffer_PACKED *_dst glTexBuffer_ARG_EXPAND_TAIL);
typedef void (*glTexBuffer_PTR)(glTexBuffer_ARG_EXPAND);
#endif
#ifndef glTexBufferARB_RETURN
#define glTexBufferARB_RETURN void
#define glTexBufferARB_ARG_NAMES target, internalformat, buffer
#define glTexBufferARB_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer
#define glTexBufferARB_ARG_NAMES_TAIL , target, internalformat, buffer
#define glTexBufferARB_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLuint buffer
#define forward_glTexBufferARB(_target, _internalformat, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glTexBufferARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexBufferARB(dst, _target, _internalformat, _buffer), NULL); \
    });
#define call_glTexBufferARB(packed, ret_v) do { \
    glTexBufferARB_PACKED *unpacked = (glTexBufferARB_PACKED *)packed; \
    glTexBufferARB_ARGS *args = (glTexBufferARB_ARGS *)&unpacked->args; \
    glTexBufferARB(args->target, args->internalformat, args->buffer);; \
} while(0)
void glTexBufferARB(glTexBufferARB_ARG_EXPAND);
packed_call_t *pack_glTexBufferARB(glTexBufferARB_PACKED *_dst glTexBufferARB_ARG_EXPAND_TAIL);
typedef void (*glTexBufferARB_PTR)(glTexBufferARB_ARG_EXPAND);
#endif
#ifndef glTexBufferEXT_RETURN
#define glTexBufferEXT_RETURN void
#define glTexBufferEXT_ARG_NAMES target, internalformat, buffer
#define glTexBufferEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer
#define glTexBufferEXT_ARG_NAMES_TAIL , target, internalformat, buffer
#define glTexBufferEXT_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLuint buffer
#define forward_glTexBufferEXT(_target, _internalformat, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glTexBufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexBufferEXT(dst, _target, _internalformat, _buffer), NULL); \
    });
#define call_glTexBufferEXT(packed, ret_v) do { \
    glTexBufferEXT_PACKED *unpacked = (glTexBufferEXT_PACKED *)packed; \
    glTexBufferEXT_ARGS *args = (glTexBufferEXT_ARGS *)&unpacked->args; \
    glTexBufferEXT(args->target, args->internalformat, args->buffer);; \
} while(0)
void glTexBufferEXT(glTexBufferEXT_ARG_EXPAND);
packed_call_t *pack_glTexBufferEXT(glTexBufferEXT_PACKED *_dst glTexBufferEXT_ARG_EXPAND_TAIL);
typedef void (*glTexBufferEXT_PTR)(glTexBufferEXT_ARG_EXPAND);
#endif
#ifndef glTexBufferRange_RETURN
#define glTexBufferRange_RETURN void
#define glTexBufferRange_ARG_NAMES target, internalformat, buffer, offset, size
#define glTexBufferRange_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glTexBufferRange_ARG_NAMES_TAIL , target, internalformat, buffer, offset, size
#define glTexBufferRange_ARG_EXPAND_TAIL , GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size
#define forward_glTexBufferRange(_target, _internalformat, _buffer, _offset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glTexBufferRange_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexBufferRange(dst, _target, _internalformat, _buffer, _offset, _size), NULL); \
    });
#define call_glTexBufferRange(packed, ret_v) do { \
    glTexBufferRange_PACKED *unpacked = (glTexBufferRange_PACKED *)packed; \
    glTexBufferRange_ARGS *args = (glTexBufferRange_ARGS *)&unpacked->args; \
    glTexBufferRange(args->target, args->internalformat, args->buffer, args->offset, args->size);; \
} while(0)
void glTexBufferRange(glTexBufferRange_ARG_EXPAND);
packed_call_t *pack_glTexBufferRange(glTexBufferRange_PACKED *_dst glTexBufferRange_ARG_EXPAND_TAIL);
typedef void (*glTexBufferRange_PTR)(glTexBufferRange_ARG_EXPAND);
#endif
#ifndef glTexBumpParameterfvATI_RETURN
#define glTexBumpParameterfvATI_RETURN void
#define glTexBumpParameterfvATI_ARG_NAMES pname, param
#define glTexBumpParameterfvATI_ARG_EXPAND GLenum pname, const GLfloat * param
#define glTexBumpParameterfvATI_ARG_NAMES_TAIL , pname, param
#define glTexBumpParameterfvATI_ARG_EXPAND_TAIL , GLenum pname, const GLfloat * param
#define forward_glTexBumpParameterfvATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexBumpParameterfvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexBumpParameterfvATI(dst, _pname, _param), NULL); \
    });
#define call_glTexBumpParameterfvATI(packed, ret_v) do { \
    glTexBumpParameterfvATI_PACKED *unpacked = (glTexBumpParameterfvATI_PACKED *)packed; \
    glTexBumpParameterfvATI_ARGS *args = (glTexBumpParameterfvATI_ARGS *)&unpacked->args; \
    glTexBumpParameterfvATI(args->pname, args->param);; \
} while(0)
void glTexBumpParameterfvATI(glTexBumpParameterfvATI_ARG_EXPAND);
packed_call_t *pack_glTexBumpParameterfvATI(glTexBumpParameterfvATI_PACKED *_dst glTexBumpParameterfvATI_ARG_EXPAND_TAIL);
typedef void (*glTexBumpParameterfvATI_PTR)(glTexBumpParameterfvATI_ARG_EXPAND);
#endif
#ifndef glTexBumpParameterivATI_RETURN
#define glTexBumpParameterivATI_RETURN void
#define glTexBumpParameterivATI_ARG_NAMES pname, param
#define glTexBumpParameterivATI_ARG_EXPAND GLenum pname, const GLint * param
#define glTexBumpParameterivATI_ARG_NAMES_TAIL , pname, param
#define glTexBumpParameterivATI_ARG_EXPAND_TAIL , GLenum pname, const GLint * param
#define forward_glTexBumpParameterivATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexBumpParameterivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexBumpParameterivATI(dst, _pname, _param), NULL); \
    });
#define call_glTexBumpParameterivATI(packed, ret_v) do { \
    glTexBumpParameterivATI_PACKED *unpacked = (glTexBumpParameterivATI_PACKED *)packed; \
    glTexBumpParameterivATI_ARGS *args = (glTexBumpParameterivATI_ARGS *)&unpacked->args; \
    glTexBumpParameterivATI(args->pname, args->param);; \
} while(0)
void glTexBumpParameterivATI(glTexBumpParameterivATI_ARG_EXPAND);
packed_call_t *pack_glTexBumpParameterivATI(glTexBumpParameterivATI_PACKED *_dst glTexBumpParameterivATI_ARG_EXPAND_TAIL);
typedef void (*glTexBumpParameterivATI_PTR)(glTexBumpParameterivATI_ARG_EXPAND);
#endif
#ifndef glTexCoord1bOES_RETURN
#define glTexCoord1bOES_RETURN void
#define glTexCoord1bOES_ARG_NAMES s
#define glTexCoord1bOES_ARG_EXPAND GLbyte s
#define glTexCoord1bOES_ARG_NAMES_TAIL , s
#define glTexCoord1bOES_ARG_EXPAND_TAIL , GLbyte s
#define forward_glTexCoord1bOES(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1bOES(dst, _s), NULL); \
    });
#define call_glTexCoord1bOES(packed, ret_v) do { \
    glTexCoord1bOES_PACKED *unpacked = (glTexCoord1bOES_PACKED *)packed; \
    glTexCoord1bOES_ARGS *args = (glTexCoord1bOES_ARGS *)&unpacked->args; \
    glTexCoord1bOES(args->s);; \
} while(0)
void glTexCoord1bOES(glTexCoord1bOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord1bOES(glTexCoord1bOES_PACKED *_dst glTexCoord1bOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1bOES_PTR)(glTexCoord1bOES_ARG_EXPAND);
#endif
#ifndef glTexCoord1bvOES_RETURN
#define glTexCoord1bvOES_RETURN void
#define glTexCoord1bvOES_ARG_NAMES coords
#define glTexCoord1bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord1bvOES_ARG_NAMES_TAIL , coords
#define glTexCoord1bvOES_ARG_EXPAND_TAIL , const GLbyte * coords
#define forward_glTexCoord1bvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1bvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord1bvOES(packed, ret_v) do { \
    glTexCoord1bvOES_PACKED *unpacked = (glTexCoord1bvOES_PACKED *)packed; \
    glTexCoord1bvOES_ARGS *args = (glTexCoord1bvOES_ARGS *)&unpacked->args; \
    glTexCoord1bvOES(args->coords);; \
} while(0)
void glTexCoord1bvOES(glTexCoord1bvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord1bvOES(glTexCoord1bvOES_PACKED *_dst glTexCoord1bvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1bvOES_PTR)(glTexCoord1bvOES_ARG_EXPAND);
#endif
#ifndef glTexCoord1d_RETURN
#define glTexCoord1d_RETURN void
#define glTexCoord1d_ARG_NAMES s
#define glTexCoord1d_ARG_EXPAND GLdouble s
#define glTexCoord1d_ARG_NAMES_TAIL , s
#define glTexCoord1d_ARG_EXPAND_TAIL , GLdouble s
#define forward_glTexCoord1d(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1d(dst, _s), NULL); \
    });
#define call_glTexCoord1d(packed, ret_v) do { \
    glTexCoord1d_PACKED *unpacked = (glTexCoord1d_PACKED *)packed; \
    glTexCoord1d_ARGS *args = (glTexCoord1d_ARGS *)&unpacked->args; \
    glTexCoord1d(args->s);; \
} while(0)
void glTexCoord1d(glTexCoord1d_ARG_EXPAND);
packed_call_t *pack_glTexCoord1d(glTexCoord1d_PACKED *_dst glTexCoord1d_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1d_PTR)(glTexCoord1d_ARG_EXPAND);
#endif
#ifndef glTexCoord1dv_RETURN
#define glTexCoord1dv_RETURN void
#define glTexCoord1dv_ARG_NAMES v
#define glTexCoord1dv_ARG_EXPAND const GLdouble * v
#define glTexCoord1dv_ARG_NAMES_TAIL , v
#define glTexCoord1dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glTexCoord1dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1dv(dst, _v), NULL); \
    });
#define call_glTexCoord1dv(packed, ret_v) do { \
    glTexCoord1dv_PACKED *unpacked = (glTexCoord1dv_PACKED *)packed; \
    glTexCoord1dv_ARGS *args = (glTexCoord1dv_ARGS *)&unpacked->args; \
    glTexCoord1dv(args->v);; \
} while(0)
void glTexCoord1dv(glTexCoord1dv_ARG_EXPAND);
packed_call_t *pack_glTexCoord1dv(glTexCoord1dv_PACKED *_dst glTexCoord1dv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1dv_PTR)(glTexCoord1dv_ARG_EXPAND);
#endif
#ifndef glTexCoord1f_RETURN
#define glTexCoord1f_RETURN void
#define glTexCoord1f_ARG_NAMES s
#define glTexCoord1f_ARG_EXPAND GLfloat s
#define glTexCoord1f_ARG_NAMES_TAIL , s
#define glTexCoord1f_ARG_EXPAND_TAIL , GLfloat s
#define forward_glTexCoord1f(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1f(dst, _s), NULL); \
    });
#define call_glTexCoord1f(packed, ret_v) do { \
    glTexCoord1f_PACKED *unpacked = (glTexCoord1f_PACKED *)packed; \
    glTexCoord1f_ARGS *args = (glTexCoord1f_ARGS *)&unpacked->args; \
    glTexCoord1f(args->s);; \
} while(0)
void glTexCoord1f(glTexCoord1f_ARG_EXPAND);
packed_call_t *pack_glTexCoord1f(glTexCoord1f_PACKED *_dst glTexCoord1f_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1f_PTR)(glTexCoord1f_ARG_EXPAND);
#endif
#ifndef glTexCoord1fv_RETURN
#define glTexCoord1fv_RETURN void
#define glTexCoord1fv_ARG_NAMES v
#define glTexCoord1fv_ARG_EXPAND const GLfloat * v
#define glTexCoord1fv_ARG_NAMES_TAIL , v
#define glTexCoord1fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glTexCoord1fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1fv(dst, _v), NULL); \
    });
#define call_glTexCoord1fv(packed, ret_v) do { \
    glTexCoord1fv_PACKED *unpacked = (glTexCoord1fv_PACKED *)packed; \
    glTexCoord1fv_ARGS *args = (glTexCoord1fv_ARGS *)&unpacked->args; \
    glTexCoord1fv(args->v);; \
} while(0)
void glTexCoord1fv(glTexCoord1fv_ARG_EXPAND);
packed_call_t *pack_glTexCoord1fv(glTexCoord1fv_PACKED *_dst glTexCoord1fv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1fv_PTR)(glTexCoord1fv_ARG_EXPAND);
#endif
#ifndef glTexCoord1hNV_RETURN
#define glTexCoord1hNV_RETURN void
#define glTexCoord1hNV_ARG_NAMES s
#define glTexCoord1hNV_ARG_EXPAND GLhalfNV s
#define glTexCoord1hNV_ARG_NAMES_TAIL , s
#define glTexCoord1hNV_ARG_EXPAND_TAIL , GLhalfNV s
#define forward_glTexCoord1hNV(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1hNV(dst, _s), NULL); \
    });
#define call_glTexCoord1hNV(packed, ret_v) do { \
    glTexCoord1hNV_PACKED *unpacked = (glTexCoord1hNV_PACKED *)packed; \
    glTexCoord1hNV_ARGS *args = (glTexCoord1hNV_ARGS *)&unpacked->args; \
    glTexCoord1hNV(args->s);; \
} while(0)
void glTexCoord1hNV(glTexCoord1hNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord1hNV(glTexCoord1hNV_PACKED *_dst glTexCoord1hNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1hNV_PTR)(glTexCoord1hNV_ARG_EXPAND);
#endif
#ifndef glTexCoord1hvNV_RETURN
#define glTexCoord1hvNV_RETURN void
#define glTexCoord1hvNV_ARG_NAMES v
#define glTexCoord1hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord1hvNV_ARG_NAMES_TAIL , v
#define glTexCoord1hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glTexCoord1hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1hvNV(dst, _v), NULL); \
    });
#define call_glTexCoord1hvNV(packed, ret_v) do { \
    glTexCoord1hvNV_PACKED *unpacked = (glTexCoord1hvNV_PACKED *)packed; \
    glTexCoord1hvNV_ARGS *args = (glTexCoord1hvNV_ARGS *)&unpacked->args; \
    glTexCoord1hvNV(args->v);; \
} while(0)
void glTexCoord1hvNV(glTexCoord1hvNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord1hvNV(glTexCoord1hvNV_PACKED *_dst glTexCoord1hvNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1hvNV_PTR)(glTexCoord1hvNV_ARG_EXPAND);
#endif
#ifndef glTexCoord1i_RETURN
#define glTexCoord1i_RETURN void
#define glTexCoord1i_ARG_NAMES s
#define glTexCoord1i_ARG_EXPAND GLint s
#define glTexCoord1i_ARG_NAMES_TAIL , s
#define glTexCoord1i_ARG_EXPAND_TAIL , GLint s
#define forward_glTexCoord1i(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1i(dst, _s), NULL); \
    });
#define call_glTexCoord1i(packed, ret_v) do { \
    glTexCoord1i_PACKED *unpacked = (glTexCoord1i_PACKED *)packed; \
    glTexCoord1i_ARGS *args = (glTexCoord1i_ARGS *)&unpacked->args; \
    glTexCoord1i(args->s);; \
} while(0)
void glTexCoord1i(glTexCoord1i_ARG_EXPAND);
packed_call_t *pack_glTexCoord1i(glTexCoord1i_PACKED *_dst glTexCoord1i_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1i_PTR)(glTexCoord1i_ARG_EXPAND);
#endif
#ifndef glTexCoord1iv_RETURN
#define glTexCoord1iv_RETURN void
#define glTexCoord1iv_ARG_NAMES v
#define glTexCoord1iv_ARG_EXPAND const GLint * v
#define glTexCoord1iv_ARG_NAMES_TAIL , v
#define glTexCoord1iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glTexCoord1iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1iv(dst, _v), NULL); \
    });
#define call_glTexCoord1iv(packed, ret_v) do { \
    glTexCoord1iv_PACKED *unpacked = (glTexCoord1iv_PACKED *)packed; \
    glTexCoord1iv_ARGS *args = (glTexCoord1iv_ARGS *)&unpacked->args; \
    glTexCoord1iv(args->v);; \
} while(0)
void glTexCoord1iv(glTexCoord1iv_ARG_EXPAND);
packed_call_t *pack_glTexCoord1iv(glTexCoord1iv_PACKED *_dst glTexCoord1iv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1iv_PTR)(glTexCoord1iv_ARG_EXPAND);
#endif
#ifndef glTexCoord1s_RETURN
#define glTexCoord1s_RETURN void
#define glTexCoord1s_ARG_NAMES s
#define glTexCoord1s_ARG_EXPAND GLshort s
#define glTexCoord1s_ARG_NAMES_TAIL , s
#define glTexCoord1s_ARG_EXPAND_TAIL , GLshort s
#define forward_glTexCoord1s(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1s(dst, _s), NULL); \
    });
#define call_glTexCoord1s(packed, ret_v) do { \
    glTexCoord1s_PACKED *unpacked = (glTexCoord1s_PACKED *)packed; \
    glTexCoord1s_ARGS *args = (glTexCoord1s_ARGS *)&unpacked->args; \
    glTexCoord1s(args->s);; \
} while(0)
void glTexCoord1s(glTexCoord1s_ARG_EXPAND);
packed_call_t *pack_glTexCoord1s(glTexCoord1s_PACKED *_dst glTexCoord1s_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1s_PTR)(glTexCoord1s_ARG_EXPAND);
#endif
#ifndef glTexCoord1sv_RETURN
#define glTexCoord1sv_RETURN void
#define glTexCoord1sv_ARG_NAMES v
#define glTexCoord1sv_ARG_EXPAND const GLshort * v
#define glTexCoord1sv_ARG_NAMES_TAIL , v
#define glTexCoord1sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glTexCoord1sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1sv(dst, _v), NULL); \
    });
#define call_glTexCoord1sv(packed, ret_v) do { \
    glTexCoord1sv_PACKED *unpacked = (glTexCoord1sv_PACKED *)packed; \
    glTexCoord1sv_ARGS *args = (glTexCoord1sv_ARGS *)&unpacked->args; \
    glTexCoord1sv(args->v);; \
} while(0)
void glTexCoord1sv(glTexCoord1sv_ARG_EXPAND);
packed_call_t *pack_glTexCoord1sv(glTexCoord1sv_PACKED *_dst glTexCoord1sv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1sv_PTR)(glTexCoord1sv_ARG_EXPAND);
#endif
#ifndef glTexCoord1xOES_RETURN
#define glTexCoord1xOES_RETURN void
#define glTexCoord1xOES_ARG_NAMES s
#define glTexCoord1xOES_ARG_EXPAND GLfixed s
#define glTexCoord1xOES_ARG_NAMES_TAIL , s
#define glTexCoord1xOES_ARG_EXPAND_TAIL , GLfixed s
#define forward_glTexCoord1xOES(_s) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1xOES(dst, _s), NULL); \
    });
#define call_glTexCoord1xOES(packed, ret_v) do { \
    glTexCoord1xOES_PACKED *unpacked = (glTexCoord1xOES_PACKED *)packed; \
    glTexCoord1xOES_ARGS *args = (glTexCoord1xOES_ARGS *)&unpacked->args; \
    glTexCoord1xOES(args->s);; \
} while(0)
void glTexCoord1xOES(glTexCoord1xOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord1xOES(glTexCoord1xOES_PACKED *_dst glTexCoord1xOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1xOES_PTR)(glTexCoord1xOES_ARG_EXPAND);
#endif
#ifndef glTexCoord1xvOES_RETURN
#define glTexCoord1xvOES_RETURN void
#define glTexCoord1xvOES_ARG_NAMES coords
#define glTexCoord1xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord1xvOES_ARG_NAMES_TAIL , coords
#define glTexCoord1xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glTexCoord1xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord1xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord1xvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord1xvOES(packed, ret_v) do { \
    glTexCoord1xvOES_PACKED *unpacked = (glTexCoord1xvOES_PACKED *)packed; \
    glTexCoord1xvOES_ARGS *args = (glTexCoord1xvOES_ARGS *)&unpacked->args; \
    glTexCoord1xvOES(args->coords);; \
} while(0)
void glTexCoord1xvOES(glTexCoord1xvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord1xvOES(glTexCoord1xvOES_PACKED *_dst glTexCoord1xvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord1xvOES_PTR)(glTexCoord1xvOES_ARG_EXPAND);
#endif
#ifndef glTexCoord2bOES_RETURN
#define glTexCoord2bOES_RETURN void
#define glTexCoord2bOES_ARG_NAMES s, t
#define glTexCoord2bOES_ARG_EXPAND GLbyte s, GLbyte t
#define glTexCoord2bOES_ARG_NAMES_TAIL , s, t
#define glTexCoord2bOES_ARG_EXPAND_TAIL , GLbyte s, GLbyte t
#define forward_glTexCoord2bOES(_s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2bOES(dst, _s, _t), NULL); \
    });
#define call_glTexCoord2bOES(packed, ret_v) do { \
    glTexCoord2bOES_PACKED *unpacked = (glTexCoord2bOES_PACKED *)packed; \
    glTexCoord2bOES_ARGS *args = (glTexCoord2bOES_ARGS *)&unpacked->args; \
    glTexCoord2bOES(args->s, args->t);; \
} while(0)
void glTexCoord2bOES(glTexCoord2bOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord2bOES(glTexCoord2bOES_PACKED *_dst glTexCoord2bOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2bOES_PTR)(glTexCoord2bOES_ARG_EXPAND);
#endif
#ifndef glTexCoord2bvOES_RETURN
#define glTexCoord2bvOES_RETURN void
#define glTexCoord2bvOES_ARG_NAMES coords
#define glTexCoord2bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord2bvOES_ARG_NAMES_TAIL , coords
#define glTexCoord2bvOES_ARG_EXPAND_TAIL , const GLbyte * coords
#define forward_glTexCoord2bvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2bvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord2bvOES(packed, ret_v) do { \
    glTexCoord2bvOES_PACKED *unpacked = (glTexCoord2bvOES_PACKED *)packed; \
    glTexCoord2bvOES_ARGS *args = (glTexCoord2bvOES_ARGS *)&unpacked->args; \
    glTexCoord2bvOES(args->coords);; \
} while(0)
void glTexCoord2bvOES(glTexCoord2bvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord2bvOES(glTexCoord2bvOES_PACKED *_dst glTexCoord2bvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2bvOES_PTR)(glTexCoord2bvOES_ARG_EXPAND);
#endif
#ifndef glTexCoord2d_RETURN
#define glTexCoord2d_RETURN void
#define glTexCoord2d_ARG_NAMES s, t
#define glTexCoord2d_ARG_EXPAND GLdouble s, GLdouble t
#define glTexCoord2d_ARG_NAMES_TAIL , s, t
#define glTexCoord2d_ARG_EXPAND_TAIL , GLdouble s, GLdouble t
#define forward_glTexCoord2d(_s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2d(dst, _s, _t), NULL); \
    });
#define call_glTexCoord2d(packed, ret_v) do { \
    glTexCoord2d_PACKED *unpacked = (glTexCoord2d_PACKED *)packed; \
    glTexCoord2d_ARGS *args = (glTexCoord2d_ARGS *)&unpacked->args; \
    glTexCoord2d(args->s, args->t);; \
} while(0)
void glTexCoord2d(glTexCoord2d_ARG_EXPAND);
packed_call_t *pack_glTexCoord2d(glTexCoord2d_PACKED *_dst glTexCoord2d_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2d_PTR)(glTexCoord2d_ARG_EXPAND);
#endif
#ifndef glTexCoord2dv_RETURN
#define glTexCoord2dv_RETURN void
#define glTexCoord2dv_ARG_NAMES v
#define glTexCoord2dv_ARG_EXPAND const GLdouble * v
#define glTexCoord2dv_ARG_NAMES_TAIL , v
#define glTexCoord2dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glTexCoord2dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2dv(dst, _v), NULL); \
    });
#define call_glTexCoord2dv(packed, ret_v) do { \
    glTexCoord2dv_PACKED *unpacked = (glTexCoord2dv_PACKED *)packed; \
    glTexCoord2dv_ARGS *args = (glTexCoord2dv_ARGS *)&unpacked->args; \
    glTexCoord2dv(args->v);; \
} while(0)
void glTexCoord2dv(glTexCoord2dv_ARG_EXPAND);
packed_call_t *pack_glTexCoord2dv(glTexCoord2dv_PACKED *_dst glTexCoord2dv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2dv_PTR)(glTexCoord2dv_ARG_EXPAND);
#endif
#ifndef glTexCoord2f_RETURN
#define glTexCoord2f_RETURN void
#define glTexCoord2f_ARG_NAMES s, t
#define glTexCoord2f_ARG_EXPAND GLfloat s, GLfloat t
#define glTexCoord2f_ARG_NAMES_TAIL , s, t
#define glTexCoord2f_ARG_EXPAND_TAIL , GLfloat s, GLfloat t
#define forward_glTexCoord2f(_s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2f(dst, _s, _t), NULL); \
    });
#define call_glTexCoord2f(packed, ret_v) do { \
    glTexCoord2f_PACKED *unpacked = (glTexCoord2f_PACKED *)packed; \
    glTexCoord2f_ARGS *args = (glTexCoord2f_ARGS *)&unpacked->args; \
    glTexCoord2f(args->s, args->t);; \
} while(0)
void glTexCoord2f(glTexCoord2f_ARG_EXPAND);
packed_call_t *pack_glTexCoord2f(glTexCoord2f_PACKED *_dst glTexCoord2f_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2f_PTR)(glTexCoord2f_ARG_EXPAND);
#endif
#ifndef glTexCoord2fColor3fVertex3fSUN_RETURN
#define glTexCoord2fColor3fVertex3fSUN_RETURN void
#define glTexCoord2fColor3fVertex3fSUN_ARG_NAMES s, t, r, g, b, x, y, z
#define glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fColor3fVertex3fSUN_ARG_NAMES_TAIL , s, t, r, g, b, x, y, z
#define glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define forward_glTexCoord2fColor3fVertex3fSUN(_s, _t, _r, _g, _b, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fColor3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fColor3fVertex3fSUN(dst, _s, _t, _r, _g, _b, _x, _y, _z), NULL); \
    });
#define call_glTexCoord2fColor3fVertex3fSUN(packed, ret_v) do { \
    glTexCoord2fColor3fVertex3fSUN_PACKED *unpacked = (glTexCoord2fColor3fVertex3fSUN_PACKED *)packed; \
    glTexCoord2fColor3fVertex3fSUN_ARGS *args = (glTexCoord2fColor3fVertex3fSUN_ARGS *)&unpacked->args; \
    glTexCoord2fColor3fVertex3fSUN(args->s, args->t, args->r, args->g, args->b, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fColor3fVertex3fSUN(glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fColor3fVertex3fSUN(glTexCoord2fColor3fVertex3fSUN_PACKED *_dst glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fColor3fVertex3fSUN_PTR)(glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fColor3fVertex3fvSUN_RETURN
#define glTexCoord2fColor3fVertex3fvSUN_RETURN void
#define glTexCoord2fColor3fVertex3fvSUN_ARG_NAMES tc, c, v
#define glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * c, const GLfloat * v
#define glTexCoord2fColor3fVertex3fvSUN_ARG_NAMES_TAIL , tc, c, v
#define glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * tc, const GLfloat * c, const GLfloat * v
#define forward_glTexCoord2fColor3fVertex3fvSUN(_tc, _c, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fColor3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fColor3fVertex3fvSUN(dst, _tc, _c, _v), NULL); \
    });
#define call_glTexCoord2fColor3fVertex3fvSUN(packed, ret_v) do { \
    glTexCoord2fColor3fVertex3fvSUN_PACKED *unpacked = (glTexCoord2fColor3fVertex3fvSUN_PACKED *)packed; \
    glTexCoord2fColor3fVertex3fvSUN_ARGS *args = (glTexCoord2fColor3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glTexCoord2fColor3fVertex3fvSUN(args->tc, args->c, args->v);; \
} while(0)
void glTexCoord2fColor3fVertex3fvSUN(glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fColor3fVertex3fvSUN(glTexCoord2fColor3fVertex3fvSUN_PACKED *_dst glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fColor3fVertex3fvSUN_PTR)(glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fColor4fNormal3fVertex3fSUN_RETURN
#define glTexCoord2fColor4fNormal3fVertex3fSUN_RETURN void
#define glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_NAMES s, t, r, g, b, a, nx, ny, nz, x, y, z
#define glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_NAMES_TAIL , s, t, r, g, b, a, nx, ny, nz, x, y, z
#define glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glTexCoord2fColor4fNormal3fVertex3fSUN(_s, _t, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fColor4fNormal3fVertex3fSUN(dst, _s, _t, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glTexCoord2fColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *unpacked = (glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *)packed; \
    glTexCoord2fColor4fNormal3fVertex3fSUN_ARGS *args = (glTexCoord2fColor4fNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glTexCoord2fColor4fNormal3fVertex3fSUN(args->s, args->t, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fColor4fNormal3fVertex3fSUN(glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fColor4fNormal3fVertex3fSUN(glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *_dst glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fColor4fNormal3fVertex3fSUN_PTR)(glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN void
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_NAMES tc, c, n, v
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_NAMES_TAIL , tc, c, n, v
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define forward_glTexCoord2fColor4fNormal3fVertex3fvSUN(_tc, _c, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fColor4fNormal3fVertex3fvSUN(dst, _tc, _c, _n, _v), NULL); \
    });
#define call_glTexCoord2fColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *unpacked = (glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *)packed; \
    glTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS *args = (glTexCoord2fColor4fNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glTexCoord2fColor4fNormal3fVertex3fvSUN(args->tc, args->c, args->n, args->v);; \
} while(0)
void glTexCoord2fColor4fNormal3fVertex3fvSUN(glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fColor4fNormal3fVertex3fvSUN(glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *_dst glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fColor4fNormal3fVertex3fvSUN_PTR)(glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fColor4ubVertex3fSUN_RETURN
#define glTexCoord2fColor4ubVertex3fSUN_RETURN void
#define glTexCoord2fColor4ubVertex3fSUN_ARG_NAMES s, t, r, g, b, a, x, y, z
#define glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fColor4ubVertex3fSUN_ARG_NAMES_TAIL , s, t, r, g, b, a, x, y, z
#define glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define forward_glTexCoord2fColor4ubVertex3fSUN(_s, _t, _r, _g, _b, _a, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fColor4ubVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fColor4ubVertex3fSUN(dst, _s, _t, _r, _g, _b, _a, _x, _y, _z), NULL); \
    });
#define call_glTexCoord2fColor4ubVertex3fSUN(packed, ret_v) do { \
    glTexCoord2fColor4ubVertex3fSUN_PACKED *unpacked = (glTexCoord2fColor4ubVertex3fSUN_PACKED *)packed; \
    glTexCoord2fColor4ubVertex3fSUN_ARGS *args = (glTexCoord2fColor4ubVertex3fSUN_ARGS *)&unpacked->args; \
    glTexCoord2fColor4ubVertex3fSUN(args->s, args->t, args->r, args->g, args->b, args->a, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fColor4ubVertex3fSUN(glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fColor4ubVertex3fSUN(glTexCoord2fColor4ubVertex3fSUN_PACKED *_dst glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fColor4ubVertex3fSUN_PTR)(glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fColor4ubVertex3fvSUN_RETURN
#define glTexCoord2fColor4ubVertex3fvSUN_RETURN void
#define glTexCoord2fColor4ubVertex3fvSUN_ARG_NAMES tc, c, v
#define glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLubyte * c, const GLfloat * v
#define glTexCoord2fColor4ubVertex3fvSUN_ARG_NAMES_TAIL , tc, c, v
#define glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * tc, const GLubyte * c, const GLfloat * v
#define forward_glTexCoord2fColor4ubVertex3fvSUN(_tc, _c, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fColor4ubVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fColor4ubVertex3fvSUN(dst, _tc, _c, _v), NULL); \
    });
#define call_glTexCoord2fColor4ubVertex3fvSUN(packed, ret_v) do { \
    glTexCoord2fColor4ubVertex3fvSUN_PACKED *unpacked = (glTexCoord2fColor4ubVertex3fvSUN_PACKED *)packed; \
    glTexCoord2fColor4ubVertex3fvSUN_ARGS *args = (glTexCoord2fColor4ubVertex3fvSUN_ARGS *)&unpacked->args; \
    glTexCoord2fColor4ubVertex3fvSUN(args->tc, args->c, args->v);; \
} while(0)
void glTexCoord2fColor4ubVertex3fvSUN(glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fColor4ubVertex3fvSUN(glTexCoord2fColor4ubVertex3fvSUN_PACKED *_dst glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fColor4ubVertex3fvSUN_PTR)(glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fNormal3fVertex3fSUN_RETURN
#define glTexCoord2fNormal3fVertex3fSUN_RETURN void
#define glTexCoord2fNormal3fVertex3fSUN_ARG_NAMES s, t, nx, ny, nz, x, y, z
#define glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fNormal3fVertex3fSUN_ARG_NAMES_TAIL , s, t, nx, ny, nz, x, y, z
#define glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define forward_glTexCoord2fNormal3fVertex3fSUN(_s, _t, _nx, _ny, _nz, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fNormal3fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fNormal3fVertex3fSUN(dst, _s, _t, _nx, _ny, _nz, _x, _y, _z), NULL); \
    });
#define call_glTexCoord2fNormal3fVertex3fSUN(packed, ret_v) do { \
    glTexCoord2fNormal3fVertex3fSUN_PACKED *unpacked = (glTexCoord2fNormal3fVertex3fSUN_PACKED *)packed; \
    glTexCoord2fNormal3fVertex3fSUN_ARGS *args = (glTexCoord2fNormal3fVertex3fSUN_ARGS *)&unpacked->args; \
    glTexCoord2fNormal3fVertex3fSUN(args->s, args->t, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fNormal3fVertex3fSUN(glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fNormal3fVertex3fSUN(glTexCoord2fNormal3fVertex3fSUN_PACKED *_dst glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fNormal3fVertex3fSUN_PTR)(glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fNormal3fVertex3fvSUN_RETURN
#define glTexCoord2fNormal3fVertex3fvSUN_RETURN void
#define glTexCoord2fNormal3fVertex3fvSUN_ARG_NAMES tc, n, v
#define glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * n, const GLfloat * v
#define glTexCoord2fNormal3fVertex3fvSUN_ARG_NAMES_TAIL , tc, n, v
#define glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * tc, const GLfloat * n, const GLfloat * v
#define forward_glTexCoord2fNormal3fVertex3fvSUN(_tc, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fNormal3fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fNormal3fVertex3fvSUN(dst, _tc, _n, _v), NULL); \
    });
#define call_glTexCoord2fNormal3fVertex3fvSUN(packed, ret_v) do { \
    glTexCoord2fNormal3fVertex3fvSUN_PACKED *unpacked = (glTexCoord2fNormal3fVertex3fvSUN_PACKED *)packed; \
    glTexCoord2fNormal3fVertex3fvSUN_ARGS *args = (glTexCoord2fNormal3fVertex3fvSUN_ARGS *)&unpacked->args; \
    glTexCoord2fNormal3fVertex3fvSUN(args->tc, args->n, args->v);; \
} while(0)
void glTexCoord2fNormal3fVertex3fvSUN(glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fNormal3fVertex3fvSUN(glTexCoord2fNormal3fVertex3fvSUN_PACKED *_dst glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fNormal3fVertex3fvSUN_PTR)(glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fVertex3fSUN_RETURN
#define glTexCoord2fVertex3fSUN_RETURN void
#define glTexCoord2fVertex3fSUN_ARG_NAMES s, t, x, y, z
#define glTexCoord2fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fVertex3fSUN_ARG_NAMES_TAIL , s, t, x, y, z
#define glTexCoord2fVertex3fSUN_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z
#define forward_glTexCoord2fVertex3fSUN(_s, _t, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fVertex3fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fVertex3fSUN(dst, _s, _t, _x, _y, _z), NULL); \
    });
#define call_glTexCoord2fVertex3fSUN(packed, ret_v) do { \
    glTexCoord2fVertex3fSUN_PACKED *unpacked = (glTexCoord2fVertex3fSUN_PACKED *)packed; \
    glTexCoord2fVertex3fSUN_ARGS *args = (glTexCoord2fVertex3fSUN_ARGS *)&unpacked->args; \
    glTexCoord2fVertex3fSUN(args->s, args->t, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fVertex3fSUN(glTexCoord2fVertex3fSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fVertex3fSUN(glTexCoord2fVertex3fSUN_PACKED *_dst glTexCoord2fVertex3fSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fVertex3fSUN_PTR)(glTexCoord2fVertex3fSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fVertex3fvSUN_RETURN
#define glTexCoord2fVertex3fvSUN_RETURN void
#define glTexCoord2fVertex3fvSUN_ARG_NAMES tc, v
#define glTexCoord2fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * v
#define glTexCoord2fVertex3fvSUN_ARG_NAMES_TAIL , tc, v
#define glTexCoord2fVertex3fvSUN_ARG_EXPAND_TAIL , const GLfloat * tc, const GLfloat * v
#define forward_glTexCoord2fVertex3fvSUN(_tc, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fVertex3fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fVertex3fvSUN(dst, _tc, _v), NULL); \
    });
#define call_glTexCoord2fVertex3fvSUN(packed, ret_v) do { \
    glTexCoord2fVertex3fvSUN_PACKED *unpacked = (glTexCoord2fVertex3fvSUN_PACKED *)packed; \
    glTexCoord2fVertex3fvSUN_ARGS *args = (glTexCoord2fVertex3fvSUN_ARGS *)&unpacked->args; \
    glTexCoord2fVertex3fvSUN(args->tc, args->v);; \
} while(0)
void glTexCoord2fVertex3fvSUN(glTexCoord2fVertex3fvSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fVertex3fvSUN(glTexCoord2fVertex3fvSUN_PACKED *_dst glTexCoord2fVertex3fvSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fVertex3fvSUN_PTR)(glTexCoord2fVertex3fvSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord2fv_RETURN
#define glTexCoord2fv_RETURN void
#define glTexCoord2fv_ARG_NAMES v
#define glTexCoord2fv_ARG_EXPAND const GLfloat * v
#define glTexCoord2fv_ARG_NAMES_TAIL , v
#define glTexCoord2fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glTexCoord2fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2fv(dst, _v), NULL); \
    });
#define call_glTexCoord2fv(packed, ret_v) do { \
    glTexCoord2fv_PACKED *unpacked = (glTexCoord2fv_PACKED *)packed; \
    glTexCoord2fv_ARGS *args = (glTexCoord2fv_ARGS *)&unpacked->args; \
    glTexCoord2fv(args->v);; \
} while(0)
void glTexCoord2fv(glTexCoord2fv_ARG_EXPAND);
packed_call_t *pack_glTexCoord2fv(glTexCoord2fv_PACKED *_dst glTexCoord2fv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2fv_PTR)(glTexCoord2fv_ARG_EXPAND);
#endif
#ifndef glTexCoord2hNV_RETURN
#define glTexCoord2hNV_RETURN void
#define glTexCoord2hNV_ARG_NAMES s, t
#define glTexCoord2hNV_ARG_EXPAND GLhalfNV s, GLhalfNV t
#define glTexCoord2hNV_ARG_NAMES_TAIL , s, t
#define glTexCoord2hNV_ARG_EXPAND_TAIL , GLhalfNV s, GLhalfNV t
#define forward_glTexCoord2hNV(_s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2hNV(dst, _s, _t), NULL); \
    });
#define call_glTexCoord2hNV(packed, ret_v) do { \
    glTexCoord2hNV_PACKED *unpacked = (glTexCoord2hNV_PACKED *)packed; \
    glTexCoord2hNV_ARGS *args = (glTexCoord2hNV_ARGS *)&unpacked->args; \
    glTexCoord2hNV(args->s, args->t);; \
} while(0)
void glTexCoord2hNV(glTexCoord2hNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord2hNV(glTexCoord2hNV_PACKED *_dst glTexCoord2hNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2hNV_PTR)(glTexCoord2hNV_ARG_EXPAND);
#endif
#ifndef glTexCoord2hvNV_RETURN
#define glTexCoord2hvNV_RETURN void
#define glTexCoord2hvNV_ARG_NAMES v
#define glTexCoord2hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord2hvNV_ARG_NAMES_TAIL , v
#define glTexCoord2hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glTexCoord2hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2hvNV(dst, _v), NULL); \
    });
#define call_glTexCoord2hvNV(packed, ret_v) do { \
    glTexCoord2hvNV_PACKED *unpacked = (glTexCoord2hvNV_PACKED *)packed; \
    glTexCoord2hvNV_ARGS *args = (glTexCoord2hvNV_ARGS *)&unpacked->args; \
    glTexCoord2hvNV(args->v);; \
} while(0)
void glTexCoord2hvNV(glTexCoord2hvNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord2hvNV(glTexCoord2hvNV_PACKED *_dst glTexCoord2hvNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2hvNV_PTR)(glTexCoord2hvNV_ARG_EXPAND);
#endif
#ifndef glTexCoord2i_RETURN
#define glTexCoord2i_RETURN void
#define glTexCoord2i_ARG_NAMES s, t
#define glTexCoord2i_ARG_EXPAND GLint s, GLint t
#define glTexCoord2i_ARG_NAMES_TAIL , s, t
#define glTexCoord2i_ARG_EXPAND_TAIL , GLint s, GLint t
#define forward_glTexCoord2i(_s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2i(dst, _s, _t), NULL); \
    });
#define call_glTexCoord2i(packed, ret_v) do { \
    glTexCoord2i_PACKED *unpacked = (glTexCoord2i_PACKED *)packed; \
    glTexCoord2i_ARGS *args = (glTexCoord2i_ARGS *)&unpacked->args; \
    glTexCoord2i(args->s, args->t);; \
} while(0)
void glTexCoord2i(glTexCoord2i_ARG_EXPAND);
packed_call_t *pack_glTexCoord2i(glTexCoord2i_PACKED *_dst glTexCoord2i_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2i_PTR)(glTexCoord2i_ARG_EXPAND);
#endif
#ifndef glTexCoord2iv_RETURN
#define glTexCoord2iv_RETURN void
#define glTexCoord2iv_ARG_NAMES v
#define glTexCoord2iv_ARG_EXPAND const GLint * v
#define glTexCoord2iv_ARG_NAMES_TAIL , v
#define glTexCoord2iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glTexCoord2iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2iv(dst, _v), NULL); \
    });
#define call_glTexCoord2iv(packed, ret_v) do { \
    glTexCoord2iv_PACKED *unpacked = (glTexCoord2iv_PACKED *)packed; \
    glTexCoord2iv_ARGS *args = (glTexCoord2iv_ARGS *)&unpacked->args; \
    glTexCoord2iv(args->v);; \
} while(0)
void glTexCoord2iv(glTexCoord2iv_ARG_EXPAND);
packed_call_t *pack_glTexCoord2iv(glTexCoord2iv_PACKED *_dst glTexCoord2iv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2iv_PTR)(glTexCoord2iv_ARG_EXPAND);
#endif
#ifndef glTexCoord2s_RETURN
#define glTexCoord2s_RETURN void
#define glTexCoord2s_ARG_NAMES s, t
#define glTexCoord2s_ARG_EXPAND GLshort s, GLshort t
#define glTexCoord2s_ARG_NAMES_TAIL , s, t
#define glTexCoord2s_ARG_EXPAND_TAIL , GLshort s, GLshort t
#define forward_glTexCoord2s(_s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2s(dst, _s, _t), NULL); \
    });
#define call_glTexCoord2s(packed, ret_v) do { \
    glTexCoord2s_PACKED *unpacked = (glTexCoord2s_PACKED *)packed; \
    glTexCoord2s_ARGS *args = (glTexCoord2s_ARGS *)&unpacked->args; \
    glTexCoord2s(args->s, args->t);; \
} while(0)
void glTexCoord2s(glTexCoord2s_ARG_EXPAND);
packed_call_t *pack_glTexCoord2s(glTexCoord2s_PACKED *_dst glTexCoord2s_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2s_PTR)(glTexCoord2s_ARG_EXPAND);
#endif
#ifndef glTexCoord2sv_RETURN
#define glTexCoord2sv_RETURN void
#define glTexCoord2sv_ARG_NAMES v
#define glTexCoord2sv_ARG_EXPAND const GLshort * v
#define glTexCoord2sv_ARG_NAMES_TAIL , v
#define glTexCoord2sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glTexCoord2sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2sv(dst, _v), NULL); \
    });
#define call_glTexCoord2sv(packed, ret_v) do { \
    glTexCoord2sv_PACKED *unpacked = (glTexCoord2sv_PACKED *)packed; \
    glTexCoord2sv_ARGS *args = (glTexCoord2sv_ARGS *)&unpacked->args; \
    glTexCoord2sv(args->v);; \
} while(0)
void glTexCoord2sv(glTexCoord2sv_ARG_EXPAND);
packed_call_t *pack_glTexCoord2sv(glTexCoord2sv_PACKED *_dst glTexCoord2sv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2sv_PTR)(glTexCoord2sv_ARG_EXPAND);
#endif
#ifndef glTexCoord2xOES_RETURN
#define glTexCoord2xOES_RETURN void
#define glTexCoord2xOES_ARG_NAMES s, t
#define glTexCoord2xOES_ARG_EXPAND GLfixed s, GLfixed t
#define glTexCoord2xOES_ARG_NAMES_TAIL , s, t
#define glTexCoord2xOES_ARG_EXPAND_TAIL , GLfixed s, GLfixed t
#define forward_glTexCoord2xOES(_s, _t) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2xOES(dst, _s, _t), NULL); \
    });
#define call_glTexCoord2xOES(packed, ret_v) do { \
    glTexCoord2xOES_PACKED *unpacked = (glTexCoord2xOES_PACKED *)packed; \
    glTexCoord2xOES_ARGS *args = (glTexCoord2xOES_ARGS *)&unpacked->args; \
    glTexCoord2xOES(args->s, args->t);; \
} while(0)
void glTexCoord2xOES(glTexCoord2xOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord2xOES(glTexCoord2xOES_PACKED *_dst glTexCoord2xOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2xOES_PTR)(glTexCoord2xOES_ARG_EXPAND);
#endif
#ifndef glTexCoord2xvOES_RETURN
#define glTexCoord2xvOES_RETURN void
#define glTexCoord2xvOES_ARG_NAMES coords
#define glTexCoord2xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord2xvOES_ARG_NAMES_TAIL , coords
#define glTexCoord2xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glTexCoord2xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord2xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord2xvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord2xvOES(packed, ret_v) do { \
    glTexCoord2xvOES_PACKED *unpacked = (glTexCoord2xvOES_PACKED *)packed; \
    glTexCoord2xvOES_ARGS *args = (glTexCoord2xvOES_ARGS *)&unpacked->args; \
    glTexCoord2xvOES(args->coords);; \
} while(0)
void glTexCoord2xvOES(glTexCoord2xvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord2xvOES(glTexCoord2xvOES_PACKED *_dst glTexCoord2xvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord2xvOES_PTR)(glTexCoord2xvOES_ARG_EXPAND);
#endif
#ifndef glTexCoord3bOES_RETURN
#define glTexCoord3bOES_RETURN void
#define glTexCoord3bOES_ARG_NAMES s, t, r
#define glTexCoord3bOES_ARG_EXPAND GLbyte s, GLbyte t, GLbyte r
#define glTexCoord3bOES_ARG_NAMES_TAIL , s, t, r
#define glTexCoord3bOES_ARG_EXPAND_TAIL , GLbyte s, GLbyte t, GLbyte r
#define forward_glTexCoord3bOES(_s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3bOES(dst, _s, _t, _r), NULL); \
    });
#define call_glTexCoord3bOES(packed, ret_v) do { \
    glTexCoord3bOES_PACKED *unpacked = (glTexCoord3bOES_PACKED *)packed; \
    glTexCoord3bOES_ARGS *args = (glTexCoord3bOES_ARGS *)&unpacked->args; \
    glTexCoord3bOES(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3bOES(glTexCoord3bOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord3bOES(glTexCoord3bOES_PACKED *_dst glTexCoord3bOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3bOES_PTR)(glTexCoord3bOES_ARG_EXPAND);
#endif
#ifndef glTexCoord3bvOES_RETURN
#define glTexCoord3bvOES_RETURN void
#define glTexCoord3bvOES_ARG_NAMES coords
#define glTexCoord3bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord3bvOES_ARG_NAMES_TAIL , coords
#define glTexCoord3bvOES_ARG_EXPAND_TAIL , const GLbyte * coords
#define forward_glTexCoord3bvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3bvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord3bvOES(packed, ret_v) do { \
    glTexCoord3bvOES_PACKED *unpacked = (glTexCoord3bvOES_PACKED *)packed; \
    glTexCoord3bvOES_ARGS *args = (glTexCoord3bvOES_ARGS *)&unpacked->args; \
    glTexCoord3bvOES(args->coords);; \
} while(0)
void glTexCoord3bvOES(glTexCoord3bvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord3bvOES(glTexCoord3bvOES_PACKED *_dst glTexCoord3bvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3bvOES_PTR)(glTexCoord3bvOES_ARG_EXPAND);
#endif
#ifndef glTexCoord3d_RETURN
#define glTexCoord3d_RETURN void
#define glTexCoord3d_ARG_NAMES s, t, r
#define glTexCoord3d_ARG_EXPAND GLdouble s, GLdouble t, GLdouble r
#define glTexCoord3d_ARG_NAMES_TAIL , s, t, r
#define glTexCoord3d_ARG_EXPAND_TAIL , GLdouble s, GLdouble t, GLdouble r
#define forward_glTexCoord3d(_s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3d(dst, _s, _t, _r), NULL); \
    });
#define call_glTexCoord3d(packed, ret_v) do { \
    glTexCoord3d_PACKED *unpacked = (glTexCoord3d_PACKED *)packed; \
    glTexCoord3d_ARGS *args = (glTexCoord3d_ARGS *)&unpacked->args; \
    glTexCoord3d(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3d(glTexCoord3d_ARG_EXPAND);
packed_call_t *pack_glTexCoord3d(glTexCoord3d_PACKED *_dst glTexCoord3d_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3d_PTR)(glTexCoord3d_ARG_EXPAND);
#endif
#ifndef glTexCoord3dv_RETURN
#define glTexCoord3dv_RETURN void
#define glTexCoord3dv_ARG_NAMES v
#define glTexCoord3dv_ARG_EXPAND const GLdouble * v
#define glTexCoord3dv_ARG_NAMES_TAIL , v
#define glTexCoord3dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glTexCoord3dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3dv(dst, _v), NULL); \
    });
#define call_glTexCoord3dv(packed, ret_v) do { \
    glTexCoord3dv_PACKED *unpacked = (glTexCoord3dv_PACKED *)packed; \
    glTexCoord3dv_ARGS *args = (glTexCoord3dv_ARGS *)&unpacked->args; \
    glTexCoord3dv(args->v);; \
} while(0)
void glTexCoord3dv(glTexCoord3dv_ARG_EXPAND);
packed_call_t *pack_glTexCoord3dv(glTexCoord3dv_PACKED *_dst glTexCoord3dv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3dv_PTR)(glTexCoord3dv_ARG_EXPAND);
#endif
#ifndef glTexCoord3f_RETURN
#define glTexCoord3f_RETURN void
#define glTexCoord3f_ARG_NAMES s, t, r
#define glTexCoord3f_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r
#define glTexCoord3f_ARG_NAMES_TAIL , s, t, r
#define glTexCoord3f_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat r
#define forward_glTexCoord3f(_s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3f(dst, _s, _t, _r), NULL); \
    });
#define call_glTexCoord3f(packed, ret_v) do { \
    glTexCoord3f_PACKED *unpacked = (glTexCoord3f_PACKED *)packed; \
    glTexCoord3f_ARGS *args = (glTexCoord3f_ARGS *)&unpacked->args; \
    glTexCoord3f(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3f(glTexCoord3f_ARG_EXPAND);
packed_call_t *pack_glTexCoord3f(glTexCoord3f_PACKED *_dst glTexCoord3f_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3f_PTR)(glTexCoord3f_ARG_EXPAND);
#endif
#ifndef glTexCoord3fv_RETURN
#define glTexCoord3fv_RETURN void
#define glTexCoord3fv_ARG_NAMES v
#define glTexCoord3fv_ARG_EXPAND const GLfloat * v
#define glTexCoord3fv_ARG_NAMES_TAIL , v
#define glTexCoord3fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glTexCoord3fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3fv(dst, _v), NULL); \
    });
#define call_glTexCoord3fv(packed, ret_v) do { \
    glTexCoord3fv_PACKED *unpacked = (glTexCoord3fv_PACKED *)packed; \
    glTexCoord3fv_ARGS *args = (glTexCoord3fv_ARGS *)&unpacked->args; \
    glTexCoord3fv(args->v);; \
} while(0)
void glTexCoord3fv(glTexCoord3fv_ARG_EXPAND);
packed_call_t *pack_glTexCoord3fv(glTexCoord3fv_PACKED *_dst glTexCoord3fv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3fv_PTR)(glTexCoord3fv_ARG_EXPAND);
#endif
#ifndef glTexCoord3hNV_RETURN
#define glTexCoord3hNV_RETURN void
#define glTexCoord3hNV_ARG_NAMES s, t, r
#define glTexCoord3hNV_ARG_EXPAND GLhalfNV s, GLhalfNV t, GLhalfNV r
#define glTexCoord3hNV_ARG_NAMES_TAIL , s, t, r
#define glTexCoord3hNV_ARG_EXPAND_TAIL , GLhalfNV s, GLhalfNV t, GLhalfNV r
#define forward_glTexCoord3hNV(_s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3hNV(dst, _s, _t, _r), NULL); \
    });
#define call_glTexCoord3hNV(packed, ret_v) do { \
    glTexCoord3hNV_PACKED *unpacked = (glTexCoord3hNV_PACKED *)packed; \
    glTexCoord3hNV_ARGS *args = (glTexCoord3hNV_ARGS *)&unpacked->args; \
    glTexCoord3hNV(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3hNV(glTexCoord3hNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord3hNV(glTexCoord3hNV_PACKED *_dst glTexCoord3hNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3hNV_PTR)(glTexCoord3hNV_ARG_EXPAND);
#endif
#ifndef glTexCoord3hvNV_RETURN
#define glTexCoord3hvNV_RETURN void
#define glTexCoord3hvNV_ARG_NAMES v
#define glTexCoord3hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord3hvNV_ARG_NAMES_TAIL , v
#define glTexCoord3hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glTexCoord3hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3hvNV(dst, _v), NULL); \
    });
#define call_glTexCoord3hvNV(packed, ret_v) do { \
    glTexCoord3hvNV_PACKED *unpacked = (glTexCoord3hvNV_PACKED *)packed; \
    glTexCoord3hvNV_ARGS *args = (glTexCoord3hvNV_ARGS *)&unpacked->args; \
    glTexCoord3hvNV(args->v);; \
} while(0)
void glTexCoord3hvNV(glTexCoord3hvNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord3hvNV(glTexCoord3hvNV_PACKED *_dst glTexCoord3hvNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3hvNV_PTR)(glTexCoord3hvNV_ARG_EXPAND);
#endif
#ifndef glTexCoord3i_RETURN
#define glTexCoord3i_RETURN void
#define glTexCoord3i_ARG_NAMES s, t, r
#define glTexCoord3i_ARG_EXPAND GLint s, GLint t, GLint r
#define glTexCoord3i_ARG_NAMES_TAIL , s, t, r
#define glTexCoord3i_ARG_EXPAND_TAIL , GLint s, GLint t, GLint r
#define forward_glTexCoord3i(_s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3i(dst, _s, _t, _r), NULL); \
    });
#define call_glTexCoord3i(packed, ret_v) do { \
    glTexCoord3i_PACKED *unpacked = (glTexCoord3i_PACKED *)packed; \
    glTexCoord3i_ARGS *args = (glTexCoord3i_ARGS *)&unpacked->args; \
    glTexCoord3i(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3i(glTexCoord3i_ARG_EXPAND);
packed_call_t *pack_glTexCoord3i(glTexCoord3i_PACKED *_dst glTexCoord3i_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3i_PTR)(glTexCoord3i_ARG_EXPAND);
#endif
#ifndef glTexCoord3iv_RETURN
#define glTexCoord3iv_RETURN void
#define glTexCoord3iv_ARG_NAMES v
#define glTexCoord3iv_ARG_EXPAND const GLint * v
#define glTexCoord3iv_ARG_NAMES_TAIL , v
#define glTexCoord3iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glTexCoord3iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3iv(dst, _v), NULL); \
    });
#define call_glTexCoord3iv(packed, ret_v) do { \
    glTexCoord3iv_PACKED *unpacked = (glTexCoord3iv_PACKED *)packed; \
    glTexCoord3iv_ARGS *args = (glTexCoord3iv_ARGS *)&unpacked->args; \
    glTexCoord3iv(args->v);; \
} while(0)
void glTexCoord3iv(glTexCoord3iv_ARG_EXPAND);
packed_call_t *pack_glTexCoord3iv(glTexCoord3iv_PACKED *_dst glTexCoord3iv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3iv_PTR)(glTexCoord3iv_ARG_EXPAND);
#endif
#ifndef glTexCoord3s_RETURN
#define glTexCoord3s_RETURN void
#define glTexCoord3s_ARG_NAMES s, t, r
#define glTexCoord3s_ARG_EXPAND GLshort s, GLshort t, GLshort r
#define glTexCoord3s_ARG_NAMES_TAIL , s, t, r
#define glTexCoord3s_ARG_EXPAND_TAIL , GLshort s, GLshort t, GLshort r
#define forward_glTexCoord3s(_s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3s(dst, _s, _t, _r), NULL); \
    });
#define call_glTexCoord3s(packed, ret_v) do { \
    glTexCoord3s_PACKED *unpacked = (glTexCoord3s_PACKED *)packed; \
    glTexCoord3s_ARGS *args = (glTexCoord3s_ARGS *)&unpacked->args; \
    glTexCoord3s(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3s(glTexCoord3s_ARG_EXPAND);
packed_call_t *pack_glTexCoord3s(glTexCoord3s_PACKED *_dst glTexCoord3s_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3s_PTR)(glTexCoord3s_ARG_EXPAND);
#endif
#ifndef glTexCoord3sv_RETURN
#define glTexCoord3sv_RETURN void
#define glTexCoord3sv_ARG_NAMES v
#define glTexCoord3sv_ARG_EXPAND const GLshort * v
#define glTexCoord3sv_ARG_NAMES_TAIL , v
#define glTexCoord3sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glTexCoord3sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3sv(dst, _v), NULL); \
    });
#define call_glTexCoord3sv(packed, ret_v) do { \
    glTexCoord3sv_PACKED *unpacked = (glTexCoord3sv_PACKED *)packed; \
    glTexCoord3sv_ARGS *args = (glTexCoord3sv_ARGS *)&unpacked->args; \
    glTexCoord3sv(args->v);; \
} while(0)
void glTexCoord3sv(glTexCoord3sv_ARG_EXPAND);
packed_call_t *pack_glTexCoord3sv(glTexCoord3sv_PACKED *_dst glTexCoord3sv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3sv_PTR)(glTexCoord3sv_ARG_EXPAND);
#endif
#ifndef glTexCoord3xOES_RETURN
#define glTexCoord3xOES_RETURN void
#define glTexCoord3xOES_ARG_NAMES s, t, r
#define glTexCoord3xOES_ARG_EXPAND GLfixed s, GLfixed t, GLfixed r
#define glTexCoord3xOES_ARG_NAMES_TAIL , s, t, r
#define glTexCoord3xOES_ARG_EXPAND_TAIL , GLfixed s, GLfixed t, GLfixed r
#define forward_glTexCoord3xOES(_s, _t, _r) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3xOES(dst, _s, _t, _r), NULL); \
    });
#define call_glTexCoord3xOES(packed, ret_v) do { \
    glTexCoord3xOES_PACKED *unpacked = (glTexCoord3xOES_PACKED *)packed; \
    glTexCoord3xOES_ARGS *args = (glTexCoord3xOES_ARGS *)&unpacked->args; \
    glTexCoord3xOES(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3xOES(glTexCoord3xOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord3xOES(glTexCoord3xOES_PACKED *_dst glTexCoord3xOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3xOES_PTR)(glTexCoord3xOES_ARG_EXPAND);
#endif
#ifndef glTexCoord3xvOES_RETURN
#define glTexCoord3xvOES_RETURN void
#define glTexCoord3xvOES_ARG_NAMES coords
#define glTexCoord3xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord3xvOES_ARG_NAMES_TAIL , coords
#define glTexCoord3xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glTexCoord3xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord3xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord3xvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord3xvOES(packed, ret_v) do { \
    glTexCoord3xvOES_PACKED *unpacked = (glTexCoord3xvOES_PACKED *)packed; \
    glTexCoord3xvOES_ARGS *args = (glTexCoord3xvOES_ARGS *)&unpacked->args; \
    glTexCoord3xvOES(args->coords);; \
} while(0)
void glTexCoord3xvOES(glTexCoord3xvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord3xvOES(glTexCoord3xvOES_PACKED *_dst glTexCoord3xvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord3xvOES_PTR)(glTexCoord3xvOES_ARG_EXPAND);
#endif
#ifndef glTexCoord4bOES_RETURN
#define glTexCoord4bOES_RETURN void
#define glTexCoord4bOES_ARG_NAMES s, t, r, q
#define glTexCoord4bOES_ARG_EXPAND GLbyte s, GLbyte t, GLbyte r, GLbyte q
#define glTexCoord4bOES_ARG_NAMES_TAIL , s, t, r, q
#define glTexCoord4bOES_ARG_EXPAND_TAIL , GLbyte s, GLbyte t, GLbyte r, GLbyte q
#define forward_glTexCoord4bOES(_s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4bOES(dst, _s, _t, _r, _q), NULL); \
    });
#define call_glTexCoord4bOES(packed, ret_v) do { \
    glTexCoord4bOES_PACKED *unpacked = (glTexCoord4bOES_PACKED *)packed; \
    glTexCoord4bOES_ARGS *args = (glTexCoord4bOES_ARGS *)&unpacked->args; \
    glTexCoord4bOES(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4bOES(glTexCoord4bOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord4bOES(glTexCoord4bOES_PACKED *_dst glTexCoord4bOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4bOES_PTR)(glTexCoord4bOES_ARG_EXPAND);
#endif
#ifndef glTexCoord4bvOES_RETURN
#define glTexCoord4bvOES_RETURN void
#define glTexCoord4bvOES_ARG_NAMES coords
#define glTexCoord4bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord4bvOES_ARG_NAMES_TAIL , coords
#define glTexCoord4bvOES_ARG_EXPAND_TAIL , const GLbyte * coords
#define forward_glTexCoord4bvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4bvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord4bvOES(packed, ret_v) do { \
    glTexCoord4bvOES_PACKED *unpacked = (glTexCoord4bvOES_PACKED *)packed; \
    glTexCoord4bvOES_ARGS *args = (glTexCoord4bvOES_ARGS *)&unpacked->args; \
    glTexCoord4bvOES(args->coords);; \
} while(0)
void glTexCoord4bvOES(glTexCoord4bvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord4bvOES(glTexCoord4bvOES_PACKED *_dst glTexCoord4bvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4bvOES_PTR)(glTexCoord4bvOES_ARG_EXPAND);
#endif
#ifndef glTexCoord4d_RETURN
#define glTexCoord4d_RETURN void
#define glTexCoord4d_ARG_NAMES s, t, r, q
#define glTexCoord4d_ARG_EXPAND GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define glTexCoord4d_ARG_NAMES_TAIL , s, t, r, q
#define glTexCoord4d_ARG_EXPAND_TAIL , GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define forward_glTexCoord4d(_s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4d(dst, _s, _t, _r, _q), NULL); \
    });
#define call_glTexCoord4d(packed, ret_v) do { \
    glTexCoord4d_PACKED *unpacked = (glTexCoord4d_PACKED *)packed; \
    glTexCoord4d_ARGS *args = (glTexCoord4d_ARGS *)&unpacked->args; \
    glTexCoord4d(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4d(glTexCoord4d_ARG_EXPAND);
packed_call_t *pack_glTexCoord4d(glTexCoord4d_PACKED *_dst glTexCoord4d_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4d_PTR)(glTexCoord4d_ARG_EXPAND);
#endif
#ifndef glTexCoord4dv_RETURN
#define glTexCoord4dv_RETURN void
#define glTexCoord4dv_ARG_NAMES v
#define glTexCoord4dv_ARG_EXPAND const GLdouble * v
#define glTexCoord4dv_ARG_NAMES_TAIL , v
#define glTexCoord4dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glTexCoord4dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4dv(dst, _v), NULL); \
    });
#define call_glTexCoord4dv(packed, ret_v) do { \
    glTexCoord4dv_PACKED *unpacked = (glTexCoord4dv_PACKED *)packed; \
    glTexCoord4dv_ARGS *args = (glTexCoord4dv_ARGS *)&unpacked->args; \
    glTexCoord4dv(args->v);; \
} while(0)
void glTexCoord4dv(glTexCoord4dv_ARG_EXPAND);
packed_call_t *pack_glTexCoord4dv(glTexCoord4dv_PACKED *_dst glTexCoord4dv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4dv_PTR)(glTexCoord4dv_ARG_EXPAND);
#endif
#ifndef glTexCoord4f_RETURN
#define glTexCoord4f_RETURN void
#define glTexCoord4f_ARG_NAMES s, t, r, q
#define glTexCoord4f_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define glTexCoord4f_ARG_NAMES_TAIL , s, t, r, q
#define glTexCoord4f_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define forward_glTexCoord4f(_s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4f(dst, _s, _t, _r, _q), NULL); \
    });
#define call_glTexCoord4f(packed, ret_v) do { \
    glTexCoord4f_PACKED *unpacked = (glTexCoord4f_PACKED *)packed; \
    glTexCoord4f_ARGS *args = (glTexCoord4f_ARGS *)&unpacked->args; \
    glTexCoord4f(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4f(glTexCoord4f_ARG_EXPAND);
packed_call_t *pack_glTexCoord4f(glTexCoord4f_PACKED *_dst glTexCoord4f_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4f_PTR)(glTexCoord4f_ARG_EXPAND);
#endif
#ifndef glTexCoord4fColor4fNormal3fVertex4fSUN_RETURN
#define glTexCoord4fColor4fNormal3fVertex4fSUN_RETURN void
#define glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_NAMES s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w
#define glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_NAMES_TAIL , s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w
#define glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glTexCoord4fColor4fNormal3fVertex4fSUN(_s, _t, _p, _q, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4fColor4fNormal3fVertex4fSUN(dst, _s, _t, _p, _q, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z, _w), NULL); \
    });
#define call_glTexCoord4fColor4fNormal3fVertex4fSUN(packed, ret_v) do { \
    glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED *unpacked = (glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED *)packed; \
    glTexCoord4fColor4fNormal3fVertex4fSUN_ARGS *args = (glTexCoord4fColor4fNormal3fVertex4fSUN_ARGS *)&unpacked->args; \
    glTexCoord4fColor4fNormal3fVertex4fSUN(args->s, args->t, args->p, args->q, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z, args->w);; \
} while(0)
void glTexCoord4fColor4fNormal3fVertex4fSUN(glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord4fColor4fNormal3fVertex4fSUN(glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED *_dst glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4fColor4fNormal3fVertex4fSUN_PTR)(glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord4fColor4fNormal3fVertex4fvSUN_RETURN
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_RETURN void
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_NAMES tc, c, n, v
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_NAMES_TAIL , tc, c, n, v
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND_TAIL , const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define forward_glTexCoord4fColor4fNormal3fVertex4fvSUN(_tc, _c, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4fColor4fNormal3fVertex4fvSUN(dst, _tc, _c, _n, _v), NULL); \
    });
#define call_glTexCoord4fColor4fNormal3fVertex4fvSUN(packed, ret_v) do { \
    glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED *unpacked = (glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED *)packed; \
    glTexCoord4fColor4fNormal3fVertex4fvSUN_ARGS *args = (glTexCoord4fColor4fNormal3fVertex4fvSUN_ARGS *)&unpacked->args; \
    glTexCoord4fColor4fNormal3fVertex4fvSUN(args->tc, args->c, args->n, args->v);; \
} while(0)
void glTexCoord4fColor4fNormal3fVertex4fvSUN(glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord4fColor4fNormal3fVertex4fvSUN(glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED *_dst glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4fColor4fNormal3fVertex4fvSUN_PTR)(glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord4fVertex4fSUN_RETURN
#define glTexCoord4fVertex4fSUN_RETURN void
#define glTexCoord4fVertex4fSUN_ARG_NAMES s, t, p, q, x, y, z, w
#define glTexCoord4fVertex4fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glTexCoord4fVertex4fSUN_ARG_NAMES_TAIL , s, t, p, q, x, y, z, w
#define glTexCoord4fVertex4fSUN_ARG_EXPAND_TAIL , GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glTexCoord4fVertex4fSUN(_s, _t, _p, _q, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4fVertex4fSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4fVertex4fSUN(dst, _s, _t, _p, _q, _x, _y, _z, _w), NULL); \
    });
#define call_glTexCoord4fVertex4fSUN(packed, ret_v) do { \
    glTexCoord4fVertex4fSUN_PACKED *unpacked = (glTexCoord4fVertex4fSUN_PACKED *)packed; \
    glTexCoord4fVertex4fSUN_ARGS *args = (glTexCoord4fVertex4fSUN_ARGS *)&unpacked->args; \
    glTexCoord4fVertex4fSUN(args->s, args->t, args->p, args->q, args->x, args->y, args->z, args->w);; \
} while(0)
void glTexCoord4fVertex4fSUN(glTexCoord4fVertex4fSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord4fVertex4fSUN(glTexCoord4fVertex4fSUN_PACKED *_dst glTexCoord4fVertex4fSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4fVertex4fSUN_PTR)(glTexCoord4fVertex4fSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord4fVertex4fvSUN_RETURN
#define glTexCoord4fVertex4fvSUN_RETURN void
#define glTexCoord4fVertex4fvSUN_ARG_NAMES tc, v
#define glTexCoord4fVertex4fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * v
#define glTexCoord4fVertex4fvSUN_ARG_NAMES_TAIL , tc, v
#define glTexCoord4fVertex4fvSUN_ARG_EXPAND_TAIL , const GLfloat * tc, const GLfloat * v
#define forward_glTexCoord4fVertex4fvSUN(_tc, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4fVertex4fvSUN_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4fVertex4fvSUN(dst, _tc, _v), NULL); \
    });
#define call_glTexCoord4fVertex4fvSUN(packed, ret_v) do { \
    glTexCoord4fVertex4fvSUN_PACKED *unpacked = (glTexCoord4fVertex4fvSUN_PACKED *)packed; \
    glTexCoord4fVertex4fvSUN_ARGS *args = (glTexCoord4fVertex4fvSUN_ARGS *)&unpacked->args; \
    glTexCoord4fVertex4fvSUN(args->tc, args->v);; \
} while(0)
void glTexCoord4fVertex4fvSUN(glTexCoord4fVertex4fvSUN_ARG_EXPAND);
packed_call_t *pack_glTexCoord4fVertex4fvSUN(glTexCoord4fVertex4fvSUN_PACKED *_dst glTexCoord4fVertex4fvSUN_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4fVertex4fvSUN_PTR)(glTexCoord4fVertex4fvSUN_ARG_EXPAND);
#endif
#ifndef glTexCoord4fv_RETURN
#define glTexCoord4fv_RETURN void
#define glTexCoord4fv_ARG_NAMES v
#define glTexCoord4fv_ARG_EXPAND const GLfloat * v
#define glTexCoord4fv_ARG_NAMES_TAIL , v
#define glTexCoord4fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glTexCoord4fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4fv(dst, _v), NULL); \
    });
#define call_glTexCoord4fv(packed, ret_v) do { \
    glTexCoord4fv_PACKED *unpacked = (glTexCoord4fv_PACKED *)packed; \
    glTexCoord4fv_ARGS *args = (glTexCoord4fv_ARGS *)&unpacked->args; \
    glTexCoord4fv(args->v);; \
} while(0)
void glTexCoord4fv(glTexCoord4fv_ARG_EXPAND);
packed_call_t *pack_glTexCoord4fv(glTexCoord4fv_PACKED *_dst glTexCoord4fv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4fv_PTR)(glTexCoord4fv_ARG_EXPAND);
#endif
#ifndef glTexCoord4hNV_RETURN
#define glTexCoord4hNV_RETURN void
#define glTexCoord4hNV_ARG_NAMES s, t, r, q
#define glTexCoord4hNV_ARG_EXPAND GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q
#define glTexCoord4hNV_ARG_NAMES_TAIL , s, t, r, q
#define glTexCoord4hNV_ARG_EXPAND_TAIL , GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q
#define forward_glTexCoord4hNV(_s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4hNV(dst, _s, _t, _r, _q), NULL); \
    });
#define call_glTexCoord4hNV(packed, ret_v) do { \
    glTexCoord4hNV_PACKED *unpacked = (glTexCoord4hNV_PACKED *)packed; \
    glTexCoord4hNV_ARGS *args = (glTexCoord4hNV_ARGS *)&unpacked->args; \
    glTexCoord4hNV(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4hNV(glTexCoord4hNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord4hNV(glTexCoord4hNV_PACKED *_dst glTexCoord4hNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4hNV_PTR)(glTexCoord4hNV_ARG_EXPAND);
#endif
#ifndef glTexCoord4hvNV_RETURN
#define glTexCoord4hvNV_RETURN void
#define glTexCoord4hvNV_ARG_NAMES v
#define glTexCoord4hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord4hvNV_ARG_NAMES_TAIL , v
#define glTexCoord4hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glTexCoord4hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4hvNV(dst, _v), NULL); \
    });
#define call_glTexCoord4hvNV(packed, ret_v) do { \
    glTexCoord4hvNV_PACKED *unpacked = (glTexCoord4hvNV_PACKED *)packed; \
    glTexCoord4hvNV_ARGS *args = (glTexCoord4hvNV_ARGS *)&unpacked->args; \
    glTexCoord4hvNV(args->v);; \
} while(0)
void glTexCoord4hvNV(glTexCoord4hvNV_ARG_EXPAND);
packed_call_t *pack_glTexCoord4hvNV(glTexCoord4hvNV_PACKED *_dst glTexCoord4hvNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4hvNV_PTR)(glTexCoord4hvNV_ARG_EXPAND);
#endif
#ifndef glTexCoord4i_RETURN
#define glTexCoord4i_RETURN void
#define glTexCoord4i_ARG_NAMES s, t, r, q
#define glTexCoord4i_ARG_EXPAND GLint s, GLint t, GLint r, GLint q
#define glTexCoord4i_ARG_NAMES_TAIL , s, t, r, q
#define glTexCoord4i_ARG_EXPAND_TAIL , GLint s, GLint t, GLint r, GLint q
#define forward_glTexCoord4i(_s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4i(dst, _s, _t, _r, _q), NULL); \
    });
#define call_glTexCoord4i(packed, ret_v) do { \
    glTexCoord4i_PACKED *unpacked = (glTexCoord4i_PACKED *)packed; \
    glTexCoord4i_ARGS *args = (glTexCoord4i_ARGS *)&unpacked->args; \
    glTexCoord4i(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4i(glTexCoord4i_ARG_EXPAND);
packed_call_t *pack_glTexCoord4i(glTexCoord4i_PACKED *_dst glTexCoord4i_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4i_PTR)(glTexCoord4i_ARG_EXPAND);
#endif
#ifndef glTexCoord4iv_RETURN
#define glTexCoord4iv_RETURN void
#define glTexCoord4iv_ARG_NAMES v
#define glTexCoord4iv_ARG_EXPAND const GLint * v
#define glTexCoord4iv_ARG_NAMES_TAIL , v
#define glTexCoord4iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glTexCoord4iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4iv(dst, _v), NULL); \
    });
#define call_glTexCoord4iv(packed, ret_v) do { \
    glTexCoord4iv_PACKED *unpacked = (glTexCoord4iv_PACKED *)packed; \
    glTexCoord4iv_ARGS *args = (glTexCoord4iv_ARGS *)&unpacked->args; \
    glTexCoord4iv(args->v);; \
} while(0)
void glTexCoord4iv(glTexCoord4iv_ARG_EXPAND);
packed_call_t *pack_glTexCoord4iv(glTexCoord4iv_PACKED *_dst glTexCoord4iv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4iv_PTR)(glTexCoord4iv_ARG_EXPAND);
#endif
#ifndef glTexCoord4s_RETURN
#define glTexCoord4s_RETURN void
#define glTexCoord4s_ARG_NAMES s, t, r, q
#define glTexCoord4s_ARG_EXPAND GLshort s, GLshort t, GLshort r, GLshort q
#define glTexCoord4s_ARG_NAMES_TAIL , s, t, r, q
#define glTexCoord4s_ARG_EXPAND_TAIL , GLshort s, GLshort t, GLshort r, GLshort q
#define forward_glTexCoord4s(_s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4s(dst, _s, _t, _r, _q), NULL); \
    });
#define call_glTexCoord4s(packed, ret_v) do { \
    glTexCoord4s_PACKED *unpacked = (glTexCoord4s_PACKED *)packed; \
    glTexCoord4s_ARGS *args = (glTexCoord4s_ARGS *)&unpacked->args; \
    glTexCoord4s(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4s(glTexCoord4s_ARG_EXPAND);
packed_call_t *pack_glTexCoord4s(glTexCoord4s_PACKED *_dst glTexCoord4s_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4s_PTR)(glTexCoord4s_ARG_EXPAND);
#endif
#ifndef glTexCoord4sv_RETURN
#define glTexCoord4sv_RETURN void
#define glTexCoord4sv_ARG_NAMES v
#define glTexCoord4sv_ARG_EXPAND const GLshort * v
#define glTexCoord4sv_ARG_NAMES_TAIL , v
#define glTexCoord4sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glTexCoord4sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4sv(dst, _v), NULL); \
    });
#define call_glTexCoord4sv(packed, ret_v) do { \
    glTexCoord4sv_PACKED *unpacked = (glTexCoord4sv_PACKED *)packed; \
    glTexCoord4sv_ARGS *args = (glTexCoord4sv_ARGS *)&unpacked->args; \
    glTexCoord4sv(args->v);; \
} while(0)
void glTexCoord4sv(glTexCoord4sv_ARG_EXPAND);
packed_call_t *pack_glTexCoord4sv(glTexCoord4sv_PACKED *_dst glTexCoord4sv_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4sv_PTR)(glTexCoord4sv_ARG_EXPAND);
#endif
#ifndef glTexCoord4xOES_RETURN
#define glTexCoord4xOES_RETURN void
#define glTexCoord4xOES_ARG_NAMES s, t, r, q
#define glTexCoord4xOES_ARG_EXPAND GLfixed s, GLfixed t, GLfixed r, GLfixed q
#define glTexCoord4xOES_ARG_NAMES_TAIL , s, t, r, q
#define glTexCoord4xOES_ARG_EXPAND_TAIL , GLfixed s, GLfixed t, GLfixed r, GLfixed q
#define forward_glTexCoord4xOES(_s, _t, _r, _q) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4xOES(dst, _s, _t, _r, _q), NULL); \
    });
#define call_glTexCoord4xOES(packed, ret_v) do { \
    glTexCoord4xOES_PACKED *unpacked = (glTexCoord4xOES_PACKED *)packed; \
    glTexCoord4xOES_ARGS *args = (glTexCoord4xOES_ARGS *)&unpacked->args; \
    glTexCoord4xOES(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4xOES(glTexCoord4xOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord4xOES(glTexCoord4xOES_PACKED *_dst glTexCoord4xOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4xOES_PTR)(glTexCoord4xOES_ARG_EXPAND);
#endif
#ifndef glTexCoord4xvOES_RETURN
#define glTexCoord4xvOES_RETURN void
#define glTexCoord4xvOES_ARG_NAMES coords
#define glTexCoord4xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord4xvOES_ARG_NAMES_TAIL , coords
#define glTexCoord4xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glTexCoord4xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoord4xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoord4xvOES(dst, _coords), NULL); \
    });
#define call_glTexCoord4xvOES(packed, ret_v) do { \
    glTexCoord4xvOES_PACKED *unpacked = (glTexCoord4xvOES_PACKED *)packed; \
    glTexCoord4xvOES_ARGS *args = (glTexCoord4xvOES_ARGS *)&unpacked->args; \
    glTexCoord4xvOES(args->coords);; \
} while(0)
void glTexCoord4xvOES(glTexCoord4xvOES_ARG_EXPAND);
packed_call_t *pack_glTexCoord4xvOES(glTexCoord4xvOES_PACKED *_dst glTexCoord4xvOES_ARG_EXPAND_TAIL);
typedef void (*glTexCoord4xvOES_PTR)(glTexCoord4xvOES_ARG_EXPAND);
#endif
#ifndef glTexCoordFormatNV_RETURN
#define glTexCoordFormatNV_RETURN void
#define glTexCoordFormatNV_ARG_NAMES size, type, stride
#define glTexCoordFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glTexCoordFormatNV_ARG_NAMES_TAIL , size, type, stride
#define glTexCoordFormatNV_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride
#define forward_glTexCoordFormatNV(_size, _type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordFormatNV(dst, _size, _type, _stride), NULL); \
    });
#define call_glTexCoordFormatNV(packed, ret_v) do { \
    glTexCoordFormatNV_PACKED *unpacked = (glTexCoordFormatNV_PACKED *)packed; \
    glTexCoordFormatNV_ARGS *args = (glTexCoordFormatNV_ARGS *)&unpacked->args; \
    glTexCoordFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glTexCoordFormatNV(glTexCoordFormatNV_ARG_EXPAND);
packed_call_t *pack_glTexCoordFormatNV(glTexCoordFormatNV_PACKED *_dst glTexCoordFormatNV_ARG_EXPAND_TAIL);
typedef void (*glTexCoordFormatNV_PTR)(glTexCoordFormatNV_ARG_EXPAND);
#endif
#ifndef glTexCoordP1ui_RETURN
#define glTexCoordP1ui_RETURN void
#define glTexCoordP1ui_ARG_NAMES type, coords
#define glTexCoordP1ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP1ui_ARG_NAMES_TAIL , type, coords
#define glTexCoordP1ui_ARG_EXPAND_TAIL , GLenum type, GLuint coords
#define forward_glTexCoordP1ui(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP1ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP1ui(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP1ui(packed, ret_v) do { \
    glTexCoordP1ui_PACKED *unpacked = (glTexCoordP1ui_PACKED *)packed; \
    glTexCoordP1ui_ARGS *args = (glTexCoordP1ui_ARGS *)&unpacked->args; \
    glTexCoordP1ui(args->type, args->coords);; \
} while(0)
void glTexCoordP1ui(glTexCoordP1ui_ARG_EXPAND);
packed_call_t *pack_glTexCoordP1ui(glTexCoordP1ui_PACKED *_dst glTexCoordP1ui_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP1ui_PTR)(glTexCoordP1ui_ARG_EXPAND);
#endif
#ifndef glTexCoordP1uiv_RETURN
#define glTexCoordP1uiv_RETURN void
#define glTexCoordP1uiv_ARG_NAMES type, coords
#define glTexCoordP1uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP1uiv_ARG_NAMES_TAIL , type, coords
#define glTexCoordP1uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * coords
#define forward_glTexCoordP1uiv(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP1uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP1uiv(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP1uiv(packed, ret_v) do { \
    glTexCoordP1uiv_PACKED *unpacked = (glTexCoordP1uiv_PACKED *)packed; \
    glTexCoordP1uiv_ARGS *args = (glTexCoordP1uiv_ARGS *)&unpacked->args; \
    glTexCoordP1uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP1uiv(glTexCoordP1uiv_ARG_EXPAND);
packed_call_t *pack_glTexCoordP1uiv(glTexCoordP1uiv_PACKED *_dst glTexCoordP1uiv_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP1uiv_PTR)(glTexCoordP1uiv_ARG_EXPAND);
#endif
#ifndef glTexCoordP2ui_RETURN
#define glTexCoordP2ui_RETURN void
#define glTexCoordP2ui_ARG_NAMES type, coords
#define glTexCoordP2ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP2ui_ARG_NAMES_TAIL , type, coords
#define glTexCoordP2ui_ARG_EXPAND_TAIL , GLenum type, GLuint coords
#define forward_glTexCoordP2ui(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP2ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP2ui(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP2ui(packed, ret_v) do { \
    glTexCoordP2ui_PACKED *unpacked = (glTexCoordP2ui_PACKED *)packed; \
    glTexCoordP2ui_ARGS *args = (glTexCoordP2ui_ARGS *)&unpacked->args; \
    glTexCoordP2ui(args->type, args->coords);; \
} while(0)
void glTexCoordP2ui(glTexCoordP2ui_ARG_EXPAND);
packed_call_t *pack_glTexCoordP2ui(glTexCoordP2ui_PACKED *_dst glTexCoordP2ui_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP2ui_PTR)(glTexCoordP2ui_ARG_EXPAND);
#endif
#ifndef glTexCoordP2uiv_RETURN
#define glTexCoordP2uiv_RETURN void
#define glTexCoordP2uiv_ARG_NAMES type, coords
#define glTexCoordP2uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP2uiv_ARG_NAMES_TAIL , type, coords
#define glTexCoordP2uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * coords
#define forward_glTexCoordP2uiv(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP2uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP2uiv(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP2uiv(packed, ret_v) do { \
    glTexCoordP2uiv_PACKED *unpacked = (glTexCoordP2uiv_PACKED *)packed; \
    glTexCoordP2uiv_ARGS *args = (glTexCoordP2uiv_ARGS *)&unpacked->args; \
    glTexCoordP2uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP2uiv(glTexCoordP2uiv_ARG_EXPAND);
packed_call_t *pack_glTexCoordP2uiv(glTexCoordP2uiv_PACKED *_dst glTexCoordP2uiv_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP2uiv_PTR)(glTexCoordP2uiv_ARG_EXPAND);
#endif
#ifndef glTexCoordP3ui_RETURN
#define glTexCoordP3ui_RETURN void
#define glTexCoordP3ui_ARG_NAMES type, coords
#define glTexCoordP3ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP3ui_ARG_NAMES_TAIL , type, coords
#define glTexCoordP3ui_ARG_EXPAND_TAIL , GLenum type, GLuint coords
#define forward_glTexCoordP3ui(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP3ui(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP3ui(packed, ret_v) do { \
    glTexCoordP3ui_PACKED *unpacked = (glTexCoordP3ui_PACKED *)packed; \
    glTexCoordP3ui_ARGS *args = (glTexCoordP3ui_ARGS *)&unpacked->args; \
    glTexCoordP3ui(args->type, args->coords);; \
} while(0)
void glTexCoordP3ui(glTexCoordP3ui_ARG_EXPAND);
packed_call_t *pack_glTexCoordP3ui(glTexCoordP3ui_PACKED *_dst glTexCoordP3ui_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP3ui_PTR)(glTexCoordP3ui_ARG_EXPAND);
#endif
#ifndef glTexCoordP3uiv_RETURN
#define glTexCoordP3uiv_RETURN void
#define glTexCoordP3uiv_ARG_NAMES type, coords
#define glTexCoordP3uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP3uiv_ARG_NAMES_TAIL , type, coords
#define glTexCoordP3uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * coords
#define forward_glTexCoordP3uiv(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP3uiv(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP3uiv(packed, ret_v) do { \
    glTexCoordP3uiv_PACKED *unpacked = (glTexCoordP3uiv_PACKED *)packed; \
    glTexCoordP3uiv_ARGS *args = (glTexCoordP3uiv_ARGS *)&unpacked->args; \
    glTexCoordP3uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP3uiv(glTexCoordP3uiv_ARG_EXPAND);
packed_call_t *pack_glTexCoordP3uiv(glTexCoordP3uiv_PACKED *_dst glTexCoordP3uiv_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP3uiv_PTR)(glTexCoordP3uiv_ARG_EXPAND);
#endif
#ifndef glTexCoordP4ui_RETURN
#define glTexCoordP4ui_RETURN void
#define glTexCoordP4ui_ARG_NAMES type, coords
#define glTexCoordP4ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP4ui_ARG_NAMES_TAIL , type, coords
#define glTexCoordP4ui_ARG_EXPAND_TAIL , GLenum type, GLuint coords
#define forward_glTexCoordP4ui(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP4ui(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP4ui(packed, ret_v) do { \
    glTexCoordP4ui_PACKED *unpacked = (glTexCoordP4ui_PACKED *)packed; \
    glTexCoordP4ui_ARGS *args = (glTexCoordP4ui_ARGS *)&unpacked->args; \
    glTexCoordP4ui(args->type, args->coords);; \
} while(0)
void glTexCoordP4ui(glTexCoordP4ui_ARG_EXPAND);
packed_call_t *pack_glTexCoordP4ui(glTexCoordP4ui_PACKED *_dst glTexCoordP4ui_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP4ui_PTR)(glTexCoordP4ui_ARG_EXPAND);
#endif
#ifndef glTexCoordP4uiv_RETURN
#define glTexCoordP4uiv_RETURN void
#define glTexCoordP4uiv_ARG_NAMES type, coords
#define glTexCoordP4uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP4uiv_ARG_NAMES_TAIL , type, coords
#define glTexCoordP4uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * coords
#define forward_glTexCoordP4uiv(_type, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordP4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordP4uiv(dst, _type, _coords), NULL); \
    });
#define call_glTexCoordP4uiv(packed, ret_v) do { \
    glTexCoordP4uiv_PACKED *unpacked = (glTexCoordP4uiv_PACKED *)packed; \
    glTexCoordP4uiv_ARGS *args = (glTexCoordP4uiv_ARGS *)&unpacked->args; \
    glTexCoordP4uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP4uiv(glTexCoordP4uiv_ARG_EXPAND);
packed_call_t *pack_glTexCoordP4uiv(glTexCoordP4uiv_PACKED *_dst glTexCoordP4uiv_ARG_EXPAND_TAIL);
typedef void (*glTexCoordP4uiv_PTR)(glTexCoordP4uiv_ARG_EXPAND);
#endif
#ifndef glTexCoordPointer_RETURN
#define glTexCoordPointer_RETURN void
#define glTexCoordPointer_ARG_NAMES size, type, stride, pointer
#define glTexCoordPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glTexCoordPointer_ARG_NAMES_TAIL , size, type, stride, pointer
#define glTexCoordPointer_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glTexCoordPointer(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordPointer(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glTexCoordPointer(packed, ret_v) do { \
    glTexCoordPointer_PACKED *unpacked = (glTexCoordPointer_PACKED *)packed; \
    glTexCoordPointer_ARGS *args = (glTexCoordPointer_ARGS *)&unpacked->args; \
    glTexCoordPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glTexCoordPointer(glTexCoordPointer_ARG_EXPAND);
packed_call_t *pack_glTexCoordPointer(glTexCoordPointer_PACKED *_dst glTexCoordPointer_ARG_EXPAND_TAIL);
typedef void (*glTexCoordPointer_PTR)(glTexCoordPointer_ARG_EXPAND);
#endif
#ifndef glTexCoordPointerEXT_RETURN
#define glTexCoordPointerEXT_RETURN void
#define glTexCoordPointerEXT_ARG_NAMES size, type, stride, count, pointer
#define glTexCoordPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glTexCoordPointerEXT_ARG_NAMES_TAIL , size, type, stride, count, pointer
#define glTexCoordPointerEXT_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define forward_glTexCoordPointerEXT(_size, _type, _stride, _count, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordPointerEXT(dst, _size, _type, _stride, _count, _pointer), NULL); \
    });
#define call_glTexCoordPointerEXT(packed, ret_v) do { \
    glTexCoordPointerEXT_PACKED *unpacked = (glTexCoordPointerEXT_PACKED *)packed; \
    glTexCoordPointerEXT_ARGS *args = (glTexCoordPointerEXT_ARGS *)&unpacked->args; \
    glTexCoordPointerEXT(args->size, args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glTexCoordPointerEXT(glTexCoordPointerEXT_ARG_EXPAND);
packed_call_t *pack_glTexCoordPointerEXT(glTexCoordPointerEXT_PACKED *_dst glTexCoordPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glTexCoordPointerEXT_PTR)(glTexCoordPointerEXT_ARG_EXPAND);
#endif
#ifndef glTexCoordPointerListIBM_RETURN
#define glTexCoordPointerListIBM_RETURN void
#define glTexCoordPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glTexCoordPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glTexCoordPointerListIBM_ARG_NAMES_TAIL , size, type, stride, pointer, ptrstride
#define glTexCoordPointerListIBM_ARG_EXPAND_TAIL , GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define forward_glTexCoordPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordPointerListIBM(dst, _size, _type, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glTexCoordPointerListIBM(packed, ret_v) do { \
    glTexCoordPointerListIBM_PACKED *unpacked = (glTexCoordPointerListIBM_PACKED *)packed; \
    glTexCoordPointerListIBM_ARGS *args = (glTexCoordPointerListIBM_ARGS *)&unpacked->args; \
    glTexCoordPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glTexCoordPointerListIBM(glTexCoordPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glTexCoordPointerListIBM(glTexCoordPointerListIBM_PACKED *_dst glTexCoordPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glTexCoordPointerListIBM_PTR)(glTexCoordPointerListIBM_ARG_EXPAND);
#endif
#ifndef glTexCoordPointervINTEL_RETURN
#define glTexCoordPointervINTEL_RETURN void
#define glTexCoordPointervINTEL_ARG_NAMES size, type, pointer
#define glTexCoordPointervINTEL_ARG_EXPAND GLint size, GLenum type, const GLvoid * pointer
#define glTexCoordPointervINTEL_ARG_NAMES_TAIL , size, type, pointer
#define glTexCoordPointervINTEL_ARG_EXPAND_TAIL , GLint size, GLenum type, const GLvoid * pointer
#define forward_glTexCoordPointervINTEL(_size, _type, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glTexCoordPointervINTEL_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexCoordPointervINTEL(dst, _size, _type, _pointer), NULL); \
    });
#define call_glTexCoordPointervINTEL(packed, ret_v) do { \
    glTexCoordPointervINTEL_PACKED *unpacked = (glTexCoordPointervINTEL_PACKED *)packed; \
    glTexCoordPointervINTEL_ARGS *args = (glTexCoordPointervINTEL_ARGS *)&unpacked->args; \
    glTexCoordPointervINTEL(args->size, args->type, args->pointer);; \
} while(0)
void glTexCoordPointervINTEL(glTexCoordPointervINTEL_ARG_EXPAND);
packed_call_t *pack_glTexCoordPointervINTEL(glTexCoordPointervINTEL_PACKED *_dst glTexCoordPointervINTEL_ARG_EXPAND_TAIL);
typedef void (*glTexCoordPointervINTEL_PTR)(glTexCoordPointervINTEL_ARG_EXPAND);
#endif
#ifndef glTexEnvf_RETURN
#define glTexEnvf_RETURN void
#define glTexEnvf_ARG_NAMES target, pname, param
#define glTexEnvf_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glTexEnvf_ARG_NAMES_TAIL , target, pname, param
#define glTexEnvf_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat param
#define forward_glTexEnvf(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexEnvf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexEnvf(dst, _target, _pname, _param), NULL); \
    });
#define call_glTexEnvf(packed, ret_v) do { \
    glTexEnvf_PACKED *unpacked = (glTexEnvf_PACKED *)packed; \
    glTexEnvf_ARGS *args = (glTexEnvf_ARGS *)&unpacked->args; \
    glTexEnvf(args->target, args->pname, args->param);; \
} while(0)
void glTexEnvf(glTexEnvf_ARG_EXPAND);
packed_call_t *pack_glTexEnvf(glTexEnvf_PACKED *_dst glTexEnvf_ARG_EXPAND_TAIL);
typedef void (*glTexEnvf_PTR)(glTexEnvf_ARG_EXPAND);
#endif
#ifndef glTexEnvfv_RETURN
#define glTexEnvfv_RETURN void
#define glTexEnvfv_ARG_NAMES target, pname, params
#define glTexEnvfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glTexEnvfv_ARG_NAMES_TAIL , target, pname, params
#define glTexEnvfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glTexEnvfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexEnvfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexEnvfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexEnvfv(packed, ret_v) do { \
    glTexEnvfv_PACKED *unpacked = (glTexEnvfv_PACKED *)packed; \
    glTexEnvfv_ARGS *args = (glTexEnvfv_ARGS *)&unpacked->args; \
    glTexEnvfv(args->target, args->pname, args->params);; \
} while(0)
void glTexEnvfv(glTexEnvfv_ARG_EXPAND);
packed_call_t *pack_glTexEnvfv(glTexEnvfv_PACKED *_dst glTexEnvfv_ARG_EXPAND_TAIL);
typedef void (*glTexEnvfv_PTR)(glTexEnvfv_ARG_EXPAND);
#endif
#ifndef glTexEnvi_RETURN
#define glTexEnvi_RETURN void
#define glTexEnvi_ARG_NAMES target, pname, param
#define glTexEnvi_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glTexEnvi_ARG_NAMES_TAIL , target, pname, param
#define glTexEnvi_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint param
#define forward_glTexEnvi(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexEnvi_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexEnvi(dst, _target, _pname, _param), NULL); \
    });
#define call_glTexEnvi(packed, ret_v) do { \
    glTexEnvi_PACKED *unpacked = (glTexEnvi_PACKED *)packed; \
    glTexEnvi_ARGS *args = (glTexEnvi_ARGS *)&unpacked->args; \
    glTexEnvi(args->target, args->pname, args->param);; \
} while(0)
void glTexEnvi(glTexEnvi_ARG_EXPAND);
packed_call_t *pack_glTexEnvi(glTexEnvi_PACKED *_dst glTexEnvi_ARG_EXPAND_TAIL);
typedef void (*glTexEnvi_PTR)(glTexEnvi_ARG_EXPAND);
#endif
#ifndef glTexEnviv_RETURN
#define glTexEnviv_RETURN void
#define glTexEnviv_ARG_NAMES target, pname, params
#define glTexEnviv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexEnviv_ARG_NAMES_TAIL , target, pname, params
#define glTexEnviv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glTexEnviv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexEnviv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexEnviv(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexEnviv(packed, ret_v) do { \
    glTexEnviv_PACKED *unpacked = (glTexEnviv_PACKED *)packed; \
    glTexEnviv_ARGS *args = (glTexEnviv_ARGS *)&unpacked->args; \
    glTexEnviv(args->target, args->pname, args->params);; \
} while(0)
void glTexEnviv(glTexEnviv_ARG_EXPAND);
packed_call_t *pack_glTexEnviv(glTexEnviv_PACKED *_dst glTexEnviv_ARG_EXPAND_TAIL);
typedef void (*glTexEnviv_PTR)(glTexEnviv_ARG_EXPAND);
#endif
#ifndef glTexEnvxOES_RETURN
#define glTexEnvxOES_RETURN void
#define glTexEnvxOES_ARG_NAMES target, pname, param
#define glTexEnvxOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glTexEnvxOES_ARG_NAMES_TAIL , target, pname, param
#define glTexEnvxOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfixed param
#define forward_glTexEnvxOES(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexEnvxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexEnvxOES(dst, _target, _pname, _param), NULL); \
    });
#define call_glTexEnvxOES(packed, ret_v) do { \
    glTexEnvxOES_PACKED *unpacked = (glTexEnvxOES_PACKED *)packed; \
    glTexEnvxOES_ARGS *args = (glTexEnvxOES_ARGS *)&unpacked->args; \
    glTexEnvxOES(args->target, args->pname, args->param);; \
} while(0)
void glTexEnvxOES(glTexEnvxOES_ARG_EXPAND);
packed_call_t *pack_glTexEnvxOES(glTexEnvxOES_PACKED *_dst glTexEnvxOES_ARG_EXPAND_TAIL);
typedef void (*glTexEnvxOES_PTR)(glTexEnvxOES_ARG_EXPAND);
#endif
#ifndef glTexEnvxvOES_RETURN
#define glTexEnvxvOES_RETURN void
#define glTexEnvxvOES_ARG_NAMES target, pname, params
#define glTexEnvxvOES_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glTexEnvxvOES_ARG_NAMES_TAIL , target, pname, params
#define glTexEnvxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfixed * params
#define forward_glTexEnvxvOES(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexEnvxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexEnvxvOES(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexEnvxvOES(packed, ret_v) do { \
    glTexEnvxvOES_PACKED *unpacked = (glTexEnvxvOES_PACKED *)packed; \
    glTexEnvxvOES_ARGS *args = (glTexEnvxvOES_ARGS *)&unpacked->args; \
    glTexEnvxvOES(args->target, args->pname, args->params);; \
} while(0)
void glTexEnvxvOES(glTexEnvxvOES_ARG_EXPAND);
packed_call_t *pack_glTexEnvxvOES(glTexEnvxvOES_PACKED *_dst glTexEnvxvOES_ARG_EXPAND_TAIL);
typedef void (*glTexEnvxvOES_PTR)(glTexEnvxvOES_ARG_EXPAND);
#endif
#ifndef glTexFilterFuncSGIS_RETURN
#define glTexFilterFuncSGIS_RETURN void
#define glTexFilterFuncSGIS_ARG_NAMES target, filter, n, weights
#define glTexFilterFuncSGIS_ARG_EXPAND GLenum target, GLenum filter, GLsizei n, const GLfloat * weights
#define glTexFilterFuncSGIS_ARG_NAMES_TAIL , target, filter, n, weights
#define glTexFilterFuncSGIS_ARG_EXPAND_TAIL , GLenum target, GLenum filter, GLsizei n, const GLfloat * weights
#define forward_glTexFilterFuncSGIS(_target, _filter, _n, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glTexFilterFuncSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexFilterFuncSGIS(dst, _target, _filter, _n, _weights), NULL); \
    });
#define call_glTexFilterFuncSGIS(packed, ret_v) do { \
    glTexFilterFuncSGIS_PACKED *unpacked = (glTexFilterFuncSGIS_PACKED *)packed; \
    glTexFilterFuncSGIS_ARGS *args = (glTexFilterFuncSGIS_ARGS *)&unpacked->args; \
    glTexFilterFuncSGIS(args->target, args->filter, args->n, args->weights);; \
} while(0)
void glTexFilterFuncSGIS(glTexFilterFuncSGIS_ARG_EXPAND);
packed_call_t *pack_glTexFilterFuncSGIS(glTexFilterFuncSGIS_PACKED *_dst glTexFilterFuncSGIS_ARG_EXPAND_TAIL);
typedef void (*glTexFilterFuncSGIS_PTR)(glTexFilterFuncSGIS_ARG_EXPAND);
#endif
#ifndef glTexGend_RETURN
#define glTexGend_RETURN void
#define glTexGend_ARG_NAMES coord, pname, param
#define glTexGend_ARG_EXPAND GLenum coord, GLenum pname, GLdouble param
#define glTexGend_ARG_NAMES_TAIL , coord, pname, param
#define glTexGend_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLdouble param
#define forward_glTexGend(_coord, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGend_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGend(dst, _coord, _pname, _param), NULL); \
    });
#define call_glTexGend(packed, ret_v) do { \
    glTexGend_PACKED *unpacked = (glTexGend_PACKED *)packed; \
    glTexGend_ARGS *args = (glTexGend_ARGS *)&unpacked->args; \
    glTexGend(args->coord, args->pname, args->param);; \
} while(0)
void glTexGend(glTexGend_ARG_EXPAND);
packed_call_t *pack_glTexGend(glTexGend_PACKED *_dst glTexGend_ARG_EXPAND_TAIL);
typedef void (*glTexGend_PTR)(glTexGend_ARG_EXPAND);
#endif
#ifndef glTexGendv_RETURN
#define glTexGendv_RETURN void
#define glTexGendv_ARG_NAMES coord, pname, params
#define glTexGendv_ARG_EXPAND GLenum coord, GLenum pname, const GLdouble * params
#define glTexGendv_ARG_NAMES_TAIL , coord, pname, params
#define glTexGendv_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, const GLdouble * params
#define forward_glTexGendv(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGendv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGendv(dst, _coord, _pname, _params), NULL); \
    });
#define call_glTexGendv(packed, ret_v) do { \
    glTexGendv_PACKED *unpacked = (glTexGendv_PACKED *)packed; \
    glTexGendv_ARGS *args = (glTexGendv_ARGS *)&unpacked->args; \
    glTexGendv(args->coord, args->pname, args->params);; \
} while(0)
void glTexGendv(glTexGendv_ARG_EXPAND);
packed_call_t *pack_glTexGendv(glTexGendv_PACKED *_dst glTexGendv_ARG_EXPAND_TAIL);
typedef void (*glTexGendv_PTR)(glTexGendv_ARG_EXPAND);
#endif
#ifndef glTexGenf_RETURN
#define glTexGenf_RETURN void
#define glTexGenf_ARG_NAMES coord, pname, param
#define glTexGenf_ARG_EXPAND GLenum coord, GLenum pname, GLfloat param
#define glTexGenf_ARG_NAMES_TAIL , coord, pname, param
#define glTexGenf_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLfloat param
#define forward_glTexGenf(_coord, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGenf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGenf(dst, _coord, _pname, _param), NULL); \
    });
#define call_glTexGenf(packed, ret_v) do { \
    glTexGenf_PACKED *unpacked = (glTexGenf_PACKED *)packed; \
    glTexGenf_ARGS *args = (glTexGenf_ARGS *)&unpacked->args; \
    glTexGenf(args->coord, args->pname, args->param);; \
} while(0)
void glTexGenf(glTexGenf_ARG_EXPAND);
packed_call_t *pack_glTexGenf(glTexGenf_PACKED *_dst glTexGenf_ARG_EXPAND_TAIL);
typedef void (*glTexGenf_PTR)(glTexGenf_ARG_EXPAND);
#endif
#ifndef glTexGenfv_RETURN
#define glTexGenfv_RETURN void
#define glTexGenfv_ARG_NAMES coord, pname, params
#define glTexGenfv_ARG_EXPAND GLenum coord, GLenum pname, const GLfloat * params
#define glTexGenfv_ARG_NAMES_TAIL , coord, pname, params
#define glTexGenfv_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, const GLfloat * params
#define forward_glTexGenfv(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGenfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGenfv(dst, _coord, _pname, _params), NULL); \
    });
#define call_glTexGenfv(packed, ret_v) do { \
    glTexGenfv_PACKED *unpacked = (glTexGenfv_PACKED *)packed; \
    glTexGenfv_ARGS *args = (glTexGenfv_ARGS *)&unpacked->args; \
    glTexGenfv(args->coord, args->pname, args->params);; \
} while(0)
void glTexGenfv(glTexGenfv_ARG_EXPAND);
packed_call_t *pack_glTexGenfv(glTexGenfv_PACKED *_dst glTexGenfv_ARG_EXPAND_TAIL);
typedef void (*glTexGenfv_PTR)(glTexGenfv_ARG_EXPAND);
#endif
#ifndef glTexGeni_RETURN
#define glTexGeni_RETURN void
#define glTexGeni_ARG_NAMES coord, pname, param
#define glTexGeni_ARG_EXPAND GLenum coord, GLenum pname, GLint param
#define glTexGeni_ARG_NAMES_TAIL , coord, pname, param
#define glTexGeni_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLint param
#define forward_glTexGeni(_coord, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGeni_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGeni(dst, _coord, _pname, _param), NULL); \
    });
#define call_glTexGeni(packed, ret_v) do { \
    glTexGeni_PACKED *unpacked = (glTexGeni_PACKED *)packed; \
    glTexGeni_ARGS *args = (glTexGeni_ARGS *)&unpacked->args; \
    glTexGeni(args->coord, args->pname, args->param);; \
} while(0)
void glTexGeni(glTexGeni_ARG_EXPAND);
packed_call_t *pack_glTexGeni(glTexGeni_PACKED *_dst glTexGeni_ARG_EXPAND_TAIL);
typedef void (*glTexGeni_PTR)(glTexGeni_ARG_EXPAND);
#endif
#ifndef glTexGeniv_RETURN
#define glTexGeniv_RETURN void
#define glTexGeniv_ARG_NAMES coord, pname, params
#define glTexGeniv_ARG_EXPAND GLenum coord, GLenum pname, const GLint * params
#define glTexGeniv_ARG_NAMES_TAIL , coord, pname, params
#define glTexGeniv_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, const GLint * params
#define forward_glTexGeniv(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGeniv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGeniv(dst, _coord, _pname, _params), NULL); \
    });
#define call_glTexGeniv(packed, ret_v) do { \
    glTexGeniv_PACKED *unpacked = (glTexGeniv_PACKED *)packed; \
    glTexGeniv_ARGS *args = (glTexGeniv_ARGS *)&unpacked->args; \
    glTexGeniv(args->coord, args->pname, args->params);; \
} while(0)
void glTexGeniv(glTexGeniv_ARG_EXPAND);
packed_call_t *pack_glTexGeniv(glTexGeniv_PACKED *_dst glTexGeniv_ARG_EXPAND_TAIL);
typedef void (*glTexGeniv_PTR)(glTexGeniv_ARG_EXPAND);
#endif
#ifndef glTexGenxOES_RETURN
#define glTexGenxOES_RETURN void
#define glTexGenxOES_ARG_NAMES coord, pname, param
#define glTexGenxOES_ARG_EXPAND GLenum coord, GLenum pname, GLfixed param
#define glTexGenxOES_ARG_NAMES_TAIL , coord, pname, param
#define glTexGenxOES_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, GLfixed param
#define forward_glTexGenxOES(_coord, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGenxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGenxOES(dst, _coord, _pname, _param), NULL); \
    });
#define call_glTexGenxOES(packed, ret_v) do { \
    glTexGenxOES_PACKED *unpacked = (glTexGenxOES_PACKED *)packed; \
    glTexGenxOES_ARGS *args = (glTexGenxOES_ARGS *)&unpacked->args; \
    glTexGenxOES(args->coord, args->pname, args->param);; \
} while(0)
void glTexGenxOES(glTexGenxOES_ARG_EXPAND);
packed_call_t *pack_glTexGenxOES(glTexGenxOES_PACKED *_dst glTexGenxOES_ARG_EXPAND_TAIL);
typedef void (*glTexGenxOES_PTR)(glTexGenxOES_ARG_EXPAND);
#endif
#ifndef glTexGenxvOES_RETURN
#define glTexGenxvOES_RETURN void
#define glTexGenxvOES_ARG_NAMES coord, pname, params
#define glTexGenxvOES_ARG_EXPAND GLenum coord, GLenum pname, const GLfixed * params
#define glTexGenxvOES_ARG_NAMES_TAIL , coord, pname, params
#define glTexGenxvOES_ARG_EXPAND_TAIL , GLenum coord, GLenum pname, const GLfixed * params
#define forward_glTexGenxvOES(_coord, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexGenxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexGenxvOES(dst, _coord, _pname, _params), NULL); \
    });
#define call_glTexGenxvOES(packed, ret_v) do { \
    glTexGenxvOES_PACKED *unpacked = (glTexGenxvOES_PACKED *)packed; \
    glTexGenxvOES_ARGS *args = (glTexGenxvOES_ARGS *)&unpacked->args; \
    glTexGenxvOES(args->coord, args->pname, args->params);; \
} while(0)
void glTexGenxvOES(glTexGenxvOES_ARG_EXPAND);
packed_call_t *pack_glTexGenxvOES(glTexGenxvOES_PACKED *_dst glTexGenxvOES_ARG_EXPAND_TAIL);
typedef void (*glTexGenxvOES_PTR)(glTexGenxvOES_ARG_EXPAND);
#endif
#ifndef glTexImage1D_RETURN
#define glTexImage1D_RETURN void
#define glTexImage1D_ARG_NAMES target, level, internalformat, width, border, format, type, pixels
#define glTexImage1D_ARG_EXPAND GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage1D_ARG_NAMES_TAIL , target, level, internalformat, width, border, format, type, pixels
#define glTexImage1D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexImage1D(_target, _level, _internalformat, _width, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage1D(dst, _target, _level, _internalformat, _width, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTexImage1D(packed, ret_v) do { \
    glTexImage1D_PACKED *unpacked = (glTexImage1D_PACKED *)packed; \
    glTexImage1D_ARGS *args = (glTexImage1D_ARGS *)&unpacked->args; \
    glTexImage1D(args->target, args->level, args->internalformat, args->width, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage1D(glTexImage1D_ARG_EXPAND);
packed_call_t *pack_glTexImage1D(glTexImage1D_PACKED *_dst glTexImage1D_ARG_EXPAND_TAIL);
typedef void (*glTexImage1D_PTR)(glTexImage1D_ARG_EXPAND);
#endif
#ifndef glTexImage2D_RETURN
#define glTexImage2D_RETURN void
#define glTexImage2D_ARG_NAMES target, level, internalformat, width, height, border, format, type, pixels
#define glTexImage2D_ARG_EXPAND GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage2D_ARG_NAMES_TAIL , target, level, internalformat, width, height, border, format, type, pixels
#define glTexImage2D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexImage2D(_target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage2D(dst, _target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTexImage2D(packed, ret_v) do { \
    glTexImage2D_PACKED *unpacked = (glTexImage2D_PACKED *)packed; \
    glTexImage2D_ARGS *args = (glTexImage2D_ARGS *)&unpacked->args; \
    glTexImage2D(args->target, args->level, args->internalformat, args->width, args->height, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage2D(glTexImage2D_ARG_EXPAND);
packed_call_t *pack_glTexImage2D(glTexImage2D_PACKED *_dst glTexImage2D_ARG_EXPAND_TAIL);
typedef void (*glTexImage2D_PTR)(glTexImage2D_ARG_EXPAND);
#endif
#ifndef glTexImage2DMultisample_RETURN
#define glTexImage2DMultisample_RETURN void
#define glTexImage2DMultisample_ARG_NAMES target, samples, internalformat, width, height, fixedsamplelocations
#define glTexImage2DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define glTexImage2DMultisample_ARG_NAMES_TAIL , target, samples, internalformat, width, height, fixedsamplelocations
#define glTexImage2DMultisample_ARG_EXPAND_TAIL , GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define forward_glTexImage2DMultisample(_target, _samples, _internalformat, _width, _height, _fixedsamplelocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage2DMultisample_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage2DMultisample(dst, _target, _samples, _internalformat, _width, _height, _fixedsamplelocations), NULL); \
    });
#define call_glTexImage2DMultisample(packed, ret_v) do { \
    glTexImage2DMultisample_PACKED *unpacked = (glTexImage2DMultisample_PACKED *)packed; \
    glTexImage2DMultisample_ARGS *args = (glTexImage2DMultisample_ARGS *)&unpacked->args; \
    glTexImage2DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->fixedsamplelocations);; \
} while(0)
void glTexImage2DMultisample(glTexImage2DMultisample_ARG_EXPAND);
packed_call_t *pack_glTexImage2DMultisample(glTexImage2DMultisample_PACKED *_dst glTexImage2DMultisample_ARG_EXPAND_TAIL);
typedef void (*glTexImage2DMultisample_PTR)(glTexImage2DMultisample_ARG_EXPAND);
#endif
#ifndef glTexImage2DMultisampleCoverageNV_RETURN
#define glTexImage2DMultisampleCoverageNV_RETURN void
#define glTexImage2DMultisampleCoverageNV_ARG_NAMES target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations
#define glTexImage2DMultisampleCoverageNV_ARG_EXPAND GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define glTexImage2DMultisampleCoverageNV_ARG_NAMES_TAIL , target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations
#define glTexImage2DMultisampleCoverageNV_ARG_EXPAND_TAIL , GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define forward_glTexImage2DMultisampleCoverageNV(_target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _fixedSampleLocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage2DMultisampleCoverageNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage2DMultisampleCoverageNV(dst, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _fixedSampleLocations), NULL); \
    });
#define call_glTexImage2DMultisampleCoverageNV(packed, ret_v) do { \
    glTexImage2DMultisampleCoverageNV_PACKED *unpacked = (glTexImage2DMultisampleCoverageNV_PACKED *)packed; \
    glTexImage2DMultisampleCoverageNV_ARGS *args = (glTexImage2DMultisampleCoverageNV_ARGS *)&unpacked->args; \
    glTexImage2DMultisampleCoverageNV(args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->fixedSampleLocations);; \
} while(0)
void glTexImage2DMultisampleCoverageNV(glTexImage2DMultisampleCoverageNV_ARG_EXPAND);
packed_call_t *pack_glTexImage2DMultisampleCoverageNV(glTexImage2DMultisampleCoverageNV_PACKED *_dst glTexImage2DMultisampleCoverageNV_ARG_EXPAND_TAIL);
typedef void (*glTexImage2DMultisampleCoverageNV_PTR)(glTexImage2DMultisampleCoverageNV_ARG_EXPAND);
#endif
#ifndef glTexImage3D_RETURN
#define glTexImage3D_RETURN void
#define glTexImage3D_ARG_NAMES target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTexImage3D_ARG_EXPAND GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage3D_ARG_NAMES_TAIL , target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTexImage3D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexImage3D(_target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage3D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage3D(dst, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTexImage3D(packed, ret_v) do { \
    glTexImage3D_PACKED *unpacked = (glTexImage3D_PACKED *)packed; \
    glTexImage3D_ARGS *args = (glTexImage3D_ARGS *)&unpacked->args; \
    glTexImage3D(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage3D(glTexImage3D_ARG_EXPAND);
packed_call_t *pack_glTexImage3D(glTexImage3D_PACKED *_dst glTexImage3D_ARG_EXPAND_TAIL);
typedef void (*glTexImage3D_PTR)(glTexImage3D_ARG_EXPAND);
#endif
#ifndef glTexImage3DEXT_RETURN
#define glTexImage3DEXT_RETURN void
#define glTexImage3DEXT_ARG_NAMES target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTexImage3DEXT_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage3DEXT_ARG_NAMES_TAIL , target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTexImage3DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexImage3DEXT(_target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage3DEXT(dst, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTexImage3DEXT(packed, ret_v) do { \
    glTexImage3DEXT_PACKED *unpacked = (glTexImage3DEXT_PACKED *)packed; \
    glTexImage3DEXT_ARGS *args = (glTexImage3DEXT_ARGS *)&unpacked->args; \
    glTexImage3DEXT(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage3DEXT(glTexImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glTexImage3DEXT(glTexImage3DEXT_PACKED *_dst glTexImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glTexImage3DEXT_PTR)(glTexImage3DEXT_ARG_EXPAND);
#endif
#ifndef glTexImage3DMultisample_RETURN
#define glTexImage3DMultisample_RETURN void
#define glTexImage3DMultisample_ARG_NAMES target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTexImage3DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define glTexImage3DMultisample_ARG_NAMES_TAIL , target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTexImage3DMultisample_ARG_EXPAND_TAIL , GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define forward_glTexImage3DMultisample(_target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage3DMultisample_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage3DMultisample(dst, _target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations), NULL); \
    });
#define call_glTexImage3DMultisample(packed, ret_v) do { \
    glTexImage3DMultisample_PACKED *unpacked = (glTexImage3DMultisample_PACKED *)packed; \
    glTexImage3DMultisample_ARGS *args = (glTexImage3DMultisample_ARGS *)&unpacked->args; \
    glTexImage3DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->depth, args->fixedsamplelocations);; \
} while(0)
void glTexImage3DMultisample(glTexImage3DMultisample_ARG_EXPAND);
packed_call_t *pack_glTexImage3DMultisample(glTexImage3DMultisample_PACKED *_dst glTexImage3DMultisample_ARG_EXPAND_TAIL);
typedef void (*glTexImage3DMultisample_PTR)(glTexImage3DMultisample_ARG_EXPAND);
#endif
#ifndef glTexImage3DMultisampleCoverageNV_RETURN
#define glTexImage3DMultisampleCoverageNV_RETURN void
#define glTexImage3DMultisampleCoverageNV_ARG_NAMES target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations
#define glTexImage3DMultisampleCoverageNV_ARG_EXPAND GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define glTexImage3DMultisampleCoverageNV_ARG_NAMES_TAIL , target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations
#define glTexImage3DMultisampleCoverageNV_ARG_EXPAND_TAIL , GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define forward_glTexImage3DMultisampleCoverageNV(_target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _depth, _fixedSampleLocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage3DMultisampleCoverageNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage3DMultisampleCoverageNV(dst, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _depth, _fixedSampleLocations), NULL); \
    });
#define call_glTexImage3DMultisampleCoverageNV(packed, ret_v) do { \
    glTexImage3DMultisampleCoverageNV_PACKED *unpacked = (glTexImage3DMultisampleCoverageNV_PACKED *)packed; \
    glTexImage3DMultisampleCoverageNV_ARGS *args = (glTexImage3DMultisampleCoverageNV_ARGS *)&unpacked->args; \
    glTexImage3DMultisampleCoverageNV(args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->depth, args->fixedSampleLocations);; \
} while(0)
void glTexImage3DMultisampleCoverageNV(glTexImage3DMultisampleCoverageNV_ARG_EXPAND);
packed_call_t *pack_glTexImage3DMultisampleCoverageNV(glTexImage3DMultisampleCoverageNV_PACKED *_dst glTexImage3DMultisampleCoverageNV_ARG_EXPAND_TAIL);
typedef void (*glTexImage3DMultisampleCoverageNV_PTR)(glTexImage3DMultisampleCoverageNV_ARG_EXPAND);
#endif
#ifndef glTexImage4DSGIS_RETURN
#define glTexImage4DSGIS_RETURN void
#define glTexImage4DSGIS_ARG_NAMES target, level, internalformat, width, height, depth, size4d, border, format, type, pixels
#define glTexImage4DSGIS_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage4DSGIS_ARG_NAMES_TAIL , target, level, internalformat, width, height, depth, size4d, border, format, type, pixels
#define glTexImage4DSGIS_ARG_EXPAND_TAIL , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexImage4DSGIS(_target, _level, _internalformat, _width, _height, _depth, _size4d, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexImage4DSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexImage4DSGIS(dst, _target, _level, _internalformat, _width, _height, _depth, _size4d, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTexImage4DSGIS(packed, ret_v) do { \
    glTexImage4DSGIS_PACKED *unpacked = (glTexImage4DSGIS_PACKED *)packed; \
    glTexImage4DSGIS_ARGS *args = (glTexImage4DSGIS_ARGS *)&unpacked->args; \
    glTexImage4DSGIS(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->size4d, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage4DSGIS(glTexImage4DSGIS_ARG_EXPAND);
packed_call_t *pack_glTexImage4DSGIS(glTexImage4DSGIS_PACKED *_dst glTexImage4DSGIS_ARG_EXPAND_TAIL);
typedef void (*glTexImage4DSGIS_PTR)(glTexImage4DSGIS_ARG_EXPAND);
#endif
#ifndef glTexParameterIiv_RETURN
#define glTexParameterIiv_RETURN void
#define glTexParameterIiv_ARG_NAMES target, pname, params
#define glTexParameterIiv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexParameterIiv_ARG_NAMES_TAIL , target, pname, params
#define glTexParameterIiv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glTexParameterIiv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterIiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterIiv(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexParameterIiv(packed, ret_v) do { \
    glTexParameterIiv_PACKED *unpacked = (glTexParameterIiv_PACKED *)packed; \
    glTexParameterIiv_ARGS *args = (glTexParameterIiv_ARGS *)&unpacked->args; \
    glTexParameterIiv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIiv(glTexParameterIiv_ARG_EXPAND);
packed_call_t *pack_glTexParameterIiv(glTexParameterIiv_PACKED *_dst glTexParameterIiv_ARG_EXPAND_TAIL);
typedef void (*glTexParameterIiv_PTR)(glTexParameterIiv_ARG_EXPAND);
#endif
#ifndef glTexParameterIivEXT_RETURN
#define glTexParameterIivEXT_RETURN void
#define glTexParameterIivEXT_ARG_NAMES target, pname, params
#define glTexParameterIivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexParameterIivEXT_ARG_NAMES_TAIL , target, pname, params
#define glTexParameterIivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glTexParameterIivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterIivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexParameterIivEXT(packed, ret_v) do { \
    glTexParameterIivEXT_PACKED *unpacked = (glTexParameterIivEXT_PACKED *)packed; \
    glTexParameterIivEXT_ARGS *args = (glTexParameterIivEXT_ARGS *)&unpacked->args; \
    glTexParameterIivEXT(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIivEXT(glTexParameterIivEXT_ARG_EXPAND);
packed_call_t *pack_glTexParameterIivEXT(glTexParameterIivEXT_PACKED *_dst glTexParameterIivEXT_ARG_EXPAND_TAIL);
typedef void (*glTexParameterIivEXT_PTR)(glTexParameterIivEXT_ARG_EXPAND);
#endif
#ifndef glTexParameterIuiv_RETURN
#define glTexParameterIuiv_RETURN void
#define glTexParameterIuiv_ARG_NAMES target, pname, params
#define glTexParameterIuiv_ARG_EXPAND GLenum target, GLenum pname, const GLuint * params
#define glTexParameterIuiv_ARG_NAMES_TAIL , target, pname, params
#define glTexParameterIuiv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLuint * params
#define forward_glTexParameterIuiv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterIuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterIuiv(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexParameterIuiv(packed, ret_v) do { \
    glTexParameterIuiv_PACKED *unpacked = (glTexParameterIuiv_PACKED *)packed; \
    glTexParameterIuiv_ARGS *args = (glTexParameterIuiv_ARGS *)&unpacked->args; \
    glTexParameterIuiv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIuiv(glTexParameterIuiv_ARG_EXPAND);
packed_call_t *pack_glTexParameterIuiv(glTexParameterIuiv_PACKED *_dst glTexParameterIuiv_ARG_EXPAND_TAIL);
typedef void (*glTexParameterIuiv_PTR)(glTexParameterIuiv_ARG_EXPAND);
#endif
#ifndef glTexParameterIuivEXT_RETURN
#define glTexParameterIuivEXT_RETURN void
#define glTexParameterIuivEXT_ARG_NAMES target, pname, params
#define glTexParameterIuivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLuint * params
#define glTexParameterIuivEXT_ARG_NAMES_TAIL , target, pname, params
#define glTexParameterIuivEXT_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLuint * params
#define forward_glTexParameterIuivEXT(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterIuivEXT(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexParameterIuivEXT(packed, ret_v) do { \
    glTexParameterIuivEXT_PACKED *unpacked = (glTexParameterIuivEXT_PACKED *)packed; \
    glTexParameterIuivEXT_ARGS *args = (glTexParameterIuivEXT_ARGS *)&unpacked->args; \
    glTexParameterIuivEXT(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIuivEXT(glTexParameterIuivEXT_ARG_EXPAND);
packed_call_t *pack_glTexParameterIuivEXT(glTexParameterIuivEXT_PACKED *_dst glTexParameterIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glTexParameterIuivEXT_PTR)(glTexParameterIuivEXT_ARG_EXPAND);
#endif
#ifndef glTexParameterf_RETURN
#define glTexParameterf_RETURN void
#define glTexParameterf_ARG_NAMES target, pname, param
#define glTexParameterf_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glTexParameterf_ARG_NAMES_TAIL , target, pname, param
#define glTexParameterf_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfloat param
#define forward_glTexParameterf(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterf(dst, _target, _pname, _param), NULL); \
    });
#define call_glTexParameterf(packed, ret_v) do { \
    glTexParameterf_PACKED *unpacked = (glTexParameterf_PACKED *)packed; \
    glTexParameterf_ARGS *args = (glTexParameterf_ARGS *)&unpacked->args; \
    glTexParameterf(args->target, args->pname, args->param);; \
} while(0)
void glTexParameterf(glTexParameterf_ARG_EXPAND);
packed_call_t *pack_glTexParameterf(glTexParameterf_PACKED *_dst glTexParameterf_ARG_EXPAND_TAIL);
typedef void (*glTexParameterf_PTR)(glTexParameterf_ARG_EXPAND);
#endif
#ifndef glTexParameterfv_RETURN
#define glTexParameterfv_RETURN void
#define glTexParameterfv_ARG_NAMES target, pname, params
#define glTexParameterfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glTexParameterfv_ARG_NAMES_TAIL , target, pname, params
#define glTexParameterfv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfloat * params
#define forward_glTexParameterfv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterfv(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexParameterfv(packed, ret_v) do { \
    glTexParameterfv_PACKED *unpacked = (glTexParameterfv_PACKED *)packed; \
    glTexParameterfv_ARGS *args = (glTexParameterfv_ARGS *)&unpacked->args; \
    glTexParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterfv(glTexParameterfv_ARG_EXPAND);
packed_call_t *pack_glTexParameterfv(glTexParameterfv_PACKED *_dst glTexParameterfv_ARG_EXPAND_TAIL);
typedef void (*glTexParameterfv_PTR)(glTexParameterfv_ARG_EXPAND);
#endif
#ifndef glTexParameteri_RETURN
#define glTexParameteri_RETURN void
#define glTexParameteri_ARG_NAMES target, pname, param
#define glTexParameteri_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glTexParameteri_ARG_NAMES_TAIL , target, pname, param
#define glTexParameteri_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLint param
#define forward_glTexParameteri(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameteri_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameteri(dst, _target, _pname, _param), NULL); \
    });
#define call_glTexParameteri(packed, ret_v) do { \
    glTexParameteri_PACKED *unpacked = (glTexParameteri_PACKED *)packed; \
    glTexParameteri_ARGS *args = (glTexParameteri_ARGS *)&unpacked->args; \
    glTexParameteri(args->target, args->pname, args->param);; \
} while(0)
void glTexParameteri(glTexParameteri_ARG_EXPAND);
packed_call_t *pack_glTexParameteri(glTexParameteri_PACKED *_dst glTexParameteri_ARG_EXPAND_TAIL);
typedef void (*glTexParameteri_PTR)(glTexParameteri_ARG_EXPAND);
#endif
#ifndef glTexParameteriv_RETURN
#define glTexParameteriv_RETURN void
#define glTexParameteriv_ARG_NAMES target, pname, params
#define glTexParameteriv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexParameteriv_ARG_NAMES_TAIL , target, pname, params
#define glTexParameteriv_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLint * params
#define forward_glTexParameteriv(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameteriv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameteriv(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexParameteriv(packed, ret_v) do { \
    glTexParameteriv_PACKED *unpacked = (glTexParameteriv_PACKED *)packed; \
    glTexParameteriv_ARGS *args = (glTexParameteriv_ARGS *)&unpacked->args; \
    glTexParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameteriv(glTexParameteriv_ARG_EXPAND);
packed_call_t *pack_glTexParameteriv(glTexParameteriv_PACKED *_dst glTexParameteriv_ARG_EXPAND_TAIL);
typedef void (*glTexParameteriv_PTR)(glTexParameteriv_ARG_EXPAND);
#endif
#ifndef glTexParameterxOES_RETURN
#define glTexParameterxOES_RETURN void
#define glTexParameterxOES_ARG_NAMES target, pname, param
#define glTexParameterxOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glTexParameterxOES_ARG_NAMES_TAIL , target, pname, param
#define glTexParameterxOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, GLfixed param
#define forward_glTexParameterxOES(_target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterxOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterxOES(dst, _target, _pname, _param), NULL); \
    });
#define call_glTexParameterxOES(packed, ret_v) do { \
    glTexParameterxOES_PACKED *unpacked = (glTexParameterxOES_PACKED *)packed; \
    glTexParameterxOES_ARGS *args = (glTexParameterxOES_ARGS *)&unpacked->args; \
    glTexParameterxOES(args->target, args->pname, args->param);; \
} while(0)
void glTexParameterxOES(glTexParameterxOES_ARG_EXPAND);
packed_call_t *pack_glTexParameterxOES(glTexParameterxOES_PACKED *_dst glTexParameterxOES_ARG_EXPAND_TAIL);
typedef void (*glTexParameterxOES_PTR)(glTexParameterxOES_ARG_EXPAND);
#endif
#ifndef glTexParameterxvOES_RETURN
#define glTexParameterxvOES_RETURN void
#define glTexParameterxvOES_ARG_NAMES target, pname, params
#define glTexParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glTexParameterxvOES_ARG_NAMES_TAIL , target, pname, params
#define glTexParameterxvOES_ARG_EXPAND_TAIL , GLenum target, GLenum pname, const GLfixed * params
#define forward_glTexParameterxvOES(_target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTexParameterxvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexParameterxvOES(dst, _target, _pname, _params), NULL); \
    });
#define call_glTexParameterxvOES(packed, ret_v) do { \
    glTexParameterxvOES_PACKED *unpacked = (glTexParameterxvOES_PACKED *)packed; \
    glTexParameterxvOES_ARGS *args = (glTexParameterxvOES_ARGS *)&unpacked->args; \
    glTexParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterxvOES(glTexParameterxvOES_ARG_EXPAND);
packed_call_t *pack_glTexParameterxvOES(glTexParameterxvOES_PACKED *_dst glTexParameterxvOES_ARG_EXPAND_TAIL);
typedef void (*glTexParameterxvOES_PTR)(glTexParameterxvOES_ARG_EXPAND);
#endif
#ifndef glTexRenderbufferNV_RETURN
#define glTexRenderbufferNV_RETURN void
#define glTexRenderbufferNV_ARG_NAMES target, renderbuffer
#define glTexRenderbufferNV_ARG_EXPAND GLenum target, GLuint renderbuffer
#define glTexRenderbufferNV_ARG_NAMES_TAIL , target, renderbuffer
#define glTexRenderbufferNV_ARG_EXPAND_TAIL , GLenum target, GLuint renderbuffer
#define forward_glTexRenderbufferNV(_target, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glTexRenderbufferNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexRenderbufferNV(dst, _target, _renderbuffer), NULL); \
    });
#define call_glTexRenderbufferNV(packed, ret_v) do { \
    glTexRenderbufferNV_PACKED *unpacked = (glTexRenderbufferNV_PACKED *)packed; \
    glTexRenderbufferNV_ARGS *args = (glTexRenderbufferNV_ARGS *)&unpacked->args; \
    glTexRenderbufferNV(args->target, args->renderbuffer);; \
} while(0)
void glTexRenderbufferNV(glTexRenderbufferNV_ARG_EXPAND);
packed_call_t *pack_glTexRenderbufferNV(glTexRenderbufferNV_PACKED *_dst glTexRenderbufferNV_ARG_EXPAND_TAIL);
typedef void (*glTexRenderbufferNV_PTR)(glTexRenderbufferNV_ARG_EXPAND);
#endif
#ifndef glTexStorage1D_RETURN
#define glTexStorage1D_RETURN void
#define glTexStorage1D_ARG_NAMES target, levels, internalformat, width
#define glTexStorage1D_ARG_EXPAND GLenum target, GLsizei levels, GLenum internalformat, GLsizei width
#define glTexStorage1D_ARG_NAMES_TAIL , target, levels, internalformat, width
#define glTexStorage1D_ARG_EXPAND_TAIL , GLenum target, GLsizei levels, GLenum internalformat, GLsizei width
#define forward_glTexStorage1D(_target, _levels, _internalformat, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glTexStorage1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexStorage1D(dst, _target, _levels, _internalformat, _width), NULL); \
    });
#define call_glTexStorage1D(packed, ret_v) do { \
    glTexStorage1D_PACKED *unpacked = (glTexStorage1D_PACKED *)packed; \
    glTexStorage1D_ARGS *args = (glTexStorage1D_ARGS *)&unpacked->args; \
    glTexStorage1D(args->target, args->levels, args->internalformat, args->width);; \
} while(0)
void glTexStorage1D(glTexStorage1D_ARG_EXPAND);
packed_call_t *pack_glTexStorage1D(glTexStorage1D_PACKED *_dst glTexStorage1D_ARG_EXPAND_TAIL);
typedef void (*glTexStorage1D_PTR)(glTexStorage1D_ARG_EXPAND);
#endif
#ifndef glTexStorage2D_RETURN
#define glTexStorage2D_RETURN void
#define glTexStorage2D_ARG_NAMES target, levels, internalformat, width, height
#define glTexStorage2D_ARG_EXPAND GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height
#define glTexStorage2D_ARG_NAMES_TAIL , target, levels, internalformat, width, height
#define glTexStorage2D_ARG_EXPAND_TAIL , GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glTexStorage2D(_target, _levels, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glTexStorage2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexStorage2D(dst, _target, _levels, _internalformat, _width, _height), NULL); \
    });
#define call_glTexStorage2D(packed, ret_v) do { \
    glTexStorage2D_PACKED *unpacked = (glTexStorage2D_PACKED *)packed; \
    glTexStorage2D_ARGS *args = (glTexStorage2D_ARGS *)&unpacked->args; \
    glTexStorage2D(args->target, args->levels, args->internalformat, args->width, args->height);; \
} while(0)
void glTexStorage2D(glTexStorage2D_ARG_EXPAND);
packed_call_t *pack_glTexStorage2D(glTexStorage2D_PACKED *_dst glTexStorage2D_ARG_EXPAND_TAIL);
typedef void (*glTexStorage2D_PTR)(glTexStorage2D_ARG_EXPAND);
#endif
#ifndef glTexStorage2DMultisample_RETURN
#define glTexStorage2DMultisample_RETURN void
#define glTexStorage2DMultisample_ARG_NAMES target, samples, internalformat, width, height, fixedsamplelocations
#define glTexStorage2DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define glTexStorage2DMultisample_ARG_NAMES_TAIL , target, samples, internalformat, width, height, fixedsamplelocations
#define glTexStorage2DMultisample_ARG_EXPAND_TAIL , GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define forward_glTexStorage2DMultisample(_target, _samples, _internalformat, _width, _height, _fixedsamplelocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTexStorage2DMultisample_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexStorage2DMultisample(dst, _target, _samples, _internalformat, _width, _height, _fixedsamplelocations), NULL); \
    });
#define call_glTexStorage2DMultisample(packed, ret_v) do { \
    glTexStorage2DMultisample_PACKED *unpacked = (glTexStorage2DMultisample_PACKED *)packed; \
    glTexStorage2DMultisample_ARGS *args = (glTexStorage2DMultisample_ARGS *)&unpacked->args; \
    glTexStorage2DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->fixedsamplelocations);; \
} while(0)
void glTexStorage2DMultisample(glTexStorage2DMultisample_ARG_EXPAND);
packed_call_t *pack_glTexStorage2DMultisample(glTexStorage2DMultisample_PACKED *_dst glTexStorage2DMultisample_ARG_EXPAND_TAIL);
typedef void (*glTexStorage2DMultisample_PTR)(glTexStorage2DMultisample_ARG_EXPAND);
#endif
#ifndef glTexStorage3D_RETURN
#define glTexStorage3D_RETURN void
#define glTexStorage3D_ARG_NAMES target, levels, internalformat, width, height, depth
#define glTexStorage3D_ARG_EXPAND GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth
#define glTexStorage3D_ARG_NAMES_TAIL , target, levels, internalformat, width, height, depth
#define glTexStorage3D_ARG_EXPAND_TAIL , GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth
#define forward_glTexStorage3D(_target, _levels, _internalformat, _width, _height, _depth) \
    ({ \
        void *dst = remote_dma(sizeof(glTexStorage3D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexStorage3D(dst, _target, _levels, _internalformat, _width, _height, _depth), NULL); \
    });
#define call_glTexStorage3D(packed, ret_v) do { \
    glTexStorage3D_PACKED *unpacked = (glTexStorage3D_PACKED *)packed; \
    glTexStorage3D_ARGS *args = (glTexStorage3D_ARGS *)&unpacked->args; \
    glTexStorage3D(args->target, args->levels, args->internalformat, args->width, args->height, args->depth);; \
} while(0)
void glTexStorage3D(glTexStorage3D_ARG_EXPAND);
packed_call_t *pack_glTexStorage3D(glTexStorage3D_PACKED *_dst glTexStorage3D_ARG_EXPAND_TAIL);
typedef void (*glTexStorage3D_PTR)(glTexStorage3D_ARG_EXPAND);
#endif
#ifndef glTexStorage3DMultisample_RETURN
#define glTexStorage3DMultisample_RETURN void
#define glTexStorage3DMultisample_ARG_NAMES target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTexStorage3DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define glTexStorage3DMultisample_ARG_NAMES_TAIL , target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTexStorage3DMultisample_ARG_EXPAND_TAIL , GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define forward_glTexStorage3DMultisample(_target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTexStorage3DMultisample_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexStorage3DMultisample(dst, _target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations), NULL); \
    });
#define call_glTexStorage3DMultisample(packed, ret_v) do { \
    glTexStorage3DMultisample_PACKED *unpacked = (glTexStorage3DMultisample_PACKED *)packed; \
    glTexStorage3DMultisample_ARGS *args = (glTexStorage3DMultisample_ARGS *)&unpacked->args; \
    glTexStorage3DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->depth, args->fixedsamplelocations);; \
} while(0)
void glTexStorage3DMultisample(glTexStorage3DMultisample_ARG_EXPAND);
packed_call_t *pack_glTexStorage3DMultisample(glTexStorage3DMultisample_PACKED *_dst glTexStorage3DMultisample_ARG_EXPAND_TAIL);
typedef void (*glTexStorage3DMultisample_PTR)(glTexStorage3DMultisample_ARG_EXPAND);
#endif
#ifndef glTexStorageSparseAMD_RETURN
#define glTexStorageSparseAMD_RETURN void
#define glTexStorageSparseAMD_ARG_NAMES target, internalFormat, width, height, depth, layers, flags
#define glTexStorageSparseAMD_ARG_EXPAND GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags
#define glTexStorageSparseAMD_ARG_NAMES_TAIL , target, internalFormat, width, height, depth, layers, flags
#define glTexStorageSparseAMD_ARG_EXPAND_TAIL , GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags
#define forward_glTexStorageSparseAMD(_target, _internalFormat, _width, _height, _depth, _layers, _flags) \
    ({ \
        void *dst = remote_dma(sizeof(glTexStorageSparseAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexStorageSparseAMD(dst, _target, _internalFormat, _width, _height, _depth, _layers, _flags), NULL); \
    });
#define call_glTexStorageSparseAMD(packed, ret_v) do { \
    glTexStorageSparseAMD_PACKED *unpacked = (glTexStorageSparseAMD_PACKED *)packed; \
    glTexStorageSparseAMD_ARGS *args = (glTexStorageSparseAMD_ARGS *)&unpacked->args; \
    glTexStorageSparseAMD(args->target, args->internalFormat, args->width, args->height, args->depth, args->layers, args->flags);; \
} while(0)
void glTexStorageSparseAMD(glTexStorageSparseAMD_ARG_EXPAND);
packed_call_t *pack_glTexStorageSparseAMD(glTexStorageSparseAMD_PACKED *_dst glTexStorageSparseAMD_ARG_EXPAND_TAIL);
typedef void (*glTexStorageSparseAMD_PTR)(glTexStorageSparseAMD_ARG_EXPAND);
#endif
#ifndef glTexSubImage1D_RETURN
#define glTexSubImage1D_RETURN void
#define glTexSubImage1D_ARG_NAMES target, level, xoffset, width, format, type, pixels
#define glTexSubImage1D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage1D_ARG_NAMES_TAIL , target, level, xoffset, width, format, type, pixels
#define glTexSubImage1D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexSubImage1D(_target, _level, _xoffset, _width, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexSubImage1D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexSubImage1D(dst, _target, _level, _xoffset, _width, _format, _type, _pixels), NULL); \
    });
#define call_glTexSubImage1D(packed, ret_v) do { \
    glTexSubImage1D_PACKED *unpacked = (glTexSubImage1D_PACKED *)packed; \
    glTexSubImage1D_ARGS *args = (glTexSubImage1D_ARGS *)&unpacked->args; \
    glTexSubImage1D(args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage1D(glTexSubImage1D_ARG_EXPAND);
packed_call_t *pack_glTexSubImage1D(glTexSubImage1D_PACKED *_dst glTexSubImage1D_ARG_EXPAND_TAIL);
typedef void (*glTexSubImage1D_PTR)(glTexSubImage1D_ARG_EXPAND);
#endif
#ifndef glTexSubImage1DEXT_RETURN
#define glTexSubImage1DEXT_RETURN void
#define glTexSubImage1DEXT_ARG_NAMES target, level, xoffset, width, format, type, pixels
#define glTexSubImage1DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage1DEXT_ARG_NAMES_TAIL , target, level, xoffset, width, format, type, pixels
#define glTexSubImage1DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexSubImage1DEXT(_target, _level, _xoffset, _width, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexSubImage1DEXT(dst, _target, _level, _xoffset, _width, _format, _type, _pixels), NULL); \
    });
#define call_glTexSubImage1DEXT(packed, ret_v) do { \
    glTexSubImage1DEXT_PACKED *unpacked = (glTexSubImage1DEXT_PACKED *)packed; \
    glTexSubImage1DEXT_ARGS *args = (glTexSubImage1DEXT_ARGS *)&unpacked->args; \
    glTexSubImage1DEXT(args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage1DEXT(glTexSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glTexSubImage1DEXT(glTexSubImage1DEXT_PACKED *_dst glTexSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glTexSubImage1DEXT_PTR)(glTexSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glTexSubImage2D_RETURN
#define glTexSubImage2D_RETURN void
#define glTexSubImage2D_ARG_NAMES target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTexSubImage2D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage2D_ARG_NAMES_TAIL , target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTexSubImage2D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexSubImage2D(_target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexSubImage2D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexSubImage2D(dst, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels), NULL); \
    });
#define call_glTexSubImage2D(packed, ret_v) do { \
    glTexSubImage2D_PACKED *unpacked = (glTexSubImage2D_PACKED *)packed; \
    glTexSubImage2D_ARGS *args = (glTexSubImage2D_ARGS *)&unpacked->args; \
    glTexSubImage2D(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage2D(glTexSubImage2D_ARG_EXPAND);
packed_call_t *pack_glTexSubImage2D(glTexSubImage2D_PACKED *_dst glTexSubImage2D_ARG_EXPAND_TAIL);
typedef void (*glTexSubImage2D_PTR)(glTexSubImage2D_ARG_EXPAND);
#endif
#ifndef glTexSubImage2DEXT_RETURN
#define glTexSubImage2DEXT_RETURN void
#define glTexSubImage2DEXT_ARG_NAMES target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTexSubImage2DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage2DEXT_ARG_NAMES_TAIL , target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTexSubImage2DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexSubImage2DEXT(_target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexSubImage2DEXT(dst, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels), NULL); \
    });
#define call_glTexSubImage2DEXT(packed, ret_v) do { \
    glTexSubImage2DEXT_PACKED *unpacked = (glTexSubImage2DEXT_PACKED *)packed; \
    glTexSubImage2DEXT_ARGS *args = (glTexSubImage2DEXT_ARGS *)&unpacked->args; \
    glTexSubImage2DEXT(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage2DEXT(glTexSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glTexSubImage2DEXT(glTexSubImage2DEXT_PACKED *_dst glTexSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glTexSubImage2DEXT_PTR)(glTexSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glTexSubImage3D_RETURN
#define glTexSubImage3D_RETURN void
#define glTexSubImage3D_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTexSubImage3D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage3D_ARG_NAMES_TAIL , target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTexSubImage3D_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexSubImage3D_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexSubImage3D(dst, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels), NULL); \
    });
#define call_glTexSubImage3D(packed, ret_v) do { \
    glTexSubImage3D_PACKED *unpacked = (glTexSubImage3D_PACKED *)packed; \
    glTexSubImage3D_ARGS *args = (glTexSubImage3D_ARGS *)&unpacked->args; \
    glTexSubImage3D(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage3D(glTexSubImage3D_ARG_EXPAND);
packed_call_t *pack_glTexSubImage3D(glTexSubImage3D_PACKED *_dst glTexSubImage3D_ARG_EXPAND_TAIL);
typedef void (*glTexSubImage3D_PTR)(glTexSubImage3D_ARG_EXPAND);
#endif
#ifndef glTexSubImage3DEXT_RETURN
#define glTexSubImage3DEXT_RETURN void
#define glTexSubImage3DEXT_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTexSubImage3DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage3DEXT_ARG_NAMES_TAIL , target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTexSubImage3DEXT_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexSubImage3DEXT(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexSubImage3DEXT(dst, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels), NULL); \
    });
#define call_glTexSubImage3DEXT(packed, ret_v) do { \
    glTexSubImage3DEXT_PACKED *unpacked = (glTexSubImage3DEXT_PACKED *)packed; \
    glTexSubImage3DEXT_ARGS *args = (glTexSubImage3DEXT_ARGS *)&unpacked->args; \
    glTexSubImage3DEXT(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage3DEXT(glTexSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glTexSubImage3DEXT(glTexSubImage3DEXT_PACKED *_dst glTexSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glTexSubImage3DEXT_PTR)(glTexSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glTexSubImage4DSGIS_RETURN
#define glTexSubImage4DSGIS_RETURN void
#define glTexSubImage4DSGIS_ARG_NAMES target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels
#define glTexSubImage4DSGIS_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage4DSGIS_ARG_NAMES_TAIL , target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels
#define glTexSubImage4DSGIS_ARG_EXPAND_TAIL , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTexSubImage4DSGIS(_target, _level, _xoffset, _yoffset, _zoffset, _woffset, _width, _height, _depth, _size4d, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTexSubImage4DSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTexSubImage4DSGIS(dst, _target, _level, _xoffset, _yoffset, _zoffset, _woffset, _width, _height, _depth, _size4d, _format, _type, _pixels), NULL); \
    });
#define call_glTexSubImage4DSGIS(packed, ret_v) do { \
    glTexSubImage4DSGIS_PACKED *unpacked = (glTexSubImage4DSGIS_PACKED *)packed; \
    glTexSubImage4DSGIS_ARGS *args = (glTexSubImage4DSGIS_ARGS *)&unpacked->args; \
    glTexSubImage4DSGIS(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->woffset, args->width, args->height, args->depth, args->size4d, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage4DSGIS(glTexSubImage4DSGIS_ARG_EXPAND);
packed_call_t *pack_glTexSubImage4DSGIS(glTexSubImage4DSGIS_PACKED *_dst glTexSubImage4DSGIS_ARG_EXPAND_TAIL);
typedef void (*glTexSubImage4DSGIS_PTR)(glTexSubImage4DSGIS_ARG_EXPAND);
#endif
#ifndef glTextureBarrierNV_RETURN
#define glTextureBarrierNV_RETURN void
#define glTextureBarrierNV_ARG_NAMES 
#define glTextureBarrierNV_ARG_EXPAND 
#define glTextureBarrierNV_ARG_NAMES_TAIL 
#define glTextureBarrierNV_ARG_EXPAND_TAIL 
#define forward_glTextureBarrierNV() \
    ({ \
        void *dst = remote_dma(sizeof(glTextureBarrierNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureBarrierNV(dst), NULL); \
    });
#define call_glTextureBarrierNV(packed, ret_v) do { \
    glTextureBarrierNV();; \
} while(0)
void glTextureBarrierNV(glTextureBarrierNV_ARG_EXPAND);
packed_call_t *pack_glTextureBarrierNV(glTextureBarrierNV_PACKED *_dst glTextureBarrierNV_ARG_EXPAND_TAIL);
typedef void (*glTextureBarrierNV_PTR)(glTextureBarrierNV_ARG_EXPAND);
#endif
#ifndef glTextureBufferEXT_RETURN
#define glTextureBufferEXT_RETURN void
#define glTextureBufferEXT_ARG_NAMES texture, target, internalformat, buffer
#define glTextureBufferEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum internalformat, GLuint buffer
#define glTextureBufferEXT_ARG_NAMES_TAIL , texture, target, internalformat, buffer
#define glTextureBufferEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum internalformat, GLuint buffer
#define forward_glTextureBufferEXT(_texture, _target, _internalformat, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureBufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureBufferEXT(dst, _texture, _target, _internalformat, _buffer), NULL); \
    });
#define call_glTextureBufferEXT(packed, ret_v) do { \
    glTextureBufferEXT_PACKED *unpacked = (glTextureBufferEXT_PACKED *)packed; \
    glTextureBufferEXT_ARGS *args = (glTextureBufferEXT_ARGS *)&unpacked->args; \
    glTextureBufferEXT(args->texture, args->target, args->internalformat, args->buffer);; \
} while(0)
void glTextureBufferEXT(glTextureBufferEXT_ARG_EXPAND);
packed_call_t *pack_glTextureBufferEXT(glTextureBufferEXT_PACKED *_dst glTextureBufferEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureBufferEXT_PTR)(glTextureBufferEXT_ARG_EXPAND);
#endif
#ifndef glTextureBufferRangeEXT_RETURN
#define glTextureBufferRangeEXT_RETURN void
#define glTextureBufferRangeEXT_ARG_NAMES texture, target, internalformat, buffer, offset, size
#define glTextureBufferRangeEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glTextureBufferRangeEXT_ARG_NAMES_TAIL , texture, target, internalformat, buffer, offset, size
#define glTextureBufferRangeEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size
#define forward_glTextureBufferRangeEXT(_texture, _target, _internalformat, _buffer, _offset, _size) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureBufferRangeEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureBufferRangeEXT(dst, _texture, _target, _internalformat, _buffer, _offset, _size), NULL); \
    });
#define call_glTextureBufferRangeEXT(packed, ret_v) do { \
    glTextureBufferRangeEXT_PACKED *unpacked = (glTextureBufferRangeEXT_PACKED *)packed; \
    glTextureBufferRangeEXT_ARGS *args = (glTextureBufferRangeEXT_ARGS *)&unpacked->args; \
    glTextureBufferRangeEXT(args->texture, args->target, args->internalformat, args->buffer, args->offset, args->size);; \
} while(0)
void glTextureBufferRangeEXT(glTextureBufferRangeEXT_ARG_EXPAND);
packed_call_t *pack_glTextureBufferRangeEXT(glTextureBufferRangeEXT_PACKED *_dst glTextureBufferRangeEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureBufferRangeEXT_PTR)(glTextureBufferRangeEXT_ARG_EXPAND);
#endif
#ifndef glTextureColorMaskSGIS_RETURN
#define glTextureColorMaskSGIS_RETURN void
#define glTextureColorMaskSGIS_ARG_NAMES red, green, blue, alpha
#define glTextureColorMaskSGIS_ARG_EXPAND GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha
#define glTextureColorMaskSGIS_ARG_NAMES_TAIL , red, green, blue, alpha
#define glTextureColorMaskSGIS_ARG_EXPAND_TAIL , GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha
#define forward_glTextureColorMaskSGIS(_red, _green, _blue, _alpha) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureColorMaskSGIS_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureColorMaskSGIS(dst, _red, _green, _blue, _alpha), NULL); \
    });
#define call_glTextureColorMaskSGIS(packed, ret_v) do { \
    glTextureColorMaskSGIS_PACKED *unpacked = (glTextureColorMaskSGIS_PACKED *)packed; \
    glTextureColorMaskSGIS_ARGS *args = (glTextureColorMaskSGIS_ARGS *)&unpacked->args; \
    glTextureColorMaskSGIS(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glTextureColorMaskSGIS(glTextureColorMaskSGIS_ARG_EXPAND);
packed_call_t *pack_glTextureColorMaskSGIS(glTextureColorMaskSGIS_PACKED *_dst glTextureColorMaskSGIS_ARG_EXPAND_TAIL);
typedef void (*glTextureColorMaskSGIS_PTR)(glTextureColorMaskSGIS_ARG_EXPAND);
#endif
#ifndef glTextureImage1DEXT_RETURN
#define glTextureImage1DEXT_RETURN void
#define glTextureImage1DEXT_ARG_NAMES texture, target, level, internalformat, width, border, format, type, pixels
#define glTextureImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureImage1DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, width, border, format, type, pixels
#define glTextureImage1DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTextureImage1DEXT(_texture, _target, _level, _internalformat, _width, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureImage1DEXT(dst, _texture, _target, _level, _internalformat, _width, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTextureImage1DEXT(packed, ret_v) do { \
    glTextureImage1DEXT_PACKED *unpacked = (glTextureImage1DEXT_PACKED *)packed; \
    glTextureImage1DEXT_ARGS *args = (glTextureImage1DEXT_ARGS *)&unpacked->args; \
    glTextureImage1DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTextureImage1DEXT(glTextureImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureImage1DEXT(glTextureImage1DEXT_PACKED *_dst glTextureImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureImage1DEXT_PTR)(glTextureImage1DEXT_ARG_EXPAND);
#endif
#ifndef glTextureImage2DEXT_RETURN
#define glTextureImage2DEXT_RETURN void
#define glTextureImage2DEXT_ARG_NAMES texture, target, level, internalformat, width, height, border, format, type, pixels
#define glTextureImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureImage2DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, width, height, border, format, type, pixels
#define glTextureImage2DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTextureImage2DEXT(_texture, _target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureImage2DEXT(dst, _texture, _target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTextureImage2DEXT(packed, ret_v) do { \
    glTextureImage2DEXT_PACKED *unpacked = (glTextureImage2DEXT_PACKED *)packed; \
    glTextureImage2DEXT_ARGS *args = (glTextureImage2DEXT_ARGS *)&unpacked->args; \
    glTextureImage2DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTextureImage2DEXT(glTextureImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureImage2DEXT(glTextureImage2DEXT_PACKED *_dst glTextureImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureImage2DEXT_PTR)(glTextureImage2DEXT_ARG_EXPAND);
#endif
#ifndef glTextureImage2DMultisampleCoverageNV_RETURN
#define glTextureImage2DMultisampleCoverageNV_RETURN void
#define glTextureImage2DMultisampleCoverageNV_ARG_NAMES texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations
#define glTextureImage2DMultisampleCoverageNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define glTextureImage2DMultisampleCoverageNV_ARG_NAMES_TAIL , texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations
#define glTextureImage2DMultisampleCoverageNV_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define forward_glTextureImage2DMultisampleCoverageNV(_texture, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _fixedSampleLocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureImage2DMultisampleCoverageNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureImage2DMultisampleCoverageNV(dst, _texture, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _fixedSampleLocations), NULL); \
    });
#define call_glTextureImage2DMultisampleCoverageNV(packed, ret_v) do { \
    glTextureImage2DMultisampleCoverageNV_PACKED *unpacked = (glTextureImage2DMultisampleCoverageNV_PACKED *)packed; \
    glTextureImage2DMultisampleCoverageNV_ARGS *args = (glTextureImage2DMultisampleCoverageNV_ARGS *)&unpacked->args; \
    glTextureImage2DMultisampleCoverageNV(args->texture, args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->fixedSampleLocations);; \
} while(0)
void glTextureImage2DMultisampleCoverageNV(glTextureImage2DMultisampleCoverageNV_ARG_EXPAND);
packed_call_t *pack_glTextureImage2DMultisampleCoverageNV(glTextureImage2DMultisampleCoverageNV_PACKED *_dst glTextureImage2DMultisampleCoverageNV_ARG_EXPAND_TAIL);
typedef void (*glTextureImage2DMultisampleCoverageNV_PTR)(glTextureImage2DMultisampleCoverageNV_ARG_EXPAND);
#endif
#ifndef glTextureImage2DMultisampleNV_RETURN
#define glTextureImage2DMultisampleNV_RETURN void
#define glTextureImage2DMultisampleNV_ARG_NAMES texture, target, samples, internalFormat, width, height, fixedSampleLocations
#define glTextureImage2DMultisampleNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define glTextureImage2DMultisampleNV_ARG_NAMES_TAIL , texture, target, samples, internalFormat, width, height, fixedSampleLocations
#define glTextureImage2DMultisampleNV_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define forward_glTextureImage2DMultisampleNV(_texture, _target, _samples, _internalFormat, _width, _height, _fixedSampleLocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureImage2DMultisampleNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureImage2DMultisampleNV(dst, _texture, _target, _samples, _internalFormat, _width, _height, _fixedSampleLocations), NULL); \
    });
#define call_glTextureImage2DMultisampleNV(packed, ret_v) do { \
    glTextureImage2DMultisampleNV_PACKED *unpacked = (glTextureImage2DMultisampleNV_PACKED *)packed; \
    glTextureImage2DMultisampleNV_ARGS *args = (glTextureImage2DMultisampleNV_ARGS *)&unpacked->args; \
    glTextureImage2DMultisampleNV(args->texture, args->target, args->samples, args->internalFormat, args->width, args->height, args->fixedSampleLocations);; \
} while(0)
void glTextureImage2DMultisampleNV(glTextureImage2DMultisampleNV_ARG_EXPAND);
packed_call_t *pack_glTextureImage2DMultisampleNV(glTextureImage2DMultisampleNV_PACKED *_dst glTextureImage2DMultisampleNV_ARG_EXPAND_TAIL);
typedef void (*glTextureImage2DMultisampleNV_PTR)(glTextureImage2DMultisampleNV_ARG_EXPAND);
#endif
#ifndef glTextureImage3DEXT_RETURN
#define glTextureImage3DEXT_RETURN void
#define glTextureImage3DEXT_ARG_NAMES texture, target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTextureImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureImage3DEXT_ARG_NAMES_TAIL , texture, target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTextureImage3DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTextureImage3DEXT(_texture, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureImage3DEXT(dst, _texture, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels), NULL); \
    });
#define call_glTextureImage3DEXT(packed, ret_v) do { \
    glTextureImage3DEXT_PACKED *unpacked = (glTextureImage3DEXT_PACKED *)packed; \
    glTextureImage3DEXT_ARGS *args = (glTextureImage3DEXT_ARGS *)&unpacked->args; \
    glTextureImage3DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTextureImage3DEXT(glTextureImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureImage3DEXT(glTextureImage3DEXT_PACKED *_dst glTextureImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureImage3DEXT_PTR)(glTextureImage3DEXT_ARG_EXPAND);
#endif
#ifndef glTextureImage3DMultisampleCoverageNV_RETURN
#define glTextureImage3DMultisampleCoverageNV_RETURN void
#define glTextureImage3DMultisampleCoverageNV_ARG_NAMES texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations
#define glTextureImage3DMultisampleCoverageNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define glTextureImage3DMultisampleCoverageNV_ARG_NAMES_TAIL , texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations
#define glTextureImage3DMultisampleCoverageNV_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define forward_glTextureImage3DMultisampleCoverageNV(_texture, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _depth, _fixedSampleLocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureImage3DMultisampleCoverageNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureImage3DMultisampleCoverageNV(dst, _texture, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _depth, _fixedSampleLocations), NULL); \
    });
#define call_glTextureImage3DMultisampleCoverageNV(packed, ret_v) do { \
    glTextureImage3DMultisampleCoverageNV_PACKED *unpacked = (glTextureImage3DMultisampleCoverageNV_PACKED *)packed; \
    glTextureImage3DMultisampleCoverageNV_ARGS *args = (glTextureImage3DMultisampleCoverageNV_ARGS *)&unpacked->args; \
    glTextureImage3DMultisampleCoverageNV(args->texture, args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->depth, args->fixedSampleLocations);; \
} while(0)
void glTextureImage3DMultisampleCoverageNV(glTextureImage3DMultisampleCoverageNV_ARG_EXPAND);
packed_call_t *pack_glTextureImage3DMultisampleCoverageNV(glTextureImage3DMultisampleCoverageNV_PACKED *_dst glTextureImage3DMultisampleCoverageNV_ARG_EXPAND_TAIL);
typedef void (*glTextureImage3DMultisampleCoverageNV_PTR)(glTextureImage3DMultisampleCoverageNV_ARG_EXPAND);
#endif
#ifndef glTextureImage3DMultisampleNV_RETURN
#define glTextureImage3DMultisampleNV_RETURN void
#define glTextureImage3DMultisampleNV_ARG_NAMES texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations
#define glTextureImage3DMultisampleNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define glTextureImage3DMultisampleNV_ARG_NAMES_TAIL , texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations
#define glTextureImage3DMultisampleNV_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define forward_glTextureImage3DMultisampleNV(_texture, _target, _samples, _internalFormat, _width, _height, _depth, _fixedSampleLocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureImage3DMultisampleNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureImage3DMultisampleNV(dst, _texture, _target, _samples, _internalFormat, _width, _height, _depth, _fixedSampleLocations), NULL); \
    });
#define call_glTextureImage3DMultisampleNV(packed, ret_v) do { \
    glTextureImage3DMultisampleNV_PACKED *unpacked = (glTextureImage3DMultisampleNV_PACKED *)packed; \
    glTextureImage3DMultisampleNV_ARGS *args = (glTextureImage3DMultisampleNV_ARGS *)&unpacked->args; \
    glTextureImage3DMultisampleNV(args->texture, args->target, args->samples, args->internalFormat, args->width, args->height, args->depth, args->fixedSampleLocations);; \
} while(0)
void glTextureImage3DMultisampleNV(glTextureImage3DMultisampleNV_ARG_EXPAND);
packed_call_t *pack_glTextureImage3DMultisampleNV(glTextureImage3DMultisampleNV_PACKED *_dst glTextureImage3DMultisampleNV_ARG_EXPAND_TAIL);
typedef void (*glTextureImage3DMultisampleNV_PTR)(glTextureImage3DMultisampleNV_ARG_EXPAND);
#endif
#ifndef glTextureLightEXT_RETURN
#define glTextureLightEXT_RETURN void
#define glTextureLightEXT_ARG_NAMES pname
#define glTextureLightEXT_ARG_EXPAND GLenum pname
#define glTextureLightEXT_ARG_NAMES_TAIL , pname
#define glTextureLightEXT_ARG_EXPAND_TAIL , GLenum pname
#define forward_glTextureLightEXT(_pname) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureLightEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureLightEXT(dst, _pname), NULL); \
    });
#define call_glTextureLightEXT(packed, ret_v) do { \
    glTextureLightEXT_PACKED *unpacked = (glTextureLightEXT_PACKED *)packed; \
    glTextureLightEXT_ARGS *args = (glTextureLightEXT_ARGS *)&unpacked->args; \
    glTextureLightEXT(args->pname);; \
} while(0)
void glTextureLightEXT(glTextureLightEXT_ARG_EXPAND);
packed_call_t *pack_glTextureLightEXT(glTextureLightEXT_PACKED *_dst glTextureLightEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureLightEXT_PTR)(glTextureLightEXT_ARG_EXPAND);
#endif
#ifndef glTextureMaterialEXT_RETURN
#define glTextureMaterialEXT_RETURN void
#define glTextureMaterialEXT_ARG_NAMES face, mode
#define glTextureMaterialEXT_ARG_EXPAND GLenum face, GLenum mode
#define glTextureMaterialEXT_ARG_NAMES_TAIL , face, mode
#define glTextureMaterialEXT_ARG_EXPAND_TAIL , GLenum face, GLenum mode
#define forward_glTextureMaterialEXT(_face, _mode) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureMaterialEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureMaterialEXT(dst, _face, _mode), NULL); \
    });
#define call_glTextureMaterialEXT(packed, ret_v) do { \
    glTextureMaterialEXT_PACKED *unpacked = (glTextureMaterialEXT_PACKED *)packed; \
    glTextureMaterialEXT_ARGS *args = (glTextureMaterialEXT_ARGS *)&unpacked->args; \
    glTextureMaterialEXT(args->face, args->mode);; \
} while(0)
void glTextureMaterialEXT(glTextureMaterialEXT_ARG_EXPAND);
packed_call_t *pack_glTextureMaterialEXT(glTextureMaterialEXT_PACKED *_dst glTextureMaterialEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureMaterialEXT_PTR)(glTextureMaterialEXT_ARG_EXPAND);
#endif
#ifndef glTextureNormalEXT_RETURN
#define glTextureNormalEXT_RETURN void
#define glTextureNormalEXT_ARG_NAMES mode
#define glTextureNormalEXT_ARG_EXPAND GLenum mode
#define glTextureNormalEXT_ARG_NAMES_TAIL , mode
#define glTextureNormalEXT_ARG_EXPAND_TAIL , GLenum mode
#define forward_glTextureNormalEXT(_mode) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureNormalEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureNormalEXT(dst, _mode), NULL); \
    });
#define call_glTextureNormalEXT(packed, ret_v) do { \
    glTextureNormalEXT_PACKED *unpacked = (glTextureNormalEXT_PACKED *)packed; \
    glTextureNormalEXT_ARGS *args = (glTextureNormalEXT_ARGS *)&unpacked->args; \
    glTextureNormalEXT(args->mode);; \
} while(0)
void glTextureNormalEXT(glTextureNormalEXT_ARG_EXPAND);
packed_call_t *pack_glTextureNormalEXT(glTextureNormalEXT_PACKED *_dst glTextureNormalEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureNormalEXT_PTR)(glTextureNormalEXT_ARG_EXPAND);
#endif
#ifndef glTextureParameterIivEXT_RETURN
#define glTextureParameterIivEXT_RETURN void
#define glTextureParameterIivEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterIivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLint * params
#define glTextureParameterIivEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glTextureParameterIivEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, const GLint * params
#define forward_glTextureParameterIivEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureParameterIivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureParameterIivEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glTextureParameterIivEXT(packed, ret_v) do { \
    glTextureParameterIivEXT_PACKED *unpacked = (glTextureParameterIivEXT_PACKED *)packed; \
    glTextureParameterIivEXT_ARGS *args = (glTextureParameterIivEXT_ARGS *)&unpacked->args; \
    glTextureParameterIivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterIivEXT(glTextureParameterIivEXT_ARG_EXPAND);
packed_call_t *pack_glTextureParameterIivEXT(glTextureParameterIivEXT_PACKED *_dst glTextureParameterIivEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureParameterIivEXT_PTR)(glTextureParameterIivEXT_ARG_EXPAND);
#endif
#ifndef glTextureParameterIuivEXT_RETURN
#define glTextureParameterIuivEXT_RETURN void
#define glTextureParameterIuivEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterIuivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLuint * params
#define glTextureParameterIuivEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glTextureParameterIuivEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, const GLuint * params
#define forward_glTextureParameterIuivEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureParameterIuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureParameterIuivEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glTextureParameterIuivEXT(packed, ret_v) do { \
    glTextureParameterIuivEXT_PACKED *unpacked = (glTextureParameterIuivEXT_PACKED *)packed; \
    glTextureParameterIuivEXT_ARGS *args = (glTextureParameterIuivEXT_ARGS *)&unpacked->args; \
    glTextureParameterIuivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterIuivEXT(glTextureParameterIuivEXT_ARG_EXPAND);
packed_call_t *pack_glTextureParameterIuivEXT(glTextureParameterIuivEXT_PACKED *_dst glTextureParameterIuivEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureParameterIuivEXT_PTR)(glTextureParameterIuivEXT_ARG_EXPAND);
#endif
#ifndef glTextureParameterfEXT_RETURN
#define glTextureParameterfEXT_RETURN void
#define glTextureParameterfEXT_ARG_NAMES texture, target, pname, param
#define glTextureParameterfEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLfloat param
#define glTextureParameterfEXT_ARG_NAMES_TAIL , texture, target, pname, param
#define glTextureParameterfEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, GLfloat param
#define forward_glTextureParameterfEXT(_texture, _target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureParameterfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureParameterfEXT(dst, _texture, _target, _pname, _param), NULL); \
    });
#define call_glTextureParameterfEXT(packed, ret_v) do { \
    glTextureParameterfEXT_PACKED *unpacked = (glTextureParameterfEXT_PACKED *)packed; \
    glTextureParameterfEXT_ARGS *args = (glTextureParameterfEXT_ARGS *)&unpacked->args; \
    glTextureParameterfEXT(args->texture, args->target, args->pname, args->param);; \
} while(0)
void glTextureParameterfEXT(glTextureParameterfEXT_ARG_EXPAND);
packed_call_t *pack_glTextureParameterfEXT(glTextureParameterfEXT_PACKED *_dst glTextureParameterfEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureParameterfEXT_PTR)(glTextureParameterfEXT_ARG_EXPAND);
#endif
#ifndef glTextureParameterfvEXT_RETURN
#define glTextureParameterfvEXT_RETURN void
#define glTextureParameterfvEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterfvEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLfloat * params
#define glTextureParameterfvEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glTextureParameterfvEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, const GLfloat * params
#define forward_glTextureParameterfvEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureParameterfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureParameterfvEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glTextureParameterfvEXT(packed, ret_v) do { \
    glTextureParameterfvEXT_PACKED *unpacked = (glTextureParameterfvEXT_PACKED *)packed; \
    glTextureParameterfvEXT_ARGS *args = (glTextureParameterfvEXT_ARGS *)&unpacked->args; \
    glTextureParameterfvEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterfvEXT(glTextureParameterfvEXT_ARG_EXPAND);
packed_call_t *pack_glTextureParameterfvEXT(glTextureParameterfvEXT_PACKED *_dst glTextureParameterfvEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureParameterfvEXT_PTR)(glTextureParameterfvEXT_ARG_EXPAND);
#endif
#ifndef glTextureParameteriEXT_RETURN
#define glTextureParameteriEXT_RETURN void
#define glTextureParameteriEXT_ARG_NAMES texture, target, pname, param
#define glTextureParameteriEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLint param
#define glTextureParameteriEXT_ARG_NAMES_TAIL , texture, target, pname, param
#define glTextureParameteriEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, GLint param
#define forward_glTextureParameteriEXT(_texture, _target, _pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureParameteriEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureParameteriEXT(dst, _texture, _target, _pname, _param), NULL); \
    });
#define call_glTextureParameteriEXT(packed, ret_v) do { \
    glTextureParameteriEXT_PACKED *unpacked = (glTextureParameteriEXT_PACKED *)packed; \
    glTextureParameteriEXT_ARGS *args = (glTextureParameteriEXT_ARGS *)&unpacked->args; \
    glTextureParameteriEXT(args->texture, args->target, args->pname, args->param);; \
} while(0)
void glTextureParameteriEXT(glTextureParameteriEXT_ARG_EXPAND);
packed_call_t *pack_glTextureParameteriEXT(glTextureParameteriEXT_PACKED *_dst glTextureParameteriEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureParameteriEXT_PTR)(glTextureParameteriEXT_ARG_EXPAND);
#endif
#ifndef glTextureParameterivEXT_RETURN
#define glTextureParameterivEXT_RETURN void
#define glTextureParameterivEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLint * params
#define glTextureParameterivEXT_ARG_NAMES_TAIL , texture, target, pname, params
#define glTextureParameterivEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum pname, const GLint * params
#define forward_glTextureParameterivEXT(_texture, _target, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureParameterivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureParameterivEXT(dst, _texture, _target, _pname, _params), NULL); \
    });
#define call_glTextureParameterivEXT(packed, ret_v) do { \
    glTextureParameterivEXT_PACKED *unpacked = (glTextureParameterivEXT_PACKED *)packed; \
    glTextureParameterivEXT_ARGS *args = (glTextureParameterivEXT_ARGS *)&unpacked->args; \
    glTextureParameterivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterivEXT(glTextureParameterivEXT_ARG_EXPAND);
packed_call_t *pack_glTextureParameterivEXT(glTextureParameterivEXT_PACKED *_dst glTextureParameterivEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureParameterivEXT_PTR)(glTextureParameterivEXT_ARG_EXPAND);
#endif
#ifndef glTextureRangeAPPLE_RETURN
#define glTextureRangeAPPLE_RETURN void
#define glTextureRangeAPPLE_ARG_NAMES target, length, pointer
#define glTextureRangeAPPLE_ARG_EXPAND GLenum target, GLsizei length, const GLvoid * pointer
#define glTextureRangeAPPLE_ARG_NAMES_TAIL , target, length, pointer
#define glTextureRangeAPPLE_ARG_EXPAND_TAIL , GLenum target, GLsizei length, const GLvoid * pointer
#define forward_glTextureRangeAPPLE(_target, _length, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureRangeAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureRangeAPPLE(dst, _target, _length, _pointer), NULL); \
    });
#define call_glTextureRangeAPPLE(packed, ret_v) do { \
    glTextureRangeAPPLE_PACKED *unpacked = (glTextureRangeAPPLE_PACKED *)packed; \
    glTextureRangeAPPLE_ARGS *args = (glTextureRangeAPPLE_ARGS *)&unpacked->args; \
    glTextureRangeAPPLE(args->target, args->length, args->pointer);; \
} while(0)
void glTextureRangeAPPLE(glTextureRangeAPPLE_ARG_EXPAND);
packed_call_t *pack_glTextureRangeAPPLE(glTextureRangeAPPLE_PACKED *_dst glTextureRangeAPPLE_ARG_EXPAND_TAIL);
typedef void (*glTextureRangeAPPLE_PTR)(glTextureRangeAPPLE_ARG_EXPAND);
#endif
#ifndef glTextureRenderbufferEXT_RETURN
#define glTextureRenderbufferEXT_RETURN void
#define glTextureRenderbufferEXT_ARG_NAMES texture, target, renderbuffer
#define glTextureRenderbufferEXT_ARG_EXPAND GLuint texture, GLenum target, GLuint renderbuffer
#define glTextureRenderbufferEXT_ARG_NAMES_TAIL , texture, target, renderbuffer
#define glTextureRenderbufferEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLuint renderbuffer
#define forward_glTextureRenderbufferEXT(_texture, _target, _renderbuffer) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureRenderbufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureRenderbufferEXT(dst, _texture, _target, _renderbuffer), NULL); \
    });
#define call_glTextureRenderbufferEXT(packed, ret_v) do { \
    glTextureRenderbufferEXT_PACKED *unpacked = (glTextureRenderbufferEXT_PACKED *)packed; \
    glTextureRenderbufferEXT_ARGS *args = (glTextureRenderbufferEXT_ARGS *)&unpacked->args; \
    glTextureRenderbufferEXT(args->texture, args->target, args->renderbuffer);; \
} while(0)
void glTextureRenderbufferEXT(glTextureRenderbufferEXT_ARG_EXPAND);
packed_call_t *pack_glTextureRenderbufferEXT(glTextureRenderbufferEXT_PACKED *_dst glTextureRenderbufferEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureRenderbufferEXT_PTR)(glTextureRenderbufferEXT_ARG_EXPAND);
#endif
#ifndef glTextureStorage1DEXT_RETURN
#define glTextureStorage1DEXT_RETURN void
#define glTextureStorage1DEXT_ARG_NAMES texture, target, levels, internalformat, width
#define glTextureStorage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width
#define glTextureStorage1DEXT_ARG_NAMES_TAIL , texture, target, levels, internalformat, width
#define glTextureStorage1DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width
#define forward_glTextureStorage1DEXT(_texture, _target, _levels, _internalformat, _width) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureStorage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureStorage1DEXT(dst, _texture, _target, _levels, _internalformat, _width), NULL); \
    });
#define call_glTextureStorage1DEXT(packed, ret_v) do { \
    glTextureStorage1DEXT_PACKED *unpacked = (glTextureStorage1DEXT_PACKED *)packed; \
    glTextureStorage1DEXT_ARGS *args = (glTextureStorage1DEXT_ARGS *)&unpacked->args; \
    glTextureStorage1DEXT(args->texture, args->target, args->levels, args->internalformat, args->width);; \
} while(0)
void glTextureStorage1DEXT(glTextureStorage1DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureStorage1DEXT(glTextureStorage1DEXT_PACKED *_dst glTextureStorage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureStorage1DEXT_PTR)(glTextureStorage1DEXT_ARG_EXPAND);
#endif
#ifndef glTextureStorage2DEXT_RETURN
#define glTextureStorage2DEXT_RETURN void
#define glTextureStorage2DEXT_ARG_NAMES texture, target, levels, internalformat, width, height
#define glTextureStorage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height
#define glTextureStorage2DEXT_ARG_NAMES_TAIL , texture, target, levels, internalformat, width, height
#define glTextureStorage2DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height
#define forward_glTextureStorage2DEXT(_texture, _target, _levels, _internalformat, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureStorage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureStorage2DEXT(dst, _texture, _target, _levels, _internalformat, _width, _height), NULL); \
    });
#define call_glTextureStorage2DEXT(packed, ret_v) do { \
    glTextureStorage2DEXT_PACKED *unpacked = (glTextureStorage2DEXT_PACKED *)packed; \
    glTextureStorage2DEXT_ARGS *args = (glTextureStorage2DEXT_ARGS *)&unpacked->args; \
    glTextureStorage2DEXT(args->texture, args->target, args->levels, args->internalformat, args->width, args->height);; \
} while(0)
void glTextureStorage2DEXT(glTextureStorage2DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureStorage2DEXT(glTextureStorage2DEXT_PACKED *_dst glTextureStorage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureStorage2DEXT_PTR)(glTextureStorage2DEXT_ARG_EXPAND);
#endif
#ifndef glTextureStorage2DMultisampleEXT_RETURN
#define glTextureStorage2DMultisampleEXT_RETURN void
#define glTextureStorage2DMultisampleEXT_ARG_NAMES texture, target, samples, internalformat, width, height, fixedsamplelocations
#define glTextureStorage2DMultisampleEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define glTextureStorage2DMultisampleEXT_ARG_NAMES_TAIL , texture, target, samples, internalformat, width, height, fixedsamplelocations
#define glTextureStorage2DMultisampleEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define forward_glTextureStorage2DMultisampleEXT(_texture, _target, _samples, _internalformat, _width, _height, _fixedsamplelocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureStorage2DMultisampleEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureStorage2DMultisampleEXT(dst, _texture, _target, _samples, _internalformat, _width, _height, _fixedsamplelocations), NULL); \
    });
#define call_glTextureStorage2DMultisampleEXT(packed, ret_v) do { \
    glTextureStorage2DMultisampleEXT_PACKED *unpacked = (glTextureStorage2DMultisampleEXT_PACKED *)packed; \
    glTextureStorage2DMultisampleEXT_ARGS *args = (glTextureStorage2DMultisampleEXT_ARGS *)&unpacked->args; \
    glTextureStorage2DMultisampleEXT(args->texture, args->target, args->samples, args->internalformat, args->width, args->height, args->fixedsamplelocations);; \
} while(0)
void glTextureStorage2DMultisampleEXT(glTextureStorage2DMultisampleEXT_ARG_EXPAND);
packed_call_t *pack_glTextureStorage2DMultisampleEXT(glTextureStorage2DMultisampleEXT_PACKED *_dst glTextureStorage2DMultisampleEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureStorage2DMultisampleEXT_PTR)(glTextureStorage2DMultisampleEXT_ARG_EXPAND);
#endif
#ifndef glTextureStorage3DEXT_RETURN
#define glTextureStorage3DEXT_RETURN void
#define glTextureStorage3DEXT_ARG_NAMES texture, target, levels, internalformat, width, height, depth
#define glTextureStorage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth
#define glTextureStorage3DEXT_ARG_NAMES_TAIL , texture, target, levels, internalformat, width, height, depth
#define glTextureStorage3DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth
#define forward_glTextureStorage3DEXT(_texture, _target, _levels, _internalformat, _width, _height, _depth) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureStorage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureStorage3DEXT(dst, _texture, _target, _levels, _internalformat, _width, _height, _depth), NULL); \
    });
#define call_glTextureStorage3DEXT(packed, ret_v) do { \
    glTextureStorage3DEXT_PACKED *unpacked = (glTextureStorage3DEXT_PACKED *)packed; \
    glTextureStorage3DEXT_ARGS *args = (glTextureStorage3DEXT_ARGS *)&unpacked->args; \
    glTextureStorage3DEXT(args->texture, args->target, args->levels, args->internalformat, args->width, args->height, args->depth);; \
} while(0)
void glTextureStorage3DEXT(glTextureStorage3DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureStorage3DEXT(glTextureStorage3DEXT_PACKED *_dst glTextureStorage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureStorage3DEXT_PTR)(glTextureStorage3DEXT_ARG_EXPAND);
#endif
#ifndef glTextureStorage3DMultisampleEXT_RETURN
#define glTextureStorage3DMultisampleEXT_RETURN void
#define glTextureStorage3DMultisampleEXT_ARG_NAMES texture, target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTextureStorage3DMultisampleEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define glTextureStorage3DMultisampleEXT_ARG_NAMES_TAIL , texture, target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTextureStorage3DMultisampleEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define forward_glTextureStorage3DMultisampleEXT(_texture, _target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureStorage3DMultisampleEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureStorage3DMultisampleEXT(dst, _texture, _target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations), NULL); \
    });
#define call_glTextureStorage3DMultisampleEXT(packed, ret_v) do { \
    glTextureStorage3DMultisampleEXT_PACKED *unpacked = (glTextureStorage3DMultisampleEXT_PACKED *)packed; \
    glTextureStorage3DMultisampleEXT_ARGS *args = (glTextureStorage3DMultisampleEXT_ARGS *)&unpacked->args; \
    glTextureStorage3DMultisampleEXT(args->texture, args->target, args->samples, args->internalformat, args->width, args->height, args->depth, args->fixedsamplelocations);; \
} while(0)
void glTextureStorage3DMultisampleEXT(glTextureStorage3DMultisampleEXT_ARG_EXPAND);
packed_call_t *pack_glTextureStorage3DMultisampleEXT(glTextureStorage3DMultisampleEXT_PACKED *_dst glTextureStorage3DMultisampleEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureStorage3DMultisampleEXT_PTR)(glTextureStorage3DMultisampleEXT_ARG_EXPAND);
#endif
#ifndef glTextureStorageSparseAMD_RETURN
#define glTextureStorageSparseAMD_RETURN void
#define glTextureStorageSparseAMD_ARG_NAMES texture, target, internalFormat, width, height, depth, layers, flags
#define glTextureStorageSparseAMD_ARG_EXPAND GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags
#define glTextureStorageSparseAMD_ARG_NAMES_TAIL , texture, target, internalFormat, width, height, depth, layers, flags
#define glTextureStorageSparseAMD_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags
#define forward_glTextureStorageSparseAMD(_texture, _target, _internalFormat, _width, _height, _depth, _layers, _flags) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureStorageSparseAMD_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureStorageSparseAMD(dst, _texture, _target, _internalFormat, _width, _height, _depth, _layers, _flags), NULL); \
    });
#define call_glTextureStorageSparseAMD(packed, ret_v) do { \
    glTextureStorageSparseAMD_PACKED *unpacked = (glTextureStorageSparseAMD_PACKED *)packed; \
    glTextureStorageSparseAMD_ARGS *args = (glTextureStorageSparseAMD_ARGS *)&unpacked->args; \
    glTextureStorageSparseAMD(args->texture, args->target, args->internalFormat, args->width, args->height, args->depth, args->layers, args->flags);; \
} while(0)
void glTextureStorageSparseAMD(glTextureStorageSparseAMD_ARG_EXPAND);
packed_call_t *pack_glTextureStorageSparseAMD(glTextureStorageSparseAMD_PACKED *_dst glTextureStorageSparseAMD_ARG_EXPAND_TAIL);
typedef void (*glTextureStorageSparseAMD_PTR)(glTextureStorageSparseAMD_ARG_EXPAND);
#endif
#ifndef glTextureSubImage1DEXT_RETURN
#define glTextureSubImage1DEXT_RETURN void
#define glTextureSubImage1DEXT_ARG_NAMES texture, target, level, xoffset, width, format, type, pixels
#define glTextureSubImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureSubImage1DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, width, format, type, pixels
#define glTextureSubImage1DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTextureSubImage1DEXT(_texture, _target, _level, _xoffset, _width, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureSubImage1DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureSubImage1DEXT(dst, _texture, _target, _level, _xoffset, _width, _format, _type, _pixels), NULL); \
    });
#define call_glTextureSubImage1DEXT(packed, ret_v) do { \
    glTextureSubImage1DEXT_PACKED *unpacked = (glTextureSubImage1DEXT_PACKED *)packed; \
    glTextureSubImage1DEXT_ARGS *args = (glTextureSubImage1DEXT_ARGS *)&unpacked->args; \
    glTextureSubImage1DEXT(args->texture, args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glTextureSubImage1DEXT(glTextureSubImage1DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureSubImage1DEXT(glTextureSubImage1DEXT_PACKED *_dst glTextureSubImage1DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureSubImage1DEXT_PTR)(glTextureSubImage1DEXT_ARG_EXPAND);
#endif
#ifndef glTextureSubImage2DEXT_RETURN
#define glTextureSubImage2DEXT_RETURN void
#define glTextureSubImage2DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTextureSubImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureSubImage2DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTextureSubImage2DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTextureSubImage2DEXT(_texture, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureSubImage2DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureSubImage2DEXT(dst, _texture, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels), NULL); \
    });
#define call_glTextureSubImage2DEXT(packed, ret_v) do { \
    glTextureSubImage2DEXT_PACKED *unpacked = (glTextureSubImage2DEXT_PACKED *)packed; \
    glTextureSubImage2DEXT_ARGS *args = (glTextureSubImage2DEXT_ARGS *)&unpacked->args; \
    glTextureSubImage2DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glTextureSubImage2DEXT(glTextureSubImage2DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureSubImage2DEXT(glTextureSubImage2DEXT_PACKED *_dst glTextureSubImage2DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureSubImage2DEXT_PTR)(glTextureSubImage2DEXT_ARG_EXPAND);
#endif
#ifndef glTextureSubImage3DEXT_RETURN
#define glTextureSubImage3DEXT_RETURN void
#define glTextureSubImage3DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTextureSubImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureSubImage3DEXT_ARG_NAMES_TAIL , texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTextureSubImage3DEXT_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define forward_glTextureSubImage3DEXT(_texture, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureSubImage3DEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureSubImage3DEXT(dst, _texture, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels), NULL); \
    });
#define call_glTextureSubImage3DEXT(packed, ret_v) do { \
    glTextureSubImage3DEXT_PACKED *unpacked = (glTextureSubImage3DEXT_PACKED *)packed; \
    glTextureSubImage3DEXT_ARGS *args = (glTextureSubImage3DEXT_ARGS *)&unpacked->args; \
    glTextureSubImage3DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glTextureSubImage3DEXT(glTextureSubImage3DEXT_ARG_EXPAND);
packed_call_t *pack_glTextureSubImage3DEXT(glTextureSubImage3DEXT_PACKED *_dst glTextureSubImage3DEXT_ARG_EXPAND_TAIL);
typedef void (*glTextureSubImage3DEXT_PTR)(glTextureSubImage3DEXT_ARG_EXPAND);
#endif
#ifndef glTextureView_RETURN
#define glTextureView_RETURN void
#define glTextureView_ARG_NAMES texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers
#define glTextureView_ARG_EXPAND GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers
#define glTextureView_ARG_NAMES_TAIL , texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers
#define glTextureView_ARG_EXPAND_TAIL , GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers
#define forward_glTextureView(_texture, _target, _origtexture, _internalformat, _minlevel, _numlevels, _minlayer, _numlayers) \
    ({ \
        void *dst = remote_dma(sizeof(glTextureView_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTextureView(dst, _texture, _target, _origtexture, _internalformat, _minlevel, _numlevels, _minlayer, _numlayers), NULL); \
    });
#define call_glTextureView(packed, ret_v) do { \
    glTextureView_PACKED *unpacked = (glTextureView_PACKED *)packed; \
    glTextureView_ARGS *args = (glTextureView_ARGS *)&unpacked->args; \
    glTextureView(args->texture, args->target, args->origtexture, args->internalformat, args->minlevel, args->numlevels, args->minlayer, args->numlayers);; \
} while(0)
void glTextureView(glTextureView_ARG_EXPAND);
packed_call_t *pack_glTextureView(glTextureView_PACKED *_dst glTextureView_ARG_EXPAND_TAIL);
typedef void (*glTextureView_PTR)(glTextureView_ARG_EXPAND);
#endif
#ifndef glTrackMatrixNV_RETURN
#define glTrackMatrixNV_RETURN void
#define glTrackMatrixNV_ARG_NAMES target, address, matrix, transform
#define glTrackMatrixNV_ARG_EXPAND GLenum target, GLuint address, GLenum matrix, GLenum transform
#define glTrackMatrixNV_ARG_NAMES_TAIL , target, address, matrix, transform
#define glTrackMatrixNV_ARG_EXPAND_TAIL , GLenum target, GLuint address, GLenum matrix, GLenum transform
#define forward_glTrackMatrixNV(_target, _address, _matrix, _transform) \
    ({ \
        void *dst = remote_dma(sizeof(glTrackMatrixNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTrackMatrixNV(dst, _target, _address, _matrix, _transform), NULL); \
    });
#define call_glTrackMatrixNV(packed, ret_v) do { \
    glTrackMatrixNV_PACKED *unpacked = (glTrackMatrixNV_PACKED *)packed; \
    glTrackMatrixNV_ARGS *args = (glTrackMatrixNV_ARGS *)&unpacked->args; \
    glTrackMatrixNV(args->target, args->address, args->matrix, args->transform);; \
} while(0)
void glTrackMatrixNV(glTrackMatrixNV_ARG_EXPAND);
packed_call_t *pack_glTrackMatrixNV(glTrackMatrixNV_PACKED *_dst glTrackMatrixNV_ARG_EXPAND_TAIL);
typedef void (*glTrackMatrixNV_PTR)(glTrackMatrixNV_ARG_EXPAND);
#endif
#ifndef glTransformFeedbackAttribsNV_RETURN
#define glTransformFeedbackAttribsNV_RETURN void
#define glTransformFeedbackAttribsNV_ARG_NAMES count, attribs, bufferMode
#define glTransformFeedbackAttribsNV_ARG_EXPAND GLsizei count, const GLint * attribs, GLenum bufferMode
#define glTransformFeedbackAttribsNV_ARG_NAMES_TAIL , count, attribs, bufferMode
#define glTransformFeedbackAttribsNV_ARG_EXPAND_TAIL , GLsizei count, const GLint * attribs, GLenum bufferMode
#define forward_glTransformFeedbackAttribsNV(_count, _attribs, _bufferMode) \
    ({ \
        void *dst = remote_dma(sizeof(glTransformFeedbackAttribsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTransformFeedbackAttribsNV(dst, _count, _attribs, _bufferMode), NULL); \
    });
#define call_glTransformFeedbackAttribsNV(packed, ret_v) do { \
    glTransformFeedbackAttribsNV_PACKED *unpacked = (glTransformFeedbackAttribsNV_PACKED *)packed; \
    glTransformFeedbackAttribsNV_ARGS *args = (glTransformFeedbackAttribsNV_ARGS *)&unpacked->args; \
    glTransformFeedbackAttribsNV(args->count, args->attribs, args->bufferMode);; \
} while(0)
void glTransformFeedbackAttribsNV(glTransformFeedbackAttribsNV_ARG_EXPAND);
packed_call_t *pack_glTransformFeedbackAttribsNV(glTransformFeedbackAttribsNV_PACKED *_dst glTransformFeedbackAttribsNV_ARG_EXPAND_TAIL);
typedef void (*glTransformFeedbackAttribsNV_PTR)(glTransformFeedbackAttribsNV_ARG_EXPAND);
#endif
#ifndef glTransformFeedbackStreamAttribsNV_RETURN
#define glTransformFeedbackStreamAttribsNV_RETURN void
#define glTransformFeedbackStreamAttribsNV_ARG_NAMES count, attribs, nbuffers, bufstreams, bufferMode
#define glTransformFeedbackStreamAttribsNV_ARG_EXPAND GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode
#define glTransformFeedbackStreamAttribsNV_ARG_NAMES_TAIL , count, attribs, nbuffers, bufstreams, bufferMode
#define glTransformFeedbackStreamAttribsNV_ARG_EXPAND_TAIL , GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode
#define forward_glTransformFeedbackStreamAttribsNV(_count, _attribs, _nbuffers, _bufstreams, _bufferMode) \
    ({ \
        void *dst = remote_dma(sizeof(glTransformFeedbackStreamAttribsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTransformFeedbackStreamAttribsNV(dst, _count, _attribs, _nbuffers, _bufstreams, _bufferMode), NULL); \
    });
#define call_glTransformFeedbackStreamAttribsNV(packed, ret_v) do { \
    glTransformFeedbackStreamAttribsNV_PACKED *unpacked = (glTransformFeedbackStreamAttribsNV_PACKED *)packed; \
    glTransformFeedbackStreamAttribsNV_ARGS *args = (glTransformFeedbackStreamAttribsNV_ARGS *)&unpacked->args; \
    glTransformFeedbackStreamAttribsNV(args->count, args->attribs, args->nbuffers, args->bufstreams, args->bufferMode);; \
} while(0)
void glTransformFeedbackStreamAttribsNV(glTransformFeedbackStreamAttribsNV_ARG_EXPAND);
packed_call_t *pack_glTransformFeedbackStreamAttribsNV(glTransformFeedbackStreamAttribsNV_PACKED *_dst glTransformFeedbackStreamAttribsNV_ARG_EXPAND_TAIL);
typedef void (*glTransformFeedbackStreamAttribsNV_PTR)(glTransformFeedbackStreamAttribsNV_ARG_EXPAND);
#endif
#ifndef glTransformFeedbackVaryings_RETURN
#define glTransformFeedbackVaryings_RETURN void
#define glTransformFeedbackVaryings_ARG_NAMES program, count, varyings, bufferMode
#define glTransformFeedbackVaryings_ARG_EXPAND GLuint program, GLsizei count, GLchar*const * varyings, GLenum bufferMode
#define glTransformFeedbackVaryings_ARG_NAMES_TAIL , program, count, varyings, bufferMode
#define glTransformFeedbackVaryings_ARG_EXPAND_TAIL , GLuint program, GLsizei count, GLchar*const * varyings, GLenum bufferMode
#define forward_glTransformFeedbackVaryings(_program, _count, _varyings, _bufferMode) \
    ({ \
        void *dst = remote_dma(sizeof(glTransformFeedbackVaryings_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTransformFeedbackVaryings(dst, _program, _count, _varyings, _bufferMode), NULL); \
    });
#define call_glTransformFeedbackVaryings(packed, ret_v) do { \
    glTransformFeedbackVaryings_PACKED *unpacked = (glTransformFeedbackVaryings_PACKED *)packed; \
    glTransformFeedbackVaryings_ARGS *args = (glTransformFeedbackVaryings_ARGS *)&unpacked->args; \
    glTransformFeedbackVaryings(args->program, args->count, args->varyings, args->bufferMode);; \
} while(0)
void glTransformFeedbackVaryings(glTransformFeedbackVaryings_ARG_EXPAND);
packed_call_t *pack_glTransformFeedbackVaryings(glTransformFeedbackVaryings_PACKED *_dst glTransformFeedbackVaryings_ARG_EXPAND_TAIL);
typedef void (*glTransformFeedbackVaryings_PTR)(glTransformFeedbackVaryings_ARG_EXPAND);
#endif
#ifndef glTransformFeedbackVaryingsEXT_RETURN
#define glTransformFeedbackVaryingsEXT_RETURN void
#define glTransformFeedbackVaryingsEXT_ARG_NAMES program, count, varyings, bufferMode
#define glTransformFeedbackVaryingsEXT_ARG_EXPAND GLuint program, GLsizei count, const GLchar * varyings, GLenum bufferMode
#define glTransformFeedbackVaryingsEXT_ARG_NAMES_TAIL , program, count, varyings, bufferMode
#define glTransformFeedbackVaryingsEXT_ARG_EXPAND_TAIL , GLuint program, GLsizei count, const GLchar * varyings, GLenum bufferMode
#define forward_glTransformFeedbackVaryingsEXT(_program, _count, _varyings, _bufferMode) \
    ({ \
        void *dst = remote_dma(sizeof(glTransformFeedbackVaryingsEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTransformFeedbackVaryingsEXT(dst, _program, _count, _varyings, _bufferMode), NULL); \
    });
#define call_glTransformFeedbackVaryingsEXT(packed, ret_v) do { \
    glTransformFeedbackVaryingsEXT_PACKED *unpacked = (glTransformFeedbackVaryingsEXT_PACKED *)packed; \
    glTransformFeedbackVaryingsEXT_ARGS *args = (glTransformFeedbackVaryingsEXT_ARGS *)&unpacked->args; \
    glTransformFeedbackVaryingsEXT(args->program, args->count, args->varyings, args->bufferMode);; \
} while(0)
void glTransformFeedbackVaryingsEXT(glTransformFeedbackVaryingsEXT_ARG_EXPAND);
packed_call_t *pack_glTransformFeedbackVaryingsEXT(glTransformFeedbackVaryingsEXT_PACKED *_dst glTransformFeedbackVaryingsEXT_ARG_EXPAND_TAIL);
typedef void (*glTransformFeedbackVaryingsEXT_PTR)(glTransformFeedbackVaryingsEXT_ARG_EXPAND);
#endif
#ifndef glTransformFeedbackVaryingsNV_RETURN
#define glTransformFeedbackVaryingsNV_RETURN void
#define glTransformFeedbackVaryingsNV_ARG_NAMES program, count, locations, bufferMode
#define glTransformFeedbackVaryingsNV_ARG_EXPAND GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode
#define glTransformFeedbackVaryingsNV_ARG_NAMES_TAIL , program, count, locations, bufferMode
#define glTransformFeedbackVaryingsNV_ARG_EXPAND_TAIL , GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode
#define forward_glTransformFeedbackVaryingsNV(_program, _count, _locations, _bufferMode) \
    ({ \
        void *dst = remote_dma(sizeof(glTransformFeedbackVaryingsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTransformFeedbackVaryingsNV(dst, _program, _count, _locations, _bufferMode), NULL); \
    });
#define call_glTransformFeedbackVaryingsNV(packed, ret_v) do { \
    glTransformFeedbackVaryingsNV_PACKED *unpacked = (glTransformFeedbackVaryingsNV_PACKED *)packed; \
    glTransformFeedbackVaryingsNV_ARGS *args = (glTransformFeedbackVaryingsNV_ARGS *)&unpacked->args; \
    glTransformFeedbackVaryingsNV(args->program, args->count, args->locations, args->bufferMode);; \
} while(0)
void glTransformFeedbackVaryingsNV(glTransformFeedbackVaryingsNV_ARG_EXPAND);
packed_call_t *pack_glTransformFeedbackVaryingsNV(glTransformFeedbackVaryingsNV_PACKED *_dst glTransformFeedbackVaryingsNV_ARG_EXPAND_TAIL);
typedef void (*glTransformFeedbackVaryingsNV_PTR)(glTransformFeedbackVaryingsNV_ARG_EXPAND);
#endif
#ifndef glTransformPathNV_RETURN
#define glTransformPathNV_RETURN void
#define glTransformPathNV_ARG_NAMES resultPath, srcPath, transformType, transformValues
#define glTransformPathNV_ARG_EXPAND GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues
#define glTransformPathNV_ARG_NAMES_TAIL , resultPath, srcPath, transformType, transformValues
#define glTransformPathNV_ARG_EXPAND_TAIL , GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues
#define forward_glTransformPathNV(_resultPath, _srcPath, _transformType, _transformValues) \
    ({ \
        void *dst = remote_dma(sizeof(glTransformPathNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTransformPathNV(dst, _resultPath, _srcPath, _transformType, _transformValues), NULL); \
    });
#define call_glTransformPathNV(packed, ret_v) do { \
    glTransformPathNV_PACKED *unpacked = (glTransformPathNV_PACKED *)packed; \
    glTransformPathNV_ARGS *args = (glTransformPathNV_ARGS *)&unpacked->args; \
    glTransformPathNV(args->resultPath, args->srcPath, args->transformType, args->transformValues);; \
} while(0)
void glTransformPathNV(glTransformPathNV_ARG_EXPAND);
packed_call_t *pack_glTransformPathNV(glTransformPathNV_PACKED *_dst glTransformPathNV_ARG_EXPAND_TAIL);
typedef void (*glTransformPathNV_PTR)(glTransformPathNV_ARG_EXPAND);
#endif
#ifndef glTranslated_RETURN
#define glTranslated_RETURN void
#define glTranslated_ARG_NAMES x, y, z
#define glTranslated_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glTranslated_ARG_NAMES_TAIL , x, y, z
#define glTranslated_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z
#define forward_glTranslated(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTranslated_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTranslated(dst, _x, _y, _z), NULL); \
    });
#define call_glTranslated(packed, ret_v) do { \
    glTranslated_PACKED *unpacked = (glTranslated_PACKED *)packed; \
    glTranslated_ARGS *args = (glTranslated_ARGS *)&unpacked->args; \
    glTranslated(args->x, args->y, args->z);; \
} while(0)
void glTranslated(glTranslated_ARG_EXPAND);
packed_call_t *pack_glTranslated(glTranslated_PACKED *_dst glTranslated_ARG_EXPAND_TAIL);
typedef void (*glTranslated_PTR)(glTranslated_ARG_EXPAND);
#endif
#ifndef glTranslatef_RETURN
#define glTranslatef_RETURN void
#define glTranslatef_ARG_NAMES x, y, z
#define glTranslatef_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glTranslatef_ARG_NAMES_TAIL , x, y, z
#define glTranslatef_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z
#define forward_glTranslatef(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTranslatef_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTranslatef(dst, _x, _y, _z), NULL); \
    });
#define call_glTranslatef(packed, ret_v) do { \
    glTranslatef_PACKED *unpacked = (glTranslatef_PACKED *)packed; \
    glTranslatef_ARGS *args = (glTranslatef_ARGS *)&unpacked->args; \
    glTranslatef(args->x, args->y, args->z);; \
} while(0)
void glTranslatef(glTranslatef_ARG_EXPAND);
packed_call_t *pack_glTranslatef(glTranslatef_PACKED *_dst glTranslatef_ARG_EXPAND_TAIL);
typedef void (*glTranslatef_PTR)(glTranslatef_ARG_EXPAND);
#endif
#ifndef glTranslatexOES_RETURN
#define glTranslatexOES_RETURN void
#define glTranslatexOES_ARG_NAMES x, y, z
#define glTranslatexOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glTranslatexOES_ARG_NAMES_TAIL , x, y, z
#define glTranslatexOES_ARG_EXPAND_TAIL , GLfixed x, GLfixed y, GLfixed z
#define forward_glTranslatexOES(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glTranslatexOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glTranslatexOES(dst, _x, _y, _z), NULL); \
    });
#define call_glTranslatexOES(packed, ret_v) do { \
    glTranslatexOES_PACKED *unpacked = (glTranslatexOES_PACKED *)packed; \
    glTranslatexOES_ARGS *args = (glTranslatexOES_ARGS *)&unpacked->args; \
    glTranslatexOES(args->x, args->y, args->z);; \
} while(0)
void glTranslatexOES(glTranslatexOES_ARG_EXPAND);
packed_call_t *pack_glTranslatexOES(glTranslatexOES_PACKED *_dst glTranslatexOES_ARG_EXPAND_TAIL);
typedef void (*glTranslatexOES_PTR)(glTranslatexOES_ARG_EXPAND);
#endif
#ifndef glUniform1d_RETURN
#define glUniform1d_RETURN void
#define glUniform1d_ARG_NAMES location, x
#define glUniform1d_ARG_EXPAND GLint location, GLdouble x
#define glUniform1d_ARG_NAMES_TAIL , location, x
#define glUniform1d_ARG_EXPAND_TAIL , GLint location, GLdouble x
#define forward_glUniform1d(_location, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1d(dst, _location, _x), NULL); \
    });
#define call_glUniform1d(packed, ret_v) do { \
    glUniform1d_PACKED *unpacked = (glUniform1d_PACKED *)packed; \
    glUniform1d_ARGS *args = (glUniform1d_ARGS *)&unpacked->args; \
    glUniform1d(args->location, args->x);; \
} while(0)
void glUniform1d(glUniform1d_ARG_EXPAND);
packed_call_t *pack_glUniform1d(glUniform1d_PACKED *_dst glUniform1d_ARG_EXPAND_TAIL);
typedef void (*glUniform1d_PTR)(glUniform1d_ARG_EXPAND);
#endif
#ifndef glUniform1dv_RETURN
#define glUniform1dv_RETURN void
#define glUniform1dv_ARG_NAMES location, count, value
#define glUniform1dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform1dv_ARG_NAMES_TAIL , location, count, value
#define glUniform1dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLdouble * value
#define forward_glUniform1dv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1dv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1dv(packed, ret_v) do { \
    glUniform1dv_PACKED *unpacked = (glUniform1dv_PACKED *)packed; \
    glUniform1dv_ARGS *args = (glUniform1dv_ARGS *)&unpacked->args; \
    glUniform1dv(args->location, args->count, args->value);; \
} while(0)
void glUniform1dv(glUniform1dv_ARG_EXPAND);
packed_call_t *pack_glUniform1dv(glUniform1dv_PACKED *_dst glUniform1dv_ARG_EXPAND_TAIL);
typedef void (*glUniform1dv_PTR)(glUniform1dv_ARG_EXPAND);
#endif
#ifndef glUniform1f_RETURN
#define glUniform1f_RETURN void
#define glUniform1f_ARG_NAMES location, v0
#define glUniform1f_ARG_EXPAND GLint location, GLfloat v0
#define glUniform1f_ARG_NAMES_TAIL , location, v0
#define glUniform1f_ARG_EXPAND_TAIL , GLint location, GLfloat v0
#define forward_glUniform1f(_location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1f(dst, _location, _v0), NULL); \
    });
#define call_glUniform1f(packed, ret_v) do { \
    glUniform1f_PACKED *unpacked = (glUniform1f_PACKED *)packed; \
    glUniform1f_ARGS *args = (glUniform1f_ARGS *)&unpacked->args; \
    glUniform1f(args->location, args->v0);; \
} while(0)
void glUniform1f(glUniform1f_ARG_EXPAND);
packed_call_t *pack_glUniform1f(glUniform1f_PACKED *_dst glUniform1f_ARG_EXPAND_TAIL);
typedef void (*glUniform1f_PTR)(glUniform1f_ARG_EXPAND);
#endif
#ifndef glUniform1fARB_RETURN
#define glUniform1fARB_RETURN void
#define glUniform1fARB_ARG_NAMES location, v0
#define glUniform1fARB_ARG_EXPAND GLint location, GLfloat v0
#define glUniform1fARB_ARG_NAMES_TAIL , location, v0
#define glUniform1fARB_ARG_EXPAND_TAIL , GLint location, GLfloat v0
#define forward_glUniform1fARB(_location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1fARB(dst, _location, _v0), NULL); \
    });
#define call_glUniform1fARB(packed, ret_v) do { \
    glUniform1fARB_PACKED *unpacked = (glUniform1fARB_PACKED *)packed; \
    glUniform1fARB_ARGS *args = (glUniform1fARB_ARGS *)&unpacked->args; \
    glUniform1fARB(args->location, args->v0);; \
} while(0)
void glUniform1fARB(glUniform1fARB_ARG_EXPAND);
packed_call_t *pack_glUniform1fARB(glUniform1fARB_PACKED *_dst glUniform1fARB_ARG_EXPAND_TAIL);
typedef void (*glUniform1fARB_PTR)(glUniform1fARB_ARG_EXPAND);
#endif
#ifndef glUniform1fv_RETURN
#define glUniform1fv_RETURN void
#define glUniform1fv_ARG_NAMES location, count, value
#define glUniform1fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform1fv_ARG_NAMES_TAIL , location, count, value
#define glUniform1fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform1fv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1fv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1fv(packed, ret_v) do { \
    glUniform1fv_PACKED *unpacked = (glUniform1fv_PACKED *)packed; \
    glUniform1fv_ARGS *args = (glUniform1fv_ARGS *)&unpacked->args; \
    glUniform1fv(args->location, args->count, args->value);; \
} while(0)
void glUniform1fv(glUniform1fv_ARG_EXPAND);
packed_call_t *pack_glUniform1fv(glUniform1fv_PACKED *_dst glUniform1fv_ARG_EXPAND_TAIL);
typedef void (*glUniform1fv_PTR)(glUniform1fv_ARG_EXPAND);
#endif
#ifndef glUniform1fvARB_RETURN
#define glUniform1fvARB_RETURN void
#define glUniform1fvARB_ARG_NAMES location, count, value
#define glUniform1fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform1fvARB_ARG_NAMES_TAIL , location, count, value
#define glUniform1fvARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform1fvARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1fvARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1fvARB(packed, ret_v) do { \
    glUniform1fvARB_PACKED *unpacked = (glUniform1fvARB_PACKED *)packed; \
    glUniform1fvARB_ARGS *args = (glUniform1fvARB_ARGS *)&unpacked->args; \
    glUniform1fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform1fvARB(glUniform1fvARB_ARG_EXPAND);
packed_call_t *pack_glUniform1fvARB(glUniform1fvARB_PACKED *_dst glUniform1fvARB_ARG_EXPAND_TAIL);
typedef void (*glUniform1fvARB_PTR)(glUniform1fvARB_ARG_EXPAND);
#endif
#ifndef glUniform1i_RETURN
#define glUniform1i_RETURN void
#define glUniform1i_ARG_NAMES location, v0
#define glUniform1i_ARG_EXPAND GLint location, GLint v0
#define glUniform1i_ARG_NAMES_TAIL , location, v0
#define glUniform1i_ARG_EXPAND_TAIL , GLint location, GLint v0
#define forward_glUniform1i(_location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1i(dst, _location, _v0), NULL); \
    });
#define call_glUniform1i(packed, ret_v) do { \
    glUniform1i_PACKED *unpacked = (glUniform1i_PACKED *)packed; \
    glUniform1i_ARGS *args = (glUniform1i_ARGS *)&unpacked->args; \
    glUniform1i(args->location, args->v0);; \
} while(0)
void glUniform1i(glUniform1i_ARG_EXPAND);
packed_call_t *pack_glUniform1i(glUniform1i_PACKED *_dst glUniform1i_ARG_EXPAND_TAIL);
typedef void (*glUniform1i_PTR)(glUniform1i_ARG_EXPAND);
#endif
#ifndef glUniform1i64NV_RETURN
#define glUniform1i64NV_RETURN void
#define glUniform1i64NV_ARG_NAMES location, x
#define glUniform1i64NV_ARG_EXPAND GLint location, GLint64EXT x
#define glUniform1i64NV_ARG_NAMES_TAIL , location, x
#define glUniform1i64NV_ARG_EXPAND_TAIL , GLint location, GLint64EXT x
#define forward_glUniform1i64NV(_location, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1i64NV(dst, _location, _x), NULL); \
    });
#define call_glUniform1i64NV(packed, ret_v) do { \
    glUniform1i64NV_PACKED *unpacked = (glUniform1i64NV_PACKED *)packed; \
    glUniform1i64NV_ARGS *args = (glUniform1i64NV_ARGS *)&unpacked->args; \
    glUniform1i64NV(args->location, args->x);; \
} while(0)
void glUniform1i64NV(glUniform1i64NV_ARG_EXPAND);
packed_call_t *pack_glUniform1i64NV(glUniform1i64NV_PACKED *_dst glUniform1i64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform1i64NV_PTR)(glUniform1i64NV_ARG_EXPAND);
#endif
#ifndef glUniform1i64vNV_RETURN
#define glUniform1i64vNV_RETURN void
#define glUniform1i64vNV_ARG_NAMES location, count, value
#define glUniform1i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform1i64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform1i64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint64EXT * value
#define forward_glUniform1i64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1i64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1i64vNV(packed, ret_v) do { \
    glUniform1i64vNV_PACKED *unpacked = (glUniform1i64vNV_PACKED *)packed; \
    glUniform1i64vNV_ARGS *args = (glUniform1i64vNV_ARGS *)&unpacked->args; \
    glUniform1i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform1i64vNV(glUniform1i64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform1i64vNV(glUniform1i64vNV_PACKED *_dst glUniform1i64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform1i64vNV_PTR)(glUniform1i64vNV_ARG_EXPAND);
#endif
#ifndef glUniform1iARB_RETURN
#define glUniform1iARB_RETURN void
#define glUniform1iARB_ARG_NAMES location, v0
#define glUniform1iARB_ARG_EXPAND GLint location, GLint v0
#define glUniform1iARB_ARG_NAMES_TAIL , location, v0
#define glUniform1iARB_ARG_EXPAND_TAIL , GLint location, GLint v0
#define forward_glUniform1iARB(_location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1iARB(dst, _location, _v0), NULL); \
    });
#define call_glUniform1iARB(packed, ret_v) do { \
    glUniform1iARB_PACKED *unpacked = (glUniform1iARB_PACKED *)packed; \
    glUniform1iARB_ARGS *args = (glUniform1iARB_ARGS *)&unpacked->args; \
    glUniform1iARB(args->location, args->v0);; \
} while(0)
void glUniform1iARB(glUniform1iARB_ARG_EXPAND);
packed_call_t *pack_glUniform1iARB(glUniform1iARB_PACKED *_dst glUniform1iARB_ARG_EXPAND_TAIL);
typedef void (*glUniform1iARB_PTR)(glUniform1iARB_ARG_EXPAND);
#endif
#ifndef glUniform1iv_RETURN
#define glUniform1iv_RETURN void
#define glUniform1iv_ARG_NAMES location, count, value
#define glUniform1iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform1iv_ARG_NAMES_TAIL , location, count, value
#define glUniform1iv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform1iv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1iv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1iv(packed, ret_v) do { \
    glUniform1iv_PACKED *unpacked = (glUniform1iv_PACKED *)packed; \
    glUniform1iv_ARGS *args = (glUniform1iv_ARGS *)&unpacked->args; \
    glUniform1iv(args->location, args->count, args->value);; \
} while(0)
void glUniform1iv(glUniform1iv_ARG_EXPAND);
packed_call_t *pack_glUniform1iv(glUniform1iv_PACKED *_dst glUniform1iv_ARG_EXPAND_TAIL);
typedef void (*glUniform1iv_PTR)(glUniform1iv_ARG_EXPAND);
#endif
#ifndef glUniform1ivARB_RETURN
#define glUniform1ivARB_RETURN void
#define glUniform1ivARB_ARG_NAMES location, count, value
#define glUniform1ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform1ivARB_ARG_NAMES_TAIL , location, count, value
#define glUniform1ivARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform1ivARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1ivARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1ivARB(packed, ret_v) do { \
    glUniform1ivARB_PACKED *unpacked = (glUniform1ivARB_PACKED *)packed; \
    glUniform1ivARB_ARGS *args = (glUniform1ivARB_ARGS *)&unpacked->args; \
    glUniform1ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform1ivARB(glUniform1ivARB_ARG_EXPAND);
packed_call_t *pack_glUniform1ivARB(glUniform1ivARB_PACKED *_dst glUniform1ivARB_ARG_EXPAND_TAIL);
typedef void (*glUniform1ivARB_PTR)(glUniform1ivARB_ARG_EXPAND);
#endif
#ifndef glUniform1ui_RETURN
#define glUniform1ui_RETURN void
#define glUniform1ui_ARG_NAMES location, v0
#define glUniform1ui_ARG_EXPAND GLint location, GLuint v0
#define glUniform1ui_ARG_NAMES_TAIL , location, v0
#define glUniform1ui_ARG_EXPAND_TAIL , GLint location, GLuint v0
#define forward_glUniform1ui(_location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1ui(dst, _location, _v0), NULL); \
    });
#define call_glUniform1ui(packed, ret_v) do { \
    glUniform1ui_PACKED *unpacked = (glUniform1ui_PACKED *)packed; \
    glUniform1ui_ARGS *args = (glUniform1ui_ARGS *)&unpacked->args; \
    glUniform1ui(args->location, args->v0);; \
} while(0)
void glUniform1ui(glUniform1ui_ARG_EXPAND);
packed_call_t *pack_glUniform1ui(glUniform1ui_PACKED *_dst glUniform1ui_ARG_EXPAND_TAIL);
typedef void (*glUniform1ui_PTR)(glUniform1ui_ARG_EXPAND);
#endif
#ifndef glUniform1ui64NV_RETURN
#define glUniform1ui64NV_RETURN void
#define glUniform1ui64NV_ARG_NAMES location, x
#define glUniform1ui64NV_ARG_EXPAND GLint location, GLuint64EXT x
#define glUniform1ui64NV_ARG_NAMES_TAIL , location, x
#define glUniform1ui64NV_ARG_EXPAND_TAIL , GLint location, GLuint64EXT x
#define forward_glUniform1ui64NV(_location, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1ui64NV(dst, _location, _x), NULL); \
    });
#define call_glUniform1ui64NV(packed, ret_v) do { \
    glUniform1ui64NV_PACKED *unpacked = (glUniform1ui64NV_PACKED *)packed; \
    glUniform1ui64NV_ARGS *args = (glUniform1ui64NV_ARGS *)&unpacked->args; \
    glUniform1ui64NV(args->location, args->x);; \
} while(0)
void glUniform1ui64NV(glUniform1ui64NV_ARG_EXPAND);
packed_call_t *pack_glUniform1ui64NV(glUniform1ui64NV_PACKED *_dst glUniform1ui64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform1ui64NV_PTR)(glUniform1ui64NV_ARG_EXPAND);
#endif
#ifndef glUniform1ui64vNV_RETURN
#define glUniform1ui64vNV_RETURN void
#define glUniform1ui64vNV_ARG_NAMES location, count, value
#define glUniform1ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform1ui64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform1ui64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glUniform1ui64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1ui64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1ui64vNV(packed, ret_v) do { \
    glUniform1ui64vNV_PACKED *unpacked = (glUniform1ui64vNV_PACKED *)packed; \
    glUniform1ui64vNV_ARGS *args = (glUniform1ui64vNV_ARGS *)&unpacked->args; \
    glUniform1ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform1ui64vNV(glUniform1ui64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform1ui64vNV(glUniform1ui64vNV_PACKED *_dst glUniform1ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform1ui64vNV_PTR)(glUniform1ui64vNV_ARG_EXPAND);
#endif
#ifndef glUniform1uiEXT_RETURN
#define glUniform1uiEXT_RETURN void
#define glUniform1uiEXT_ARG_NAMES location, v0
#define glUniform1uiEXT_ARG_EXPAND GLint location, GLuint v0
#define glUniform1uiEXT_ARG_NAMES_TAIL , location, v0
#define glUniform1uiEXT_ARG_EXPAND_TAIL , GLint location, GLuint v0
#define forward_glUniform1uiEXT(_location, _v0) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1uiEXT(dst, _location, _v0), NULL); \
    });
#define call_glUniform1uiEXT(packed, ret_v) do { \
    glUniform1uiEXT_PACKED *unpacked = (glUniform1uiEXT_PACKED *)packed; \
    glUniform1uiEXT_ARGS *args = (glUniform1uiEXT_ARGS *)&unpacked->args; \
    glUniform1uiEXT(args->location, args->v0);; \
} while(0)
void glUniform1uiEXT(glUniform1uiEXT_ARG_EXPAND);
packed_call_t *pack_glUniform1uiEXT(glUniform1uiEXT_PACKED *_dst glUniform1uiEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform1uiEXT_PTR)(glUniform1uiEXT_ARG_EXPAND);
#endif
#ifndef glUniform1uiv_RETURN
#define glUniform1uiv_RETURN void
#define glUniform1uiv_ARG_NAMES location, count, value
#define glUniform1uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform1uiv_ARG_NAMES_TAIL , location, count, value
#define glUniform1uiv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform1uiv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1uiv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1uiv(packed, ret_v) do { \
    glUniform1uiv_PACKED *unpacked = (glUniform1uiv_PACKED *)packed; \
    glUniform1uiv_ARGS *args = (glUniform1uiv_ARGS *)&unpacked->args; \
    glUniform1uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform1uiv(glUniform1uiv_ARG_EXPAND);
packed_call_t *pack_glUniform1uiv(glUniform1uiv_PACKED *_dst glUniform1uiv_ARG_EXPAND_TAIL);
typedef void (*glUniform1uiv_PTR)(glUniform1uiv_ARG_EXPAND);
#endif
#ifndef glUniform1uivEXT_RETURN
#define glUniform1uivEXT_RETURN void
#define glUniform1uivEXT_ARG_NAMES location, count, value
#define glUniform1uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform1uivEXT_ARG_NAMES_TAIL , location, count, value
#define glUniform1uivEXT_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform1uivEXT(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform1uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform1uivEXT(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform1uivEXT(packed, ret_v) do { \
    glUniform1uivEXT_PACKED *unpacked = (glUniform1uivEXT_PACKED *)packed; \
    glUniform1uivEXT_ARGS *args = (glUniform1uivEXT_ARGS *)&unpacked->args; \
    glUniform1uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform1uivEXT(glUniform1uivEXT_ARG_EXPAND);
packed_call_t *pack_glUniform1uivEXT(glUniform1uivEXT_PACKED *_dst glUniform1uivEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform1uivEXT_PTR)(glUniform1uivEXT_ARG_EXPAND);
#endif
#ifndef glUniform2d_RETURN
#define glUniform2d_RETURN void
#define glUniform2d_ARG_NAMES location, x, y
#define glUniform2d_ARG_EXPAND GLint location, GLdouble x, GLdouble y
#define glUniform2d_ARG_NAMES_TAIL , location, x, y
#define glUniform2d_ARG_EXPAND_TAIL , GLint location, GLdouble x, GLdouble y
#define forward_glUniform2d(_location, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2d(dst, _location, _x, _y), NULL); \
    });
#define call_glUniform2d(packed, ret_v) do { \
    glUniform2d_PACKED *unpacked = (glUniform2d_PACKED *)packed; \
    glUniform2d_ARGS *args = (glUniform2d_ARGS *)&unpacked->args; \
    glUniform2d(args->location, args->x, args->y);; \
} while(0)
void glUniform2d(glUniform2d_ARG_EXPAND);
packed_call_t *pack_glUniform2d(glUniform2d_PACKED *_dst glUniform2d_ARG_EXPAND_TAIL);
typedef void (*glUniform2d_PTR)(glUniform2d_ARG_EXPAND);
#endif
#ifndef glUniform2dv_RETURN
#define glUniform2dv_RETURN void
#define glUniform2dv_ARG_NAMES location, count, value
#define glUniform2dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform2dv_ARG_NAMES_TAIL , location, count, value
#define glUniform2dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLdouble * value
#define forward_glUniform2dv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2dv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2dv(packed, ret_v) do { \
    glUniform2dv_PACKED *unpacked = (glUniform2dv_PACKED *)packed; \
    glUniform2dv_ARGS *args = (glUniform2dv_ARGS *)&unpacked->args; \
    glUniform2dv(args->location, args->count, args->value);; \
} while(0)
void glUniform2dv(glUniform2dv_ARG_EXPAND);
packed_call_t *pack_glUniform2dv(glUniform2dv_PACKED *_dst glUniform2dv_ARG_EXPAND_TAIL);
typedef void (*glUniform2dv_PTR)(glUniform2dv_ARG_EXPAND);
#endif
#ifndef glUniform2f_RETURN
#define glUniform2f_RETURN void
#define glUniform2f_ARG_NAMES location, v0, v1
#define glUniform2f_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1
#define glUniform2f_ARG_NAMES_TAIL , location, v0, v1
#define glUniform2f_ARG_EXPAND_TAIL , GLint location, GLfloat v0, GLfloat v1
#define forward_glUniform2f(_location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2f(dst, _location, _v0, _v1), NULL); \
    });
#define call_glUniform2f(packed, ret_v) do { \
    glUniform2f_PACKED *unpacked = (glUniform2f_PACKED *)packed; \
    glUniform2f_ARGS *args = (glUniform2f_ARGS *)&unpacked->args; \
    glUniform2f(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2f(glUniform2f_ARG_EXPAND);
packed_call_t *pack_glUniform2f(glUniform2f_PACKED *_dst glUniform2f_ARG_EXPAND_TAIL);
typedef void (*glUniform2f_PTR)(glUniform2f_ARG_EXPAND);
#endif
#ifndef glUniform2fARB_RETURN
#define glUniform2fARB_RETURN void
#define glUniform2fARB_ARG_NAMES location, v0, v1
#define glUniform2fARB_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1
#define glUniform2fARB_ARG_NAMES_TAIL , location, v0, v1
#define glUniform2fARB_ARG_EXPAND_TAIL , GLint location, GLfloat v0, GLfloat v1
#define forward_glUniform2fARB(_location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2fARB(dst, _location, _v0, _v1), NULL); \
    });
#define call_glUniform2fARB(packed, ret_v) do { \
    glUniform2fARB_PACKED *unpacked = (glUniform2fARB_PACKED *)packed; \
    glUniform2fARB_ARGS *args = (glUniform2fARB_ARGS *)&unpacked->args; \
    glUniform2fARB(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2fARB(glUniform2fARB_ARG_EXPAND);
packed_call_t *pack_glUniform2fARB(glUniform2fARB_PACKED *_dst glUniform2fARB_ARG_EXPAND_TAIL);
typedef void (*glUniform2fARB_PTR)(glUniform2fARB_ARG_EXPAND);
#endif
#ifndef glUniform2fv_RETURN
#define glUniform2fv_RETURN void
#define glUniform2fv_ARG_NAMES location, count, value
#define glUniform2fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform2fv_ARG_NAMES_TAIL , location, count, value
#define glUniform2fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform2fv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2fv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2fv(packed, ret_v) do { \
    glUniform2fv_PACKED *unpacked = (glUniform2fv_PACKED *)packed; \
    glUniform2fv_ARGS *args = (glUniform2fv_ARGS *)&unpacked->args; \
    glUniform2fv(args->location, args->count, args->value);; \
} while(0)
void glUniform2fv(glUniform2fv_ARG_EXPAND);
packed_call_t *pack_glUniform2fv(glUniform2fv_PACKED *_dst glUniform2fv_ARG_EXPAND_TAIL);
typedef void (*glUniform2fv_PTR)(glUniform2fv_ARG_EXPAND);
#endif
#ifndef glUniform2fvARB_RETURN
#define glUniform2fvARB_RETURN void
#define glUniform2fvARB_ARG_NAMES location, count, value
#define glUniform2fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform2fvARB_ARG_NAMES_TAIL , location, count, value
#define glUniform2fvARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform2fvARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2fvARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2fvARB(packed, ret_v) do { \
    glUniform2fvARB_PACKED *unpacked = (glUniform2fvARB_PACKED *)packed; \
    glUniform2fvARB_ARGS *args = (glUniform2fvARB_ARGS *)&unpacked->args; \
    glUniform2fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform2fvARB(glUniform2fvARB_ARG_EXPAND);
packed_call_t *pack_glUniform2fvARB(glUniform2fvARB_PACKED *_dst glUniform2fvARB_ARG_EXPAND_TAIL);
typedef void (*glUniform2fvARB_PTR)(glUniform2fvARB_ARG_EXPAND);
#endif
#ifndef glUniform2i_RETURN
#define glUniform2i_RETURN void
#define glUniform2i_ARG_NAMES location, v0, v1
#define glUniform2i_ARG_EXPAND GLint location, GLint v0, GLint v1
#define glUniform2i_ARG_NAMES_TAIL , location, v0, v1
#define glUniform2i_ARG_EXPAND_TAIL , GLint location, GLint v0, GLint v1
#define forward_glUniform2i(_location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2i(dst, _location, _v0, _v1), NULL); \
    });
#define call_glUniform2i(packed, ret_v) do { \
    glUniform2i_PACKED *unpacked = (glUniform2i_PACKED *)packed; \
    glUniform2i_ARGS *args = (glUniform2i_ARGS *)&unpacked->args; \
    glUniform2i(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2i(glUniform2i_ARG_EXPAND);
packed_call_t *pack_glUniform2i(glUniform2i_PACKED *_dst glUniform2i_ARG_EXPAND_TAIL);
typedef void (*glUniform2i_PTR)(glUniform2i_ARG_EXPAND);
#endif
#ifndef glUniform2i64NV_RETURN
#define glUniform2i64NV_RETURN void
#define glUniform2i64NV_ARG_NAMES location, x, y
#define glUniform2i64NV_ARG_EXPAND GLint location, GLint64EXT x, GLint64EXT y
#define glUniform2i64NV_ARG_NAMES_TAIL , location, x, y
#define glUniform2i64NV_ARG_EXPAND_TAIL , GLint location, GLint64EXT x, GLint64EXT y
#define forward_glUniform2i64NV(_location, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2i64NV(dst, _location, _x, _y), NULL); \
    });
#define call_glUniform2i64NV(packed, ret_v) do { \
    glUniform2i64NV_PACKED *unpacked = (glUniform2i64NV_PACKED *)packed; \
    glUniform2i64NV_ARGS *args = (glUniform2i64NV_ARGS *)&unpacked->args; \
    glUniform2i64NV(args->location, args->x, args->y);; \
} while(0)
void glUniform2i64NV(glUniform2i64NV_ARG_EXPAND);
packed_call_t *pack_glUniform2i64NV(glUniform2i64NV_PACKED *_dst glUniform2i64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform2i64NV_PTR)(glUniform2i64NV_ARG_EXPAND);
#endif
#ifndef glUniform2i64vNV_RETURN
#define glUniform2i64vNV_RETURN void
#define glUniform2i64vNV_ARG_NAMES location, count, value
#define glUniform2i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform2i64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform2i64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint64EXT * value
#define forward_glUniform2i64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2i64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2i64vNV(packed, ret_v) do { \
    glUniform2i64vNV_PACKED *unpacked = (glUniform2i64vNV_PACKED *)packed; \
    glUniform2i64vNV_ARGS *args = (glUniform2i64vNV_ARGS *)&unpacked->args; \
    glUniform2i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform2i64vNV(glUniform2i64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform2i64vNV(glUniform2i64vNV_PACKED *_dst glUniform2i64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform2i64vNV_PTR)(glUniform2i64vNV_ARG_EXPAND);
#endif
#ifndef glUniform2iARB_RETURN
#define glUniform2iARB_RETURN void
#define glUniform2iARB_ARG_NAMES location, v0, v1
#define glUniform2iARB_ARG_EXPAND GLint location, GLint v0, GLint v1
#define glUniform2iARB_ARG_NAMES_TAIL , location, v0, v1
#define glUniform2iARB_ARG_EXPAND_TAIL , GLint location, GLint v0, GLint v1
#define forward_glUniform2iARB(_location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2iARB(dst, _location, _v0, _v1), NULL); \
    });
#define call_glUniform2iARB(packed, ret_v) do { \
    glUniform2iARB_PACKED *unpacked = (glUniform2iARB_PACKED *)packed; \
    glUniform2iARB_ARGS *args = (glUniform2iARB_ARGS *)&unpacked->args; \
    glUniform2iARB(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2iARB(glUniform2iARB_ARG_EXPAND);
packed_call_t *pack_glUniform2iARB(glUniform2iARB_PACKED *_dst glUniform2iARB_ARG_EXPAND_TAIL);
typedef void (*glUniform2iARB_PTR)(glUniform2iARB_ARG_EXPAND);
#endif
#ifndef glUniform2iv_RETURN
#define glUniform2iv_RETURN void
#define glUniform2iv_ARG_NAMES location, count, value
#define glUniform2iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform2iv_ARG_NAMES_TAIL , location, count, value
#define glUniform2iv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform2iv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2iv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2iv(packed, ret_v) do { \
    glUniform2iv_PACKED *unpacked = (glUniform2iv_PACKED *)packed; \
    glUniform2iv_ARGS *args = (glUniform2iv_ARGS *)&unpacked->args; \
    glUniform2iv(args->location, args->count, args->value);; \
} while(0)
void glUniform2iv(glUniform2iv_ARG_EXPAND);
packed_call_t *pack_glUniform2iv(glUniform2iv_PACKED *_dst glUniform2iv_ARG_EXPAND_TAIL);
typedef void (*glUniform2iv_PTR)(glUniform2iv_ARG_EXPAND);
#endif
#ifndef glUniform2ivARB_RETURN
#define glUniform2ivARB_RETURN void
#define glUniform2ivARB_ARG_NAMES location, count, value
#define glUniform2ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform2ivARB_ARG_NAMES_TAIL , location, count, value
#define glUniform2ivARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform2ivARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2ivARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2ivARB(packed, ret_v) do { \
    glUniform2ivARB_PACKED *unpacked = (glUniform2ivARB_PACKED *)packed; \
    glUniform2ivARB_ARGS *args = (glUniform2ivARB_ARGS *)&unpacked->args; \
    glUniform2ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform2ivARB(glUniform2ivARB_ARG_EXPAND);
packed_call_t *pack_glUniform2ivARB(glUniform2ivARB_PACKED *_dst glUniform2ivARB_ARG_EXPAND_TAIL);
typedef void (*glUniform2ivARB_PTR)(glUniform2ivARB_ARG_EXPAND);
#endif
#ifndef glUniform2ui_RETURN
#define glUniform2ui_RETURN void
#define glUniform2ui_ARG_NAMES location, v0, v1
#define glUniform2ui_ARG_EXPAND GLint location, GLuint v0, GLuint v1
#define glUniform2ui_ARG_NAMES_TAIL , location, v0, v1
#define glUniform2ui_ARG_EXPAND_TAIL , GLint location, GLuint v0, GLuint v1
#define forward_glUniform2ui(_location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2ui(dst, _location, _v0, _v1), NULL); \
    });
#define call_glUniform2ui(packed, ret_v) do { \
    glUniform2ui_PACKED *unpacked = (glUniform2ui_PACKED *)packed; \
    glUniform2ui_ARGS *args = (glUniform2ui_ARGS *)&unpacked->args; \
    glUniform2ui(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2ui(glUniform2ui_ARG_EXPAND);
packed_call_t *pack_glUniform2ui(glUniform2ui_PACKED *_dst glUniform2ui_ARG_EXPAND_TAIL);
typedef void (*glUniform2ui_PTR)(glUniform2ui_ARG_EXPAND);
#endif
#ifndef glUniform2ui64NV_RETURN
#define glUniform2ui64NV_RETURN void
#define glUniform2ui64NV_ARG_NAMES location, x, y
#define glUniform2ui64NV_ARG_EXPAND GLint location, GLuint64EXT x, GLuint64EXT y
#define glUniform2ui64NV_ARG_NAMES_TAIL , location, x, y
#define glUniform2ui64NV_ARG_EXPAND_TAIL , GLint location, GLuint64EXT x, GLuint64EXT y
#define forward_glUniform2ui64NV(_location, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2ui64NV(dst, _location, _x, _y), NULL); \
    });
#define call_glUniform2ui64NV(packed, ret_v) do { \
    glUniform2ui64NV_PACKED *unpacked = (glUniform2ui64NV_PACKED *)packed; \
    glUniform2ui64NV_ARGS *args = (glUniform2ui64NV_ARGS *)&unpacked->args; \
    glUniform2ui64NV(args->location, args->x, args->y);; \
} while(0)
void glUniform2ui64NV(glUniform2ui64NV_ARG_EXPAND);
packed_call_t *pack_glUniform2ui64NV(glUniform2ui64NV_PACKED *_dst glUniform2ui64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform2ui64NV_PTR)(glUniform2ui64NV_ARG_EXPAND);
#endif
#ifndef glUniform2ui64vNV_RETURN
#define glUniform2ui64vNV_RETURN void
#define glUniform2ui64vNV_ARG_NAMES location, count, value
#define glUniform2ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform2ui64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform2ui64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glUniform2ui64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2ui64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2ui64vNV(packed, ret_v) do { \
    glUniform2ui64vNV_PACKED *unpacked = (glUniform2ui64vNV_PACKED *)packed; \
    glUniform2ui64vNV_ARGS *args = (glUniform2ui64vNV_ARGS *)&unpacked->args; \
    glUniform2ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform2ui64vNV(glUniform2ui64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform2ui64vNV(glUniform2ui64vNV_PACKED *_dst glUniform2ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform2ui64vNV_PTR)(glUniform2ui64vNV_ARG_EXPAND);
#endif
#ifndef glUniform2uiEXT_RETURN
#define glUniform2uiEXT_RETURN void
#define glUniform2uiEXT_ARG_NAMES location, v0, v1
#define glUniform2uiEXT_ARG_EXPAND GLint location, GLuint v0, GLuint v1
#define glUniform2uiEXT_ARG_NAMES_TAIL , location, v0, v1
#define glUniform2uiEXT_ARG_EXPAND_TAIL , GLint location, GLuint v0, GLuint v1
#define forward_glUniform2uiEXT(_location, _v0, _v1) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2uiEXT(dst, _location, _v0, _v1), NULL); \
    });
#define call_glUniform2uiEXT(packed, ret_v) do { \
    glUniform2uiEXT_PACKED *unpacked = (glUniform2uiEXT_PACKED *)packed; \
    glUniform2uiEXT_ARGS *args = (glUniform2uiEXT_ARGS *)&unpacked->args; \
    glUniform2uiEXT(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2uiEXT(glUniform2uiEXT_ARG_EXPAND);
packed_call_t *pack_glUniform2uiEXT(glUniform2uiEXT_PACKED *_dst glUniform2uiEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform2uiEXT_PTR)(glUniform2uiEXT_ARG_EXPAND);
#endif
#ifndef glUniform2uiv_RETURN
#define glUniform2uiv_RETURN void
#define glUniform2uiv_ARG_NAMES location, count, value
#define glUniform2uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform2uiv_ARG_NAMES_TAIL , location, count, value
#define glUniform2uiv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform2uiv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2uiv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2uiv(packed, ret_v) do { \
    glUniform2uiv_PACKED *unpacked = (glUniform2uiv_PACKED *)packed; \
    glUniform2uiv_ARGS *args = (glUniform2uiv_ARGS *)&unpacked->args; \
    glUniform2uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform2uiv(glUniform2uiv_ARG_EXPAND);
packed_call_t *pack_glUniform2uiv(glUniform2uiv_PACKED *_dst glUniform2uiv_ARG_EXPAND_TAIL);
typedef void (*glUniform2uiv_PTR)(glUniform2uiv_ARG_EXPAND);
#endif
#ifndef glUniform2uivEXT_RETURN
#define glUniform2uivEXT_RETURN void
#define glUniform2uivEXT_ARG_NAMES location, count, value
#define glUniform2uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform2uivEXT_ARG_NAMES_TAIL , location, count, value
#define glUniform2uivEXT_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform2uivEXT(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform2uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform2uivEXT(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform2uivEXT(packed, ret_v) do { \
    glUniform2uivEXT_PACKED *unpacked = (glUniform2uivEXT_PACKED *)packed; \
    glUniform2uivEXT_ARGS *args = (glUniform2uivEXT_ARGS *)&unpacked->args; \
    glUniform2uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform2uivEXT(glUniform2uivEXT_ARG_EXPAND);
packed_call_t *pack_glUniform2uivEXT(glUniform2uivEXT_PACKED *_dst glUniform2uivEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform2uivEXT_PTR)(glUniform2uivEXT_ARG_EXPAND);
#endif
#ifndef glUniform3d_RETURN
#define glUniform3d_RETURN void
#define glUniform3d_ARG_NAMES location, x, y, z
#define glUniform3d_ARG_EXPAND GLint location, GLdouble x, GLdouble y, GLdouble z
#define glUniform3d_ARG_NAMES_TAIL , location, x, y, z
#define glUniform3d_ARG_EXPAND_TAIL , GLint location, GLdouble x, GLdouble y, GLdouble z
#define forward_glUniform3d(_location, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3d(dst, _location, _x, _y, _z), NULL); \
    });
#define call_glUniform3d(packed, ret_v) do { \
    glUniform3d_PACKED *unpacked = (glUniform3d_PACKED *)packed; \
    glUniform3d_ARGS *args = (glUniform3d_ARGS *)&unpacked->args; \
    glUniform3d(args->location, args->x, args->y, args->z);; \
} while(0)
void glUniform3d(glUniform3d_ARG_EXPAND);
packed_call_t *pack_glUniform3d(glUniform3d_PACKED *_dst glUniform3d_ARG_EXPAND_TAIL);
typedef void (*glUniform3d_PTR)(glUniform3d_ARG_EXPAND);
#endif
#ifndef glUniform3dv_RETURN
#define glUniform3dv_RETURN void
#define glUniform3dv_ARG_NAMES location, count, value
#define glUniform3dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform3dv_ARG_NAMES_TAIL , location, count, value
#define glUniform3dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLdouble * value
#define forward_glUniform3dv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3dv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3dv(packed, ret_v) do { \
    glUniform3dv_PACKED *unpacked = (glUniform3dv_PACKED *)packed; \
    glUniform3dv_ARGS *args = (glUniform3dv_ARGS *)&unpacked->args; \
    glUniform3dv(args->location, args->count, args->value);; \
} while(0)
void glUniform3dv(glUniform3dv_ARG_EXPAND);
packed_call_t *pack_glUniform3dv(glUniform3dv_PACKED *_dst glUniform3dv_ARG_EXPAND_TAIL);
typedef void (*glUniform3dv_PTR)(glUniform3dv_ARG_EXPAND);
#endif
#ifndef glUniform3f_RETURN
#define glUniform3f_RETURN void
#define glUniform3f_ARG_NAMES location, v0, v1, v2
#define glUniform3f_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glUniform3f_ARG_NAMES_TAIL , location, v0, v1, v2
#define glUniform3f_ARG_EXPAND_TAIL , GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define forward_glUniform3f(_location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3f(dst, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glUniform3f(packed, ret_v) do { \
    glUniform3f_PACKED *unpacked = (glUniform3f_PACKED *)packed; \
    glUniform3f_ARGS *args = (glUniform3f_ARGS *)&unpacked->args; \
    glUniform3f(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3f(glUniform3f_ARG_EXPAND);
packed_call_t *pack_glUniform3f(glUniform3f_PACKED *_dst glUniform3f_ARG_EXPAND_TAIL);
typedef void (*glUniform3f_PTR)(glUniform3f_ARG_EXPAND);
#endif
#ifndef glUniform3fARB_RETURN
#define glUniform3fARB_RETURN void
#define glUniform3fARB_ARG_NAMES location, v0, v1, v2
#define glUniform3fARB_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glUniform3fARB_ARG_NAMES_TAIL , location, v0, v1, v2
#define glUniform3fARB_ARG_EXPAND_TAIL , GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define forward_glUniform3fARB(_location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3fARB(dst, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glUniform3fARB(packed, ret_v) do { \
    glUniform3fARB_PACKED *unpacked = (glUniform3fARB_PACKED *)packed; \
    glUniform3fARB_ARGS *args = (glUniform3fARB_ARGS *)&unpacked->args; \
    glUniform3fARB(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3fARB(glUniform3fARB_ARG_EXPAND);
packed_call_t *pack_glUniform3fARB(glUniform3fARB_PACKED *_dst glUniform3fARB_ARG_EXPAND_TAIL);
typedef void (*glUniform3fARB_PTR)(glUniform3fARB_ARG_EXPAND);
#endif
#ifndef glUniform3fv_RETURN
#define glUniform3fv_RETURN void
#define glUniform3fv_ARG_NAMES location, count, value
#define glUniform3fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform3fv_ARG_NAMES_TAIL , location, count, value
#define glUniform3fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform3fv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3fv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3fv(packed, ret_v) do { \
    glUniform3fv_PACKED *unpacked = (glUniform3fv_PACKED *)packed; \
    glUniform3fv_ARGS *args = (glUniform3fv_ARGS *)&unpacked->args; \
    glUniform3fv(args->location, args->count, args->value);; \
} while(0)
void glUniform3fv(glUniform3fv_ARG_EXPAND);
packed_call_t *pack_glUniform3fv(glUniform3fv_PACKED *_dst glUniform3fv_ARG_EXPAND_TAIL);
typedef void (*glUniform3fv_PTR)(glUniform3fv_ARG_EXPAND);
#endif
#ifndef glUniform3fvARB_RETURN
#define glUniform3fvARB_RETURN void
#define glUniform3fvARB_ARG_NAMES location, count, value
#define glUniform3fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform3fvARB_ARG_NAMES_TAIL , location, count, value
#define glUniform3fvARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform3fvARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3fvARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3fvARB(packed, ret_v) do { \
    glUniform3fvARB_PACKED *unpacked = (glUniform3fvARB_PACKED *)packed; \
    glUniform3fvARB_ARGS *args = (glUniform3fvARB_ARGS *)&unpacked->args; \
    glUniform3fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform3fvARB(glUniform3fvARB_ARG_EXPAND);
packed_call_t *pack_glUniform3fvARB(glUniform3fvARB_PACKED *_dst glUniform3fvARB_ARG_EXPAND_TAIL);
typedef void (*glUniform3fvARB_PTR)(glUniform3fvARB_ARG_EXPAND);
#endif
#ifndef glUniform3i_RETURN
#define glUniform3i_RETURN void
#define glUniform3i_ARG_NAMES location, v0, v1, v2
#define glUniform3i_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2
#define glUniform3i_ARG_NAMES_TAIL , location, v0, v1, v2
#define glUniform3i_ARG_EXPAND_TAIL , GLint location, GLint v0, GLint v1, GLint v2
#define forward_glUniform3i(_location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3i(dst, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glUniform3i(packed, ret_v) do { \
    glUniform3i_PACKED *unpacked = (glUniform3i_PACKED *)packed; \
    glUniform3i_ARGS *args = (glUniform3i_ARGS *)&unpacked->args; \
    glUniform3i(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3i(glUniform3i_ARG_EXPAND);
packed_call_t *pack_glUniform3i(glUniform3i_PACKED *_dst glUniform3i_ARG_EXPAND_TAIL);
typedef void (*glUniform3i_PTR)(glUniform3i_ARG_EXPAND);
#endif
#ifndef glUniform3i64NV_RETURN
#define glUniform3i64NV_RETURN void
#define glUniform3i64NV_ARG_NAMES location, x, y, z
#define glUniform3i64NV_ARG_EXPAND GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define glUniform3i64NV_ARG_NAMES_TAIL , location, x, y, z
#define glUniform3i64NV_ARG_EXPAND_TAIL , GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define forward_glUniform3i64NV(_location, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3i64NV(dst, _location, _x, _y, _z), NULL); \
    });
#define call_glUniform3i64NV(packed, ret_v) do { \
    glUniform3i64NV_PACKED *unpacked = (glUniform3i64NV_PACKED *)packed; \
    glUniform3i64NV_ARGS *args = (glUniform3i64NV_ARGS *)&unpacked->args; \
    glUniform3i64NV(args->location, args->x, args->y, args->z);; \
} while(0)
void glUniform3i64NV(glUniform3i64NV_ARG_EXPAND);
packed_call_t *pack_glUniform3i64NV(glUniform3i64NV_PACKED *_dst glUniform3i64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform3i64NV_PTR)(glUniform3i64NV_ARG_EXPAND);
#endif
#ifndef glUniform3i64vNV_RETURN
#define glUniform3i64vNV_RETURN void
#define glUniform3i64vNV_ARG_NAMES location, count, value
#define glUniform3i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform3i64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform3i64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint64EXT * value
#define forward_glUniform3i64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3i64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3i64vNV(packed, ret_v) do { \
    glUniform3i64vNV_PACKED *unpacked = (glUniform3i64vNV_PACKED *)packed; \
    glUniform3i64vNV_ARGS *args = (glUniform3i64vNV_ARGS *)&unpacked->args; \
    glUniform3i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform3i64vNV(glUniform3i64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform3i64vNV(glUniform3i64vNV_PACKED *_dst glUniform3i64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform3i64vNV_PTR)(glUniform3i64vNV_ARG_EXPAND);
#endif
#ifndef glUniform3iARB_RETURN
#define glUniform3iARB_RETURN void
#define glUniform3iARB_ARG_NAMES location, v0, v1, v2
#define glUniform3iARB_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2
#define glUniform3iARB_ARG_NAMES_TAIL , location, v0, v1, v2
#define glUniform3iARB_ARG_EXPAND_TAIL , GLint location, GLint v0, GLint v1, GLint v2
#define forward_glUniform3iARB(_location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3iARB(dst, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glUniform3iARB(packed, ret_v) do { \
    glUniform3iARB_PACKED *unpacked = (glUniform3iARB_PACKED *)packed; \
    glUniform3iARB_ARGS *args = (glUniform3iARB_ARGS *)&unpacked->args; \
    glUniform3iARB(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3iARB(glUniform3iARB_ARG_EXPAND);
packed_call_t *pack_glUniform3iARB(glUniform3iARB_PACKED *_dst glUniform3iARB_ARG_EXPAND_TAIL);
typedef void (*glUniform3iARB_PTR)(glUniform3iARB_ARG_EXPAND);
#endif
#ifndef glUniform3iv_RETURN
#define glUniform3iv_RETURN void
#define glUniform3iv_ARG_NAMES location, count, value
#define glUniform3iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform3iv_ARG_NAMES_TAIL , location, count, value
#define glUniform3iv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform3iv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3iv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3iv(packed, ret_v) do { \
    glUniform3iv_PACKED *unpacked = (glUniform3iv_PACKED *)packed; \
    glUniform3iv_ARGS *args = (glUniform3iv_ARGS *)&unpacked->args; \
    glUniform3iv(args->location, args->count, args->value);; \
} while(0)
void glUniform3iv(glUniform3iv_ARG_EXPAND);
packed_call_t *pack_glUniform3iv(glUniform3iv_PACKED *_dst glUniform3iv_ARG_EXPAND_TAIL);
typedef void (*glUniform3iv_PTR)(glUniform3iv_ARG_EXPAND);
#endif
#ifndef glUniform3ivARB_RETURN
#define glUniform3ivARB_RETURN void
#define glUniform3ivARB_ARG_NAMES location, count, value
#define glUniform3ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform3ivARB_ARG_NAMES_TAIL , location, count, value
#define glUniform3ivARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform3ivARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3ivARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3ivARB(packed, ret_v) do { \
    glUniform3ivARB_PACKED *unpacked = (glUniform3ivARB_PACKED *)packed; \
    glUniform3ivARB_ARGS *args = (glUniform3ivARB_ARGS *)&unpacked->args; \
    glUniform3ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform3ivARB(glUniform3ivARB_ARG_EXPAND);
packed_call_t *pack_glUniform3ivARB(glUniform3ivARB_PACKED *_dst glUniform3ivARB_ARG_EXPAND_TAIL);
typedef void (*glUniform3ivARB_PTR)(glUniform3ivARB_ARG_EXPAND);
#endif
#ifndef glUniform3ui_RETURN
#define glUniform3ui_RETURN void
#define glUniform3ui_ARG_NAMES location, v0, v1, v2
#define glUniform3ui_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2
#define glUniform3ui_ARG_NAMES_TAIL , location, v0, v1, v2
#define glUniform3ui_ARG_EXPAND_TAIL , GLint location, GLuint v0, GLuint v1, GLuint v2
#define forward_glUniform3ui(_location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3ui(dst, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glUniform3ui(packed, ret_v) do { \
    glUniform3ui_PACKED *unpacked = (glUniform3ui_PACKED *)packed; \
    glUniform3ui_ARGS *args = (glUniform3ui_ARGS *)&unpacked->args; \
    glUniform3ui(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3ui(glUniform3ui_ARG_EXPAND);
packed_call_t *pack_glUniform3ui(glUniform3ui_PACKED *_dst glUniform3ui_ARG_EXPAND_TAIL);
typedef void (*glUniform3ui_PTR)(glUniform3ui_ARG_EXPAND);
#endif
#ifndef glUniform3ui64NV_RETURN
#define glUniform3ui64NV_RETURN void
#define glUniform3ui64NV_ARG_NAMES location, x, y, z
#define glUniform3ui64NV_ARG_EXPAND GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define glUniform3ui64NV_ARG_NAMES_TAIL , location, x, y, z
#define glUniform3ui64NV_ARG_EXPAND_TAIL , GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define forward_glUniform3ui64NV(_location, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3ui64NV(dst, _location, _x, _y, _z), NULL); \
    });
#define call_glUniform3ui64NV(packed, ret_v) do { \
    glUniform3ui64NV_PACKED *unpacked = (glUniform3ui64NV_PACKED *)packed; \
    glUniform3ui64NV_ARGS *args = (glUniform3ui64NV_ARGS *)&unpacked->args; \
    glUniform3ui64NV(args->location, args->x, args->y, args->z);; \
} while(0)
void glUniform3ui64NV(glUniform3ui64NV_ARG_EXPAND);
packed_call_t *pack_glUniform3ui64NV(glUniform3ui64NV_PACKED *_dst glUniform3ui64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform3ui64NV_PTR)(glUniform3ui64NV_ARG_EXPAND);
#endif
#ifndef glUniform3ui64vNV_RETURN
#define glUniform3ui64vNV_RETURN void
#define glUniform3ui64vNV_ARG_NAMES location, count, value
#define glUniform3ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform3ui64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform3ui64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glUniform3ui64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3ui64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3ui64vNV(packed, ret_v) do { \
    glUniform3ui64vNV_PACKED *unpacked = (glUniform3ui64vNV_PACKED *)packed; \
    glUniform3ui64vNV_ARGS *args = (glUniform3ui64vNV_ARGS *)&unpacked->args; \
    glUniform3ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform3ui64vNV(glUniform3ui64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform3ui64vNV(glUniform3ui64vNV_PACKED *_dst glUniform3ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform3ui64vNV_PTR)(glUniform3ui64vNV_ARG_EXPAND);
#endif
#ifndef glUniform3uiEXT_RETURN
#define glUniform3uiEXT_RETURN void
#define glUniform3uiEXT_ARG_NAMES location, v0, v1, v2
#define glUniform3uiEXT_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2
#define glUniform3uiEXT_ARG_NAMES_TAIL , location, v0, v1, v2
#define glUniform3uiEXT_ARG_EXPAND_TAIL , GLint location, GLuint v0, GLuint v1, GLuint v2
#define forward_glUniform3uiEXT(_location, _v0, _v1, _v2) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3uiEXT(dst, _location, _v0, _v1, _v2), NULL); \
    });
#define call_glUniform3uiEXT(packed, ret_v) do { \
    glUniform3uiEXT_PACKED *unpacked = (glUniform3uiEXT_PACKED *)packed; \
    glUniform3uiEXT_ARGS *args = (glUniform3uiEXT_ARGS *)&unpacked->args; \
    glUniform3uiEXT(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3uiEXT(glUniform3uiEXT_ARG_EXPAND);
packed_call_t *pack_glUniform3uiEXT(glUniform3uiEXT_PACKED *_dst glUniform3uiEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform3uiEXT_PTR)(glUniform3uiEXT_ARG_EXPAND);
#endif
#ifndef glUniform3uiv_RETURN
#define glUniform3uiv_RETURN void
#define glUniform3uiv_ARG_NAMES location, count, value
#define glUniform3uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform3uiv_ARG_NAMES_TAIL , location, count, value
#define glUniform3uiv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform3uiv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3uiv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3uiv(packed, ret_v) do { \
    glUniform3uiv_PACKED *unpacked = (glUniform3uiv_PACKED *)packed; \
    glUniform3uiv_ARGS *args = (glUniform3uiv_ARGS *)&unpacked->args; \
    glUniform3uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform3uiv(glUniform3uiv_ARG_EXPAND);
packed_call_t *pack_glUniform3uiv(glUniform3uiv_PACKED *_dst glUniform3uiv_ARG_EXPAND_TAIL);
typedef void (*glUniform3uiv_PTR)(glUniform3uiv_ARG_EXPAND);
#endif
#ifndef glUniform3uivEXT_RETURN
#define glUniform3uivEXT_RETURN void
#define glUniform3uivEXT_ARG_NAMES location, count, value
#define glUniform3uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform3uivEXT_ARG_NAMES_TAIL , location, count, value
#define glUniform3uivEXT_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform3uivEXT(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform3uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform3uivEXT(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform3uivEXT(packed, ret_v) do { \
    glUniform3uivEXT_PACKED *unpacked = (glUniform3uivEXT_PACKED *)packed; \
    glUniform3uivEXT_ARGS *args = (glUniform3uivEXT_ARGS *)&unpacked->args; \
    glUniform3uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform3uivEXT(glUniform3uivEXT_ARG_EXPAND);
packed_call_t *pack_glUniform3uivEXT(glUniform3uivEXT_PACKED *_dst glUniform3uivEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform3uivEXT_PTR)(glUniform3uivEXT_ARG_EXPAND);
#endif
#ifndef glUniform4d_RETURN
#define glUniform4d_RETURN void
#define glUniform4d_ARG_NAMES location, x, y, z, w
#define glUniform4d_ARG_EXPAND GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glUniform4d_ARG_NAMES_TAIL , location, x, y, z, w
#define glUniform4d_ARG_EXPAND_TAIL , GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glUniform4d(_location, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4d(dst, _location, _x, _y, _z, _w), NULL); \
    });
#define call_glUniform4d(packed, ret_v) do { \
    glUniform4d_PACKED *unpacked = (glUniform4d_PACKED *)packed; \
    glUniform4d_ARGS *args = (glUniform4d_ARGS *)&unpacked->args; \
    glUniform4d(args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glUniform4d(glUniform4d_ARG_EXPAND);
packed_call_t *pack_glUniform4d(glUniform4d_PACKED *_dst glUniform4d_ARG_EXPAND_TAIL);
typedef void (*glUniform4d_PTR)(glUniform4d_ARG_EXPAND);
#endif
#ifndef glUniform4dv_RETURN
#define glUniform4dv_RETURN void
#define glUniform4dv_ARG_NAMES location, count, value
#define glUniform4dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform4dv_ARG_NAMES_TAIL , location, count, value
#define glUniform4dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLdouble * value
#define forward_glUniform4dv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4dv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4dv(packed, ret_v) do { \
    glUniform4dv_PACKED *unpacked = (glUniform4dv_PACKED *)packed; \
    glUniform4dv_ARGS *args = (glUniform4dv_ARGS *)&unpacked->args; \
    glUniform4dv(args->location, args->count, args->value);; \
} while(0)
void glUniform4dv(glUniform4dv_ARG_EXPAND);
packed_call_t *pack_glUniform4dv(glUniform4dv_PACKED *_dst glUniform4dv_ARG_EXPAND_TAIL);
typedef void (*glUniform4dv_PTR)(glUniform4dv_ARG_EXPAND);
#endif
#ifndef glUniform4f_RETURN
#define glUniform4f_RETURN void
#define glUniform4f_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4f_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glUniform4f_ARG_NAMES_TAIL , location, v0, v1, v2, v3
#define glUniform4f_ARG_EXPAND_TAIL , GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define forward_glUniform4f(_location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4f(dst, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glUniform4f(packed, ret_v) do { \
    glUniform4f_PACKED *unpacked = (glUniform4f_PACKED *)packed; \
    glUniform4f_ARGS *args = (glUniform4f_ARGS *)&unpacked->args; \
    glUniform4f(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4f(glUniform4f_ARG_EXPAND);
packed_call_t *pack_glUniform4f(glUniform4f_PACKED *_dst glUniform4f_ARG_EXPAND_TAIL);
typedef void (*glUniform4f_PTR)(glUniform4f_ARG_EXPAND);
#endif
#ifndef glUniform4fARB_RETURN
#define glUniform4fARB_RETURN void
#define glUniform4fARB_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4fARB_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glUniform4fARB_ARG_NAMES_TAIL , location, v0, v1, v2, v3
#define glUniform4fARB_ARG_EXPAND_TAIL , GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define forward_glUniform4fARB(_location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4fARB(dst, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glUniform4fARB(packed, ret_v) do { \
    glUniform4fARB_PACKED *unpacked = (glUniform4fARB_PACKED *)packed; \
    glUniform4fARB_ARGS *args = (glUniform4fARB_ARGS *)&unpacked->args; \
    glUniform4fARB(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4fARB(glUniform4fARB_ARG_EXPAND);
packed_call_t *pack_glUniform4fARB(glUniform4fARB_PACKED *_dst glUniform4fARB_ARG_EXPAND_TAIL);
typedef void (*glUniform4fARB_PTR)(glUniform4fARB_ARG_EXPAND);
#endif
#ifndef glUniform4fv_RETURN
#define glUniform4fv_RETURN void
#define glUniform4fv_ARG_NAMES location, count, value
#define glUniform4fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform4fv_ARG_NAMES_TAIL , location, count, value
#define glUniform4fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform4fv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4fv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4fv(packed, ret_v) do { \
    glUniform4fv_PACKED *unpacked = (glUniform4fv_PACKED *)packed; \
    glUniform4fv_ARGS *args = (glUniform4fv_ARGS *)&unpacked->args; \
    glUniform4fv(args->location, args->count, args->value);; \
} while(0)
void glUniform4fv(glUniform4fv_ARG_EXPAND);
packed_call_t *pack_glUniform4fv(glUniform4fv_PACKED *_dst glUniform4fv_ARG_EXPAND_TAIL);
typedef void (*glUniform4fv_PTR)(glUniform4fv_ARG_EXPAND);
#endif
#ifndef glUniform4fvARB_RETURN
#define glUniform4fvARB_RETURN void
#define glUniform4fvARB_ARG_NAMES location, count, value
#define glUniform4fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform4fvARB_ARG_NAMES_TAIL , location, count, value
#define glUniform4fvARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLfloat * value
#define forward_glUniform4fvARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4fvARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4fvARB(packed, ret_v) do { \
    glUniform4fvARB_PACKED *unpacked = (glUniform4fvARB_PACKED *)packed; \
    glUniform4fvARB_ARGS *args = (glUniform4fvARB_ARGS *)&unpacked->args; \
    glUniform4fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform4fvARB(glUniform4fvARB_ARG_EXPAND);
packed_call_t *pack_glUniform4fvARB(glUniform4fvARB_PACKED *_dst glUniform4fvARB_ARG_EXPAND_TAIL);
typedef void (*glUniform4fvARB_PTR)(glUniform4fvARB_ARG_EXPAND);
#endif
#ifndef glUniform4i_RETURN
#define glUniform4i_RETURN void
#define glUniform4i_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4i_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glUniform4i_ARG_NAMES_TAIL , location, v0, v1, v2, v3
#define glUniform4i_ARG_EXPAND_TAIL , GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define forward_glUniform4i(_location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4i(dst, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glUniform4i(packed, ret_v) do { \
    glUniform4i_PACKED *unpacked = (glUniform4i_PACKED *)packed; \
    glUniform4i_ARGS *args = (glUniform4i_ARGS *)&unpacked->args; \
    glUniform4i(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4i(glUniform4i_ARG_EXPAND);
packed_call_t *pack_glUniform4i(glUniform4i_PACKED *_dst glUniform4i_ARG_EXPAND_TAIL);
typedef void (*glUniform4i_PTR)(glUniform4i_ARG_EXPAND);
#endif
#ifndef glUniform4i64NV_RETURN
#define glUniform4i64NV_RETURN void
#define glUniform4i64NV_ARG_NAMES location, x, y, z, w
#define glUniform4i64NV_ARG_EXPAND GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define glUniform4i64NV_ARG_NAMES_TAIL , location, x, y, z, w
#define glUniform4i64NV_ARG_EXPAND_TAIL , GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define forward_glUniform4i64NV(_location, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4i64NV(dst, _location, _x, _y, _z, _w), NULL); \
    });
#define call_glUniform4i64NV(packed, ret_v) do { \
    glUniform4i64NV_PACKED *unpacked = (glUniform4i64NV_PACKED *)packed; \
    glUniform4i64NV_ARGS *args = (glUniform4i64NV_ARGS *)&unpacked->args; \
    glUniform4i64NV(args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glUniform4i64NV(glUniform4i64NV_ARG_EXPAND);
packed_call_t *pack_glUniform4i64NV(glUniform4i64NV_PACKED *_dst glUniform4i64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform4i64NV_PTR)(glUniform4i64NV_ARG_EXPAND);
#endif
#ifndef glUniform4i64vNV_RETURN
#define glUniform4i64vNV_RETURN void
#define glUniform4i64vNV_ARG_NAMES location, count, value
#define glUniform4i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform4i64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform4i64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint64EXT * value
#define forward_glUniform4i64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4i64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4i64vNV(packed, ret_v) do { \
    glUniform4i64vNV_PACKED *unpacked = (glUniform4i64vNV_PACKED *)packed; \
    glUniform4i64vNV_ARGS *args = (glUniform4i64vNV_ARGS *)&unpacked->args; \
    glUniform4i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform4i64vNV(glUniform4i64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform4i64vNV(glUniform4i64vNV_PACKED *_dst glUniform4i64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform4i64vNV_PTR)(glUniform4i64vNV_ARG_EXPAND);
#endif
#ifndef glUniform4iARB_RETURN
#define glUniform4iARB_RETURN void
#define glUniform4iARB_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4iARB_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glUniform4iARB_ARG_NAMES_TAIL , location, v0, v1, v2, v3
#define glUniform4iARB_ARG_EXPAND_TAIL , GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define forward_glUniform4iARB(_location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4iARB(dst, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glUniform4iARB(packed, ret_v) do { \
    glUniform4iARB_PACKED *unpacked = (glUniform4iARB_PACKED *)packed; \
    glUniform4iARB_ARGS *args = (glUniform4iARB_ARGS *)&unpacked->args; \
    glUniform4iARB(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4iARB(glUniform4iARB_ARG_EXPAND);
packed_call_t *pack_glUniform4iARB(glUniform4iARB_PACKED *_dst glUniform4iARB_ARG_EXPAND_TAIL);
typedef void (*glUniform4iARB_PTR)(glUniform4iARB_ARG_EXPAND);
#endif
#ifndef glUniform4iv_RETURN
#define glUniform4iv_RETURN void
#define glUniform4iv_ARG_NAMES location, count, value
#define glUniform4iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform4iv_ARG_NAMES_TAIL , location, count, value
#define glUniform4iv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform4iv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4iv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4iv(packed, ret_v) do { \
    glUniform4iv_PACKED *unpacked = (glUniform4iv_PACKED *)packed; \
    glUniform4iv_ARGS *args = (glUniform4iv_ARGS *)&unpacked->args; \
    glUniform4iv(args->location, args->count, args->value);; \
} while(0)
void glUniform4iv(glUniform4iv_ARG_EXPAND);
packed_call_t *pack_glUniform4iv(glUniform4iv_PACKED *_dst glUniform4iv_ARG_EXPAND_TAIL);
typedef void (*glUniform4iv_PTR)(glUniform4iv_ARG_EXPAND);
#endif
#ifndef glUniform4ivARB_RETURN
#define glUniform4ivARB_RETURN void
#define glUniform4ivARB_ARG_NAMES location, count, value
#define glUniform4ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform4ivARB_ARG_NAMES_TAIL , location, count, value
#define glUniform4ivARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLint * value
#define forward_glUniform4ivARB(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4ivARB(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4ivARB(packed, ret_v) do { \
    glUniform4ivARB_PACKED *unpacked = (glUniform4ivARB_PACKED *)packed; \
    glUniform4ivARB_ARGS *args = (glUniform4ivARB_ARGS *)&unpacked->args; \
    glUniform4ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform4ivARB(glUniform4ivARB_ARG_EXPAND);
packed_call_t *pack_glUniform4ivARB(glUniform4ivARB_PACKED *_dst glUniform4ivARB_ARG_EXPAND_TAIL);
typedef void (*glUniform4ivARB_PTR)(glUniform4ivARB_ARG_EXPAND);
#endif
#ifndef glUniform4ui_RETURN
#define glUniform4ui_RETURN void
#define glUniform4ui_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4ui_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glUniform4ui_ARG_NAMES_TAIL , location, v0, v1, v2, v3
#define glUniform4ui_ARG_EXPAND_TAIL , GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define forward_glUniform4ui(_location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4ui(dst, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glUniform4ui(packed, ret_v) do { \
    glUniform4ui_PACKED *unpacked = (glUniform4ui_PACKED *)packed; \
    glUniform4ui_ARGS *args = (glUniform4ui_ARGS *)&unpacked->args; \
    glUniform4ui(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4ui(glUniform4ui_ARG_EXPAND);
packed_call_t *pack_glUniform4ui(glUniform4ui_PACKED *_dst glUniform4ui_ARG_EXPAND_TAIL);
typedef void (*glUniform4ui_PTR)(glUniform4ui_ARG_EXPAND);
#endif
#ifndef glUniform4ui64NV_RETURN
#define glUniform4ui64NV_RETURN void
#define glUniform4ui64NV_ARG_NAMES location, x, y, z, w
#define glUniform4ui64NV_ARG_EXPAND GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define glUniform4ui64NV_ARG_NAMES_TAIL , location, x, y, z, w
#define glUniform4ui64NV_ARG_EXPAND_TAIL , GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define forward_glUniform4ui64NV(_location, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4ui64NV(dst, _location, _x, _y, _z, _w), NULL); \
    });
#define call_glUniform4ui64NV(packed, ret_v) do { \
    glUniform4ui64NV_PACKED *unpacked = (glUniform4ui64NV_PACKED *)packed; \
    glUniform4ui64NV_ARGS *args = (glUniform4ui64NV_ARGS *)&unpacked->args; \
    glUniform4ui64NV(args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glUniform4ui64NV(glUniform4ui64NV_ARG_EXPAND);
packed_call_t *pack_glUniform4ui64NV(glUniform4ui64NV_PACKED *_dst glUniform4ui64NV_ARG_EXPAND_TAIL);
typedef void (*glUniform4ui64NV_PTR)(glUniform4ui64NV_ARG_EXPAND);
#endif
#ifndef glUniform4ui64vNV_RETURN
#define glUniform4ui64vNV_RETURN void
#define glUniform4ui64vNV_ARG_NAMES location, count, value
#define glUniform4ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform4ui64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniform4ui64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glUniform4ui64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4ui64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4ui64vNV(packed, ret_v) do { \
    glUniform4ui64vNV_PACKED *unpacked = (glUniform4ui64vNV_PACKED *)packed; \
    glUniform4ui64vNV_ARGS *args = (glUniform4ui64vNV_ARGS *)&unpacked->args; \
    glUniform4ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform4ui64vNV(glUniform4ui64vNV_ARG_EXPAND);
packed_call_t *pack_glUniform4ui64vNV(glUniform4ui64vNV_PACKED *_dst glUniform4ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniform4ui64vNV_PTR)(glUniform4ui64vNV_ARG_EXPAND);
#endif
#ifndef glUniform4uiEXT_RETURN
#define glUniform4uiEXT_RETURN void
#define glUniform4uiEXT_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4uiEXT_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glUniform4uiEXT_ARG_NAMES_TAIL , location, v0, v1, v2, v3
#define glUniform4uiEXT_ARG_EXPAND_TAIL , GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define forward_glUniform4uiEXT(_location, _v0, _v1, _v2, _v3) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4uiEXT(dst, _location, _v0, _v1, _v2, _v3), NULL); \
    });
#define call_glUniform4uiEXT(packed, ret_v) do { \
    glUniform4uiEXT_PACKED *unpacked = (glUniform4uiEXT_PACKED *)packed; \
    glUniform4uiEXT_ARGS *args = (glUniform4uiEXT_ARGS *)&unpacked->args; \
    glUniform4uiEXT(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4uiEXT(glUniform4uiEXT_ARG_EXPAND);
packed_call_t *pack_glUniform4uiEXT(glUniform4uiEXT_PACKED *_dst glUniform4uiEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform4uiEXT_PTR)(glUniform4uiEXT_ARG_EXPAND);
#endif
#ifndef glUniform4uiv_RETURN
#define glUniform4uiv_RETURN void
#define glUniform4uiv_ARG_NAMES location, count, value
#define glUniform4uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform4uiv_ARG_NAMES_TAIL , location, count, value
#define glUniform4uiv_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform4uiv(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4uiv(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4uiv(packed, ret_v) do { \
    glUniform4uiv_PACKED *unpacked = (glUniform4uiv_PACKED *)packed; \
    glUniform4uiv_ARGS *args = (glUniform4uiv_ARGS *)&unpacked->args; \
    glUniform4uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform4uiv(glUniform4uiv_ARG_EXPAND);
packed_call_t *pack_glUniform4uiv(glUniform4uiv_PACKED *_dst glUniform4uiv_ARG_EXPAND_TAIL);
typedef void (*glUniform4uiv_PTR)(glUniform4uiv_ARG_EXPAND);
#endif
#ifndef glUniform4uivEXT_RETURN
#define glUniform4uivEXT_RETURN void
#define glUniform4uivEXT_ARG_NAMES location, count, value
#define glUniform4uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform4uivEXT_ARG_NAMES_TAIL , location, count, value
#define glUniform4uivEXT_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint * value
#define forward_glUniform4uivEXT(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniform4uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniform4uivEXT(dst, _location, _count, _value), NULL); \
    });
#define call_glUniform4uivEXT(packed, ret_v) do { \
    glUniform4uivEXT_PACKED *unpacked = (glUniform4uivEXT_PACKED *)packed; \
    glUniform4uivEXT_ARGS *args = (glUniform4uivEXT_ARGS *)&unpacked->args; \
    glUniform4uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform4uivEXT(glUniform4uivEXT_ARG_EXPAND);
packed_call_t *pack_glUniform4uivEXT(glUniform4uivEXT_PACKED *_dst glUniform4uivEXT_ARG_EXPAND_TAIL);
typedef void (*glUniform4uivEXT_PTR)(glUniform4uivEXT_ARG_EXPAND);
#endif
#ifndef glUniformBlockBinding_RETURN
#define glUniformBlockBinding_RETURN void
#define glUniformBlockBinding_ARG_NAMES program, uniformBlockIndex, uniformBlockBinding
#define glUniformBlockBinding_ARG_EXPAND GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding
#define glUniformBlockBinding_ARG_NAMES_TAIL , program, uniformBlockIndex, uniformBlockBinding
#define glUniformBlockBinding_ARG_EXPAND_TAIL , GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding
#define forward_glUniformBlockBinding(_program, _uniformBlockIndex, _uniformBlockBinding) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformBlockBinding_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformBlockBinding(dst, _program, _uniformBlockIndex, _uniformBlockBinding), NULL); \
    });
#define call_glUniformBlockBinding(packed, ret_v) do { \
    glUniformBlockBinding_PACKED *unpacked = (glUniformBlockBinding_PACKED *)packed; \
    glUniformBlockBinding_ARGS *args = (glUniformBlockBinding_ARGS *)&unpacked->args; \
    glUniformBlockBinding(args->program, args->uniformBlockIndex, args->uniformBlockBinding);; \
} while(0)
void glUniformBlockBinding(glUniformBlockBinding_ARG_EXPAND);
packed_call_t *pack_glUniformBlockBinding(glUniformBlockBinding_PACKED *_dst glUniformBlockBinding_ARG_EXPAND_TAIL);
typedef void (*glUniformBlockBinding_PTR)(glUniformBlockBinding_ARG_EXPAND);
#endif
#ifndef glUniformBufferEXT_RETURN
#define glUniformBufferEXT_RETURN void
#define glUniformBufferEXT_ARG_NAMES program, location, buffer
#define glUniformBufferEXT_ARG_EXPAND GLuint program, GLint location, GLuint buffer
#define glUniformBufferEXT_ARG_NAMES_TAIL , program, location, buffer
#define glUniformBufferEXT_ARG_EXPAND_TAIL , GLuint program, GLint location, GLuint buffer
#define forward_glUniformBufferEXT(_program, _location, _buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformBufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformBufferEXT(dst, _program, _location, _buffer), NULL); \
    });
#define call_glUniformBufferEXT(packed, ret_v) do { \
    glUniformBufferEXT_PACKED *unpacked = (glUniformBufferEXT_PACKED *)packed; \
    glUniformBufferEXT_ARGS *args = (glUniformBufferEXT_ARGS *)&unpacked->args; \
    glUniformBufferEXT(args->program, args->location, args->buffer);; \
} while(0)
void glUniformBufferEXT(glUniformBufferEXT_ARG_EXPAND);
packed_call_t *pack_glUniformBufferEXT(glUniformBufferEXT_PACKED *_dst glUniformBufferEXT_ARG_EXPAND_TAIL);
typedef void (*glUniformBufferEXT_PTR)(glUniformBufferEXT_ARG_EXPAND);
#endif
#ifndef glUniformHandleui64NV_RETURN
#define glUniformHandleui64NV_RETURN void
#define glUniformHandleui64NV_ARG_NAMES location, value
#define glUniformHandleui64NV_ARG_EXPAND GLint location, GLuint64 value
#define glUniformHandleui64NV_ARG_NAMES_TAIL , location, value
#define glUniformHandleui64NV_ARG_EXPAND_TAIL , GLint location, GLuint64 value
#define forward_glUniformHandleui64NV(_location, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformHandleui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformHandleui64NV(dst, _location, _value), NULL); \
    });
#define call_glUniformHandleui64NV(packed, ret_v) do { \
    glUniformHandleui64NV_PACKED *unpacked = (glUniformHandleui64NV_PACKED *)packed; \
    glUniformHandleui64NV_ARGS *args = (glUniformHandleui64NV_ARGS *)&unpacked->args; \
    glUniformHandleui64NV(args->location, args->value);; \
} while(0)
void glUniformHandleui64NV(glUniformHandleui64NV_ARG_EXPAND);
packed_call_t *pack_glUniformHandleui64NV(glUniformHandleui64NV_PACKED *_dst glUniformHandleui64NV_ARG_EXPAND_TAIL);
typedef void (*glUniformHandleui64NV_PTR)(glUniformHandleui64NV_ARG_EXPAND);
#endif
#ifndef glUniformHandleui64vNV_RETURN
#define glUniformHandleui64vNV_RETURN void
#define glUniformHandleui64vNV_ARG_NAMES location, count, value
#define glUniformHandleui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64 * value
#define glUniformHandleui64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniformHandleui64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint64 * value
#define forward_glUniformHandleui64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformHandleui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformHandleui64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniformHandleui64vNV(packed, ret_v) do { \
    glUniformHandleui64vNV_PACKED *unpacked = (glUniformHandleui64vNV_PACKED *)packed; \
    glUniformHandleui64vNV_ARGS *args = (glUniformHandleui64vNV_ARGS *)&unpacked->args; \
    glUniformHandleui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniformHandleui64vNV(glUniformHandleui64vNV_ARG_EXPAND);
packed_call_t *pack_glUniformHandleui64vNV(glUniformHandleui64vNV_PACKED *_dst glUniformHandleui64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniformHandleui64vNV_PTR)(glUniformHandleui64vNV_ARG_EXPAND);
#endif
#ifndef glUniformMatrix2dv_RETURN
#define glUniformMatrix2dv_RETURN void
#define glUniformMatrix2dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix2dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix2dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix2dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix2dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix2dv(packed, ret_v) do { \
    glUniformMatrix2dv_PACKED *unpacked = (glUniformMatrix2dv_PACKED *)packed; \
    glUniformMatrix2dv_ARGS *args = (glUniformMatrix2dv_ARGS *)&unpacked->args; \
    glUniformMatrix2dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2dv(glUniformMatrix2dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix2dv(glUniformMatrix2dv_PACKED *_dst glUniformMatrix2dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix2dv_PTR)(glUniformMatrix2dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix2fv_RETURN
#define glUniformMatrix2fv_RETURN void
#define glUniformMatrix2fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix2fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix2fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix2fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix2fv(packed, ret_v) do { \
    glUniformMatrix2fv_PACKED *unpacked = (glUniformMatrix2fv_PACKED *)packed; \
    glUniformMatrix2fv_ARGS *args = (glUniformMatrix2fv_ARGS *)&unpacked->args; \
    glUniformMatrix2fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2fv(glUniformMatrix2fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix2fv(glUniformMatrix2fv_PACKED *_dst glUniformMatrix2fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix2fv_PTR)(glUniformMatrix2fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix2fvARB_RETURN
#define glUniformMatrix2fvARB_RETURN void
#define glUniformMatrix2fvARB_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2fvARB_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2fvARB_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix2fvARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix2fvARB(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix2fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix2fvARB(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix2fvARB(packed, ret_v) do { \
    glUniformMatrix2fvARB_PACKED *unpacked = (glUniformMatrix2fvARB_PACKED *)packed; \
    glUniformMatrix2fvARB_ARGS *args = (glUniformMatrix2fvARB_ARGS *)&unpacked->args; \
    glUniformMatrix2fvARB(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2fvARB(glUniformMatrix2fvARB_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix2fvARB(glUniformMatrix2fvARB_PACKED *_dst glUniformMatrix2fvARB_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix2fvARB_PTR)(glUniformMatrix2fvARB_ARG_EXPAND);
#endif
#ifndef glUniformMatrix2x3dv_RETURN
#define glUniformMatrix2x3dv_RETURN void
#define glUniformMatrix2x3dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x3dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix2x3dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix2x3dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix2x3dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix2x3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix2x3dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix2x3dv(packed, ret_v) do { \
    glUniformMatrix2x3dv_PACKED *unpacked = (glUniformMatrix2x3dv_PACKED *)packed; \
    glUniformMatrix2x3dv_ARGS *args = (glUniformMatrix2x3dv_ARGS *)&unpacked->args; \
    glUniformMatrix2x3dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x3dv(glUniformMatrix2x3dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix2x3dv(glUniformMatrix2x3dv_PACKED *_dst glUniformMatrix2x3dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix2x3dv_PTR)(glUniformMatrix2x3dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix2x3fv_RETURN
#define glUniformMatrix2x3fv_RETURN void
#define glUniformMatrix2x3fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x3fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2x3fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix2x3fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix2x3fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix2x3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix2x3fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix2x3fv(packed, ret_v) do { \
    glUniformMatrix2x3fv_PACKED *unpacked = (glUniformMatrix2x3fv_PACKED *)packed; \
    glUniformMatrix2x3fv_ARGS *args = (glUniformMatrix2x3fv_ARGS *)&unpacked->args; \
    glUniformMatrix2x3fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x3fv(glUniformMatrix2x3fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix2x3fv(glUniformMatrix2x3fv_PACKED *_dst glUniformMatrix2x3fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix2x3fv_PTR)(glUniformMatrix2x3fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix2x4dv_RETURN
#define glUniformMatrix2x4dv_RETURN void
#define glUniformMatrix2x4dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x4dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix2x4dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix2x4dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix2x4dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix2x4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix2x4dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix2x4dv(packed, ret_v) do { \
    glUniformMatrix2x4dv_PACKED *unpacked = (glUniformMatrix2x4dv_PACKED *)packed; \
    glUniformMatrix2x4dv_ARGS *args = (glUniformMatrix2x4dv_ARGS *)&unpacked->args; \
    glUniformMatrix2x4dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x4dv(glUniformMatrix2x4dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix2x4dv(glUniformMatrix2x4dv_PACKED *_dst glUniformMatrix2x4dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix2x4dv_PTR)(glUniformMatrix2x4dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix2x4fv_RETURN
#define glUniformMatrix2x4fv_RETURN void
#define glUniformMatrix2x4fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x4fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2x4fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix2x4fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix2x4fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix2x4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix2x4fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix2x4fv(packed, ret_v) do { \
    glUniformMatrix2x4fv_PACKED *unpacked = (glUniformMatrix2x4fv_PACKED *)packed; \
    glUniformMatrix2x4fv_ARGS *args = (glUniformMatrix2x4fv_ARGS *)&unpacked->args; \
    glUniformMatrix2x4fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x4fv(glUniformMatrix2x4fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix2x4fv(glUniformMatrix2x4fv_PACKED *_dst glUniformMatrix2x4fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix2x4fv_PTR)(glUniformMatrix2x4fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix3dv_RETURN
#define glUniformMatrix3dv_RETURN void
#define glUniformMatrix3dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix3dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix3dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix3dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix3dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix3dv(packed, ret_v) do { \
    glUniformMatrix3dv_PACKED *unpacked = (glUniformMatrix3dv_PACKED *)packed; \
    glUniformMatrix3dv_ARGS *args = (glUniformMatrix3dv_ARGS *)&unpacked->args; \
    glUniformMatrix3dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3dv(glUniformMatrix3dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix3dv(glUniformMatrix3dv_PACKED *_dst glUniformMatrix3dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix3dv_PTR)(glUniformMatrix3dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix3fv_RETURN
#define glUniformMatrix3fv_RETURN void
#define glUniformMatrix3fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix3fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix3fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix3fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix3fv(packed, ret_v) do { \
    glUniformMatrix3fv_PACKED *unpacked = (glUniformMatrix3fv_PACKED *)packed; \
    glUniformMatrix3fv_ARGS *args = (glUniformMatrix3fv_ARGS *)&unpacked->args; \
    glUniformMatrix3fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3fv(glUniformMatrix3fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix3fv(glUniformMatrix3fv_PACKED *_dst glUniformMatrix3fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix3fv_PTR)(glUniformMatrix3fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix3fvARB_RETURN
#define glUniformMatrix3fvARB_RETURN void
#define glUniformMatrix3fvARB_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3fvARB_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3fvARB_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix3fvARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix3fvARB(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix3fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix3fvARB(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix3fvARB(packed, ret_v) do { \
    glUniformMatrix3fvARB_PACKED *unpacked = (glUniformMatrix3fvARB_PACKED *)packed; \
    glUniformMatrix3fvARB_ARGS *args = (glUniformMatrix3fvARB_ARGS *)&unpacked->args; \
    glUniformMatrix3fvARB(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3fvARB(glUniformMatrix3fvARB_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix3fvARB(glUniformMatrix3fvARB_PACKED *_dst glUniformMatrix3fvARB_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix3fvARB_PTR)(glUniformMatrix3fvARB_ARG_EXPAND);
#endif
#ifndef glUniformMatrix3x2dv_RETURN
#define glUniformMatrix3x2dv_RETURN void
#define glUniformMatrix3x2dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x2dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix3x2dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix3x2dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix3x2dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix3x2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix3x2dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix3x2dv(packed, ret_v) do { \
    glUniformMatrix3x2dv_PACKED *unpacked = (glUniformMatrix3x2dv_PACKED *)packed; \
    glUniformMatrix3x2dv_ARGS *args = (glUniformMatrix3x2dv_ARGS *)&unpacked->args; \
    glUniformMatrix3x2dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x2dv(glUniformMatrix3x2dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix3x2dv(glUniformMatrix3x2dv_PACKED *_dst glUniformMatrix3x2dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix3x2dv_PTR)(glUniformMatrix3x2dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix3x2fv_RETURN
#define glUniformMatrix3x2fv_RETURN void
#define glUniformMatrix3x2fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x2fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3x2fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix3x2fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix3x2fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix3x2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix3x2fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix3x2fv(packed, ret_v) do { \
    glUniformMatrix3x2fv_PACKED *unpacked = (glUniformMatrix3x2fv_PACKED *)packed; \
    glUniformMatrix3x2fv_ARGS *args = (glUniformMatrix3x2fv_ARGS *)&unpacked->args; \
    glUniformMatrix3x2fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x2fv(glUniformMatrix3x2fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix3x2fv(glUniformMatrix3x2fv_PACKED *_dst glUniformMatrix3x2fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix3x2fv_PTR)(glUniformMatrix3x2fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix3x4dv_RETURN
#define glUniformMatrix3x4dv_RETURN void
#define glUniformMatrix3x4dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x4dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix3x4dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix3x4dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix3x4dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix3x4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix3x4dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix3x4dv(packed, ret_v) do { \
    glUniformMatrix3x4dv_PACKED *unpacked = (glUniformMatrix3x4dv_PACKED *)packed; \
    glUniformMatrix3x4dv_ARGS *args = (glUniformMatrix3x4dv_ARGS *)&unpacked->args; \
    glUniformMatrix3x4dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x4dv(glUniformMatrix3x4dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix3x4dv(glUniformMatrix3x4dv_PACKED *_dst glUniformMatrix3x4dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix3x4dv_PTR)(glUniformMatrix3x4dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix3x4fv_RETURN
#define glUniformMatrix3x4fv_RETURN void
#define glUniformMatrix3x4fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x4fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3x4fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix3x4fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix3x4fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix3x4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix3x4fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix3x4fv(packed, ret_v) do { \
    glUniformMatrix3x4fv_PACKED *unpacked = (glUniformMatrix3x4fv_PACKED *)packed; \
    glUniformMatrix3x4fv_ARGS *args = (glUniformMatrix3x4fv_ARGS *)&unpacked->args; \
    glUniformMatrix3x4fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x4fv(glUniformMatrix3x4fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix3x4fv(glUniformMatrix3x4fv_PACKED *_dst glUniformMatrix3x4fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix3x4fv_PTR)(glUniformMatrix3x4fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix4dv_RETURN
#define glUniformMatrix4dv_RETURN void
#define glUniformMatrix4dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix4dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix4dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix4dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix4dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix4dv(packed, ret_v) do { \
    glUniformMatrix4dv_PACKED *unpacked = (glUniformMatrix4dv_PACKED *)packed; \
    glUniformMatrix4dv_ARGS *args = (glUniformMatrix4dv_ARGS *)&unpacked->args; \
    glUniformMatrix4dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4dv(glUniformMatrix4dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix4dv(glUniformMatrix4dv_PACKED *_dst glUniformMatrix4dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix4dv_PTR)(glUniformMatrix4dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix4fv_RETURN
#define glUniformMatrix4fv_RETURN void
#define glUniformMatrix4fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix4fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix4fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix4fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix4fv(packed, ret_v) do { \
    glUniformMatrix4fv_PACKED *unpacked = (glUniformMatrix4fv_PACKED *)packed; \
    glUniformMatrix4fv_ARGS *args = (glUniformMatrix4fv_ARGS *)&unpacked->args; \
    glUniformMatrix4fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4fv(glUniformMatrix4fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix4fv(glUniformMatrix4fv_PACKED *_dst glUniformMatrix4fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix4fv_PTR)(glUniformMatrix4fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix4fvARB_RETURN
#define glUniformMatrix4fvARB_RETURN void
#define glUniformMatrix4fvARB_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4fvARB_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4fvARB_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix4fvARB_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix4fvARB(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix4fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix4fvARB(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix4fvARB(packed, ret_v) do { \
    glUniformMatrix4fvARB_PACKED *unpacked = (glUniformMatrix4fvARB_PACKED *)packed; \
    glUniformMatrix4fvARB_ARGS *args = (glUniformMatrix4fvARB_ARGS *)&unpacked->args; \
    glUniformMatrix4fvARB(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4fvARB(glUniformMatrix4fvARB_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix4fvARB(glUniformMatrix4fvARB_PACKED *_dst glUniformMatrix4fvARB_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix4fvARB_PTR)(glUniformMatrix4fvARB_ARG_EXPAND);
#endif
#ifndef glUniformMatrix4x2dv_RETURN
#define glUniformMatrix4x2dv_RETURN void
#define glUniformMatrix4x2dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x2dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix4x2dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix4x2dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix4x2dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix4x2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix4x2dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix4x2dv(packed, ret_v) do { \
    glUniformMatrix4x2dv_PACKED *unpacked = (glUniformMatrix4x2dv_PACKED *)packed; \
    glUniformMatrix4x2dv_ARGS *args = (glUniformMatrix4x2dv_ARGS *)&unpacked->args; \
    glUniformMatrix4x2dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x2dv(glUniformMatrix4x2dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix4x2dv(glUniformMatrix4x2dv_PACKED *_dst glUniformMatrix4x2dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix4x2dv_PTR)(glUniformMatrix4x2dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix4x2fv_RETURN
#define glUniformMatrix4x2fv_RETURN void
#define glUniformMatrix4x2fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x2fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4x2fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix4x2fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix4x2fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix4x2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix4x2fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix4x2fv(packed, ret_v) do { \
    glUniformMatrix4x2fv_PACKED *unpacked = (glUniformMatrix4x2fv_PACKED *)packed; \
    glUniformMatrix4x2fv_ARGS *args = (glUniformMatrix4x2fv_ARGS *)&unpacked->args; \
    glUniformMatrix4x2fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x2fv(glUniformMatrix4x2fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix4x2fv(glUniformMatrix4x2fv_PACKED *_dst glUniformMatrix4x2fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix4x2fv_PTR)(glUniformMatrix4x2fv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix4x3dv_RETURN
#define glUniformMatrix4x3dv_RETURN void
#define glUniformMatrix4x3dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x3dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix4x3dv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix4x3dv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define forward_glUniformMatrix4x3dv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix4x3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix4x3dv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix4x3dv(packed, ret_v) do { \
    glUniformMatrix4x3dv_PACKED *unpacked = (glUniformMatrix4x3dv_PACKED *)packed; \
    glUniformMatrix4x3dv_ARGS *args = (glUniformMatrix4x3dv_ARGS *)&unpacked->args; \
    glUniformMatrix4x3dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x3dv(glUniformMatrix4x3dv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix4x3dv(glUniformMatrix4x3dv_PACKED *_dst glUniformMatrix4x3dv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix4x3dv_PTR)(glUniformMatrix4x3dv_ARG_EXPAND);
#endif
#ifndef glUniformMatrix4x3fv_RETURN
#define glUniformMatrix4x3fv_RETURN void
#define glUniformMatrix4x3fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x3fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4x3fv_ARG_NAMES_TAIL , location, count, transpose, value
#define glUniformMatrix4x3fv_ARG_EXPAND_TAIL , GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define forward_glUniformMatrix4x3fv(_location, _count, _transpose, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformMatrix4x3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformMatrix4x3fv(dst, _location, _count, _transpose, _value), NULL); \
    });
#define call_glUniformMatrix4x3fv(packed, ret_v) do { \
    glUniformMatrix4x3fv_PACKED *unpacked = (glUniformMatrix4x3fv_PACKED *)packed; \
    glUniformMatrix4x3fv_ARGS *args = (glUniformMatrix4x3fv_ARGS *)&unpacked->args; \
    glUniformMatrix4x3fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x3fv(glUniformMatrix4x3fv_ARG_EXPAND);
packed_call_t *pack_glUniformMatrix4x3fv(glUniformMatrix4x3fv_PACKED *_dst glUniformMatrix4x3fv_ARG_EXPAND_TAIL);
typedef void (*glUniformMatrix4x3fv_PTR)(glUniformMatrix4x3fv_ARG_EXPAND);
#endif
#ifndef glUniformSubroutinesuiv_RETURN
#define glUniformSubroutinesuiv_RETURN void
#define glUniformSubroutinesuiv_ARG_NAMES shadertype, count, indices
#define glUniformSubroutinesuiv_ARG_EXPAND GLenum shadertype, GLsizei count, const GLuint * indices
#define glUniformSubroutinesuiv_ARG_NAMES_TAIL , shadertype, count, indices
#define glUniformSubroutinesuiv_ARG_EXPAND_TAIL , GLenum shadertype, GLsizei count, const GLuint * indices
#define forward_glUniformSubroutinesuiv(_shadertype, _count, _indices) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformSubroutinesuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformSubroutinesuiv(dst, _shadertype, _count, _indices), NULL); \
    });
#define call_glUniformSubroutinesuiv(packed, ret_v) do { \
    glUniformSubroutinesuiv_PACKED *unpacked = (glUniformSubroutinesuiv_PACKED *)packed; \
    glUniformSubroutinesuiv_ARGS *args = (glUniformSubroutinesuiv_ARGS *)&unpacked->args; \
    glUniformSubroutinesuiv(args->shadertype, args->count, args->indices);; \
} while(0)
void glUniformSubroutinesuiv(glUniformSubroutinesuiv_ARG_EXPAND);
packed_call_t *pack_glUniformSubroutinesuiv(glUniformSubroutinesuiv_PACKED *_dst glUniformSubroutinesuiv_ARG_EXPAND_TAIL);
typedef void (*glUniformSubroutinesuiv_PTR)(glUniformSubroutinesuiv_ARG_EXPAND);
#endif
#ifndef glUniformui64NV_RETURN
#define glUniformui64NV_RETURN void
#define glUniformui64NV_ARG_NAMES location, value
#define glUniformui64NV_ARG_EXPAND GLint location, GLuint64EXT value
#define glUniformui64NV_ARG_NAMES_TAIL , location, value
#define glUniformui64NV_ARG_EXPAND_TAIL , GLint location, GLuint64EXT value
#define forward_glUniformui64NV(_location, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformui64NV(dst, _location, _value), NULL); \
    });
#define call_glUniformui64NV(packed, ret_v) do { \
    glUniformui64NV_PACKED *unpacked = (glUniformui64NV_PACKED *)packed; \
    glUniformui64NV_ARGS *args = (glUniformui64NV_ARGS *)&unpacked->args; \
    glUniformui64NV(args->location, args->value);; \
} while(0)
void glUniformui64NV(glUniformui64NV_ARG_EXPAND);
packed_call_t *pack_glUniformui64NV(glUniformui64NV_PACKED *_dst glUniformui64NV_ARG_EXPAND_TAIL);
typedef void (*glUniformui64NV_PTR)(glUniformui64NV_ARG_EXPAND);
#endif
#ifndef glUniformui64vNV_RETURN
#define glUniformui64vNV_RETURN void
#define glUniformui64vNV_ARG_NAMES location, count, value
#define glUniformui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniformui64vNV_ARG_NAMES_TAIL , location, count, value
#define glUniformui64vNV_ARG_EXPAND_TAIL , GLint location, GLsizei count, const GLuint64EXT * value
#define forward_glUniformui64vNV(_location, _count, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glUniformui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUniformui64vNV(dst, _location, _count, _value), NULL); \
    });
#define call_glUniformui64vNV(packed, ret_v) do { \
    glUniformui64vNV_PACKED *unpacked = (glUniformui64vNV_PACKED *)packed; \
    glUniformui64vNV_ARGS *args = (glUniformui64vNV_ARGS *)&unpacked->args; \
    glUniformui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniformui64vNV(glUniformui64vNV_ARG_EXPAND);
packed_call_t *pack_glUniformui64vNV(glUniformui64vNV_PACKED *_dst glUniformui64vNV_ARG_EXPAND_TAIL);
typedef void (*glUniformui64vNV_PTR)(glUniformui64vNV_ARG_EXPAND);
#endif
#ifndef glUnlockArraysEXT_RETURN
#define glUnlockArraysEXT_RETURN void
#define glUnlockArraysEXT_ARG_NAMES 
#define glUnlockArraysEXT_ARG_EXPAND 
#define glUnlockArraysEXT_ARG_NAMES_TAIL 
#define glUnlockArraysEXT_ARG_EXPAND_TAIL 
#define forward_glUnlockArraysEXT() \
    ({ \
        void *dst = remote_dma(sizeof(glUnlockArraysEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUnlockArraysEXT(dst), NULL); \
    });
#define call_glUnlockArraysEXT(packed, ret_v) do { \
    glUnlockArraysEXT();; \
} while(0)
void glUnlockArraysEXT(glUnlockArraysEXT_ARG_EXPAND);
packed_call_t *pack_glUnlockArraysEXT(glUnlockArraysEXT_PACKED *_dst glUnlockArraysEXT_ARG_EXPAND_TAIL);
typedef void (*glUnlockArraysEXT_PTR)(glUnlockArraysEXT_ARG_EXPAND);
#endif
#ifndef glUnmapBuffer_RETURN
#define glUnmapBuffer_RETURN GLboolean
#define glUnmapBuffer_ARG_NAMES target
#define glUnmapBuffer_ARG_EXPAND GLenum target
#define glUnmapBuffer_ARG_NAMES_TAIL , target
#define glUnmapBuffer_ARG_EXPAND_TAIL , GLenum target
#define forward_glUnmapBuffer(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glUnmapBuffer_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glUnmapBuffer(dst, _target), &ret); \
        ret; \
    });
#define call_glUnmapBuffer(packed, ret_v) do { \
    glUnmapBuffer_PACKED *unpacked = (glUnmapBuffer_PACKED *)packed; \
    glUnmapBuffer_ARGS *args = (glUnmapBuffer_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glUnmapBuffer(args->target);; \
    } else { \
        glUnmapBuffer(args->target);; \
    } \
} while(0)
GLboolean glUnmapBuffer(glUnmapBuffer_ARG_EXPAND);
packed_call_t *pack_glUnmapBuffer(glUnmapBuffer_PACKED *_dst glUnmapBuffer_ARG_EXPAND_TAIL);
typedef GLboolean (*glUnmapBuffer_PTR)(glUnmapBuffer_ARG_EXPAND);
#endif
#ifndef glUnmapBufferARB_RETURN
#define glUnmapBufferARB_RETURN GLboolean
#define glUnmapBufferARB_ARG_NAMES target
#define glUnmapBufferARB_ARG_EXPAND GLenum target
#define glUnmapBufferARB_ARG_NAMES_TAIL , target
#define glUnmapBufferARB_ARG_EXPAND_TAIL , GLenum target
#define forward_glUnmapBufferARB(_target) \
    ({ \
        void *dst = remote_dma(sizeof(glUnmapBufferARB_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glUnmapBufferARB(dst, _target), &ret); \
        ret; \
    });
#define call_glUnmapBufferARB(packed, ret_v) do { \
    glUnmapBufferARB_PACKED *unpacked = (glUnmapBufferARB_PACKED *)packed; \
    glUnmapBufferARB_ARGS *args = (glUnmapBufferARB_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glUnmapBufferARB(args->target);; \
    } else { \
        glUnmapBufferARB(args->target);; \
    } \
} while(0)
GLboolean glUnmapBufferARB(glUnmapBufferARB_ARG_EXPAND);
packed_call_t *pack_glUnmapBufferARB(glUnmapBufferARB_PACKED *_dst glUnmapBufferARB_ARG_EXPAND_TAIL);
typedef GLboolean (*glUnmapBufferARB_PTR)(glUnmapBufferARB_ARG_EXPAND);
#endif
#ifndef glUnmapNamedBufferEXT_RETURN
#define glUnmapNamedBufferEXT_RETURN GLboolean
#define glUnmapNamedBufferEXT_ARG_NAMES buffer
#define glUnmapNamedBufferEXT_ARG_EXPAND GLuint buffer
#define glUnmapNamedBufferEXT_ARG_NAMES_TAIL , buffer
#define glUnmapNamedBufferEXT_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glUnmapNamedBufferEXT(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glUnmapNamedBufferEXT_PACKED)); \
        GLboolean ret = (GLboolean)0; \
        remote_dma_send((packed_call_t *)pack_glUnmapNamedBufferEXT(dst, _buffer), &ret); \
        ret; \
    });
#define call_glUnmapNamedBufferEXT(packed, ret_v) do { \
    glUnmapNamedBufferEXT_PACKED *unpacked = (glUnmapNamedBufferEXT_PACKED *)packed; \
    glUnmapNamedBufferEXT_ARGS *args = (glUnmapNamedBufferEXT_ARGS *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glUnmapNamedBufferEXT(args->buffer);; \
    } else { \
        glUnmapNamedBufferEXT(args->buffer);; \
    } \
} while(0)
GLboolean glUnmapNamedBufferEXT(glUnmapNamedBufferEXT_ARG_EXPAND);
packed_call_t *pack_glUnmapNamedBufferEXT(glUnmapNamedBufferEXT_PACKED *_dst glUnmapNamedBufferEXT_ARG_EXPAND_TAIL);
typedef GLboolean (*glUnmapNamedBufferEXT_PTR)(glUnmapNamedBufferEXT_ARG_EXPAND);
#endif
#ifndef glUnmapObjectBufferATI_RETURN
#define glUnmapObjectBufferATI_RETURN void
#define glUnmapObjectBufferATI_ARG_NAMES buffer
#define glUnmapObjectBufferATI_ARG_EXPAND GLuint buffer
#define glUnmapObjectBufferATI_ARG_NAMES_TAIL , buffer
#define glUnmapObjectBufferATI_ARG_EXPAND_TAIL , GLuint buffer
#define forward_glUnmapObjectBufferATI(_buffer) \
    ({ \
        void *dst = remote_dma(sizeof(glUnmapObjectBufferATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUnmapObjectBufferATI(dst, _buffer), NULL); \
    });
#define call_glUnmapObjectBufferATI(packed, ret_v) do { \
    glUnmapObjectBufferATI_PACKED *unpacked = (glUnmapObjectBufferATI_PACKED *)packed; \
    glUnmapObjectBufferATI_ARGS *args = (glUnmapObjectBufferATI_ARGS *)&unpacked->args; \
    glUnmapObjectBufferATI(args->buffer);; \
} while(0)
void glUnmapObjectBufferATI(glUnmapObjectBufferATI_ARG_EXPAND);
packed_call_t *pack_glUnmapObjectBufferATI(glUnmapObjectBufferATI_PACKED *_dst glUnmapObjectBufferATI_ARG_EXPAND_TAIL);
typedef void (*glUnmapObjectBufferATI_PTR)(glUnmapObjectBufferATI_ARG_EXPAND);
#endif
#ifndef glUnmapTexture2DINTEL_RETURN
#define glUnmapTexture2DINTEL_RETURN void
#define glUnmapTexture2DINTEL_ARG_NAMES texture, level
#define glUnmapTexture2DINTEL_ARG_EXPAND GLuint texture, GLint level
#define glUnmapTexture2DINTEL_ARG_NAMES_TAIL , texture, level
#define glUnmapTexture2DINTEL_ARG_EXPAND_TAIL , GLuint texture, GLint level
#define forward_glUnmapTexture2DINTEL(_texture, _level) \
    ({ \
        void *dst = remote_dma(sizeof(glUnmapTexture2DINTEL_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUnmapTexture2DINTEL(dst, _texture, _level), NULL); \
    });
#define call_glUnmapTexture2DINTEL(packed, ret_v) do { \
    glUnmapTexture2DINTEL_PACKED *unpacked = (glUnmapTexture2DINTEL_PACKED *)packed; \
    glUnmapTexture2DINTEL_ARGS *args = (glUnmapTexture2DINTEL_ARGS *)&unpacked->args; \
    glUnmapTexture2DINTEL(args->texture, args->level);; \
} while(0)
void glUnmapTexture2DINTEL(glUnmapTexture2DINTEL_ARG_EXPAND);
packed_call_t *pack_glUnmapTexture2DINTEL(glUnmapTexture2DINTEL_PACKED *_dst glUnmapTexture2DINTEL_ARG_EXPAND_TAIL);
typedef void (*glUnmapTexture2DINTEL_PTR)(glUnmapTexture2DINTEL_ARG_EXPAND);
#endif
#ifndef glUpdateObjectBufferATI_RETURN
#define glUpdateObjectBufferATI_RETURN void
#define glUpdateObjectBufferATI_ARG_NAMES buffer, offset, size, pointer, preserve
#define glUpdateObjectBufferATI_ARG_EXPAND GLuint buffer, GLuint offset, GLsizei size, const GLvoid * pointer, GLenum preserve
#define glUpdateObjectBufferATI_ARG_NAMES_TAIL , buffer, offset, size, pointer, preserve
#define glUpdateObjectBufferATI_ARG_EXPAND_TAIL , GLuint buffer, GLuint offset, GLsizei size, const GLvoid * pointer, GLenum preserve
#define forward_glUpdateObjectBufferATI(_buffer, _offset, _size, _pointer, _preserve) \
    ({ \
        void *dst = remote_dma(sizeof(glUpdateObjectBufferATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUpdateObjectBufferATI(dst, _buffer, _offset, _size, _pointer, _preserve), NULL); \
    });
#define call_glUpdateObjectBufferATI(packed, ret_v) do { \
    glUpdateObjectBufferATI_PACKED *unpacked = (glUpdateObjectBufferATI_PACKED *)packed; \
    glUpdateObjectBufferATI_ARGS *args = (glUpdateObjectBufferATI_ARGS *)&unpacked->args; \
    glUpdateObjectBufferATI(args->buffer, args->offset, args->size, args->pointer, args->preserve);; \
} while(0)
void glUpdateObjectBufferATI(glUpdateObjectBufferATI_ARG_EXPAND);
packed_call_t *pack_glUpdateObjectBufferATI(glUpdateObjectBufferATI_PACKED *_dst glUpdateObjectBufferATI_ARG_EXPAND_TAIL);
typedef void (*glUpdateObjectBufferATI_PTR)(glUpdateObjectBufferATI_ARG_EXPAND);
#endif
#ifndef glUseProgram_RETURN
#define glUseProgram_RETURN void
#define glUseProgram_ARG_NAMES program
#define glUseProgram_ARG_EXPAND GLuint program
#define glUseProgram_ARG_NAMES_TAIL , program
#define glUseProgram_ARG_EXPAND_TAIL , GLuint program
#define forward_glUseProgram(_program) \
    ({ \
        void *dst = remote_dma(sizeof(glUseProgram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUseProgram(dst, _program), NULL); \
    });
#define call_glUseProgram(packed, ret_v) do { \
    glUseProgram_PACKED *unpacked = (glUseProgram_PACKED *)packed; \
    glUseProgram_ARGS *args = (glUseProgram_ARGS *)&unpacked->args; \
    glUseProgram(args->program);; \
} while(0)
void glUseProgram(glUseProgram_ARG_EXPAND);
packed_call_t *pack_glUseProgram(glUseProgram_PACKED *_dst glUseProgram_ARG_EXPAND_TAIL);
typedef void (*glUseProgram_PTR)(glUseProgram_ARG_EXPAND);
#endif
#ifndef glUseProgramObjectARB_RETURN
#define glUseProgramObjectARB_RETURN void
#define glUseProgramObjectARB_ARG_NAMES programObj
#define glUseProgramObjectARB_ARG_EXPAND GLhandleARB programObj
#define glUseProgramObjectARB_ARG_NAMES_TAIL , programObj
#define glUseProgramObjectARB_ARG_EXPAND_TAIL , GLhandleARB programObj
#define forward_glUseProgramObjectARB(_programObj) \
    ({ \
        void *dst = remote_dma(sizeof(glUseProgramObjectARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUseProgramObjectARB(dst, _programObj), NULL); \
    });
#define call_glUseProgramObjectARB(packed, ret_v) do { \
    glUseProgramObjectARB_PACKED *unpacked = (glUseProgramObjectARB_PACKED *)packed; \
    glUseProgramObjectARB_ARGS *args = (glUseProgramObjectARB_ARGS *)&unpacked->args; \
    glUseProgramObjectARB(args->programObj);; \
} while(0)
void glUseProgramObjectARB(glUseProgramObjectARB_ARG_EXPAND);
packed_call_t *pack_glUseProgramObjectARB(glUseProgramObjectARB_PACKED *_dst glUseProgramObjectARB_ARG_EXPAND_TAIL);
typedef void (*glUseProgramObjectARB_PTR)(glUseProgramObjectARB_ARG_EXPAND);
#endif
#ifndef glUseProgramStages_RETURN
#define glUseProgramStages_RETURN void
#define glUseProgramStages_ARG_NAMES pipeline, stages, program
#define glUseProgramStages_ARG_EXPAND GLuint pipeline, GLbitfield stages, GLuint program
#define glUseProgramStages_ARG_NAMES_TAIL , pipeline, stages, program
#define glUseProgramStages_ARG_EXPAND_TAIL , GLuint pipeline, GLbitfield stages, GLuint program
#define forward_glUseProgramStages(_pipeline, _stages, _program) \
    ({ \
        void *dst = remote_dma(sizeof(glUseProgramStages_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUseProgramStages(dst, _pipeline, _stages, _program), NULL); \
    });
#define call_glUseProgramStages(packed, ret_v) do { \
    glUseProgramStages_PACKED *unpacked = (glUseProgramStages_PACKED *)packed; \
    glUseProgramStages_ARGS *args = (glUseProgramStages_ARGS *)&unpacked->args; \
    glUseProgramStages(args->pipeline, args->stages, args->program);; \
} while(0)
void glUseProgramStages(glUseProgramStages_ARG_EXPAND);
packed_call_t *pack_glUseProgramStages(glUseProgramStages_PACKED *_dst glUseProgramStages_ARG_EXPAND_TAIL);
typedef void (*glUseProgramStages_PTR)(glUseProgramStages_ARG_EXPAND);
#endif
#ifndef glUseShaderProgramEXT_RETURN
#define glUseShaderProgramEXT_RETURN void
#define glUseShaderProgramEXT_ARG_NAMES type, program
#define glUseShaderProgramEXT_ARG_EXPAND GLenum type, GLuint program
#define glUseShaderProgramEXT_ARG_NAMES_TAIL , type, program
#define glUseShaderProgramEXT_ARG_EXPAND_TAIL , GLenum type, GLuint program
#define forward_glUseShaderProgramEXT(_type, _program) \
    ({ \
        void *dst = remote_dma(sizeof(glUseShaderProgramEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glUseShaderProgramEXT(dst, _type, _program), NULL); \
    });
#define call_glUseShaderProgramEXT(packed, ret_v) do { \
    glUseShaderProgramEXT_PACKED *unpacked = (glUseShaderProgramEXT_PACKED *)packed; \
    glUseShaderProgramEXT_ARGS *args = (glUseShaderProgramEXT_ARGS *)&unpacked->args; \
    glUseShaderProgramEXT(args->type, args->program);; \
} while(0)
void glUseShaderProgramEXT(glUseShaderProgramEXT_ARG_EXPAND);
packed_call_t *pack_glUseShaderProgramEXT(glUseShaderProgramEXT_PACKED *_dst glUseShaderProgramEXT_ARG_EXPAND_TAIL);
typedef void (*glUseShaderProgramEXT_PTR)(glUseShaderProgramEXT_ARG_EXPAND);
#endif
#ifndef glVDPAUFiniNV_RETURN
#define glVDPAUFiniNV_RETURN void
#define glVDPAUFiniNV_ARG_NAMES 
#define glVDPAUFiniNV_ARG_EXPAND 
#define glVDPAUFiniNV_ARG_NAMES_TAIL 
#define glVDPAUFiniNV_ARG_EXPAND_TAIL 
#define forward_glVDPAUFiniNV() \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUFiniNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUFiniNV(dst), NULL); \
    });
#define call_glVDPAUFiniNV(packed, ret_v) do { \
    glVDPAUFiniNV();; \
} while(0)
void glVDPAUFiniNV(glVDPAUFiniNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUFiniNV(glVDPAUFiniNV_PACKED *_dst glVDPAUFiniNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUFiniNV_PTR)(glVDPAUFiniNV_ARG_EXPAND);
#endif
#ifndef glVDPAUGetSurfaceivNV_RETURN
#define glVDPAUGetSurfaceivNV_RETURN void
#define glVDPAUGetSurfaceivNV_ARG_NAMES surface, pname, bufSize, length, values
#define glVDPAUGetSurfaceivNV_ARG_EXPAND GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values
#define glVDPAUGetSurfaceivNV_ARG_NAMES_TAIL , surface, pname, bufSize, length, values
#define glVDPAUGetSurfaceivNV_ARG_EXPAND_TAIL , GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values
#define forward_glVDPAUGetSurfaceivNV(_surface, _pname, _bufSize, _length, _values) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUGetSurfaceivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUGetSurfaceivNV(dst, _surface, _pname, _bufSize, _length, _values), NULL); \
    });
#define call_glVDPAUGetSurfaceivNV(packed, ret_v) do { \
    glVDPAUGetSurfaceivNV_PACKED *unpacked = (glVDPAUGetSurfaceivNV_PACKED *)packed; \
    glVDPAUGetSurfaceivNV_ARGS *args = (glVDPAUGetSurfaceivNV_ARGS *)&unpacked->args; \
    glVDPAUGetSurfaceivNV(args->surface, args->pname, args->bufSize, args->length, args->values);; \
} while(0)
void glVDPAUGetSurfaceivNV(glVDPAUGetSurfaceivNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUGetSurfaceivNV(glVDPAUGetSurfaceivNV_PACKED *_dst glVDPAUGetSurfaceivNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUGetSurfaceivNV_PTR)(glVDPAUGetSurfaceivNV_ARG_EXPAND);
#endif
#ifndef glVDPAUInitNV_RETURN
#define glVDPAUInitNV_RETURN void
#define glVDPAUInitNV_ARG_NAMES vdpDevice, getProcAddress
#define glVDPAUInitNV_ARG_EXPAND const GLvoid * vdpDevice, const GLvoid * getProcAddress
#define glVDPAUInitNV_ARG_NAMES_TAIL , vdpDevice, getProcAddress
#define glVDPAUInitNV_ARG_EXPAND_TAIL , const GLvoid * vdpDevice, const GLvoid * getProcAddress
#define forward_glVDPAUInitNV(_vdpDevice, _getProcAddress) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUInitNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUInitNV(dst, _vdpDevice, _getProcAddress), NULL); \
    });
#define call_glVDPAUInitNV(packed, ret_v) do { \
    glVDPAUInitNV_PACKED *unpacked = (glVDPAUInitNV_PACKED *)packed; \
    glVDPAUInitNV_ARGS *args = (glVDPAUInitNV_ARGS *)&unpacked->args; \
    glVDPAUInitNV(args->vdpDevice, args->getProcAddress);; \
} while(0)
void glVDPAUInitNV(glVDPAUInitNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUInitNV(glVDPAUInitNV_PACKED *_dst glVDPAUInitNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUInitNV_PTR)(glVDPAUInitNV_ARG_EXPAND);
#endif
#ifndef glVDPAUIsSurfaceNV_RETURN
#define glVDPAUIsSurfaceNV_RETURN void
#define glVDPAUIsSurfaceNV_ARG_NAMES surface
#define glVDPAUIsSurfaceNV_ARG_EXPAND GLvdpauSurfaceNV surface
#define glVDPAUIsSurfaceNV_ARG_NAMES_TAIL , surface
#define glVDPAUIsSurfaceNV_ARG_EXPAND_TAIL , GLvdpauSurfaceNV surface
#define forward_glVDPAUIsSurfaceNV(_surface) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUIsSurfaceNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUIsSurfaceNV(dst, _surface), NULL); \
    });
#define call_glVDPAUIsSurfaceNV(packed, ret_v) do { \
    glVDPAUIsSurfaceNV_PACKED *unpacked = (glVDPAUIsSurfaceNV_PACKED *)packed; \
    glVDPAUIsSurfaceNV_ARGS *args = (glVDPAUIsSurfaceNV_ARGS *)&unpacked->args; \
    glVDPAUIsSurfaceNV(args->surface);; \
} while(0)
void glVDPAUIsSurfaceNV(glVDPAUIsSurfaceNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUIsSurfaceNV(glVDPAUIsSurfaceNV_PACKED *_dst glVDPAUIsSurfaceNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUIsSurfaceNV_PTR)(glVDPAUIsSurfaceNV_ARG_EXPAND);
#endif
#ifndef glVDPAUMapSurfacesNV_RETURN
#define glVDPAUMapSurfacesNV_RETURN void
#define glVDPAUMapSurfacesNV_ARG_NAMES numSurfaces, surfaces
#define glVDPAUMapSurfacesNV_ARG_EXPAND GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces
#define glVDPAUMapSurfacesNV_ARG_NAMES_TAIL , numSurfaces, surfaces
#define glVDPAUMapSurfacesNV_ARG_EXPAND_TAIL , GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces
#define forward_glVDPAUMapSurfacesNV(_numSurfaces, _surfaces) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUMapSurfacesNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUMapSurfacesNV(dst, _numSurfaces, _surfaces), NULL); \
    });
#define call_glVDPAUMapSurfacesNV(packed, ret_v) do { \
    glVDPAUMapSurfacesNV_PACKED *unpacked = (glVDPAUMapSurfacesNV_PACKED *)packed; \
    glVDPAUMapSurfacesNV_ARGS *args = (glVDPAUMapSurfacesNV_ARGS *)&unpacked->args; \
    glVDPAUMapSurfacesNV(args->numSurfaces, args->surfaces);; \
} while(0)
void glVDPAUMapSurfacesNV(glVDPAUMapSurfacesNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUMapSurfacesNV(glVDPAUMapSurfacesNV_PACKED *_dst glVDPAUMapSurfacesNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUMapSurfacesNV_PTR)(glVDPAUMapSurfacesNV_ARG_EXPAND);
#endif
#ifndef glVDPAURegisterOutputSurfaceNV_RETURN
#define glVDPAURegisterOutputSurfaceNV_RETURN GLvdpauSurfaceNV
#define glVDPAURegisterOutputSurfaceNV_ARG_NAMES vdpSurface, target, numTextureNames, textureNames
#define glVDPAURegisterOutputSurfaceNV_ARG_EXPAND GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames
#define glVDPAURegisterOutputSurfaceNV_ARG_NAMES_TAIL , vdpSurface, target, numTextureNames, textureNames
#define glVDPAURegisterOutputSurfaceNV_ARG_EXPAND_TAIL , GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames
#define forward_glVDPAURegisterOutputSurfaceNV(_vdpSurface, _target, _numTextureNames, _textureNames) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAURegisterOutputSurfaceNV_PACKED)); \
        GLvdpauSurfaceNV ret = (GLvdpauSurfaceNV)0; \
        remote_dma_send((packed_call_t *)pack_glVDPAURegisterOutputSurfaceNV(dst, _vdpSurface, _target, _numTextureNames, _textureNames), &ret); \
        ret; \
    });
#define call_glVDPAURegisterOutputSurfaceNV(packed, ret_v) do { \
    glVDPAURegisterOutputSurfaceNV_PACKED *unpacked = (glVDPAURegisterOutputSurfaceNV_PACKED *)packed; \
    glVDPAURegisterOutputSurfaceNV_ARGS *args = (glVDPAURegisterOutputSurfaceNV_ARGS *)&unpacked->args; \
    GLvdpauSurfaceNV *ret = (GLvdpauSurfaceNV *)ret_v; \
    if (ret != NULL) { \
        *ret = glVDPAURegisterOutputSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } else { \
        glVDPAURegisterOutputSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } \
} while(0)
GLvdpauSurfaceNV glVDPAURegisterOutputSurfaceNV(glVDPAURegisterOutputSurfaceNV_ARG_EXPAND);
packed_call_t *pack_glVDPAURegisterOutputSurfaceNV(glVDPAURegisterOutputSurfaceNV_PACKED *_dst glVDPAURegisterOutputSurfaceNV_ARG_EXPAND_TAIL);
typedef GLvdpauSurfaceNV (*glVDPAURegisterOutputSurfaceNV_PTR)(glVDPAURegisterOutputSurfaceNV_ARG_EXPAND);
#endif
#ifndef glVDPAURegisterVideoSurfaceNV_RETURN
#define glVDPAURegisterVideoSurfaceNV_RETURN GLvdpauSurfaceNV
#define glVDPAURegisterVideoSurfaceNV_ARG_NAMES vdpSurface, target, numTextureNames, textureNames
#define glVDPAURegisterVideoSurfaceNV_ARG_EXPAND const GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames
#define glVDPAURegisterVideoSurfaceNV_ARG_NAMES_TAIL , vdpSurface, target, numTextureNames, textureNames
#define glVDPAURegisterVideoSurfaceNV_ARG_EXPAND_TAIL , const GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames
#define forward_glVDPAURegisterVideoSurfaceNV(_vdpSurface, _target, _numTextureNames, _textureNames) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAURegisterVideoSurfaceNV_PACKED)); \
        GLvdpauSurfaceNV ret = (GLvdpauSurfaceNV)0; \
        remote_dma_send((packed_call_t *)pack_glVDPAURegisterVideoSurfaceNV(dst, _vdpSurface, _target, _numTextureNames, _textureNames), &ret); \
        ret; \
    });
#define call_glVDPAURegisterVideoSurfaceNV(packed, ret_v) do { \
    glVDPAURegisterVideoSurfaceNV_PACKED *unpacked = (glVDPAURegisterVideoSurfaceNV_PACKED *)packed; \
    glVDPAURegisterVideoSurfaceNV_ARGS *args = (glVDPAURegisterVideoSurfaceNV_ARGS *)&unpacked->args; \
    GLvdpauSurfaceNV *ret = (GLvdpauSurfaceNV *)ret_v; \
    if (ret != NULL) { \
        *ret = glVDPAURegisterVideoSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } else { \
        glVDPAURegisterVideoSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } \
} while(0)
GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceNV(glVDPAURegisterVideoSurfaceNV_ARG_EXPAND);
packed_call_t *pack_glVDPAURegisterVideoSurfaceNV(glVDPAURegisterVideoSurfaceNV_PACKED *_dst glVDPAURegisterVideoSurfaceNV_ARG_EXPAND_TAIL);
typedef GLvdpauSurfaceNV (*glVDPAURegisterVideoSurfaceNV_PTR)(glVDPAURegisterVideoSurfaceNV_ARG_EXPAND);
#endif
#ifndef glVDPAUSurfaceAccessNV_RETURN
#define glVDPAUSurfaceAccessNV_RETURN void
#define glVDPAUSurfaceAccessNV_ARG_NAMES surface, access
#define glVDPAUSurfaceAccessNV_ARG_EXPAND GLvdpauSurfaceNV surface, GLenum access
#define glVDPAUSurfaceAccessNV_ARG_NAMES_TAIL , surface, access
#define glVDPAUSurfaceAccessNV_ARG_EXPAND_TAIL , GLvdpauSurfaceNV surface, GLenum access
#define forward_glVDPAUSurfaceAccessNV(_surface, _access) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUSurfaceAccessNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUSurfaceAccessNV(dst, _surface, _access), NULL); \
    });
#define call_glVDPAUSurfaceAccessNV(packed, ret_v) do { \
    glVDPAUSurfaceAccessNV_PACKED *unpacked = (glVDPAUSurfaceAccessNV_PACKED *)packed; \
    glVDPAUSurfaceAccessNV_ARGS *args = (glVDPAUSurfaceAccessNV_ARGS *)&unpacked->args; \
    glVDPAUSurfaceAccessNV(args->surface, args->access);; \
} while(0)
void glVDPAUSurfaceAccessNV(glVDPAUSurfaceAccessNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUSurfaceAccessNV(glVDPAUSurfaceAccessNV_PACKED *_dst glVDPAUSurfaceAccessNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUSurfaceAccessNV_PTR)(glVDPAUSurfaceAccessNV_ARG_EXPAND);
#endif
#ifndef glVDPAUUnmapSurfacesNV_RETURN
#define glVDPAUUnmapSurfacesNV_RETURN void
#define glVDPAUUnmapSurfacesNV_ARG_NAMES numSurface, surfaces
#define glVDPAUUnmapSurfacesNV_ARG_EXPAND GLsizei numSurface, const GLvdpauSurfaceNV * surfaces
#define glVDPAUUnmapSurfacesNV_ARG_NAMES_TAIL , numSurface, surfaces
#define glVDPAUUnmapSurfacesNV_ARG_EXPAND_TAIL , GLsizei numSurface, const GLvdpauSurfaceNV * surfaces
#define forward_glVDPAUUnmapSurfacesNV(_numSurface, _surfaces) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUUnmapSurfacesNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUUnmapSurfacesNV(dst, _numSurface, _surfaces), NULL); \
    });
#define call_glVDPAUUnmapSurfacesNV(packed, ret_v) do { \
    glVDPAUUnmapSurfacesNV_PACKED *unpacked = (glVDPAUUnmapSurfacesNV_PACKED *)packed; \
    glVDPAUUnmapSurfacesNV_ARGS *args = (glVDPAUUnmapSurfacesNV_ARGS *)&unpacked->args; \
    glVDPAUUnmapSurfacesNV(args->numSurface, args->surfaces);; \
} while(0)
void glVDPAUUnmapSurfacesNV(glVDPAUUnmapSurfacesNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUUnmapSurfacesNV(glVDPAUUnmapSurfacesNV_PACKED *_dst glVDPAUUnmapSurfacesNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUUnmapSurfacesNV_PTR)(glVDPAUUnmapSurfacesNV_ARG_EXPAND);
#endif
#ifndef glVDPAUUnregisterSurfaceNV_RETURN
#define glVDPAUUnregisterSurfaceNV_RETURN void
#define glVDPAUUnregisterSurfaceNV_ARG_NAMES surface
#define glVDPAUUnregisterSurfaceNV_ARG_EXPAND GLvdpauSurfaceNV surface
#define glVDPAUUnregisterSurfaceNV_ARG_NAMES_TAIL , surface
#define glVDPAUUnregisterSurfaceNV_ARG_EXPAND_TAIL , GLvdpauSurfaceNV surface
#define forward_glVDPAUUnregisterSurfaceNV(_surface) \
    ({ \
        void *dst = remote_dma(sizeof(glVDPAUUnregisterSurfaceNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVDPAUUnregisterSurfaceNV(dst, _surface), NULL); \
    });
#define call_glVDPAUUnregisterSurfaceNV(packed, ret_v) do { \
    glVDPAUUnregisterSurfaceNV_PACKED *unpacked = (glVDPAUUnregisterSurfaceNV_PACKED *)packed; \
    glVDPAUUnregisterSurfaceNV_ARGS *args = (glVDPAUUnregisterSurfaceNV_ARGS *)&unpacked->args; \
    glVDPAUUnregisterSurfaceNV(args->surface);; \
} while(0)
void glVDPAUUnregisterSurfaceNV(glVDPAUUnregisterSurfaceNV_ARG_EXPAND);
packed_call_t *pack_glVDPAUUnregisterSurfaceNV(glVDPAUUnregisterSurfaceNV_PACKED *_dst glVDPAUUnregisterSurfaceNV_ARG_EXPAND_TAIL);
typedef void (*glVDPAUUnregisterSurfaceNV_PTR)(glVDPAUUnregisterSurfaceNV_ARG_EXPAND);
#endif
#ifndef glValidateProgram_RETURN
#define glValidateProgram_RETURN void
#define glValidateProgram_ARG_NAMES program
#define glValidateProgram_ARG_EXPAND GLuint program
#define glValidateProgram_ARG_NAMES_TAIL , program
#define glValidateProgram_ARG_EXPAND_TAIL , GLuint program
#define forward_glValidateProgram(_program) \
    ({ \
        void *dst = remote_dma(sizeof(glValidateProgram_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glValidateProgram(dst, _program), NULL); \
    });
#define call_glValidateProgram(packed, ret_v) do { \
    glValidateProgram_PACKED *unpacked = (glValidateProgram_PACKED *)packed; \
    glValidateProgram_ARGS *args = (glValidateProgram_ARGS *)&unpacked->args; \
    glValidateProgram(args->program);; \
} while(0)
void glValidateProgram(glValidateProgram_ARG_EXPAND);
packed_call_t *pack_glValidateProgram(glValidateProgram_PACKED *_dst glValidateProgram_ARG_EXPAND_TAIL);
typedef void (*glValidateProgram_PTR)(glValidateProgram_ARG_EXPAND);
#endif
#ifndef glValidateProgramARB_RETURN
#define glValidateProgramARB_RETURN void
#define glValidateProgramARB_ARG_NAMES programObj
#define glValidateProgramARB_ARG_EXPAND GLhandleARB programObj
#define glValidateProgramARB_ARG_NAMES_TAIL , programObj
#define glValidateProgramARB_ARG_EXPAND_TAIL , GLhandleARB programObj
#define forward_glValidateProgramARB(_programObj) \
    ({ \
        void *dst = remote_dma(sizeof(glValidateProgramARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glValidateProgramARB(dst, _programObj), NULL); \
    });
#define call_glValidateProgramARB(packed, ret_v) do { \
    glValidateProgramARB_PACKED *unpacked = (glValidateProgramARB_PACKED *)packed; \
    glValidateProgramARB_ARGS *args = (glValidateProgramARB_ARGS *)&unpacked->args; \
    glValidateProgramARB(args->programObj);; \
} while(0)
void glValidateProgramARB(glValidateProgramARB_ARG_EXPAND);
packed_call_t *pack_glValidateProgramARB(glValidateProgramARB_PACKED *_dst glValidateProgramARB_ARG_EXPAND_TAIL);
typedef void (*glValidateProgramARB_PTR)(glValidateProgramARB_ARG_EXPAND);
#endif
#ifndef glValidateProgramPipeline_RETURN
#define glValidateProgramPipeline_RETURN void
#define glValidateProgramPipeline_ARG_NAMES pipeline
#define glValidateProgramPipeline_ARG_EXPAND GLuint pipeline
#define glValidateProgramPipeline_ARG_NAMES_TAIL , pipeline
#define glValidateProgramPipeline_ARG_EXPAND_TAIL , GLuint pipeline
#define forward_glValidateProgramPipeline(_pipeline) \
    ({ \
        void *dst = remote_dma(sizeof(glValidateProgramPipeline_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glValidateProgramPipeline(dst, _pipeline), NULL); \
    });
#define call_glValidateProgramPipeline(packed, ret_v) do { \
    glValidateProgramPipeline_PACKED *unpacked = (glValidateProgramPipeline_PACKED *)packed; \
    glValidateProgramPipeline_ARGS *args = (glValidateProgramPipeline_ARGS *)&unpacked->args; \
    glValidateProgramPipeline(args->pipeline);; \
} while(0)
void glValidateProgramPipeline(glValidateProgramPipeline_ARG_EXPAND);
packed_call_t *pack_glValidateProgramPipeline(glValidateProgramPipeline_PACKED *_dst glValidateProgramPipeline_ARG_EXPAND_TAIL);
typedef void (*glValidateProgramPipeline_PTR)(glValidateProgramPipeline_ARG_EXPAND);
#endif
#ifndef glVariantArrayObjectATI_RETURN
#define glVariantArrayObjectATI_RETURN void
#define glVariantArrayObjectATI_ARG_NAMES id, type, stride, buffer, offset
#define glVariantArrayObjectATI_ARG_EXPAND GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset
#define glVariantArrayObjectATI_ARG_NAMES_TAIL , id, type, stride, buffer, offset
#define glVariantArrayObjectATI_ARG_EXPAND_TAIL , GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset
#define forward_glVariantArrayObjectATI(_id, _type, _stride, _buffer, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantArrayObjectATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantArrayObjectATI(dst, _id, _type, _stride, _buffer, _offset), NULL); \
    });
#define call_glVariantArrayObjectATI(packed, ret_v) do { \
    glVariantArrayObjectATI_PACKED *unpacked = (glVariantArrayObjectATI_PACKED *)packed; \
    glVariantArrayObjectATI_ARGS *args = (glVariantArrayObjectATI_ARGS *)&unpacked->args; \
    glVariantArrayObjectATI(args->id, args->type, args->stride, args->buffer, args->offset);; \
} while(0)
void glVariantArrayObjectATI(glVariantArrayObjectATI_ARG_EXPAND);
packed_call_t *pack_glVariantArrayObjectATI(glVariantArrayObjectATI_PACKED *_dst glVariantArrayObjectATI_ARG_EXPAND_TAIL);
typedef void (*glVariantArrayObjectATI_PTR)(glVariantArrayObjectATI_ARG_EXPAND);
#endif
#ifndef glVariantPointerEXT_RETURN
#define glVariantPointerEXT_RETURN void
#define glVariantPointerEXT_ARG_NAMES id, type, stride, addr
#define glVariantPointerEXT_ARG_EXPAND GLuint id, GLenum type, GLuint stride, const GLvoid * addr
#define glVariantPointerEXT_ARG_NAMES_TAIL , id, type, stride, addr
#define glVariantPointerEXT_ARG_EXPAND_TAIL , GLuint id, GLenum type, GLuint stride, const GLvoid * addr
#define forward_glVariantPointerEXT(_id, _type, _stride, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantPointerEXT(dst, _id, _type, _stride, _addr), NULL); \
    });
#define call_glVariantPointerEXT(packed, ret_v) do { \
    glVariantPointerEXT_PACKED *unpacked = (glVariantPointerEXT_PACKED *)packed; \
    glVariantPointerEXT_ARGS *args = (glVariantPointerEXT_ARGS *)&unpacked->args; \
    glVariantPointerEXT(args->id, args->type, args->stride, args->addr);; \
} while(0)
void glVariantPointerEXT(glVariantPointerEXT_ARG_EXPAND);
packed_call_t *pack_glVariantPointerEXT(glVariantPointerEXT_PACKED *_dst glVariantPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantPointerEXT_PTR)(glVariantPointerEXT_ARG_EXPAND);
#endif
#ifndef glVariantbvEXT_RETURN
#define glVariantbvEXT_RETURN void
#define glVariantbvEXT_ARG_NAMES id, addr
#define glVariantbvEXT_ARG_EXPAND GLuint id, const GLbyte * addr
#define glVariantbvEXT_ARG_NAMES_TAIL , id, addr
#define glVariantbvEXT_ARG_EXPAND_TAIL , GLuint id, const GLbyte * addr
#define forward_glVariantbvEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantbvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantbvEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantbvEXT(packed, ret_v) do { \
    glVariantbvEXT_PACKED *unpacked = (glVariantbvEXT_PACKED *)packed; \
    glVariantbvEXT_ARGS *args = (glVariantbvEXT_ARGS *)&unpacked->args; \
    glVariantbvEXT(args->id, args->addr);; \
} while(0)
void glVariantbvEXT(glVariantbvEXT_ARG_EXPAND);
packed_call_t *pack_glVariantbvEXT(glVariantbvEXT_PACKED *_dst glVariantbvEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantbvEXT_PTR)(glVariantbvEXT_ARG_EXPAND);
#endif
#ifndef glVariantdvEXT_RETURN
#define glVariantdvEXT_RETURN void
#define glVariantdvEXT_ARG_NAMES id, addr
#define glVariantdvEXT_ARG_EXPAND GLuint id, const GLdouble * addr
#define glVariantdvEXT_ARG_NAMES_TAIL , id, addr
#define glVariantdvEXT_ARG_EXPAND_TAIL , GLuint id, const GLdouble * addr
#define forward_glVariantdvEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantdvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantdvEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantdvEXT(packed, ret_v) do { \
    glVariantdvEXT_PACKED *unpacked = (glVariantdvEXT_PACKED *)packed; \
    glVariantdvEXT_ARGS *args = (glVariantdvEXT_ARGS *)&unpacked->args; \
    glVariantdvEXT(args->id, args->addr);; \
} while(0)
void glVariantdvEXT(glVariantdvEXT_ARG_EXPAND);
packed_call_t *pack_glVariantdvEXT(glVariantdvEXT_PACKED *_dst glVariantdvEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantdvEXT_PTR)(glVariantdvEXT_ARG_EXPAND);
#endif
#ifndef glVariantfvEXT_RETURN
#define glVariantfvEXT_RETURN void
#define glVariantfvEXT_ARG_NAMES id, addr
#define glVariantfvEXT_ARG_EXPAND GLuint id, const GLfloat * addr
#define glVariantfvEXT_ARG_NAMES_TAIL , id, addr
#define glVariantfvEXT_ARG_EXPAND_TAIL , GLuint id, const GLfloat * addr
#define forward_glVariantfvEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantfvEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantfvEXT(packed, ret_v) do { \
    glVariantfvEXT_PACKED *unpacked = (glVariantfvEXT_PACKED *)packed; \
    glVariantfvEXT_ARGS *args = (glVariantfvEXT_ARGS *)&unpacked->args; \
    glVariantfvEXT(args->id, args->addr);; \
} while(0)
void glVariantfvEXT(glVariantfvEXT_ARG_EXPAND);
packed_call_t *pack_glVariantfvEXT(glVariantfvEXT_PACKED *_dst glVariantfvEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantfvEXT_PTR)(glVariantfvEXT_ARG_EXPAND);
#endif
#ifndef glVariantivEXT_RETURN
#define glVariantivEXT_RETURN void
#define glVariantivEXT_ARG_NAMES id, addr
#define glVariantivEXT_ARG_EXPAND GLuint id, const GLint * addr
#define glVariantivEXT_ARG_NAMES_TAIL , id, addr
#define glVariantivEXT_ARG_EXPAND_TAIL , GLuint id, const GLint * addr
#define forward_glVariantivEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantivEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantivEXT(packed, ret_v) do { \
    glVariantivEXT_PACKED *unpacked = (glVariantivEXT_PACKED *)packed; \
    glVariantivEXT_ARGS *args = (glVariantivEXT_ARGS *)&unpacked->args; \
    glVariantivEXT(args->id, args->addr);; \
} while(0)
void glVariantivEXT(glVariantivEXT_ARG_EXPAND);
packed_call_t *pack_glVariantivEXT(glVariantivEXT_PACKED *_dst glVariantivEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantivEXT_PTR)(glVariantivEXT_ARG_EXPAND);
#endif
#ifndef glVariantsvEXT_RETURN
#define glVariantsvEXT_RETURN void
#define glVariantsvEXT_ARG_NAMES id, addr
#define glVariantsvEXT_ARG_EXPAND GLuint id, const GLshort * addr
#define glVariantsvEXT_ARG_NAMES_TAIL , id, addr
#define glVariantsvEXT_ARG_EXPAND_TAIL , GLuint id, const GLshort * addr
#define forward_glVariantsvEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantsvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantsvEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantsvEXT(packed, ret_v) do { \
    glVariantsvEXT_PACKED *unpacked = (glVariantsvEXT_PACKED *)packed; \
    glVariantsvEXT_ARGS *args = (glVariantsvEXT_ARGS *)&unpacked->args; \
    glVariantsvEXT(args->id, args->addr);; \
} while(0)
void glVariantsvEXT(glVariantsvEXT_ARG_EXPAND);
packed_call_t *pack_glVariantsvEXT(glVariantsvEXT_PACKED *_dst glVariantsvEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantsvEXT_PTR)(glVariantsvEXT_ARG_EXPAND);
#endif
#ifndef glVariantubvEXT_RETURN
#define glVariantubvEXT_RETURN void
#define glVariantubvEXT_ARG_NAMES id, addr
#define glVariantubvEXT_ARG_EXPAND GLuint id, const GLubyte * addr
#define glVariantubvEXT_ARG_NAMES_TAIL , id, addr
#define glVariantubvEXT_ARG_EXPAND_TAIL , GLuint id, const GLubyte * addr
#define forward_glVariantubvEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantubvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantubvEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantubvEXT(packed, ret_v) do { \
    glVariantubvEXT_PACKED *unpacked = (glVariantubvEXT_PACKED *)packed; \
    glVariantubvEXT_ARGS *args = (glVariantubvEXT_ARGS *)&unpacked->args; \
    glVariantubvEXT(args->id, args->addr);; \
} while(0)
void glVariantubvEXT(glVariantubvEXT_ARG_EXPAND);
packed_call_t *pack_glVariantubvEXT(glVariantubvEXT_PACKED *_dst glVariantubvEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantubvEXT_PTR)(glVariantubvEXT_ARG_EXPAND);
#endif
#ifndef glVariantuivEXT_RETURN
#define glVariantuivEXT_RETURN void
#define glVariantuivEXT_ARG_NAMES id, addr
#define glVariantuivEXT_ARG_EXPAND GLuint id, const GLuint * addr
#define glVariantuivEXT_ARG_NAMES_TAIL , id, addr
#define glVariantuivEXT_ARG_EXPAND_TAIL , GLuint id, const GLuint * addr
#define forward_glVariantuivEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantuivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantuivEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantuivEXT(packed, ret_v) do { \
    glVariantuivEXT_PACKED *unpacked = (glVariantuivEXT_PACKED *)packed; \
    glVariantuivEXT_ARGS *args = (glVariantuivEXT_ARGS *)&unpacked->args; \
    glVariantuivEXT(args->id, args->addr);; \
} while(0)
void glVariantuivEXT(glVariantuivEXT_ARG_EXPAND);
packed_call_t *pack_glVariantuivEXT(glVariantuivEXT_PACKED *_dst glVariantuivEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantuivEXT_PTR)(glVariantuivEXT_ARG_EXPAND);
#endif
#ifndef glVariantusvEXT_RETURN
#define glVariantusvEXT_RETURN void
#define glVariantusvEXT_ARG_NAMES id, addr
#define glVariantusvEXT_ARG_EXPAND GLuint id, const GLushort * addr
#define glVariantusvEXT_ARG_NAMES_TAIL , id, addr
#define glVariantusvEXT_ARG_EXPAND_TAIL , GLuint id, const GLushort * addr
#define forward_glVariantusvEXT(_id, _addr) \
    ({ \
        void *dst = remote_dma(sizeof(glVariantusvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVariantusvEXT(dst, _id, _addr), NULL); \
    });
#define call_glVariantusvEXT(packed, ret_v) do { \
    glVariantusvEXT_PACKED *unpacked = (glVariantusvEXT_PACKED *)packed; \
    glVariantusvEXT_ARGS *args = (glVariantusvEXT_ARGS *)&unpacked->args; \
    glVariantusvEXT(args->id, args->addr);; \
} while(0)
void glVariantusvEXT(glVariantusvEXT_ARG_EXPAND);
packed_call_t *pack_glVariantusvEXT(glVariantusvEXT_PACKED *_dst glVariantusvEXT_ARG_EXPAND_TAIL);
typedef void (*glVariantusvEXT_PTR)(glVariantusvEXT_ARG_EXPAND);
#endif
#ifndef glVertex2bOES_RETURN
#define glVertex2bOES_RETURN void
#define glVertex2bOES_ARG_NAMES x
#define glVertex2bOES_ARG_EXPAND GLbyte x
#define glVertex2bOES_ARG_NAMES_TAIL , x
#define glVertex2bOES_ARG_EXPAND_TAIL , GLbyte x
#define forward_glVertex2bOES(_x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2bOES(dst, _x), NULL); \
    });
#define call_glVertex2bOES(packed, ret_v) do { \
    glVertex2bOES_PACKED *unpacked = (glVertex2bOES_PACKED *)packed; \
    glVertex2bOES_ARGS *args = (glVertex2bOES_ARGS *)&unpacked->args; \
    glVertex2bOES(args->x);; \
} while(0)
void glVertex2bOES(glVertex2bOES_ARG_EXPAND);
packed_call_t *pack_glVertex2bOES(glVertex2bOES_PACKED *_dst glVertex2bOES_ARG_EXPAND_TAIL);
typedef void (*glVertex2bOES_PTR)(glVertex2bOES_ARG_EXPAND);
#endif
#ifndef glVertex2bvOES_RETURN
#define glVertex2bvOES_RETURN void
#define glVertex2bvOES_ARG_NAMES coords
#define glVertex2bvOES_ARG_EXPAND const GLbyte * coords
#define glVertex2bvOES_ARG_NAMES_TAIL , coords
#define glVertex2bvOES_ARG_EXPAND_TAIL , const GLbyte * coords
#define forward_glVertex2bvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2bvOES(dst, _coords), NULL); \
    });
#define call_glVertex2bvOES(packed, ret_v) do { \
    glVertex2bvOES_PACKED *unpacked = (glVertex2bvOES_PACKED *)packed; \
    glVertex2bvOES_ARGS *args = (glVertex2bvOES_ARGS *)&unpacked->args; \
    glVertex2bvOES(args->coords);; \
} while(0)
void glVertex2bvOES(glVertex2bvOES_ARG_EXPAND);
packed_call_t *pack_glVertex2bvOES(glVertex2bvOES_PACKED *_dst glVertex2bvOES_ARG_EXPAND_TAIL);
typedef void (*glVertex2bvOES_PTR)(glVertex2bvOES_ARG_EXPAND);
#endif
#ifndef glVertex2d_RETURN
#define glVertex2d_RETURN void
#define glVertex2d_ARG_NAMES x, y
#define glVertex2d_ARG_EXPAND GLdouble x, GLdouble y
#define glVertex2d_ARG_NAMES_TAIL , x, y
#define glVertex2d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y
#define forward_glVertex2d(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2d(dst, _x, _y), NULL); \
    });
#define call_glVertex2d(packed, ret_v) do { \
    glVertex2d_PACKED *unpacked = (glVertex2d_PACKED *)packed; \
    glVertex2d_ARGS *args = (glVertex2d_ARGS *)&unpacked->args; \
    glVertex2d(args->x, args->y);; \
} while(0)
void glVertex2d(glVertex2d_ARG_EXPAND);
packed_call_t *pack_glVertex2d(glVertex2d_PACKED *_dst glVertex2d_ARG_EXPAND_TAIL);
typedef void (*glVertex2d_PTR)(glVertex2d_ARG_EXPAND);
#endif
#ifndef glVertex2dv_RETURN
#define glVertex2dv_RETURN void
#define glVertex2dv_ARG_NAMES v
#define glVertex2dv_ARG_EXPAND const GLdouble * v
#define glVertex2dv_ARG_NAMES_TAIL , v
#define glVertex2dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glVertex2dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2dv(dst, _v), NULL); \
    });
#define call_glVertex2dv(packed, ret_v) do { \
    glVertex2dv_PACKED *unpacked = (glVertex2dv_PACKED *)packed; \
    glVertex2dv_ARGS *args = (glVertex2dv_ARGS *)&unpacked->args; \
    glVertex2dv(args->v);; \
} while(0)
void glVertex2dv(glVertex2dv_ARG_EXPAND);
packed_call_t *pack_glVertex2dv(glVertex2dv_PACKED *_dst glVertex2dv_ARG_EXPAND_TAIL);
typedef void (*glVertex2dv_PTR)(glVertex2dv_ARG_EXPAND);
#endif
#ifndef glVertex2f_RETURN
#define glVertex2f_RETURN void
#define glVertex2f_ARG_NAMES x, y
#define glVertex2f_ARG_EXPAND GLfloat x, GLfloat y
#define glVertex2f_ARG_NAMES_TAIL , x, y
#define glVertex2f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y
#define forward_glVertex2f(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2f(dst, _x, _y), NULL); \
    });
#define call_glVertex2f(packed, ret_v) do { \
    glVertex2f_PACKED *unpacked = (glVertex2f_PACKED *)packed; \
    glVertex2f_ARGS *args = (glVertex2f_ARGS *)&unpacked->args; \
    glVertex2f(args->x, args->y);; \
} while(0)
void glVertex2f(glVertex2f_ARG_EXPAND);
packed_call_t *pack_glVertex2f(glVertex2f_PACKED *_dst glVertex2f_ARG_EXPAND_TAIL);
typedef void (*glVertex2f_PTR)(glVertex2f_ARG_EXPAND);
#endif
#ifndef glVertex2fv_RETURN
#define glVertex2fv_RETURN void
#define glVertex2fv_ARG_NAMES v
#define glVertex2fv_ARG_EXPAND const GLfloat * v
#define glVertex2fv_ARG_NAMES_TAIL , v
#define glVertex2fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glVertex2fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2fv(dst, _v), NULL); \
    });
#define call_glVertex2fv(packed, ret_v) do { \
    glVertex2fv_PACKED *unpacked = (glVertex2fv_PACKED *)packed; \
    glVertex2fv_ARGS *args = (glVertex2fv_ARGS *)&unpacked->args; \
    glVertex2fv(args->v);; \
} while(0)
void glVertex2fv(glVertex2fv_ARG_EXPAND);
packed_call_t *pack_glVertex2fv(glVertex2fv_PACKED *_dst glVertex2fv_ARG_EXPAND_TAIL);
typedef void (*glVertex2fv_PTR)(glVertex2fv_ARG_EXPAND);
#endif
#ifndef glVertex2hNV_RETURN
#define glVertex2hNV_RETURN void
#define glVertex2hNV_ARG_NAMES x, y
#define glVertex2hNV_ARG_EXPAND GLhalfNV x, GLhalfNV y
#define glVertex2hNV_ARG_NAMES_TAIL , x, y
#define glVertex2hNV_ARG_EXPAND_TAIL , GLhalfNV x, GLhalfNV y
#define forward_glVertex2hNV(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2hNV(dst, _x, _y), NULL); \
    });
#define call_glVertex2hNV(packed, ret_v) do { \
    glVertex2hNV_PACKED *unpacked = (glVertex2hNV_PACKED *)packed; \
    glVertex2hNV_ARGS *args = (glVertex2hNV_ARGS *)&unpacked->args; \
    glVertex2hNV(args->x, args->y);; \
} while(0)
void glVertex2hNV(glVertex2hNV_ARG_EXPAND);
packed_call_t *pack_glVertex2hNV(glVertex2hNV_PACKED *_dst glVertex2hNV_ARG_EXPAND_TAIL);
typedef void (*glVertex2hNV_PTR)(glVertex2hNV_ARG_EXPAND);
#endif
#ifndef glVertex2hvNV_RETURN
#define glVertex2hvNV_RETURN void
#define glVertex2hvNV_ARG_NAMES v
#define glVertex2hvNV_ARG_EXPAND const GLhalfNV * v
#define glVertex2hvNV_ARG_NAMES_TAIL , v
#define glVertex2hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glVertex2hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2hvNV(dst, _v), NULL); \
    });
#define call_glVertex2hvNV(packed, ret_v) do { \
    glVertex2hvNV_PACKED *unpacked = (glVertex2hvNV_PACKED *)packed; \
    glVertex2hvNV_ARGS *args = (glVertex2hvNV_ARGS *)&unpacked->args; \
    glVertex2hvNV(args->v);; \
} while(0)
void glVertex2hvNV(glVertex2hvNV_ARG_EXPAND);
packed_call_t *pack_glVertex2hvNV(glVertex2hvNV_PACKED *_dst glVertex2hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertex2hvNV_PTR)(glVertex2hvNV_ARG_EXPAND);
#endif
#ifndef glVertex2i_RETURN
#define glVertex2i_RETURN void
#define glVertex2i_ARG_NAMES x, y
#define glVertex2i_ARG_EXPAND GLint x, GLint y
#define glVertex2i_ARG_NAMES_TAIL , x, y
#define glVertex2i_ARG_EXPAND_TAIL , GLint x, GLint y
#define forward_glVertex2i(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2i(dst, _x, _y), NULL); \
    });
#define call_glVertex2i(packed, ret_v) do { \
    glVertex2i_PACKED *unpacked = (glVertex2i_PACKED *)packed; \
    glVertex2i_ARGS *args = (glVertex2i_ARGS *)&unpacked->args; \
    glVertex2i(args->x, args->y);; \
} while(0)
void glVertex2i(glVertex2i_ARG_EXPAND);
packed_call_t *pack_glVertex2i(glVertex2i_PACKED *_dst glVertex2i_ARG_EXPAND_TAIL);
typedef void (*glVertex2i_PTR)(glVertex2i_ARG_EXPAND);
#endif
#ifndef glVertex2iv_RETURN
#define glVertex2iv_RETURN void
#define glVertex2iv_ARG_NAMES v
#define glVertex2iv_ARG_EXPAND const GLint * v
#define glVertex2iv_ARG_NAMES_TAIL , v
#define glVertex2iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glVertex2iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2iv(dst, _v), NULL); \
    });
#define call_glVertex2iv(packed, ret_v) do { \
    glVertex2iv_PACKED *unpacked = (glVertex2iv_PACKED *)packed; \
    glVertex2iv_ARGS *args = (glVertex2iv_ARGS *)&unpacked->args; \
    glVertex2iv(args->v);; \
} while(0)
void glVertex2iv(glVertex2iv_ARG_EXPAND);
packed_call_t *pack_glVertex2iv(glVertex2iv_PACKED *_dst glVertex2iv_ARG_EXPAND_TAIL);
typedef void (*glVertex2iv_PTR)(glVertex2iv_ARG_EXPAND);
#endif
#ifndef glVertex2s_RETURN
#define glVertex2s_RETURN void
#define glVertex2s_ARG_NAMES x, y
#define glVertex2s_ARG_EXPAND GLshort x, GLshort y
#define glVertex2s_ARG_NAMES_TAIL , x, y
#define glVertex2s_ARG_EXPAND_TAIL , GLshort x, GLshort y
#define forward_glVertex2s(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2s(dst, _x, _y), NULL); \
    });
#define call_glVertex2s(packed, ret_v) do { \
    glVertex2s_PACKED *unpacked = (glVertex2s_PACKED *)packed; \
    glVertex2s_ARGS *args = (glVertex2s_ARGS *)&unpacked->args; \
    glVertex2s(args->x, args->y);; \
} while(0)
void glVertex2s(glVertex2s_ARG_EXPAND);
packed_call_t *pack_glVertex2s(glVertex2s_PACKED *_dst glVertex2s_ARG_EXPAND_TAIL);
typedef void (*glVertex2s_PTR)(glVertex2s_ARG_EXPAND);
#endif
#ifndef glVertex2sv_RETURN
#define glVertex2sv_RETURN void
#define glVertex2sv_ARG_NAMES v
#define glVertex2sv_ARG_EXPAND const GLshort * v
#define glVertex2sv_ARG_NAMES_TAIL , v
#define glVertex2sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glVertex2sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2sv(dst, _v), NULL); \
    });
#define call_glVertex2sv(packed, ret_v) do { \
    glVertex2sv_PACKED *unpacked = (glVertex2sv_PACKED *)packed; \
    glVertex2sv_ARGS *args = (glVertex2sv_ARGS *)&unpacked->args; \
    glVertex2sv(args->v);; \
} while(0)
void glVertex2sv(glVertex2sv_ARG_EXPAND);
packed_call_t *pack_glVertex2sv(glVertex2sv_PACKED *_dst glVertex2sv_ARG_EXPAND_TAIL);
typedef void (*glVertex2sv_PTR)(glVertex2sv_ARG_EXPAND);
#endif
#ifndef glVertex2xOES_RETURN
#define glVertex2xOES_RETURN void
#define glVertex2xOES_ARG_NAMES x
#define glVertex2xOES_ARG_EXPAND GLfixed x
#define glVertex2xOES_ARG_NAMES_TAIL , x
#define glVertex2xOES_ARG_EXPAND_TAIL , GLfixed x
#define forward_glVertex2xOES(_x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2xOES(dst, _x), NULL); \
    });
#define call_glVertex2xOES(packed, ret_v) do { \
    glVertex2xOES_PACKED *unpacked = (glVertex2xOES_PACKED *)packed; \
    glVertex2xOES_ARGS *args = (glVertex2xOES_ARGS *)&unpacked->args; \
    glVertex2xOES(args->x);; \
} while(0)
void glVertex2xOES(glVertex2xOES_ARG_EXPAND);
packed_call_t *pack_glVertex2xOES(glVertex2xOES_PACKED *_dst glVertex2xOES_ARG_EXPAND_TAIL);
typedef void (*glVertex2xOES_PTR)(glVertex2xOES_ARG_EXPAND);
#endif
#ifndef glVertex2xvOES_RETURN
#define glVertex2xvOES_RETURN void
#define glVertex2xvOES_ARG_NAMES coords
#define glVertex2xvOES_ARG_EXPAND const GLfixed * coords
#define glVertex2xvOES_ARG_NAMES_TAIL , coords
#define glVertex2xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glVertex2xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex2xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex2xvOES(dst, _coords), NULL); \
    });
#define call_glVertex2xvOES(packed, ret_v) do { \
    glVertex2xvOES_PACKED *unpacked = (glVertex2xvOES_PACKED *)packed; \
    glVertex2xvOES_ARGS *args = (glVertex2xvOES_ARGS *)&unpacked->args; \
    glVertex2xvOES(args->coords);; \
} while(0)
void glVertex2xvOES(glVertex2xvOES_ARG_EXPAND);
packed_call_t *pack_glVertex2xvOES(glVertex2xvOES_PACKED *_dst glVertex2xvOES_ARG_EXPAND_TAIL);
typedef void (*glVertex2xvOES_PTR)(glVertex2xvOES_ARG_EXPAND);
#endif
#ifndef glVertex3bOES_RETURN
#define glVertex3bOES_RETURN void
#define glVertex3bOES_ARG_NAMES x, y
#define glVertex3bOES_ARG_EXPAND GLbyte x, GLbyte y
#define glVertex3bOES_ARG_NAMES_TAIL , x, y
#define glVertex3bOES_ARG_EXPAND_TAIL , GLbyte x, GLbyte y
#define forward_glVertex3bOES(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3bOES(dst, _x, _y), NULL); \
    });
#define call_glVertex3bOES(packed, ret_v) do { \
    glVertex3bOES_PACKED *unpacked = (glVertex3bOES_PACKED *)packed; \
    glVertex3bOES_ARGS *args = (glVertex3bOES_ARGS *)&unpacked->args; \
    glVertex3bOES(args->x, args->y);; \
} while(0)
void glVertex3bOES(glVertex3bOES_ARG_EXPAND);
packed_call_t *pack_glVertex3bOES(glVertex3bOES_PACKED *_dst glVertex3bOES_ARG_EXPAND_TAIL);
typedef void (*glVertex3bOES_PTR)(glVertex3bOES_ARG_EXPAND);
#endif
#ifndef glVertex3bvOES_RETURN
#define glVertex3bvOES_RETURN void
#define glVertex3bvOES_ARG_NAMES coords
#define glVertex3bvOES_ARG_EXPAND const GLbyte * coords
#define glVertex3bvOES_ARG_NAMES_TAIL , coords
#define glVertex3bvOES_ARG_EXPAND_TAIL , const GLbyte * coords
#define forward_glVertex3bvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3bvOES(dst, _coords), NULL); \
    });
#define call_glVertex3bvOES(packed, ret_v) do { \
    glVertex3bvOES_PACKED *unpacked = (glVertex3bvOES_PACKED *)packed; \
    glVertex3bvOES_ARGS *args = (glVertex3bvOES_ARGS *)&unpacked->args; \
    glVertex3bvOES(args->coords);; \
} while(0)
void glVertex3bvOES(glVertex3bvOES_ARG_EXPAND);
packed_call_t *pack_glVertex3bvOES(glVertex3bvOES_PACKED *_dst glVertex3bvOES_ARG_EXPAND_TAIL);
typedef void (*glVertex3bvOES_PTR)(glVertex3bvOES_ARG_EXPAND);
#endif
#ifndef glVertex3d_RETURN
#define glVertex3d_RETURN void
#define glVertex3d_ARG_NAMES x, y, z
#define glVertex3d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glVertex3d_ARG_NAMES_TAIL , x, y, z
#define glVertex3d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z
#define forward_glVertex3d(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3d(dst, _x, _y, _z), NULL); \
    });
#define call_glVertex3d(packed, ret_v) do { \
    glVertex3d_PACKED *unpacked = (glVertex3d_PACKED *)packed; \
    glVertex3d_ARGS *args = (glVertex3d_ARGS *)&unpacked->args; \
    glVertex3d(args->x, args->y, args->z);; \
} while(0)
void glVertex3d(glVertex3d_ARG_EXPAND);
packed_call_t *pack_glVertex3d(glVertex3d_PACKED *_dst glVertex3d_ARG_EXPAND_TAIL);
typedef void (*glVertex3d_PTR)(glVertex3d_ARG_EXPAND);
#endif
#ifndef glVertex3dv_RETURN
#define glVertex3dv_RETURN void
#define glVertex3dv_ARG_NAMES v
#define glVertex3dv_ARG_EXPAND const GLdouble * v
#define glVertex3dv_ARG_NAMES_TAIL , v
#define glVertex3dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glVertex3dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3dv(dst, _v), NULL); \
    });
#define call_glVertex3dv(packed, ret_v) do { \
    glVertex3dv_PACKED *unpacked = (glVertex3dv_PACKED *)packed; \
    glVertex3dv_ARGS *args = (glVertex3dv_ARGS *)&unpacked->args; \
    glVertex3dv(args->v);; \
} while(0)
void glVertex3dv(glVertex3dv_ARG_EXPAND);
packed_call_t *pack_glVertex3dv(glVertex3dv_PACKED *_dst glVertex3dv_ARG_EXPAND_TAIL);
typedef void (*glVertex3dv_PTR)(glVertex3dv_ARG_EXPAND);
#endif
#ifndef glVertex3f_RETURN
#define glVertex3f_RETURN void
#define glVertex3f_ARG_NAMES x, y, z
#define glVertex3f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glVertex3f_ARG_NAMES_TAIL , x, y, z
#define glVertex3f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z
#define forward_glVertex3f(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3f(dst, _x, _y, _z), NULL); \
    });
#define call_glVertex3f(packed, ret_v) do { \
    glVertex3f_PACKED *unpacked = (glVertex3f_PACKED *)packed; \
    glVertex3f_ARGS *args = (glVertex3f_ARGS *)&unpacked->args; \
    glVertex3f(args->x, args->y, args->z);; \
} while(0)
void glVertex3f(glVertex3f_ARG_EXPAND);
packed_call_t *pack_glVertex3f(glVertex3f_PACKED *_dst glVertex3f_ARG_EXPAND_TAIL);
typedef void (*glVertex3f_PTR)(glVertex3f_ARG_EXPAND);
#endif
#ifndef glVertex3fv_RETURN
#define glVertex3fv_RETURN void
#define glVertex3fv_ARG_NAMES v
#define glVertex3fv_ARG_EXPAND const GLfloat * v
#define glVertex3fv_ARG_NAMES_TAIL , v
#define glVertex3fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glVertex3fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3fv(dst, _v), NULL); \
    });
#define call_glVertex3fv(packed, ret_v) do { \
    glVertex3fv_PACKED *unpacked = (glVertex3fv_PACKED *)packed; \
    glVertex3fv_ARGS *args = (glVertex3fv_ARGS *)&unpacked->args; \
    glVertex3fv(args->v);; \
} while(0)
void glVertex3fv(glVertex3fv_ARG_EXPAND);
packed_call_t *pack_glVertex3fv(glVertex3fv_PACKED *_dst glVertex3fv_ARG_EXPAND_TAIL);
typedef void (*glVertex3fv_PTR)(glVertex3fv_ARG_EXPAND);
#endif
#ifndef glVertex3hNV_RETURN
#define glVertex3hNV_RETURN void
#define glVertex3hNV_ARG_NAMES x, y, z
#define glVertex3hNV_ARG_EXPAND GLhalfNV x, GLhalfNV y, GLhalfNV z
#define glVertex3hNV_ARG_NAMES_TAIL , x, y, z
#define glVertex3hNV_ARG_EXPAND_TAIL , GLhalfNV x, GLhalfNV y, GLhalfNV z
#define forward_glVertex3hNV(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3hNV(dst, _x, _y, _z), NULL); \
    });
#define call_glVertex3hNV(packed, ret_v) do { \
    glVertex3hNV_PACKED *unpacked = (glVertex3hNV_PACKED *)packed; \
    glVertex3hNV_ARGS *args = (glVertex3hNV_ARGS *)&unpacked->args; \
    glVertex3hNV(args->x, args->y, args->z);; \
} while(0)
void glVertex3hNV(glVertex3hNV_ARG_EXPAND);
packed_call_t *pack_glVertex3hNV(glVertex3hNV_PACKED *_dst glVertex3hNV_ARG_EXPAND_TAIL);
typedef void (*glVertex3hNV_PTR)(glVertex3hNV_ARG_EXPAND);
#endif
#ifndef glVertex3hvNV_RETURN
#define glVertex3hvNV_RETURN void
#define glVertex3hvNV_ARG_NAMES v
#define glVertex3hvNV_ARG_EXPAND const GLhalfNV * v
#define glVertex3hvNV_ARG_NAMES_TAIL , v
#define glVertex3hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glVertex3hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3hvNV(dst, _v), NULL); \
    });
#define call_glVertex3hvNV(packed, ret_v) do { \
    glVertex3hvNV_PACKED *unpacked = (glVertex3hvNV_PACKED *)packed; \
    glVertex3hvNV_ARGS *args = (glVertex3hvNV_ARGS *)&unpacked->args; \
    glVertex3hvNV(args->v);; \
} while(0)
void glVertex3hvNV(glVertex3hvNV_ARG_EXPAND);
packed_call_t *pack_glVertex3hvNV(glVertex3hvNV_PACKED *_dst glVertex3hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertex3hvNV_PTR)(glVertex3hvNV_ARG_EXPAND);
#endif
#ifndef glVertex3i_RETURN
#define glVertex3i_RETURN void
#define glVertex3i_ARG_NAMES x, y, z
#define glVertex3i_ARG_EXPAND GLint x, GLint y, GLint z
#define glVertex3i_ARG_NAMES_TAIL , x, y, z
#define glVertex3i_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z
#define forward_glVertex3i(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3i(dst, _x, _y, _z), NULL); \
    });
#define call_glVertex3i(packed, ret_v) do { \
    glVertex3i_PACKED *unpacked = (glVertex3i_PACKED *)packed; \
    glVertex3i_ARGS *args = (glVertex3i_ARGS *)&unpacked->args; \
    glVertex3i(args->x, args->y, args->z);; \
} while(0)
void glVertex3i(glVertex3i_ARG_EXPAND);
packed_call_t *pack_glVertex3i(glVertex3i_PACKED *_dst glVertex3i_ARG_EXPAND_TAIL);
typedef void (*glVertex3i_PTR)(glVertex3i_ARG_EXPAND);
#endif
#ifndef glVertex3iv_RETURN
#define glVertex3iv_RETURN void
#define glVertex3iv_ARG_NAMES v
#define glVertex3iv_ARG_EXPAND const GLint * v
#define glVertex3iv_ARG_NAMES_TAIL , v
#define glVertex3iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glVertex3iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3iv(dst, _v), NULL); \
    });
#define call_glVertex3iv(packed, ret_v) do { \
    glVertex3iv_PACKED *unpacked = (glVertex3iv_PACKED *)packed; \
    glVertex3iv_ARGS *args = (glVertex3iv_ARGS *)&unpacked->args; \
    glVertex3iv(args->v);; \
} while(0)
void glVertex3iv(glVertex3iv_ARG_EXPAND);
packed_call_t *pack_glVertex3iv(glVertex3iv_PACKED *_dst glVertex3iv_ARG_EXPAND_TAIL);
typedef void (*glVertex3iv_PTR)(glVertex3iv_ARG_EXPAND);
#endif
#ifndef glVertex3s_RETURN
#define glVertex3s_RETURN void
#define glVertex3s_ARG_NAMES x, y, z
#define glVertex3s_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glVertex3s_ARG_NAMES_TAIL , x, y, z
#define glVertex3s_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z
#define forward_glVertex3s(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3s(dst, _x, _y, _z), NULL); \
    });
#define call_glVertex3s(packed, ret_v) do { \
    glVertex3s_PACKED *unpacked = (glVertex3s_PACKED *)packed; \
    glVertex3s_ARGS *args = (glVertex3s_ARGS *)&unpacked->args; \
    glVertex3s(args->x, args->y, args->z);; \
} while(0)
void glVertex3s(glVertex3s_ARG_EXPAND);
packed_call_t *pack_glVertex3s(glVertex3s_PACKED *_dst glVertex3s_ARG_EXPAND_TAIL);
typedef void (*glVertex3s_PTR)(glVertex3s_ARG_EXPAND);
#endif
#ifndef glVertex3sv_RETURN
#define glVertex3sv_RETURN void
#define glVertex3sv_ARG_NAMES v
#define glVertex3sv_ARG_EXPAND const GLshort * v
#define glVertex3sv_ARG_NAMES_TAIL , v
#define glVertex3sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glVertex3sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3sv(dst, _v), NULL); \
    });
#define call_glVertex3sv(packed, ret_v) do { \
    glVertex3sv_PACKED *unpacked = (glVertex3sv_PACKED *)packed; \
    glVertex3sv_ARGS *args = (glVertex3sv_ARGS *)&unpacked->args; \
    glVertex3sv(args->v);; \
} while(0)
void glVertex3sv(glVertex3sv_ARG_EXPAND);
packed_call_t *pack_glVertex3sv(glVertex3sv_PACKED *_dst glVertex3sv_ARG_EXPAND_TAIL);
typedef void (*glVertex3sv_PTR)(glVertex3sv_ARG_EXPAND);
#endif
#ifndef glVertex3xOES_RETURN
#define glVertex3xOES_RETURN void
#define glVertex3xOES_ARG_NAMES x, y
#define glVertex3xOES_ARG_EXPAND GLfixed x, GLfixed y
#define glVertex3xOES_ARG_NAMES_TAIL , x, y
#define glVertex3xOES_ARG_EXPAND_TAIL , GLfixed x, GLfixed y
#define forward_glVertex3xOES(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3xOES(dst, _x, _y), NULL); \
    });
#define call_glVertex3xOES(packed, ret_v) do { \
    glVertex3xOES_PACKED *unpacked = (glVertex3xOES_PACKED *)packed; \
    glVertex3xOES_ARGS *args = (glVertex3xOES_ARGS *)&unpacked->args; \
    glVertex3xOES(args->x, args->y);; \
} while(0)
void glVertex3xOES(glVertex3xOES_ARG_EXPAND);
packed_call_t *pack_glVertex3xOES(glVertex3xOES_PACKED *_dst glVertex3xOES_ARG_EXPAND_TAIL);
typedef void (*glVertex3xOES_PTR)(glVertex3xOES_ARG_EXPAND);
#endif
#ifndef glVertex3xvOES_RETURN
#define glVertex3xvOES_RETURN void
#define glVertex3xvOES_ARG_NAMES coords
#define glVertex3xvOES_ARG_EXPAND const GLfixed * coords
#define glVertex3xvOES_ARG_NAMES_TAIL , coords
#define glVertex3xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glVertex3xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex3xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex3xvOES(dst, _coords), NULL); \
    });
#define call_glVertex3xvOES(packed, ret_v) do { \
    glVertex3xvOES_PACKED *unpacked = (glVertex3xvOES_PACKED *)packed; \
    glVertex3xvOES_ARGS *args = (glVertex3xvOES_ARGS *)&unpacked->args; \
    glVertex3xvOES(args->coords);; \
} while(0)
void glVertex3xvOES(glVertex3xvOES_ARG_EXPAND);
packed_call_t *pack_glVertex3xvOES(glVertex3xvOES_PACKED *_dst glVertex3xvOES_ARG_EXPAND_TAIL);
typedef void (*glVertex3xvOES_PTR)(glVertex3xvOES_ARG_EXPAND);
#endif
#ifndef glVertex4bOES_RETURN
#define glVertex4bOES_RETURN void
#define glVertex4bOES_ARG_NAMES x, y, z
#define glVertex4bOES_ARG_EXPAND GLbyte x, GLbyte y, GLbyte z
#define glVertex4bOES_ARG_NAMES_TAIL , x, y, z
#define glVertex4bOES_ARG_EXPAND_TAIL , GLbyte x, GLbyte y, GLbyte z
#define forward_glVertex4bOES(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4bOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4bOES(dst, _x, _y, _z), NULL); \
    });
#define call_glVertex4bOES(packed, ret_v) do { \
    glVertex4bOES_PACKED *unpacked = (glVertex4bOES_PACKED *)packed; \
    glVertex4bOES_ARGS *args = (glVertex4bOES_ARGS *)&unpacked->args; \
    glVertex4bOES(args->x, args->y, args->z);; \
} while(0)
void glVertex4bOES(glVertex4bOES_ARG_EXPAND);
packed_call_t *pack_glVertex4bOES(glVertex4bOES_PACKED *_dst glVertex4bOES_ARG_EXPAND_TAIL);
typedef void (*glVertex4bOES_PTR)(glVertex4bOES_ARG_EXPAND);
#endif
#ifndef glVertex4bvOES_RETURN
#define glVertex4bvOES_RETURN void
#define glVertex4bvOES_ARG_NAMES coords
#define glVertex4bvOES_ARG_EXPAND const GLbyte * coords
#define glVertex4bvOES_ARG_NAMES_TAIL , coords
#define glVertex4bvOES_ARG_EXPAND_TAIL , const GLbyte * coords
#define forward_glVertex4bvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4bvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4bvOES(dst, _coords), NULL); \
    });
#define call_glVertex4bvOES(packed, ret_v) do { \
    glVertex4bvOES_PACKED *unpacked = (glVertex4bvOES_PACKED *)packed; \
    glVertex4bvOES_ARGS *args = (glVertex4bvOES_ARGS *)&unpacked->args; \
    glVertex4bvOES(args->coords);; \
} while(0)
void glVertex4bvOES(glVertex4bvOES_ARG_EXPAND);
packed_call_t *pack_glVertex4bvOES(glVertex4bvOES_PACKED *_dst glVertex4bvOES_ARG_EXPAND_TAIL);
typedef void (*glVertex4bvOES_PTR)(glVertex4bvOES_ARG_EXPAND);
#endif
#ifndef glVertex4d_RETURN
#define glVertex4d_RETURN void
#define glVertex4d_ARG_NAMES x, y, z, w
#define glVertex4d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertex4d_ARG_NAMES_TAIL , x, y, z, w
#define glVertex4d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glVertex4d(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4d(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glVertex4d(packed, ret_v) do { \
    glVertex4d_PACKED *unpacked = (glVertex4d_PACKED *)packed; \
    glVertex4d_ARGS *args = (glVertex4d_ARGS *)&unpacked->args; \
    glVertex4d(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4d(glVertex4d_ARG_EXPAND);
packed_call_t *pack_glVertex4d(glVertex4d_PACKED *_dst glVertex4d_ARG_EXPAND_TAIL);
typedef void (*glVertex4d_PTR)(glVertex4d_ARG_EXPAND);
#endif
#ifndef glVertex4dv_RETURN
#define glVertex4dv_RETURN void
#define glVertex4dv_ARG_NAMES v
#define glVertex4dv_ARG_EXPAND const GLdouble * v
#define glVertex4dv_ARG_NAMES_TAIL , v
#define glVertex4dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glVertex4dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4dv(dst, _v), NULL); \
    });
#define call_glVertex4dv(packed, ret_v) do { \
    glVertex4dv_PACKED *unpacked = (glVertex4dv_PACKED *)packed; \
    glVertex4dv_ARGS *args = (glVertex4dv_ARGS *)&unpacked->args; \
    glVertex4dv(args->v);; \
} while(0)
void glVertex4dv(glVertex4dv_ARG_EXPAND);
packed_call_t *pack_glVertex4dv(glVertex4dv_PACKED *_dst glVertex4dv_ARG_EXPAND_TAIL);
typedef void (*glVertex4dv_PTR)(glVertex4dv_ARG_EXPAND);
#endif
#ifndef glVertex4f_RETURN
#define glVertex4f_RETURN void
#define glVertex4f_ARG_NAMES x, y, z, w
#define glVertex4f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertex4f_ARG_NAMES_TAIL , x, y, z, w
#define glVertex4f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glVertex4f(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4f(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glVertex4f(packed, ret_v) do { \
    glVertex4f_PACKED *unpacked = (glVertex4f_PACKED *)packed; \
    glVertex4f_ARGS *args = (glVertex4f_ARGS *)&unpacked->args; \
    glVertex4f(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4f(glVertex4f_ARG_EXPAND);
packed_call_t *pack_glVertex4f(glVertex4f_PACKED *_dst glVertex4f_ARG_EXPAND_TAIL);
typedef void (*glVertex4f_PTR)(glVertex4f_ARG_EXPAND);
#endif
#ifndef glVertex4fv_RETURN
#define glVertex4fv_RETURN void
#define glVertex4fv_ARG_NAMES v
#define glVertex4fv_ARG_EXPAND const GLfloat * v
#define glVertex4fv_ARG_NAMES_TAIL , v
#define glVertex4fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glVertex4fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4fv(dst, _v), NULL); \
    });
#define call_glVertex4fv(packed, ret_v) do { \
    glVertex4fv_PACKED *unpacked = (glVertex4fv_PACKED *)packed; \
    glVertex4fv_ARGS *args = (glVertex4fv_ARGS *)&unpacked->args; \
    glVertex4fv(args->v);; \
} while(0)
void glVertex4fv(glVertex4fv_ARG_EXPAND);
packed_call_t *pack_glVertex4fv(glVertex4fv_PACKED *_dst glVertex4fv_ARG_EXPAND_TAIL);
typedef void (*glVertex4fv_PTR)(glVertex4fv_ARG_EXPAND);
#endif
#ifndef glVertex4hNV_RETURN
#define glVertex4hNV_RETURN void
#define glVertex4hNV_ARG_NAMES x, y, z, w
#define glVertex4hNV_ARG_EXPAND GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w
#define glVertex4hNV_ARG_NAMES_TAIL , x, y, z, w
#define glVertex4hNV_ARG_EXPAND_TAIL , GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w
#define forward_glVertex4hNV(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4hNV(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glVertex4hNV(packed, ret_v) do { \
    glVertex4hNV_PACKED *unpacked = (glVertex4hNV_PACKED *)packed; \
    glVertex4hNV_ARGS *args = (glVertex4hNV_ARGS *)&unpacked->args; \
    glVertex4hNV(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4hNV(glVertex4hNV_ARG_EXPAND);
packed_call_t *pack_glVertex4hNV(glVertex4hNV_PACKED *_dst glVertex4hNV_ARG_EXPAND_TAIL);
typedef void (*glVertex4hNV_PTR)(glVertex4hNV_ARG_EXPAND);
#endif
#ifndef glVertex4hvNV_RETURN
#define glVertex4hvNV_RETURN void
#define glVertex4hvNV_ARG_NAMES v
#define glVertex4hvNV_ARG_EXPAND const GLhalfNV * v
#define glVertex4hvNV_ARG_NAMES_TAIL , v
#define glVertex4hvNV_ARG_EXPAND_TAIL , const GLhalfNV * v
#define forward_glVertex4hvNV(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4hvNV(dst, _v), NULL); \
    });
#define call_glVertex4hvNV(packed, ret_v) do { \
    glVertex4hvNV_PACKED *unpacked = (glVertex4hvNV_PACKED *)packed; \
    glVertex4hvNV_ARGS *args = (glVertex4hvNV_ARGS *)&unpacked->args; \
    glVertex4hvNV(args->v);; \
} while(0)
void glVertex4hvNV(glVertex4hvNV_ARG_EXPAND);
packed_call_t *pack_glVertex4hvNV(glVertex4hvNV_PACKED *_dst glVertex4hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertex4hvNV_PTR)(glVertex4hvNV_ARG_EXPAND);
#endif
#ifndef glVertex4i_RETURN
#define glVertex4i_RETURN void
#define glVertex4i_ARG_NAMES x, y, z, w
#define glVertex4i_ARG_EXPAND GLint x, GLint y, GLint z, GLint w
#define glVertex4i_ARG_NAMES_TAIL , x, y, z, w
#define glVertex4i_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z, GLint w
#define forward_glVertex4i(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4i(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glVertex4i(packed, ret_v) do { \
    glVertex4i_PACKED *unpacked = (glVertex4i_PACKED *)packed; \
    glVertex4i_ARGS *args = (glVertex4i_ARGS *)&unpacked->args; \
    glVertex4i(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4i(glVertex4i_ARG_EXPAND);
packed_call_t *pack_glVertex4i(glVertex4i_PACKED *_dst glVertex4i_ARG_EXPAND_TAIL);
typedef void (*glVertex4i_PTR)(glVertex4i_ARG_EXPAND);
#endif
#ifndef glVertex4iv_RETURN
#define glVertex4iv_RETURN void
#define glVertex4iv_ARG_NAMES v
#define glVertex4iv_ARG_EXPAND const GLint * v
#define glVertex4iv_ARG_NAMES_TAIL , v
#define glVertex4iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glVertex4iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4iv(dst, _v), NULL); \
    });
#define call_glVertex4iv(packed, ret_v) do { \
    glVertex4iv_PACKED *unpacked = (glVertex4iv_PACKED *)packed; \
    glVertex4iv_ARGS *args = (glVertex4iv_ARGS *)&unpacked->args; \
    glVertex4iv(args->v);; \
} while(0)
void glVertex4iv(glVertex4iv_ARG_EXPAND);
packed_call_t *pack_glVertex4iv(glVertex4iv_PACKED *_dst glVertex4iv_ARG_EXPAND_TAIL);
typedef void (*glVertex4iv_PTR)(glVertex4iv_ARG_EXPAND);
#endif
#ifndef glVertex4s_RETURN
#define glVertex4s_RETURN void
#define glVertex4s_ARG_NAMES x, y, z, w
#define glVertex4s_ARG_EXPAND GLshort x, GLshort y, GLshort z, GLshort w
#define glVertex4s_ARG_NAMES_TAIL , x, y, z, w
#define glVertex4s_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z, GLshort w
#define forward_glVertex4s(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4s(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glVertex4s(packed, ret_v) do { \
    glVertex4s_PACKED *unpacked = (glVertex4s_PACKED *)packed; \
    glVertex4s_ARGS *args = (glVertex4s_ARGS *)&unpacked->args; \
    glVertex4s(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4s(glVertex4s_ARG_EXPAND);
packed_call_t *pack_glVertex4s(glVertex4s_PACKED *_dst glVertex4s_ARG_EXPAND_TAIL);
typedef void (*glVertex4s_PTR)(glVertex4s_ARG_EXPAND);
#endif
#ifndef glVertex4sv_RETURN
#define glVertex4sv_RETURN void
#define glVertex4sv_ARG_NAMES v
#define glVertex4sv_ARG_EXPAND const GLshort * v
#define glVertex4sv_ARG_NAMES_TAIL , v
#define glVertex4sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glVertex4sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4sv(dst, _v), NULL); \
    });
#define call_glVertex4sv(packed, ret_v) do { \
    glVertex4sv_PACKED *unpacked = (glVertex4sv_PACKED *)packed; \
    glVertex4sv_ARGS *args = (glVertex4sv_ARGS *)&unpacked->args; \
    glVertex4sv(args->v);; \
} while(0)
void glVertex4sv(glVertex4sv_ARG_EXPAND);
packed_call_t *pack_glVertex4sv(glVertex4sv_PACKED *_dst glVertex4sv_ARG_EXPAND_TAIL);
typedef void (*glVertex4sv_PTR)(glVertex4sv_ARG_EXPAND);
#endif
#ifndef glVertex4xOES_RETURN
#define glVertex4xOES_RETURN void
#define glVertex4xOES_ARG_NAMES x, y, z
#define glVertex4xOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glVertex4xOES_ARG_NAMES_TAIL , x, y, z
#define glVertex4xOES_ARG_EXPAND_TAIL , GLfixed x, GLfixed y, GLfixed z
#define forward_glVertex4xOES(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4xOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4xOES(dst, _x, _y, _z), NULL); \
    });
#define call_glVertex4xOES(packed, ret_v) do { \
    glVertex4xOES_PACKED *unpacked = (glVertex4xOES_PACKED *)packed; \
    glVertex4xOES_ARGS *args = (glVertex4xOES_ARGS *)&unpacked->args; \
    glVertex4xOES(args->x, args->y, args->z);; \
} while(0)
void glVertex4xOES(glVertex4xOES_ARG_EXPAND);
packed_call_t *pack_glVertex4xOES(glVertex4xOES_PACKED *_dst glVertex4xOES_ARG_EXPAND_TAIL);
typedef void (*glVertex4xOES_PTR)(glVertex4xOES_ARG_EXPAND);
#endif
#ifndef glVertex4xvOES_RETURN
#define glVertex4xvOES_RETURN void
#define glVertex4xvOES_ARG_NAMES coords
#define glVertex4xvOES_ARG_EXPAND const GLfixed * coords
#define glVertex4xvOES_ARG_NAMES_TAIL , coords
#define glVertex4xvOES_ARG_EXPAND_TAIL , const GLfixed * coords
#define forward_glVertex4xvOES(_coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertex4xvOES_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertex4xvOES(dst, _coords), NULL); \
    });
#define call_glVertex4xvOES(packed, ret_v) do { \
    glVertex4xvOES_PACKED *unpacked = (glVertex4xvOES_PACKED *)packed; \
    glVertex4xvOES_ARGS *args = (glVertex4xvOES_ARGS *)&unpacked->args; \
    glVertex4xvOES(args->coords);; \
} while(0)
void glVertex4xvOES(glVertex4xvOES_ARG_EXPAND);
packed_call_t *pack_glVertex4xvOES(glVertex4xvOES_PACKED *_dst glVertex4xvOES_ARG_EXPAND_TAIL);
typedef void (*glVertex4xvOES_PTR)(glVertex4xvOES_ARG_EXPAND);
#endif
#ifndef glVertexArrayBindVertexBufferEXT_RETURN
#define glVertexArrayBindVertexBufferEXT_RETURN void
#define glVertexArrayBindVertexBufferEXT_ARG_NAMES vaobj, bindingindex, buffer, offset, stride
#define glVertexArrayBindVertexBufferEXT_ARG_EXPAND GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride
#define glVertexArrayBindVertexBufferEXT_ARG_NAMES_TAIL , vaobj, bindingindex, buffer, offset, stride
#define glVertexArrayBindVertexBufferEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride
#define forward_glVertexArrayBindVertexBufferEXT(_vaobj, _bindingindex, _buffer, _offset, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayBindVertexBufferEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayBindVertexBufferEXT(dst, _vaobj, _bindingindex, _buffer, _offset, _stride), NULL); \
    });
#define call_glVertexArrayBindVertexBufferEXT(packed, ret_v) do { \
    glVertexArrayBindVertexBufferEXT_PACKED *unpacked = (glVertexArrayBindVertexBufferEXT_PACKED *)packed; \
    glVertexArrayBindVertexBufferEXT_ARGS *args = (glVertexArrayBindVertexBufferEXT_ARGS *)&unpacked->args; \
    glVertexArrayBindVertexBufferEXT(args->vaobj, args->bindingindex, args->buffer, args->offset, args->stride);; \
} while(0)
void glVertexArrayBindVertexBufferEXT(glVertexArrayBindVertexBufferEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayBindVertexBufferEXT(glVertexArrayBindVertexBufferEXT_PACKED *_dst glVertexArrayBindVertexBufferEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayBindVertexBufferEXT_PTR)(glVertexArrayBindVertexBufferEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayColorOffsetEXT_RETURN
#define glVertexArrayColorOffsetEXT_RETURN void
#define glVertexArrayColorOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArrayColorOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayColorOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, size, type, stride, offset
#define glVertexArrayColorOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayColorOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayColorOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayColorOffsetEXT(dst, _vaobj, _buffer, _size, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayColorOffsetEXT(packed, ret_v) do { \
    glVertexArrayColorOffsetEXT_PACKED *unpacked = (glVertexArrayColorOffsetEXT_PACKED *)packed; \
    glVertexArrayColorOffsetEXT_ARGS *args = (glVertexArrayColorOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayColorOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayColorOffsetEXT(glVertexArrayColorOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayColorOffsetEXT(glVertexArrayColorOffsetEXT_PACKED *_dst glVertexArrayColorOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayColorOffsetEXT_PTR)(glVertexArrayColorOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayEdgeFlagOffsetEXT_RETURN
#define glVertexArrayEdgeFlagOffsetEXT_RETURN void
#define glVertexArrayEdgeFlagOffsetEXT_ARG_NAMES vaobj, buffer, stride, offset
#define glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset
#define glVertexArrayEdgeFlagOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, stride, offset
#define glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset
#define forward_glVertexArrayEdgeFlagOffsetEXT(_vaobj, _buffer, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayEdgeFlagOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayEdgeFlagOffsetEXT(dst, _vaobj, _buffer, _stride, _offset), NULL); \
    });
#define call_glVertexArrayEdgeFlagOffsetEXT(packed, ret_v) do { \
    glVertexArrayEdgeFlagOffsetEXT_PACKED *unpacked = (glVertexArrayEdgeFlagOffsetEXT_PACKED *)packed; \
    glVertexArrayEdgeFlagOffsetEXT_ARGS *args = (glVertexArrayEdgeFlagOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayEdgeFlagOffsetEXT(args->vaobj, args->buffer, args->stride, args->offset);; \
} while(0)
void glVertexArrayEdgeFlagOffsetEXT(glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayEdgeFlagOffsetEXT(glVertexArrayEdgeFlagOffsetEXT_PACKED *_dst glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayEdgeFlagOffsetEXT_PTR)(glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayFogCoordOffsetEXT_RETURN
#define glVertexArrayFogCoordOffsetEXT_RETURN void
#define glVertexArrayFogCoordOffsetEXT_ARG_NAMES vaobj, buffer, type, stride, offset
#define glVertexArrayFogCoordOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayFogCoordOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, type, stride, offset
#define glVertexArrayFogCoordOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayFogCoordOffsetEXT(_vaobj, _buffer, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayFogCoordOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayFogCoordOffsetEXT(dst, _vaobj, _buffer, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayFogCoordOffsetEXT(packed, ret_v) do { \
    glVertexArrayFogCoordOffsetEXT_PACKED *unpacked = (glVertexArrayFogCoordOffsetEXT_PACKED *)packed; \
    glVertexArrayFogCoordOffsetEXT_ARGS *args = (glVertexArrayFogCoordOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayFogCoordOffsetEXT(args->vaobj, args->buffer, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayFogCoordOffsetEXT(glVertexArrayFogCoordOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayFogCoordOffsetEXT(glVertexArrayFogCoordOffsetEXT_PACKED *_dst glVertexArrayFogCoordOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayFogCoordOffsetEXT_PTR)(glVertexArrayFogCoordOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayIndexOffsetEXT_RETURN
#define glVertexArrayIndexOffsetEXT_RETURN void
#define glVertexArrayIndexOffsetEXT_ARG_NAMES vaobj, buffer, type, stride, offset
#define glVertexArrayIndexOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayIndexOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, type, stride, offset
#define glVertexArrayIndexOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayIndexOffsetEXT(_vaobj, _buffer, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayIndexOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayIndexOffsetEXT(dst, _vaobj, _buffer, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayIndexOffsetEXT(packed, ret_v) do { \
    glVertexArrayIndexOffsetEXT_PACKED *unpacked = (glVertexArrayIndexOffsetEXT_PACKED *)packed; \
    glVertexArrayIndexOffsetEXT_ARGS *args = (glVertexArrayIndexOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayIndexOffsetEXT(args->vaobj, args->buffer, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayIndexOffsetEXT(glVertexArrayIndexOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayIndexOffsetEXT(glVertexArrayIndexOffsetEXT_PACKED *_dst glVertexArrayIndexOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayIndexOffsetEXT_PTR)(glVertexArrayIndexOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayMultiTexCoordOffsetEXT_RETURN
#define glVertexArrayMultiTexCoordOffsetEXT_RETURN void
#define glVertexArrayMultiTexCoordOffsetEXT_ARG_NAMES vaobj, buffer, texunit, size, type, stride, offset
#define glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayMultiTexCoordOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, texunit, size, type, stride, offset
#define glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayMultiTexCoordOffsetEXT(_vaobj, _buffer, _texunit, _size, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayMultiTexCoordOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayMultiTexCoordOffsetEXT(dst, _vaobj, _buffer, _texunit, _size, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayMultiTexCoordOffsetEXT(packed, ret_v) do { \
    glVertexArrayMultiTexCoordOffsetEXT_PACKED *unpacked = (glVertexArrayMultiTexCoordOffsetEXT_PACKED *)packed; \
    glVertexArrayMultiTexCoordOffsetEXT_ARGS *args = (glVertexArrayMultiTexCoordOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayMultiTexCoordOffsetEXT(args->vaobj, args->buffer, args->texunit, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayMultiTexCoordOffsetEXT(glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayMultiTexCoordOffsetEXT(glVertexArrayMultiTexCoordOffsetEXT_PACKED *_dst glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayMultiTexCoordOffsetEXT_PTR)(glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayNormalOffsetEXT_RETURN
#define glVertexArrayNormalOffsetEXT_RETURN void
#define glVertexArrayNormalOffsetEXT_ARG_NAMES vaobj, buffer, type, stride, offset
#define glVertexArrayNormalOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayNormalOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, type, stride, offset
#define glVertexArrayNormalOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayNormalOffsetEXT(_vaobj, _buffer, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayNormalOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayNormalOffsetEXT(dst, _vaobj, _buffer, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayNormalOffsetEXT(packed, ret_v) do { \
    glVertexArrayNormalOffsetEXT_PACKED *unpacked = (glVertexArrayNormalOffsetEXT_PACKED *)packed; \
    glVertexArrayNormalOffsetEXT_ARGS *args = (glVertexArrayNormalOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayNormalOffsetEXT(args->vaobj, args->buffer, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayNormalOffsetEXT(glVertexArrayNormalOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayNormalOffsetEXT(glVertexArrayNormalOffsetEXT_PACKED *_dst glVertexArrayNormalOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayNormalOffsetEXT_PTR)(glVertexArrayNormalOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayParameteriAPPLE_RETURN
#define glVertexArrayParameteriAPPLE_RETURN void
#define glVertexArrayParameteriAPPLE_ARG_NAMES pname, param
#define glVertexArrayParameteriAPPLE_ARG_EXPAND GLenum pname, GLint param
#define glVertexArrayParameteriAPPLE_ARG_NAMES_TAIL , pname, param
#define glVertexArrayParameteriAPPLE_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glVertexArrayParameteriAPPLE(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayParameteriAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayParameteriAPPLE(dst, _pname, _param), NULL); \
    });
#define call_glVertexArrayParameteriAPPLE(packed, ret_v) do { \
    glVertexArrayParameteriAPPLE_PACKED *unpacked = (glVertexArrayParameteriAPPLE_PACKED *)packed; \
    glVertexArrayParameteriAPPLE_ARGS *args = (glVertexArrayParameteriAPPLE_ARGS *)&unpacked->args; \
    glVertexArrayParameteriAPPLE(args->pname, args->param);; \
} while(0)
void glVertexArrayParameteriAPPLE(glVertexArrayParameteriAPPLE_ARG_EXPAND);
packed_call_t *pack_glVertexArrayParameteriAPPLE(glVertexArrayParameteriAPPLE_PACKED *_dst glVertexArrayParameteriAPPLE_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayParameteriAPPLE_PTR)(glVertexArrayParameteriAPPLE_ARG_EXPAND);
#endif
#ifndef glVertexArrayRangeAPPLE_RETURN
#define glVertexArrayRangeAPPLE_RETURN void
#define glVertexArrayRangeAPPLE_ARG_NAMES length, pointer
#define glVertexArrayRangeAPPLE_ARG_EXPAND GLsizei length, GLvoid * pointer
#define glVertexArrayRangeAPPLE_ARG_NAMES_TAIL , length, pointer
#define glVertexArrayRangeAPPLE_ARG_EXPAND_TAIL , GLsizei length, GLvoid * pointer
#define forward_glVertexArrayRangeAPPLE(_length, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayRangeAPPLE_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayRangeAPPLE(dst, _length, _pointer), NULL); \
    });
#define call_glVertexArrayRangeAPPLE(packed, ret_v) do { \
    glVertexArrayRangeAPPLE_PACKED *unpacked = (glVertexArrayRangeAPPLE_PACKED *)packed; \
    glVertexArrayRangeAPPLE_ARGS *args = (glVertexArrayRangeAPPLE_ARGS *)&unpacked->args; \
    glVertexArrayRangeAPPLE(args->length, args->pointer);; \
} while(0)
void glVertexArrayRangeAPPLE(glVertexArrayRangeAPPLE_ARG_EXPAND);
packed_call_t *pack_glVertexArrayRangeAPPLE(glVertexArrayRangeAPPLE_PACKED *_dst glVertexArrayRangeAPPLE_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayRangeAPPLE_PTR)(glVertexArrayRangeAPPLE_ARG_EXPAND);
#endif
#ifndef glVertexArrayRangeNV_RETURN
#define glVertexArrayRangeNV_RETURN void
#define glVertexArrayRangeNV_ARG_NAMES length, pointer
#define glVertexArrayRangeNV_ARG_EXPAND GLsizei length, const GLvoid * pointer
#define glVertexArrayRangeNV_ARG_NAMES_TAIL , length, pointer
#define glVertexArrayRangeNV_ARG_EXPAND_TAIL , GLsizei length, const GLvoid * pointer
#define forward_glVertexArrayRangeNV(_length, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayRangeNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayRangeNV(dst, _length, _pointer), NULL); \
    });
#define call_glVertexArrayRangeNV(packed, ret_v) do { \
    glVertexArrayRangeNV_PACKED *unpacked = (glVertexArrayRangeNV_PACKED *)packed; \
    glVertexArrayRangeNV_ARGS *args = (glVertexArrayRangeNV_ARGS *)&unpacked->args; \
    glVertexArrayRangeNV(args->length, args->pointer);; \
} while(0)
void glVertexArrayRangeNV(glVertexArrayRangeNV_ARG_EXPAND);
packed_call_t *pack_glVertexArrayRangeNV(glVertexArrayRangeNV_PACKED *_dst glVertexArrayRangeNV_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayRangeNV_PTR)(glVertexArrayRangeNV_ARG_EXPAND);
#endif
#ifndef glVertexArraySecondaryColorOffsetEXT_RETURN
#define glVertexArraySecondaryColorOffsetEXT_RETURN void
#define glVertexArraySecondaryColorOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArraySecondaryColorOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, size, type, stride, offset
#define glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArraySecondaryColorOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArraySecondaryColorOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArraySecondaryColorOffsetEXT(dst, _vaobj, _buffer, _size, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArraySecondaryColorOffsetEXT(packed, ret_v) do { \
    glVertexArraySecondaryColorOffsetEXT_PACKED *unpacked = (glVertexArraySecondaryColorOffsetEXT_PACKED *)packed; \
    glVertexArraySecondaryColorOffsetEXT_ARGS *args = (glVertexArraySecondaryColorOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArraySecondaryColorOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArraySecondaryColorOffsetEXT(glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArraySecondaryColorOffsetEXT(glVertexArraySecondaryColorOffsetEXT_PACKED *_dst glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArraySecondaryColorOffsetEXT_PTR)(glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayTexCoordOffsetEXT_RETURN
#define glVertexArrayTexCoordOffsetEXT_RETURN void
#define glVertexArrayTexCoordOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArrayTexCoordOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayTexCoordOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, size, type, stride, offset
#define glVertexArrayTexCoordOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayTexCoordOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayTexCoordOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayTexCoordOffsetEXT(dst, _vaobj, _buffer, _size, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayTexCoordOffsetEXT(packed, ret_v) do { \
    glVertexArrayTexCoordOffsetEXT_PACKED *unpacked = (glVertexArrayTexCoordOffsetEXT_PACKED *)packed; \
    glVertexArrayTexCoordOffsetEXT_ARGS *args = (glVertexArrayTexCoordOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayTexCoordOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayTexCoordOffsetEXT(glVertexArrayTexCoordOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayTexCoordOffsetEXT(glVertexArrayTexCoordOffsetEXT_PACKED *_dst glVertexArrayTexCoordOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayTexCoordOffsetEXT_PTR)(glVertexArrayTexCoordOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexAttribBindingEXT_RETURN
#define glVertexArrayVertexAttribBindingEXT_RETURN void
#define glVertexArrayVertexAttribBindingEXT_ARG_NAMES vaobj, attribindex, bindingindex
#define glVertexArrayVertexAttribBindingEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLuint bindingindex
#define glVertexArrayVertexAttribBindingEXT_ARG_NAMES_TAIL , vaobj, attribindex, bindingindex
#define glVertexArrayVertexAttribBindingEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint attribindex, GLuint bindingindex
#define forward_glVertexArrayVertexAttribBindingEXT(_vaobj, _attribindex, _bindingindex) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexAttribBindingEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexAttribBindingEXT(dst, _vaobj, _attribindex, _bindingindex), NULL); \
    });
#define call_glVertexArrayVertexAttribBindingEXT(packed, ret_v) do { \
    glVertexArrayVertexAttribBindingEXT_PACKED *unpacked = (glVertexArrayVertexAttribBindingEXT_PACKED *)packed; \
    glVertexArrayVertexAttribBindingEXT_ARGS *args = (glVertexArrayVertexAttribBindingEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexAttribBindingEXT(args->vaobj, args->attribindex, args->bindingindex);; \
} while(0)
void glVertexArrayVertexAttribBindingEXT(glVertexArrayVertexAttribBindingEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexAttribBindingEXT(glVertexArrayVertexAttribBindingEXT_PACKED *_dst glVertexArrayVertexAttribBindingEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexAttribBindingEXT_PTR)(glVertexArrayVertexAttribBindingEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexAttribFormatEXT_RETURN
#define glVertexArrayVertexAttribFormatEXT_RETURN void
#define glVertexArrayVertexAttribFormatEXT_ARG_NAMES vaobj, attribindex, size, type, normalized, relativeoffset
#define glVertexArrayVertexAttribFormatEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset
#define glVertexArrayVertexAttribFormatEXT_ARG_NAMES_TAIL , vaobj, attribindex, size, type, normalized, relativeoffset
#define glVertexArrayVertexAttribFormatEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset
#define forward_glVertexArrayVertexAttribFormatEXT(_vaobj, _attribindex, _size, _type, _normalized, _relativeoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexAttribFormatEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexAttribFormatEXT(dst, _vaobj, _attribindex, _size, _type, _normalized, _relativeoffset), NULL); \
    });
#define call_glVertexArrayVertexAttribFormatEXT(packed, ret_v) do { \
    glVertexArrayVertexAttribFormatEXT_PACKED *unpacked = (glVertexArrayVertexAttribFormatEXT_PACKED *)packed; \
    glVertexArrayVertexAttribFormatEXT_ARGS *args = (glVertexArrayVertexAttribFormatEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexAttribFormatEXT(args->vaobj, args->attribindex, args->size, args->type, args->normalized, args->relativeoffset);; \
} while(0)
void glVertexArrayVertexAttribFormatEXT(glVertexArrayVertexAttribFormatEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexAttribFormatEXT(glVertexArrayVertexAttribFormatEXT_PACKED *_dst glVertexArrayVertexAttribFormatEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexAttribFormatEXT_PTR)(glVertexArrayVertexAttribFormatEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexAttribIFormatEXT_RETURN
#define glVertexArrayVertexAttribIFormatEXT_RETURN void
#define glVertexArrayVertexAttribIFormatEXT_ARG_NAMES vaobj, attribindex, size, type, relativeoffset
#define glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexArrayVertexAttribIFormatEXT_ARG_NAMES_TAIL , vaobj, attribindex, size, type, relativeoffset
#define glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define forward_glVertexArrayVertexAttribIFormatEXT(_vaobj, _attribindex, _size, _type, _relativeoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexAttribIFormatEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexAttribIFormatEXT(dst, _vaobj, _attribindex, _size, _type, _relativeoffset), NULL); \
    });
#define call_glVertexArrayVertexAttribIFormatEXT(packed, ret_v) do { \
    glVertexArrayVertexAttribIFormatEXT_PACKED *unpacked = (glVertexArrayVertexAttribIFormatEXT_PACKED *)packed; \
    glVertexArrayVertexAttribIFormatEXT_ARGS *args = (glVertexArrayVertexAttribIFormatEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexAttribIFormatEXT(args->vaobj, args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexArrayVertexAttribIFormatEXT(glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexAttribIFormatEXT(glVertexArrayVertexAttribIFormatEXT_PACKED *_dst glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexAttribIFormatEXT_PTR)(glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexAttribIOffsetEXT_RETURN
#define glVertexArrayVertexAttribIOffsetEXT_RETURN void
#define glVertexArrayVertexAttribIOffsetEXT_ARG_NAMES vaobj, buffer, index, size, type, stride, offset
#define glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayVertexAttribIOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, index, size, type, stride, offset
#define glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayVertexAttribIOffsetEXT(_vaobj, _buffer, _index, _size, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexAttribIOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexAttribIOffsetEXT(dst, _vaobj, _buffer, _index, _size, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayVertexAttribIOffsetEXT(packed, ret_v) do { \
    glVertexArrayVertexAttribIOffsetEXT_PACKED *unpacked = (glVertexArrayVertexAttribIOffsetEXT_PACKED *)packed; \
    glVertexArrayVertexAttribIOffsetEXT_ARGS *args = (glVertexArrayVertexAttribIOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexAttribIOffsetEXT(args->vaobj, args->buffer, args->index, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexAttribIOffsetEXT(glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexAttribIOffsetEXT(glVertexArrayVertexAttribIOffsetEXT_PACKED *_dst glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexAttribIOffsetEXT_PTR)(glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexAttribLFormatEXT_RETURN
#define glVertexArrayVertexAttribLFormatEXT_RETURN void
#define glVertexArrayVertexAttribLFormatEXT_ARG_NAMES vaobj, attribindex, size, type, relativeoffset
#define glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexArrayVertexAttribLFormatEXT_ARG_NAMES_TAIL , vaobj, attribindex, size, type, relativeoffset
#define glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define forward_glVertexArrayVertexAttribLFormatEXT(_vaobj, _attribindex, _size, _type, _relativeoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexAttribLFormatEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexAttribLFormatEXT(dst, _vaobj, _attribindex, _size, _type, _relativeoffset), NULL); \
    });
#define call_glVertexArrayVertexAttribLFormatEXT(packed, ret_v) do { \
    glVertexArrayVertexAttribLFormatEXT_PACKED *unpacked = (glVertexArrayVertexAttribLFormatEXT_PACKED *)packed; \
    glVertexArrayVertexAttribLFormatEXT_ARGS *args = (glVertexArrayVertexAttribLFormatEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexAttribLFormatEXT(args->vaobj, args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexArrayVertexAttribLFormatEXT(glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexAttribLFormatEXT(glVertexArrayVertexAttribLFormatEXT_PACKED *_dst glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexAttribLFormatEXT_PTR)(glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexAttribLOffsetEXT_RETURN
#define glVertexArrayVertexAttribLOffsetEXT_RETURN void
#define glVertexArrayVertexAttribLOffsetEXT_ARG_NAMES vaobj, buffer, index, size, type, stride, offset
#define glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayVertexAttribLOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, index, size, type, stride, offset
#define glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayVertexAttribLOffsetEXT(_vaobj, _buffer, _index, _size, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexAttribLOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexAttribLOffsetEXT(dst, _vaobj, _buffer, _index, _size, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayVertexAttribLOffsetEXT(packed, ret_v) do { \
    glVertexArrayVertexAttribLOffsetEXT_PACKED *unpacked = (glVertexArrayVertexAttribLOffsetEXT_PACKED *)packed; \
    glVertexArrayVertexAttribLOffsetEXT_ARGS *args = (glVertexArrayVertexAttribLOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexAttribLOffsetEXT(args->vaobj, args->buffer, args->index, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexAttribLOffsetEXT(glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexAttribLOffsetEXT(glVertexArrayVertexAttribLOffsetEXT_PACKED *_dst glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexAttribLOffsetEXT_PTR)(glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexAttribOffsetEXT_RETURN
#define glVertexArrayVertexAttribOffsetEXT_RETURN void
#define glVertexArrayVertexAttribOffsetEXT_ARG_NAMES vaobj, buffer, index, size, type, normalized, stride, offset
#define glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset
#define glVertexArrayVertexAttribOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, index, size, type, normalized, stride, offset
#define glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset
#define forward_glVertexArrayVertexAttribOffsetEXT(_vaobj, _buffer, _index, _size, _type, _normalized, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexAttribOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexAttribOffsetEXT(dst, _vaobj, _buffer, _index, _size, _type, _normalized, _stride, _offset), NULL); \
    });
#define call_glVertexArrayVertexAttribOffsetEXT(packed, ret_v) do { \
    glVertexArrayVertexAttribOffsetEXT_PACKED *unpacked = (glVertexArrayVertexAttribOffsetEXT_PACKED *)packed; \
    glVertexArrayVertexAttribOffsetEXT_ARGS *args = (glVertexArrayVertexAttribOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexAttribOffsetEXT(args->vaobj, args->buffer, args->index, args->size, args->type, args->normalized, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexAttribOffsetEXT(glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexAttribOffsetEXT(glVertexArrayVertexAttribOffsetEXT_PACKED *_dst glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexAttribOffsetEXT_PTR)(glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexBindingDivisorEXT_RETURN
#define glVertexArrayVertexBindingDivisorEXT_RETURN void
#define glVertexArrayVertexBindingDivisorEXT_ARG_NAMES vaobj, bindingindex, divisor
#define glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND GLuint vaobj, GLuint bindingindex, GLuint divisor
#define glVertexArrayVertexBindingDivisorEXT_ARG_NAMES_TAIL , vaobj, bindingindex, divisor
#define glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint bindingindex, GLuint divisor
#define forward_glVertexArrayVertexBindingDivisorEXT(_vaobj, _bindingindex, _divisor) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexBindingDivisorEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexBindingDivisorEXT(dst, _vaobj, _bindingindex, _divisor), NULL); \
    });
#define call_glVertexArrayVertexBindingDivisorEXT(packed, ret_v) do { \
    glVertexArrayVertexBindingDivisorEXT_PACKED *unpacked = (glVertexArrayVertexBindingDivisorEXT_PACKED *)packed; \
    glVertexArrayVertexBindingDivisorEXT_ARGS *args = (glVertexArrayVertexBindingDivisorEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexBindingDivisorEXT(args->vaobj, args->bindingindex, args->divisor);; \
} while(0)
void glVertexArrayVertexBindingDivisorEXT(glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexBindingDivisorEXT(glVertexArrayVertexBindingDivisorEXT_PACKED *_dst glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexBindingDivisorEXT_PTR)(glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND);
#endif
#ifndef glVertexArrayVertexOffsetEXT_RETURN
#define glVertexArrayVertexOffsetEXT_RETURN void
#define glVertexArrayVertexOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArrayVertexOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayVertexOffsetEXT_ARG_NAMES_TAIL , vaobj, buffer, size, type, stride, offset
#define glVertexArrayVertexOffsetEXT_ARG_EXPAND_TAIL , GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define forward_glVertexArrayVertexOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexArrayVertexOffsetEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexArrayVertexOffsetEXT(dst, _vaobj, _buffer, _size, _type, _stride, _offset), NULL); \
    });
#define call_glVertexArrayVertexOffsetEXT(packed, ret_v) do { \
    glVertexArrayVertexOffsetEXT_PACKED *unpacked = (glVertexArrayVertexOffsetEXT_PACKED *)packed; \
    glVertexArrayVertexOffsetEXT_ARGS *args = (glVertexArrayVertexOffsetEXT_ARGS *)&unpacked->args; \
    glVertexArrayVertexOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexOffsetEXT(glVertexArrayVertexOffsetEXT_ARG_EXPAND);
packed_call_t *pack_glVertexArrayVertexOffsetEXT(glVertexArrayVertexOffsetEXT_PACKED *_dst glVertexArrayVertexOffsetEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexArrayVertexOffsetEXT_PTR)(glVertexArrayVertexOffsetEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1d_RETURN
#define glVertexAttrib1d_RETURN void
#define glVertexAttrib1d_ARG_NAMES index, x
#define glVertexAttrib1d_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttrib1d_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1d_ARG_EXPAND_TAIL , GLuint index, GLdouble x
#define forward_glVertexAttrib1d(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1d(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1d(packed, ret_v) do { \
    glVertexAttrib1d_PACKED *unpacked = (glVertexAttrib1d_PACKED *)packed; \
    glVertexAttrib1d_ARGS *args = (glVertexAttrib1d_ARGS *)&unpacked->args; \
    glVertexAttrib1d(args->index, args->x);; \
} while(0)
void glVertexAttrib1d(glVertexAttrib1d_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1d(glVertexAttrib1d_PACKED *_dst glVertexAttrib1d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1d_PTR)(glVertexAttrib1d_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1dARB_RETURN
#define glVertexAttrib1dARB_RETURN void
#define glVertexAttrib1dARB_ARG_NAMES index, x
#define glVertexAttrib1dARB_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttrib1dARB_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1dARB_ARG_EXPAND_TAIL , GLuint index, GLdouble x
#define forward_glVertexAttrib1dARB(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1dARB(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1dARB(packed, ret_v) do { \
    glVertexAttrib1dARB_PACKED *unpacked = (glVertexAttrib1dARB_PACKED *)packed; \
    glVertexAttrib1dARB_ARGS *args = (glVertexAttrib1dARB_ARGS *)&unpacked->args; \
    glVertexAttrib1dARB(args->index, args->x);; \
} while(0)
void glVertexAttrib1dARB(glVertexAttrib1dARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1dARB(glVertexAttrib1dARB_PACKED *_dst glVertexAttrib1dARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1dARB_PTR)(glVertexAttrib1dARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1dNV_RETURN
#define glVertexAttrib1dNV_RETURN void
#define glVertexAttrib1dNV_ARG_NAMES index, x
#define glVertexAttrib1dNV_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttrib1dNV_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1dNV_ARG_EXPAND_TAIL , GLuint index, GLdouble x
#define forward_glVertexAttrib1dNV(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1dNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1dNV(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1dNV(packed, ret_v) do { \
    glVertexAttrib1dNV_PACKED *unpacked = (glVertexAttrib1dNV_PACKED *)packed; \
    glVertexAttrib1dNV_ARGS *args = (glVertexAttrib1dNV_ARGS *)&unpacked->args; \
    glVertexAttrib1dNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1dNV(glVertexAttrib1dNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1dNV(glVertexAttrib1dNV_PACKED *_dst glVertexAttrib1dNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1dNV_PTR)(glVertexAttrib1dNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1dv_RETURN
#define glVertexAttrib1dv_RETURN void
#define glVertexAttrib1dv_ARG_NAMES index, v
#define glVertexAttrib1dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib1dv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib1dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1dv(packed, ret_v) do { \
    glVertexAttrib1dv_PACKED *unpacked = (glVertexAttrib1dv_PACKED *)packed; \
    glVertexAttrib1dv_ARGS *args = (glVertexAttrib1dv_ARGS *)&unpacked->args; \
    glVertexAttrib1dv(args->index, args->v);; \
} while(0)
void glVertexAttrib1dv(glVertexAttrib1dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1dv(glVertexAttrib1dv_PACKED *_dst glVertexAttrib1dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1dv_PTR)(glVertexAttrib1dv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1dvARB_RETURN
#define glVertexAttrib1dvARB_RETURN void
#define glVertexAttrib1dvARB_ARG_NAMES index, v
#define glVertexAttrib1dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib1dvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1dvARB_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib1dvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1dvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1dvARB(packed, ret_v) do { \
    glVertexAttrib1dvARB_PACKED *unpacked = (glVertexAttrib1dvARB_PACKED *)packed; \
    glVertexAttrib1dvARB_ARGS *args = (glVertexAttrib1dvARB_ARGS *)&unpacked->args; \
    glVertexAttrib1dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib1dvARB(glVertexAttrib1dvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1dvARB(glVertexAttrib1dvARB_PACKED *_dst glVertexAttrib1dvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1dvARB_PTR)(glVertexAttrib1dvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1dvNV_RETURN
#define glVertexAttrib1dvNV_RETURN void
#define glVertexAttrib1dvNV_ARG_NAMES index, v
#define glVertexAttrib1dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib1dvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1dvNV_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib1dvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1dvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1dvNV(packed, ret_v) do { \
    glVertexAttrib1dvNV_PACKED *unpacked = (glVertexAttrib1dvNV_PACKED *)packed; \
    glVertexAttrib1dvNV_ARGS *args = (glVertexAttrib1dvNV_ARGS *)&unpacked->args; \
    glVertexAttrib1dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1dvNV(glVertexAttrib1dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1dvNV(glVertexAttrib1dvNV_PACKED *_dst glVertexAttrib1dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1dvNV_PTR)(glVertexAttrib1dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1f_RETURN
#define glVertexAttrib1f_RETURN void
#define glVertexAttrib1f_ARG_NAMES index, x
#define glVertexAttrib1f_ARG_EXPAND GLuint index, GLfloat x
#define glVertexAttrib1f_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1f_ARG_EXPAND_TAIL , GLuint index, GLfloat x
#define forward_glVertexAttrib1f(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1f(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1f(packed, ret_v) do { \
    glVertexAttrib1f_PACKED *unpacked = (glVertexAttrib1f_PACKED *)packed; \
    glVertexAttrib1f_ARGS *args = (glVertexAttrib1f_ARGS *)&unpacked->args; \
    glVertexAttrib1f(args->index, args->x);; \
} while(0)
void glVertexAttrib1f(glVertexAttrib1f_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1f(glVertexAttrib1f_PACKED *_dst glVertexAttrib1f_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1f_PTR)(glVertexAttrib1f_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1fARB_RETURN
#define glVertexAttrib1fARB_RETURN void
#define glVertexAttrib1fARB_ARG_NAMES index, x
#define glVertexAttrib1fARB_ARG_EXPAND GLuint index, GLfloat x
#define glVertexAttrib1fARB_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1fARB_ARG_EXPAND_TAIL , GLuint index, GLfloat x
#define forward_glVertexAttrib1fARB(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1fARB(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1fARB(packed, ret_v) do { \
    glVertexAttrib1fARB_PACKED *unpacked = (glVertexAttrib1fARB_PACKED *)packed; \
    glVertexAttrib1fARB_ARGS *args = (glVertexAttrib1fARB_ARGS *)&unpacked->args; \
    glVertexAttrib1fARB(args->index, args->x);; \
} while(0)
void glVertexAttrib1fARB(glVertexAttrib1fARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1fARB(glVertexAttrib1fARB_PACKED *_dst glVertexAttrib1fARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1fARB_PTR)(glVertexAttrib1fARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1fNV_RETURN
#define glVertexAttrib1fNV_RETURN void
#define glVertexAttrib1fNV_ARG_NAMES index, x
#define glVertexAttrib1fNV_ARG_EXPAND GLuint index, GLfloat x
#define glVertexAttrib1fNV_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1fNV_ARG_EXPAND_TAIL , GLuint index, GLfloat x
#define forward_glVertexAttrib1fNV(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1fNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1fNV(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1fNV(packed, ret_v) do { \
    glVertexAttrib1fNV_PACKED *unpacked = (glVertexAttrib1fNV_PACKED *)packed; \
    glVertexAttrib1fNV_ARGS *args = (glVertexAttrib1fNV_ARGS *)&unpacked->args; \
    glVertexAttrib1fNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1fNV(glVertexAttrib1fNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1fNV(glVertexAttrib1fNV_PACKED *_dst glVertexAttrib1fNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1fNV_PTR)(glVertexAttrib1fNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1fv_RETURN
#define glVertexAttrib1fv_RETURN void
#define glVertexAttrib1fv_ARG_NAMES index, v
#define glVertexAttrib1fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib1fv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1fv_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib1fv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1fv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1fv(packed, ret_v) do { \
    glVertexAttrib1fv_PACKED *unpacked = (glVertexAttrib1fv_PACKED *)packed; \
    glVertexAttrib1fv_ARGS *args = (glVertexAttrib1fv_ARGS *)&unpacked->args; \
    glVertexAttrib1fv(args->index, args->v);; \
} while(0)
void glVertexAttrib1fv(glVertexAttrib1fv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1fv(glVertexAttrib1fv_PACKED *_dst glVertexAttrib1fv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1fv_PTR)(glVertexAttrib1fv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1fvARB_RETURN
#define glVertexAttrib1fvARB_RETURN void
#define glVertexAttrib1fvARB_ARG_NAMES index, v
#define glVertexAttrib1fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib1fvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1fvARB_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib1fvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1fvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1fvARB(packed, ret_v) do { \
    glVertexAttrib1fvARB_PACKED *unpacked = (glVertexAttrib1fvARB_PACKED *)packed; \
    glVertexAttrib1fvARB_ARGS *args = (glVertexAttrib1fvARB_ARGS *)&unpacked->args; \
    glVertexAttrib1fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib1fvARB(glVertexAttrib1fvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1fvARB(glVertexAttrib1fvARB_PACKED *_dst glVertexAttrib1fvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1fvARB_PTR)(glVertexAttrib1fvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1fvNV_RETURN
#define glVertexAttrib1fvNV_RETURN void
#define glVertexAttrib1fvNV_ARG_NAMES index, v
#define glVertexAttrib1fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib1fvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1fvNV_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib1fvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1fvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1fvNV(packed, ret_v) do { \
    glVertexAttrib1fvNV_PACKED *unpacked = (glVertexAttrib1fvNV_PACKED *)packed; \
    glVertexAttrib1fvNV_ARGS *args = (glVertexAttrib1fvNV_ARGS *)&unpacked->args; \
    glVertexAttrib1fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1fvNV(glVertexAttrib1fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1fvNV(glVertexAttrib1fvNV_PACKED *_dst glVertexAttrib1fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1fvNV_PTR)(glVertexAttrib1fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1hNV_RETURN
#define glVertexAttrib1hNV_RETURN void
#define glVertexAttrib1hNV_ARG_NAMES index, x
#define glVertexAttrib1hNV_ARG_EXPAND GLuint index, GLhalfNV x
#define glVertexAttrib1hNV_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1hNV_ARG_EXPAND_TAIL , GLuint index, GLhalfNV x
#define forward_glVertexAttrib1hNV(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1hNV(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1hNV(packed, ret_v) do { \
    glVertexAttrib1hNV_PACKED *unpacked = (glVertexAttrib1hNV_PACKED *)packed; \
    glVertexAttrib1hNV_ARGS *args = (glVertexAttrib1hNV_ARGS *)&unpacked->args; \
    glVertexAttrib1hNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1hNV(glVertexAttrib1hNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1hNV(glVertexAttrib1hNV_PACKED *_dst glVertexAttrib1hNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1hNV_PTR)(glVertexAttrib1hNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1hvNV_RETURN
#define glVertexAttrib1hvNV_RETURN void
#define glVertexAttrib1hvNV_ARG_NAMES index, v
#define glVertexAttrib1hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib1hvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1hvNV_ARG_EXPAND_TAIL , GLuint index, const GLhalfNV * v
#define forward_glVertexAttrib1hvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1hvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1hvNV(packed, ret_v) do { \
    glVertexAttrib1hvNV_PACKED *unpacked = (glVertexAttrib1hvNV_PACKED *)packed; \
    glVertexAttrib1hvNV_ARGS *args = (glVertexAttrib1hvNV_ARGS *)&unpacked->args; \
    glVertexAttrib1hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1hvNV(glVertexAttrib1hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1hvNV(glVertexAttrib1hvNV_PACKED *_dst glVertexAttrib1hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1hvNV_PTR)(glVertexAttrib1hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1s_RETURN
#define glVertexAttrib1s_RETURN void
#define glVertexAttrib1s_ARG_NAMES index, x
#define glVertexAttrib1s_ARG_EXPAND GLuint index, GLshort x
#define glVertexAttrib1s_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1s_ARG_EXPAND_TAIL , GLuint index, GLshort x
#define forward_glVertexAttrib1s(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1s(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1s(packed, ret_v) do { \
    glVertexAttrib1s_PACKED *unpacked = (glVertexAttrib1s_PACKED *)packed; \
    glVertexAttrib1s_ARGS *args = (glVertexAttrib1s_ARGS *)&unpacked->args; \
    glVertexAttrib1s(args->index, args->x);; \
} while(0)
void glVertexAttrib1s(glVertexAttrib1s_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1s(glVertexAttrib1s_PACKED *_dst glVertexAttrib1s_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1s_PTR)(glVertexAttrib1s_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1sARB_RETURN
#define glVertexAttrib1sARB_RETURN void
#define glVertexAttrib1sARB_ARG_NAMES index, x
#define glVertexAttrib1sARB_ARG_EXPAND GLuint index, GLshort x
#define glVertexAttrib1sARB_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1sARB_ARG_EXPAND_TAIL , GLuint index, GLshort x
#define forward_glVertexAttrib1sARB(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1sARB(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1sARB(packed, ret_v) do { \
    glVertexAttrib1sARB_PACKED *unpacked = (glVertexAttrib1sARB_PACKED *)packed; \
    glVertexAttrib1sARB_ARGS *args = (glVertexAttrib1sARB_ARGS *)&unpacked->args; \
    glVertexAttrib1sARB(args->index, args->x);; \
} while(0)
void glVertexAttrib1sARB(glVertexAttrib1sARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1sARB(glVertexAttrib1sARB_PACKED *_dst glVertexAttrib1sARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1sARB_PTR)(glVertexAttrib1sARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1sNV_RETURN
#define glVertexAttrib1sNV_RETURN void
#define glVertexAttrib1sNV_ARG_NAMES index, x
#define glVertexAttrib1sNV_ARG_EXPAND GLuint index, GLshort x
#define glVertexAttrib1sNV_ARG_NAMES_TAIL , index, x
#define glVertexAttrib1sNV_ARG_EXPAND_TAIL , GLuint index, GLshort x
#define forward_glVertexAttrib1sNV(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1sNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1sNV(dst, _index, _x), NULL); \
    });
#define call_glVertexAttrib1sNV(packed, ret_v) do { \
    glVertexAttrib1sNV_PACKED *unpacked = (glVertexAttrib1sNV_PACKED *)packed; \
    glVertexAttrib1sNV_ARGS *args = (glVertexAttrib1sNV_ARGS *)&unpacked->args; \
    glVertexAttrib1sNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1sNV(glVertexAttrib1sNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1sNV(glVertexAttrib1sNV_PACKED *_dst glVertexAttrib1sNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1sNV_PTR)(glVertexAttrib1sNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1sv_RETURN
#define glVertexAttrib1sv_RETURN void
#define glVertexAttrib1sv_ARG_NAMES index, v
#define glVertexAttrib1sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib1sv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1sv_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib1sv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1sv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1sv(packed, ret_v) do { \
    glVertexAttrib1sv_PACKED *unpacked = (glVertexAttrib1sv_PACKED *)packed; \
    glVertexAttrib1sv_ARGS *args = (glVertexAttrib1sv_ARGS *)&unpacked->args; \
    glVertexAttrib1sv(args->index, args->v);; \
} while(0)
void glVertexAttrib1sv(glVertexAttrib1sv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1sv(glVertexAttrib1sv_PACKED *_dst glVertexAttrib1sv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1sv_PTR)(glVertexAttrib1sv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1svARB_RETURN
#define glVertexAttrib1svARB_RETURN void
#define glVertexAttrib1svARB_ARG_NAMES index, v
#define glVertexAttrib1svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib1svARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1svARB_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib1svARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1svARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1svARB(packed, ret_v) do { \
    glVertexAttrib1svARB_PACKED *unpacked = (glVertexAttrib1svARB_PACKED *)packed; \
    glVertexAttrib1svARB_ARGS *args = (glVertexAttrib1svARB_ARGS *)&unpacked->args; \
    glVertexAttrib1svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib1svARB(glVertexAttrib1svARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1svARB(glVertexAttrib1svARB_PACKED *_dst glVertexAttrib1svARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1svARB_PTR)(glVertexAttrib1svARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib1svNV_RETURN
#define glVertexAttrib1svNV_RETURN void
#define glVertexAttrib1svNV_ARG_NAMES index, v
#define glVertexAttrib1svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib1svNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib1svNV_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib1svNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib1svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib1svNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib1svNV(packed, ret_v) do { \
    glVertexAttrib1svNV_PACKED *unpacked = (glVertexAttrib1svNV_PACKED *)packed; \
    glVertexAttrib1svNV_ARGS *args = (glVertexAttrib1svNV_ARGS *)&unpacked->args; \
    glVertexAttrib1svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1svNV(glVertexAttrib1svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib1svNV(glVertexAttrib1svNV_PACKED *_dst glVertexAttrib1svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib1svNV_PTR)(glVertexAttrib1svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2d_RETURN
#define glVertexAttrib2d_RETURN void
#define glVertexAttrib2d_ARG_NAMES index, x, y
#define glVertexAttrib2d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttrib2d_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2d_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y
#define forward_glVertexAttrib2d(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2d(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2d(packed, ret_v) do { \
    glVertexAttrib2d_PACKED *unpacked = (glVertexAttrib2d_PACKED *)packed; \
    glVertexAttrib2d_ARGS *args = (glVertexAttrib2d_ARGS *)&unpacked->args; \
    glVertexAttrib2d(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2d(glVertexAttrib2d_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2d(glVertexAttrib2d_PACKED *_dst glVertexAttrib2d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2d_PTR)(glVertexAttrib2d_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2dARB_RETURN
#define glVertexAttrib2dARB_RETURN void
#define glVertexAttrib2dARB_ARG_NAMES index, x, y
#define glVertexAttrib2dARB_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttrib2dARB_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2dARB_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y
#define forward_glVertexAttrib2dARB(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2dARB(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2dARB(packed, ret_v) do { \
    glVertexAttrib2dARB_PACKED *unpacked = (glVertexAttrib2dARB_PACKED *)packed; \
    glVertexAttrib2dARB_ARGS *args = (glVertexAttrib2dARB_ARGS *)&unpacked->args; \
    glVertexAttrib2dARB(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2dARB(glVertexAttrib2dARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2dARB(glVertexAttrib2dARB_PACKED *_dst glVertexAttrib2dARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2dARB_PTR)(glVertexAttrib2dARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2dNV_RETURN
#define glVertexAttrib2dNV_RETURN void
#define glVertexAttrib2dNV_ARG_NAMES index, x, y
#define glVertexAttrib2dNV_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttrib2dNV_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2dNV_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y
#define forward_glVertexAttrib2dNV(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2dNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2dNV(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2dNV(packed, ret_v) do { \
    glVertexAttrib2dNV_PACKED *unpacked = (glVertexAttrib2dNV_PACKED *)packed; \
    glVertexAttrib2dNV_ARGS *args = (glVertexAttrib2dNV_ARGS *)&unpacked->args; \
    glVertexAttrib2dNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2dNV(glVertexAttrib2dNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2dNV(glVertexAttrib2dNV_PACKED *_dst glVertexAttrib2dNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2dNV_PTR)(glVertexAttrib2dNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2dv_RETURN
#define glVertexAttrib2dv_RETURN void
#define glVertexAttrib2dv_ARG_NAMES index, v
#define glVertexAttrib2dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib2dv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib2dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2dv(packed, ret_v) do { \
    glVertexAttrib2dv_PACKED *unpacked = (glVertexAttrib2dv_PACKED *)packed; \
    glVertexAttrib2dv_ARGS *args = (glVertexAttrib2dv_ARGS *)&unpacked->args; \
    glVertexAttrib2dv(args->index, args->v);; \
} while(0)
void glVertexAttrib2dv(glVertexAttrib2dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2dv(glVertexAttrib2dv_PACKED *_dst glVertexAttrib2dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2dv_PTR)(glVertexAttrib2dv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2dvARB_RETURN
#define glVertexAttrib2dvARB_RETURN void
#define glVertexAttrib2dvARB_ARG_NAMES index, v
#define glVertexAttrib2dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib2dvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2dvARB_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib2dvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2dvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2dvARB(packed, ret_v) do { \
    glVertexAttrib2dvARB_PACKED *unpacked = (glVertexAttrib2dvARB_PACKED *)packed; \
    glVertexAttrib2dvARB_ARGS *args = (glVertexAttrib2dvARB_ARGS *)&unpacked->args; \
    glVertexAttrib2dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib2dvARB(glVertexAttrib2dvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2dvARB(glVertexAttrib2dvARB_PACKED *_dst glVertexAttrib2dvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2dvARB_PTR)(glVertexAttrib2dvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2dvNV_RETURN
#define glVertexAttrib2dvNV_RETURN void
#define glVertexAttrib2dvNV_ARG_NAMES index, v
#define glVertexAttrib2dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib2dvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2dvNV_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib2dvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2dvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2dvNV(packed, ret_v) do { \
    glVertexAttrib2dvNV_PACKED *unpacked = (glVertexAttrib2dvNV_PACKED *)packed; \
    glVertexAttrib2dvNV_ARGS *args = (glVertexAttrib2dvNV_ARGS *)&unpacked->args; \
    glVertexAttrib2dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2dvNV(glVertexAttrib2dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2dvNV(glVertexAttrib2dvNV_PACKED *_dst glVertexAttrib2dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2dvNV_PTR)(glVertexAttrib2dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2f_RETURN
#define glVertexAttrib2f_RETURN void
#define glVertexAttrib2f_ARG_NAMES index, x, y
#define glVertexAttrib2f_ARG_EXPAND GLuint index, GLfloat x, GLfloat y
#define glVertexAttrib2f_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2f_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y
#define forward_glVertexAttrib2f(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2f(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2f(packed, ret_v) do { \
    glVertexAttrib2f_PACKED *unpacked = (glVertexAttrib2f_PACKED *)packed; \
    glVertexAttrib2f_ARGS *args = (glVertexAttrib2f_ARGS *)&unpacked->args; \
    glVertexAttrib2f(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2f(glVertexAttrib2f_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2f(glVertexAttrib2f_PACKED *_dst glVertexAttrib2f_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2f_PTR)(glVertexAttrib2f_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2fARB_RETURN
#define glVertexAttrib2fARB_RETURN void
#define glVertexAttrib2fARB_ARG_NAMES index, x, y
#define glVertexAttrib2fARB_ARG_EXPAND GLuint index, GLfloat x, GLfloat y
#define glVertexAttrib2fARB_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2fARB_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y
#define forward_glVertexAttrib2fARB(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2fARB(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2fARB(packed, ret_v) do { \
    glVertexAttrib2fARB_PACKED *unpacked = (glVertexAttrib2fARB_PACKED *)packed; \
    glVertexAttrib2fARB_ARGS *args = (glVertexAttrib2fARB_ARGS *)&unpacked->args; \
    glVertexAttrib2fARB(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2fARB(glVertexAttrib2fARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2fARB(glVertexAttrib2fARB_PACKED *_dst glVertexAttrib2fARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2fARB_PTR)(glVertexAttrib2fARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2fNV_RETURN
#define glVertexAttrib2fNV_RETURN void
#define glVertexAttrib2fNV_ARG_NAMES index, x, y
#define glVertexAttrib2fNV_ARG_EXPAND GLuint index, GLfloat x, GLfloat y
#define glVertexAttrib2fNV_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2fNV_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y
#define forward_glVertexAttrib2fNV(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2fNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2fNV(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2fNV(packed, ret_v) do { \
    glVertexAttrib2fNV_PACKED *unpacked = (glVertexAttrib2fNV_PACKED *)packed; \
    glVertexAttrib2fNV_ARGS *args = (glVertexAttrib2fNV_ARGS *)&unpacked->args; \
    glVertexAttrib2fNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2fNV(glVertexAttrib2fNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2fNV(glVertexAttrib2fNV_PACKED *_dst glVertexAttrib2fNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2fNV_PTR)(glVertexAttrib2fNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2fv_RETURN
#define glVertexAttrib2fv_RETURN void
#define glVertexAttrib2fv_ARG_NAMES index, v
#define glVertexAttrib2fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib2fv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2fv_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib2fv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2fv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2fv(packed, ret_v) do { \
    glVertexAttrib2fv_PACKED *unpacked = (glVertexAttrib2fv_PACKED *)packed; \
    glVertexAttrib2fv_ARGS *args = (glVertexAttrib2fv_ARGS *)&unpacked->args; \
    glVertexAttrib2fv(args->index, args->v);; \
} while(0)
void glVertexAttrib2fv(glVertexAttrib2fv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2fv(glVertexAttrib2fv_PACKED *_dst glVertexAttrib2fv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2fv_PTR)(glVertexAttrib2fv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2fvARB_RETURN
#define glVertexAttrib2fvARB_RETURN void
#define glVertexAttrib2fvARB_ARG_NAMES index, v
#define glVertexAttrib2fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib2fvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2fvARB_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib2fvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2fvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2fvARB(packed, ret_v) do { \
    glVertexAttrib2fvARB_PACKED *unpacked = (glVertexAttrib2fvARB_PACKED *)packed; \
    glVertexAttrib2fvARB_ARGS *args = (glVertexAttrib2fvARB_ARGS *)&unpacked->args; \
    glVertexAttrib2fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib2fvARB(glVertexAttrib2fvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2fvARB(glVertexAttrib2fvARB_PACKED *_dst glVertexAttrib2fvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2fvARB_PTR)(glVertexAttrib2fvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2fvNV_RETURN
#define glVertexAttrib2fvNV_RETURN void
#define glVertexAttrib2fvNV_ARG_NAMES index, v
#define glVertexAttrib2fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib2fvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2fvNV_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib2fvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2fvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2fvNV(packed, ret_v) do { \
    glVertexAttrib2fvNV_PACKED *unpacked = (glVertexAttrib2fvNV_PACKED *)packed; \
    glVertexAttrib2fvNV_ARGS *args = (glVertexAttrib2fvNV_ARGS *)&unpacked->args; \
    glVertexAttrib2fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2fvNV(glVertexAttrib2fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2fvNV(glVertexAttrib2fvNV_PACKED *_dst glVertexAttrib2fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2fvNV_PTR)(glVertexAttrib2fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2hNV_RETURN
#define glVertexAttrib2hNV_RETURN void
#define glVertexAttrib2hNV_ARG_NAMES index, x, y
#define glVertexAttrib2hNV_ARG_EXPAND GLuint index, GLhalfNV x, GLhalfNV y
#define glVertexAttrib2hNV_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2hNV_ARG_EXPAND_TAIL , GLuint index, GLhalfNV x, GLhalfNV y
#define forward_glVertexAttrib2hNV(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2hNV(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2hNV(packed, ret_v) do { \
    glVertexAttrib2hNV_PACKED *unpacked = (glVertexAttrib2hNV_PACKED *)packed; \
    glVertexAttrib2hNV_ARGS *args = (glVertexAttrib2hNV_ARGS *)&unpacked->args; \
    glVertexAttrib2hNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2hNV(glVertexAttrib2hNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2hNV(glVertexAttrib2hNV_PACKED *_dst glVertexAttrib2hNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2hNV_PTR)(glVertexAttrib2hNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2hvNV_RETURN
#define glVertexAttrib2hvNV_RETURN void
#define glVertexAttrib2hvNV_ARG_NAMES index, v
#define glVertexAttrib2hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib2hvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2hvNV_ARG_EXPAND_TAIL , GLuint index, const GLhalfNV * v
#define forward_glVertexAttrib2hvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2hvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2hvNV(packed, ret_v) do { \
    glVertexAttrib2hvNV_PACKED *unpacked = (glVertexAttrib2hvNV_PACKED *)packed; \
    glVertexAttrib2hvNV_ARGS *args = (glVertexAttrib2hvNV_ARGS *)&unpacked->args; \
    glVertexAttrib2hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2hvNV(glVertexAttrib2hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2hvNV(glVertexAttrib2hvNV_PACKED *_dst glVertexAttrib2hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2hvNV_PTR)(glVertexAttrib2hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2s_RETURN
#define glVertexAttrib2s_RETURN void
#define glVertexAttrib2s_ARG_NAMES index, x, y
#define glVertexAttrib2s_ARG_EXPAND GLuint index, GLshort x, GLshort y
#define glVertexAttrib2s_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2s_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y
#define forward_glVertexAttrib2s(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2s(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2s(packed, ret_v) do { \
    glVertexAttrib2s_PACKED *unpacked = (glVertexAttrib2s_PACKED *)packed; \
    glVertexAttrib2s_ARGS *args = (glVertexAttrib2s_ARGS *)&unpacked->args; \
    glVertexAttrib2s(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2s(glVertexAttrib2s_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2s(glVertexAttrib2s_PACKED *_dst glVertexAttrib2s_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2s_PTR)(glVertexAttrib2s_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2sARB_RETURN
#define glVertexAttrib2sARB_RETURN void
#define glVertexAttrib2sARB_ARG_NAMES index, x, y
#define glVertexAttrib2sARB_ARG_EXPAND GLuint index, GLshort x, GLshort y
#define glVertexAttrib2sARB_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2sARB_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y
#define forward_glVertexAttrib2sARB(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2sARB(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2sARB(packed, ret_v) do { \
    glVertexAttrib2sARB_PACKED *unpacked = (glVertexAttrib2sARB_PACKED *)packed; \
    glVertexAttrib2sARB_ARGS *args = (glVertexAttrib2sARB_ARGS *)&unpacked->args; \
    glVertexAttrib2sARB(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2sARB(glVertexAttrib2sARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2sARB(glVertexAttrib2sARB_PACKED *_dst glVertexAttrib2sARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2sARB_PTR)(glVertexAttrib2sARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2sNV_RETURN
#define glVertexAttrib2sNV_RETURN void
#define glVertexAttrib2sNV_ARG_NAMES index, x, y
#define glVertexAttrib2sNV_ARG_EXPAND GLuint index, GLshort x, GLshort y
#define glVertexAttrib2sNV_ARG_NAMES_TAIL , index, x, y
#define glVertexAttrib2sNV_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y
#define forward_glVertexAttrib2sNV(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2sNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2sNV(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttrib2sNV(packed, ret_v) do { \
    glVertexAttrib2sNV_PACKED *unpacked = (glVertexAttrib2sNV_PACKED *)packed; \
    glVertexAttrib2sNV_ARGS *args = (glVertexAttrib2sNV_ARGS *)&unpacked->args; \
    glVertexAttrib2sNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2sNV(glVertexAttrib2sNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2sNV(glVertexAttrib2sNV_PACKED *_dst glVertexAttrib2sNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2sNV_PTR)(glVertexAttrib2sNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2sv_RETURN
#define glVertexAttrib2sv_RETURN void
#define glVertexAttrib2sv_ARG_NAMES index, v
#define glVertexAttrib2sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib2sv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2sv_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib2sv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2sv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2sv(packed, ret_v) do { \
    glVertexAttrib2sv_PACKED *unpacked = (glVertexAttrib2sv_PACKED *)packed; \
    glVertexAttrib2sv_ARGS *args = (glVertexAttrib2sv_ARGS *)&unpacked->args; \
    glVertexAttrib2sv(args->index, args->v);; \
} while(0)
void glVertexAttrib2sv(glVertexAttrib2sv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2sv(glVertexAttrib2sv_PACKED *_dst glVertexAttrib2sv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2sv_PTR)(glVertexAttrib2sv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2svARB_RETURN
#define glVertexAttrib2svARB_RETURN void
#define glVertexAttrib2svARB_ARG_NAMES index, v
#define glVertexAttrib2svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib2svARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2svARB_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib2svARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2svARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2svARB(packed, ret_v) do { \
    glVertexAttrib2svARB_PACKED *unpacked = (glVertexAttrib2svARB_PACKED *)packed; \
    glVertexAttrib2svARB_ARGS *args = (glVertexAttrib2svARB_ARGS *)&unpacked->args; \
    glVertexAttrib2svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib2svARB(glVertexAttrib2svARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2svARB(glVertexAttrib2svARB_PACKED *_dst glVertexAttrib2svARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2svARB_PTR)(glVertexAttrib2svARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib2svNV_RETURN
#define glVertexAttrib2svNV_RETURN void
#define glVertexAttrib2svNV_ARG_NAMES index, v
#define glVertexAttrib2svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib2svNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib2svNV_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib2svNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib2svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib2svNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib2svNV(packed, ret_v) do { \
    glVertexAttrib2svNV_PACKED *unpacked = (glVertexAttrib2svNV_PACKED *)packed; \
    glVertexAttrib2svNV_ARGS *args = (glVertexAttrib2svNV_ARGS *)&unpacked->args; \
    glVertexAttrib2svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2svNV(glVertexAttrib2svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib2svNV(glVertexAttrib2svNV_PACKED *_dst glVertexAttrib2svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib2svNV_PTR)(glVertexAttrib2svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3d_RETURN
#define glVertexAttrib3d_RETURN void
#define glVertexAttrib3d_ARG_NAMES index, x, y, z
#define glVertexAttrib3d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttrib3d_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3d_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z
#define forward_glVertexAttrib3d(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3d(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3d(packed, ret_v) do { \
    glVertexAttrib3d_PACKED *unpacked = (glVertexAttrib3d_PACKED *)packed; \
    glVertexAttrib3d_ARGS *args = (glVertexAttrib3d_ARGS *)&unpacked->args; \
    glVertexAttrib3d(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3d(glVertexAttrib3d_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3d(glVertexAttrib3d_PACKED *_dst glVertexAttrib3d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3d_PTR)(glVertexAttrib3d_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3dARB_RETURN
#define glVertexAttrib3dARB_RETURN void
#define glVertexAttrib3dARB_ARG_NAMES index, x, y, z
#define glVertexAttrib3dARB_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttrib3dARB_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3dARB_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z
#define forward_glVertexAttrib3dARB(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3dARB(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3dARB(packed, ret_v) do { \
    glVertexAttrib3dARB_PACKED *unpacked = (glVertexAttrib3dARB_PACKED *)packed; \
    glVertexAttrib3dARB_ARGS *args = (glVertexAttrib3dARB_ARGS *)&unpacked->args; \
    glVertexAttrib3dARB(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3dARB(glVertexAttrib3dARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3dARB(glVertexAttrib3dARB_PACKED *_dst glVertexAttrib3dARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3dARB_PTR)(glVertexAttrib3dARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3dNV_RETURN
#define glVertexAttrib3dNV_RETURN void
#define glVertexAttrib3dNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3dNV_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttrib3dNV_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3dNV_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z
#define forward_glVertexAttrib3dNV(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3dNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3dNV(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3dNV(packed, ret_v) do { \
    glVertexAttrib3dNV_PACKED *unpacked = (glVertexAttrib3dNV_PACKED *)packed; \
    glVertexAttrib3dNV_ARGS *args = (glVertexAttrib3dNV_ARGS *)&unpacked->args; \
    glVertexAttrib3dNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3dNV(glVertexAttrib3dNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3dNV(glVertexAttrib3dNV_PACKED *_dst glVertexAttrib3dNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3dNV_PTR)(glVertexAttrib3dNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3dv_RETURN
#define glVertexAttrib3dv_RETURN void
#define glVertexAttrib3dv_ARG_NAMES index, v
#define glVertexAttrib3dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib3dv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib3dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3dv(packed, ret_v) do { \
    glVertexAttrib3dv_PACKED *unpacked = (glVertexAttrib3dv_PACKED *)packed; \
    glVertexAttrib3dv_ARGS *args = (glVertexAttrib3dv_ARGS *)&unpacked->args; \
    glVertexAttrib3dv(args->index, args->v);; \
} while(0)
void glVertexAttrib3dv(glVertexAttrib3dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3dv(glVertexAttrib3dv_PACKED *_dst glVertexAttrib3dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3dv_PTR)(glVertexAttrib3dv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3dvARB_RETURN
#define glVertexAttrib3dvARB_RETURN void
#define glVertexAttrib3dvARB_ARG_NAMES index, v
#define glVertexAttrib3dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib3dvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3dvARB_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib3dvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3dvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3dvARB(packed, ret_v) do { \
    glVertexAttrib3dvARB_PACKED *unpacked = (glVertexAttrib3dvARB_PACKED *)packed; \
    glVertexAttrib3dvARB_ARGS *args = (glVertexAttrib3dvARB_ARGS *)&unpacked->args; \
    glVertexAttrib3dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib3dvARB(glVertexAttrib3dvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3dvARB(glVertexAttrib3dvARB_PACKED *_dst glVertexAttrib3dvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3dvARB_PTR)(glVertexAttrib3dvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3dvNV_RETURN
#define glVertexAttrib3dvNV_RETURN void
#define glVertexAttrib3dvNV_ARG_NAMES index, v
#define glVertexAttrib3dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib3dvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3dvNV_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib3dvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3dvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3dvNV(packed, ret_v) do { \
    glVertexAttrib3dvNV_PACKED *unpacked = (glVertexAttrib3dvNV_PACKED *)packed; \
    glVertexAttrib3dvNV_ARGS *args = (glVertexAttrib3dvNV_ARGS *)&unpacked->args; \
    glVertexAttrib3dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3dvNV(glVertexAttrib3dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3dvNV(glVertexAttrib3dvNV_PACKED *_dst glVertexAttrib3dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3dvNV_PTR)(glVertexAttrib3dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3f_RETURN
#define glVertexAttrib3f_RETURN void
#define glVertexAttrib3f_ARG_NAMES index, x, y, z
#define glVertexAttrib3f_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z
#define glVertexAttrib3f_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3f_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y, GLfloat z
#define forward_glVertexAttrib3f(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3f(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3f(packed, ret_v) do { \
    glVertexAttrib3f_PACKED *unpacked = (glVertexAttrib3f_PACKED *)packed; \
    glVertexAttrib3f_ARGS *args = (glVertexAttrib3f_ARGS *)&unpacked->args; \
    glVertexAttrib3f(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3f(glVertexAttrib3f_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3f(glVertexAttrib3f_PACKED *_dst glVertexAttrib3f_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3f_PTR)(glVertexAttrib3f_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3fARB_RETURN
#define glVertexAttrib3fARB_RETURN void
#define glVertexAttrib3fARB_ARG_NAMES index, x, y, z
#define glVertexAttrib3fARB_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z
#define glVertexAttrib3fARB_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3fARB_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y, GLfloat z
#define forward_glVertexAttrib3fARB(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3fARB(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3fARB(packed, ret_v) do { \
    glVertexAttrib3fARB_PACKED *unpacked = (glVertexAttrib3fARB_PACKED *)packed; \
    glVertexAttrib3fARB_ARGS *args = (glVertexAttrib3fARB_ARGS *)&unpacked->args; \
    glVertexAttrib3fARB(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3fARB(glVertexAttrib3fARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3fARB(glVertexAttrib3fARB_PACKED *_dst glVertexAttrib3fARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3fARB_PTR)(glVertexAttrib3fARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3fNV_RETURN
#define glVertexAttrib3fNV_RETURN void
#define glVertexAttrib3fNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3fNV_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z
#define glVertexAttrib3fNV_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3fNV_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y, GLfloat z
#define forward_glVertexAttrib3fNV(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3fNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3fNV(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3fNV(packed, ret_v) do { \
    glVertexAttrib3fNV_PACKED *unpacked = (glVertexAttrib3fNV_PACKED *)packed; \
    glVertexAttrib3fNV_ARGS *args = (glVertexAttrib3fNV_ARGS *)&unpacked->args; \
    glVertexAttrib3fNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3fNV(glVertexAttrib3fNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3fNV(glVertexAttrib3fNV_PACKED *_dst glVertexAttrib3fNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3fNV_PTR)(glVertexAttrib3fNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3fv_RETURN
#define glVertexAttrib3fv_RETURN void
#define glVertexAttrib3fv_ARG_NAMES index, v
#define glVertexAttrib3fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib3fv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3fv_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib3fv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3fv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3fv(packed, ret_v) do { \
    glVertexAttrib3fv_PACKED *unpacked = (glVertexAttrib3fv_PACKED *)packed; \
    glVertexAttrib3fv_ARGS *args = (glVertexAttrib3fv_ARGS *)&unpacked->args; \
    glVertexAttrib3fv(args->index, args->v);; \
} while(0)
void glVertexAttrib3fv(glVertexAttrib3fv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3fv(glVertexAttrib3fv_PACKED *_dst glVertexAttrib3fv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3fv_PTR)(glVertexAttrib3fv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3fvARB_RETURN
#define glVertexAttrib3fvARB_RETURN void
#define glVertexAttrib3fvARB_ARG_NAMES index, v
#define glVertexAttrib3fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib3fvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3fvARB_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib3fvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3fvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3fvARB(packed, ret_v) do { \
    glVertexAttrib3fvARB_PACKED *unpacked = (glVertexAttrib3fvARB_PACKED *)packed; \
    glVertexAttrib3fvARB_ARGS *args = (glVertexAttrib3fvARB_ARGS *)&unpacked->args; \
    glVertexAttrib3fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib3fvARB(glVertexAttrib3fvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3fvARB(glVertexAttrib3fvARB_PACKED *_dst glVertexAttrib3fvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3fvARB_PTR)(glVertexAttrib3fvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3fvNV_RETURN
#define glVertexAttrib3fvNV_RETURN void
#define glVertexAttrib3fvNV_ARG_NAMES index, v
#define glVertexAttrib3fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib3fvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3fvNV_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib3fvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3fvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3fvNV(packed, ret_v) do { \
    glVertexAttrib3fvNV_PACKED *unpacked = (glVertexAttrib3fvNV_PACKED *)packed; \
    glVertexAttrib3fvNV_ARGS *args = (glVertexAttrib3fvNV_ARGS *)&unpacked->args; \
    glVertexAttrib3fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3fvNV(glVertexAttrib3fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3fvNV(glVertexAttrib3fvNV_PACKED *_dst glVertexAttrib3fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3fvNV_PTR)(glVertexAttrib3fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3hNV_RETURN
#define glVertexAttrib3hNV_RETURN void
#define glVertexAttrib3hNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3hNV_ARG_EXPAND GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z
#define glVertexAttrib3hNV_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3hNV_ARG_EXPAND_TAIL , GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z
#define forward_glVertexAttrib3hNV(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3hNV(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3hNV(packed, ret_v) do { \
    glVertexAttrib3hNV_PACKED *unpacked = (glVertexAttrib3hNV_PACKED *)packed; \
    glVertexAttrib3hNV_ARGS *args = (glVertexAttrib3hNV_ARGS *)&unpacked->args; \
    glVertexAttrib3hNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3hNV(glVertexAttrib3hNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3hNV(glVertexAttrib3hNV_PACKED *_dst glVertexAttrib3hNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3hNV_PTR)(glVertexAttrib3hNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3hvNV_RETURN
#define glVertexAttrib3hvNV_RETURN void
#define glVertexAttrib3hvNV_ARG_NAMES index, v
#define glVertexAttrib3hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib3hvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3hvNV_ARG_EXPAND_TAIL , GLuint index, const GLhalfNV * v
#define forward_glVertexAttrib3hvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3hvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3hvNV(packed, ret_v) do { \
    glVertexAttrib3hvNV_PACKED *unpacked = (glVertexAttrib3hvNV_PACKED *)packed; \
    glVertexAttrib3hvNV_ARGS *args = (glVertexAttrib3hvNV_ARGS *)&unpacked->args; \
    glVertexAttrib3hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3hvNV(glVertexAttrib3hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3hvNV(glVertexAttrib3hvNV_PACKED *_dst glVertexAttrib3hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3hvNV_PTR)(glVertexAttrib3hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3s_RETURN
#define glVertexAttrib3s_RETURN void
#define glVertexAttrib3s_ARG_NAMES index, x, y, z
#define glVertexAttrib3s_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z
#define glVertexAttrib3s_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3s_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y, GLshort z
#define forward_glVertexAttrib3s(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3s(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3s(packed, ret_v) do { \
    glVertexAttrib3s_PACKED *unpacked = (glVertexAttrib3s_PACKED *)packed; \
    glVertexAttrib3s_ARGS *args = (glVertexAttrib3s_ARGS *)&unpacked->args; \
    glVertexAttrib3s(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3s(glVertexAttrib3s_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3s(glVertexAttrib3s_PACKED *_dst glVertexAttrib3s_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3s_PTR)(glVertexAttrib3s_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3sARB_RETURN
#define glVertexAttrib3sARB_RETURN void
#define glVertexAttrib3sARB_ARG_NAMES index, x, y, z
#define glVertexAttrib3sARB_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z
#define glVertexAttrib3sARB_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3sARB_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y, GLshort z
#define forward_glVertexAttrib3sARB(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3sARB(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3sARB(packed, ret_v) do { \
    glVertexAttrib3sARB_PACKED *unpacked = (glVertexAttrib3sARB_PACKED *)packed; \
    glVertexAttrib3sARB_ARGS *args = (glVertexAttrib3sARB_ARGS *)&unpacked->args; \
    glVertexAttrib3sARB(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3sARB(glVertexAttrib3sARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3sARB(glVertexAttrib3sARB_PACKED *_dst glVertexAttrib3sARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3sARB_PTR)(glVertexAttrib3sARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3sNV_RETURN
#define glVertexAttrib3sNV_RETURN void
#define glVertexAttrib3sNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3sNV_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z
#define glVertexAttrib3sNV_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttrib3sNV_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y, GLshort z
#define forward_glVertexAttrib3sNV(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3sNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3sNV(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttrib3sNV(packed, ret_v) do { \
    glVertexAttrib3sNV_PACKED *unpacked = (glVertexAttrib3sNV_PACKED *)packed; \
    glVertexAttrib3sNV_ARGS *args = (glVertexAttrib3sNV_ARGS *)&unpacked->args; \
    glVertexAttrib3sNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3sNV(glVertexAttrib3sNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3sNV(glVertexAttrib3sNV_PACKED *_dst glVertexAttrib3sNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3sNV_PTR)(glVertexAttrib3sNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3sv_RETURN
#define glVertexAttrib3sv_RETURN void
#define glVertexAttrib3sv_ARG_NAMES index, v
#define glVertexAttrib3sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib3sv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3sv_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib3sv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3sv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3sv(packed, ret_v) do { \
    glVertexAttrib3sv_PACKED *unpacked = (glVertexAttrib3sv_PACKED *)packed; \
    glVertexAttrib3sv_ARGS *args = (glVertexAttrib3sv_ARGS *)&unpacked->args; \
    glVertexAttrib3sv(args->index, args->v);; \
} while(0)
void glVertexAttrib3sv(glVertexAttrib3sv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3sv(glVertexAttrib3sv_PACKED *_dst glVertexAttrib3sv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3sv_PTR)(glVertexAttrib3sv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3svARB_RETURN
#define glVertexAttrib3svARB_RETURN void
#define glVertexAttrib3svARB_ARG_NAMES index, v
#define glVertexAttrib3svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib3svARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3svARB_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib3svARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3svARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3svARB(packed, ret_v) do { \
    glVertexAttrib3svARB_PACKED *unpacked = (glVertexAttrib3svARB_PACKED *)packed; \
    glVertexAttrib3svARB_ARGS *args = (glVertexAttrib3svARB_ARGS *)&unpacked->args; \
    glVertexAttrib3svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib3svARB(glVertexAttrib3svARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3svARB(glVertexAttrib3svARB_PACKED *_dst glVertexAttrib3svARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3svARB_PTR)(glVertexAttrib3svARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib3svNV_RETURN
#define glVertexAttrib3svNV_RETURN void
#define glVertexAttrib3svNV_ARG_NAMES index, v
#define glVertexAttrib3svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib3svNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib3svNV_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib3svNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib3svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib3svNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib3svNV(packed, ret_v) do { \
    glVertexAttrib3svNV_PACKED *unpacked = (glVertexAttrib3svNV_PACKED *)packed; \
    glVertexAttrib3svNV_ARGS *args = (glVertexAttrib3svNV_ARGS *)&unpacked->args; \
    glVertexAttrib3svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3svNV(glVertexAttrib3svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib3svNV(glVertexAttrib3svNV_PACKED *_dst glVertexAttrib3svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib3svNV_PTR)(glVertexAttrib3svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4Nbv_RETURN
#define glVertexAttrib4Nbv_RETURN void
#define glVertexAttrib4Nbv_ARG_NAMES index, v
#define glVertexAttrib4Nbv_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4Nbv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4Nbv_ARG_EXPAND_TAIL , GLuint index, const GLbyte * v
#define forward_glVertexAttrib4Nbv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4Nbv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4Nbv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4Nbv(packed, ret_v) do { \
    glVertexAttrib4Nbv_PACKED *unpacked = (glVertexAttrib4Nbv_PACKED *)packed; \
    glVertexAttrib4Nbv_ARGS *args = (glVertexAttrib4Nbv_ARGS *)&unpacked->args; \
    glVertexAttrib4Nbv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nbv(glVertexAttrib4Nbv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4Nbv(glVertexAttrib4Nbv_PACKED *_dst glVertexAttrib4Nbv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4Nbv_PTR)(glVertexAttrib4Nbv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4NbvARB_RETURN
#define glVertexAttrib4NbvARB_RETURN void
#define glVertexAttrib4NbvARB_ARG_NAMES index, v
#define glVertexAttrib4NbvARB_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4NbvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4NbvARB_ARG_EXPAND_TAIL , GLuint index, const GLbyte * v
#define forward_glVertexAttrib4NbvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4NbvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4NbvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4NbvARB(packed, ret_v) do { \
    glVertexAttrib4NbvARB_PACKED *unpacked = (glVertexAttrib4NbvARB_PACKED *)packed; \
    glVertexAttrib4NbvARB_ARGS *args = (glVertexAttrib4NbvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4NbvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NbvARB(glVertexAttrib4NbvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4NbvARB(glVertexAttrib4NbvARB_PACKED *_dst glVertexAttrib4NbvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4NbvARB_PTR)(glVertexAttrib4NbvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4Niv_RETURN
#define glVertexAttrib4Niv_RETURN void
#define glVertexAttrib4Niv_ARG_NAMES index, v
#define glVertexAttrib4Niv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4Niv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4Niv_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttrib4Niv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4Niv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4Niv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4Niv(packed, ret_v) do { \
    glVertexAttrib4Niv_PACKED *unpacked = (glVertexAttrib4Niv_PACKED *)packed; \
    glVertexAttrib4Niv_ARGS *args = (glVertexAttrib4Niv_ARGS *)&unpacked->args; \
    glVertexAttrib4Niv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Niv(glVertexAttrib4Niv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4Niv(glVertexAttrib4Niv_PACKED *_dst glVertexAttrib4Niv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4Niv_PTR)(glVertexAttrib4Niv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4NivARB_RETURN
#define glVertexAttrib4NivARB_RETURN void
#define glVertexAttrib4NivARB_ARG_NAMES index, v
#define glVertexAttrib4NivARB_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4NivARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4NivARB_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttrib4NivARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4NivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4NivARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4NivARB(packed, ret_v) do { \
    glVertexAttrib4NivARB_PACKED *unpacked = (glVertexAttrib4NivARB_PACKED *)packed; \
    glVertexAttrib4NivARB_ARGS *args = (glVertexAttrib4NivARB_ARGS *)&unpacked->args; \
    glVertexAttrib4NivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NivARB(glVertexAttrib4NivARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4NivARB(glVertexAttrib4NivARB_PACKED *_dst glVertexAttrib4NivARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4NivARB_PTR)(glVertexAttrib4NivARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4Nsv_RETURN
#define glVertexAttrib4Nsv_RETURN void
#define glVertexAttrib4Nsv_ARG_NAMES index, v
#define glVertexAttrib4Nsv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4Nsv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4Nsv_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib4Nsv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4Nsv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4Nsv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4Nsv(packed, ret_v) do { \
    glVertexAttrib4Nsv_PACKED *unpacked = (glVertexAttrib4Nsv_PACKED *)packed; \
    glVertexAttrib4Nsv_ARGS *args = (glVertexAttrib4Nsv_ARGS *)&unpacked->args; \
    glVertexAttrib4Nsv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nsv(glVertexAttrib4Nsv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4Nsv(glVertexAttrib4Nsv_PACKED *_dst glVertexAttrib4Nsv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4Nsv_PTR)(glVertexAttrib4Nsv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4NsvARB_RETURN
#define glVertexAttrib4NsvARB_RETURN void
#define glVertexAttrib4NsvARB_ARG_NAMES index, v
#define glVertexAttrib4NsvARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4NsvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4NsvARB_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib4NsvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4NsvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4NsvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4NsvARB(packed, ret_v) do { \
    glVertexAttrib4NsvARB_PACKED *unpacked = (glVertexAttrib4NsvARB_PACKED *)packed; \
    glVertexAttrib4NsvARB_ARGS *args = (glVertexAttrib4NsvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4NsvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NsvARB(glVertexAttrib4NsvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4NsvARB(glVertexAttrib4NsvARB_PACKED *_dst glVertexAttrib4NsvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4NsvARB_PTR)(glVertexAttrib4NsvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4Nub_RETURN
#define glVertexAttrib4Nub_RETURN void
#define glVertexAttrib4Nub_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4Nub_ARG_EXPAND GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define glVertexAttrib4Nub_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4Nub_ARG_EXPAND_TAIL , GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define forward_glVertexAttrib4Nub(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4Nub_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4Nub(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4Nub(packed, ret_v) do { \
    glVertexAttrib4Nub_PACKED *unpacked = (glVertexAttrib4Nub_PACKED *)packed; \
    glVertexAttrib4Nub_ARGS *args = (glVertexAttrib4Nub_ARGS *)&unpacked->args; \
    glVertexAttrib4Nub(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4Nub(glVertexAttrib4Nub_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4Nub(glVertexAttrib4Nub_PACKED *_dst glVertexAttrib4Nub_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4Nub_PTR)(glVertexAttrib4Nub_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4NubARB_RETURN
#define glVertexAttrib4NubARB_RETURN void
#define glVertexAttrib4NubARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4NubARB_ARG_EXPAND GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define glVertexAttrib4NubARB_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4NubARB_ARG_EXPAND_TAIL , GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define forward_glVertexAttrib4NubARB(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4NubARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4NubARB(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4NubARB(packed, ret_v) do { \
    glVertexAttrib4NubARB_PACKED *unpacked = (glVertexAttrib4NubARB_PACKED *)packed; \
    glVertexAttrib4NubARB_ARGS *args = (glVertexAttrib4NubARB_ARGS *)&unpacked->args; \
    glVertexAttrib4NubARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4NubARB(glVertexAttrib4NubARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4NubARB(glVertexAttrib4NubARB_PACKED *_dst glVertexAttrib4NubARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4NubARB_PTR)(glVertexAttrib4NubARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4Nubv_RETURN
#define glVertexAttrib4Nubv_RETURN void
#define glVertexAttrib4Nubv_ARG_NAMES index, v
#define glVertexAttrib4Nubv_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4Nubv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4Nubv_ARG_EXPAND_TAIL , GLuint index, const GLubyte * v
#define forward_glVertexAttrib4Nubv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4Nubv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4Nubv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4Nubv(packed, ret_v) do { \
    glVertexAttrib4Nubv_PACKED *unpacked = (glVertexAttrib4Nubv_PACKED *)packed; \
    glVertexAttrib4Nubv_ARGS *args = (glVertexAttrib4Nubv_ARGS *)&unpacked->args; \
    glVertexAttrib4Nubv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nubv(glVertexAttrib4Nubv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4Nubv(glVertexAttrib4Nubv_PACKED *_dst glVertexAttrib4Nubv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4Nubv_PTR)(glVertexAttrib4Nubv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4NubvARB_RETURN
#define glVertexAttrib4NubvARB_RETURN void
#define glVertexAttrib4NubvARB_ARG_NAMES index, v
#define glVertexAttrib4NubvARB_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4NubvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4NubvARB_ARG_EXPAND_TAIL , GLuint index, const GLubyte * v
#define forward_glVertexAttrib4NubvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4NubvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4NubvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4NubvARB(packed, ret_v) do { \
    glVertexAttrib4NubvARB_PACKED *unpacked = (glVertexAttrib4NubvARB_PACKED *)packed; \
    glVertexAttrib4NubvARB_ARGS *args = (glVertexAttrib4NubvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4NubvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NubvARB(glVertexAttrib4NubvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4NubvARB(glVertexAttrib4NubvARB_PACKED *_dst glVertexAttrib4NubvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4NubvARB_PTR)(glVertexAttrib4NubvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4Nuiv_RETURN
#define glVertexAttrib4Nuiv_RETURN void
#define glVertexAttrib4Nuiv_ARG_NAMES index, v
#define glVertexAttrib4Nuiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4Nuiv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4Nuiv_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttrib4Nuiv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4Nuiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4Nuiv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4Nuiv(packed, ret_v) do { \
    glVertexAttrib4Nuiv_PACKED *unpacked = (glVertexAttrib4Nuiv_PACKED *)packed; \
    glVertexAttrib4Nuiv_ARGS *args = (glVertexAttrib4Nuiv_ARGS *)&unpacked->args; \
    glVertexAttrib4Nuiv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nuiv(glVertexAttrib4Nuiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4Nuiv(glVertexAttrib4Nuiv_PACKED *_dst glVertexAttrib4Nuiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4Nuiv_PTR)(glVertexAttrib4Nuiv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4NuivARB_RETURN
#define glVertexAttrib4NuivARB_RETURN void
#define glVertexAttrib4NuivARB_ARG_NAMES index, v
#define glVertexAttrib4NuivARB_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4NuivARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4NuivARB_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttrib4NuivARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4NuivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4NuivARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4NuivARB(packed, ret_v) do { \
    glVertexAttrib4NuivARB_PACKED *unpacked = (glVertexAttrib4NuivARB_PACKED *)packed; \
    glVertexAttrib4NuivARB_ARGS *args = (glVertexAttrib4NuivARB_ARGS *)&unpacked->args; \
    glVertexAttrib4NuivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NuivARB(glVertexAttrib4NuivARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4NuivARB(glVertexAttrib4NuivARB_PACKED *_dst glVertexAttrib4NuivARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4NuivARB_PTR)(glVertexAttrib4NuivARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4Nusv_RETURN
#define glVertexAttrib4Nusv_RETURN void
#define glVertexAttrib4Nusv_ARG_NAMES index, v
#define glVertexAttrib4Nusv_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4Nusv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4Nusv_ARG_EXPAND_TAIL , GLuint index, const GLushort * v
#define forward_glVertexAttrib4Nusv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4Nusv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4Nusv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4Nusv(packed, ret_v) do { \
    glVertexAttrib4Nusv_PACKED *unpacked = (glVertexAttrib4Nusv_PACKED *)packed; \
    glVertexAttrib4Nusv_ARGS *args = (glVertexAttrib4Nusv_ARGS *)&unpacked->args; \
    glVertexAttrib4Nusv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nusv(glVertexAttrib4Nusv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4Nusv(glVertexAttrib4Nusv_PACKED *_dst glVertexAttrib4Nusv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4Nusv_PTR)(glVertexAttrib4Nusv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4NusvARB_RETURN
#define glVertexAttrib4NusvARB_RETURN void
#define glVertexAttrib4NusvARB_ARG_NAMES index, v
#define glVertexAttrib4NusvARB_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4NusvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4NusvARB_ARG_EXPAND_TAIL , GLuint index, const GLushort * v
#define forward_glVertexAttrib4NusvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4NusvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4NusvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4NusvARB(packed, ret_v) do { \
    glVertexAttrib4NusvARB_PACKED *unpacked = (glVertexAttrib4NusvARB_PACKED *)packed; \
    glVertexAttrib4NusvARB_ARGS *args = (glVertexAttrib4NusvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4NusvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NusvARB(glVertexAttrib4NusvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4NusvARB(glVertexAttrib4NusvARB_PACKED *_dst glVertexAttrib4NusvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4NusvARB_PTR)(glVertexAttrib4NusvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4bv_RETURN
#define glVertexAttrib4bv_RETURN void
#define glVertexAttrib4bv_ARG_NAMES index, v
#define glVertexAttrib4bv_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4bv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4bv_ARG_EXPAND_TAIL , GLuint index, const GLbyte * v
#define forward_glVertexAttrib4bv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4bv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4bv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4bv(packed, ret_v) do { \
    glVertexAttrib4bv_PACKED *unpacked = (glVertexAttrib4bv_PACKED *)packed; \
    glVertexAttrib4bv_ARGS *args = (glVertexAttrib4bv_ARGS *)&unpacked->args; \
    glVertexAttrib4bv(args->index, args->v);; \
} while(0)
void glVertexAttrib4bv(glVertexAttrib4bv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4bv(glVertexAttrib4bv_PACKED *_dst glVertexAttrib4bv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4bv_PTR)(glVertexAttrib4bv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4bvARB_RETURN
#define glVertexAttrib4bvARB_RETURN void
#define glVertexAttrib4bvARB_ARG_NAMES index, v
#define glVertexAttrib4bvARB_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4bvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4bvARB_ARG_EXPAND_TAIL , GLuint index, const GLbyte * v
#define forward_glVertexAttrib4bvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4bvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4bvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4bvARB(packed, ret_v) do { \
    glVertexAttrib4bvARB_PACKED *unpacked = (glVertexAttrib4bvARB_PACKED *)packed; \
    glVertexAttrib4bvARB_ARGS *args = (glVertexAttrib4bvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4bvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4bvARB(glVertexAttrib4bvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4bvARB(glVertexAttrib4bvARB_PACKED *_dst glVertexAttrib4bvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4bvARB_PTR)(glVertexAttrib4bvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4d_RETURN
#define glVertexAttrib4d_RETURN void
#define glVertexAttrib4d_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttrib4d_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4d_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glVertexAttrib4d(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4d(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4d(packed, ret_v) do { \
    glVertexAttrib4d_PACKED *unpacked = (glVertexAttrib4d_PACKED *)packed; \
    glVertexAttrib4d_ARGS *args = (glVertexAttrib4d_ARGS *)&unpacked->args; \
    glVertexAttrib4d(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4d(glVertexAttrib4d_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4d(glVertexAttrib4d_PACKED *_dst glVertexAttrib4d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4d_PTR)(glVertexAttrib4d_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4dARB_RETURN
#define glVertexAttrib4dARB_RETURN void
#define glVertexAttrib4dARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4dARB_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttrib4dARB_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4dARB_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glVertexAttrib4dARB(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4dARB(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4dARB(packed, ret_v) do { \
    glVertexAttrib4dARB_PACKED *unpacked = (glVertexAttrib4dARB_PACKED *)packed; \
    glVertexAttrib4dARB_ARGS *args = (glVertexAttrib4dARB_ARGS *)&unpacked->args; \
    glVertexAttrib4dARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4dARB(glVertexAttrib4dARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4dARB(glVertexAttrib4dARB_PACKED *_dst glVertexAttrib4dARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4dARB_PTR)(glVertexAttrib4dARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4dNV_RETURN
#define glVertexAttrib4dNV_RETURN void
#define glVertexAttrib4dNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4dNV_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttrib4dNV_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4dNV_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glVertexAttrib4dNV(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4dNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4dNV(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4dNV(packed, ret_v) do { \
    glVertexAttrib4dNV_PACKED *unpacked = (glVertexAttrib4dNV_PACKED *)packed; \
    glVertexAttrib4dNV_ARGS *args = (glVertexAttrib4dNV_ARGS *)&unpacked->args; \
    glVertexAttrib4dNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4dNV(glVertexAttrib4dNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4dNV(glVertexAttrib4dNV_PACKED *_dst glVertexAttrib4dNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4dNV_PTR)(glVertexAttrib4dNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4dv_RETURN
#define glVertexAttrib4dv_RETURN void
#define glVertexAttrib4dv_ARG_NAMES index, v
#define glVertexAttrib4dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib4dv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib4dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4dv(packed, ret_v) do { \
    glVertexAttrib4dv_PACKED *unpacked = (glVertexAttrib4dv_PACKED *)packed; \
    glVertexAttrib4dv_ARGS *args = (glVertexAttrib4dv_ARGS *)&unpacked->args; \
    glVertexAttrib4dv(args->index, args->v);; \
} while(0)
void glVertexAttrib4dv(glVertexAttrib4dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4dv(glVertexAttrib4dv_PACKED *_dst glVertexAttrib4dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4dv_PTR)(glVertexAttrib4dv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4dvARB_RETURN
#define glVertexAttrib4dvARB_RETURN void
#define glVertexAttrib4dvARB_ARG_NAMES index, v
#define glVertexAttrib4dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib4dvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4dvARB_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib4dvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4dvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4dvARB(packed, ret_v) do { \
    glVertexAttrib4dvARB_PACKED *unpacked = (glVertexAttrib4dvARB_PACKED *)packed; \
    glVertexAttrib4dvARB_ARGS *args = (glVertexAttrib4dvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4dvARB(glVertexAttrib4dvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4dvARB(glVertexAttrib4dvARB_PACKED *_dst glVertexAttrib4dvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4dvARB_PTR)(glVertexAttrib4dvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4dvNV_RETURN
#define glVertexAttrib4dvNV_RETURN void
#define glVertexAttrib4dvNV_ARG_NAMES index, v
#define glVertexAttrib4dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib4dvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4dvNV_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttrib4dvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4dvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4dvNV(packed, ret_v) do { \
    glVertexAttrib4dvNV_PACKED *unpacked = (glVertexAttrib4dvNV_PACKED *)packed; \
    glVertexAttrib4dvNV_ARGS *args = (glVertexAttrib4dvNV_ARGS *)&unpacked->args; \
    glVertexAttrib4dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4dvNV(glVertexAttrib4dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4dvNV(glVertexAttrib4dvNV_PACKED *_dst glVertexAttrib4dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4dvNV_PTR)(glVertexAttrib4dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4f_RETURN
#define glVertexAttrib4f_RETURN void
#define glVertexAttrib4f_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4f_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexAttrib4f_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4f_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glVertexAttrib4f(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4f(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4f(packed, ret_v) do { \
    glVertexAttrib4f_PACKED *unpacked = (glVertexAttrib4f_PACKED *)packed; \
    glVertexAttrib4f_ARGS *args = (glVertexAttrib4f_ARGS *)&unpacked->args; \
    glVertexAttrib4f(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4f(glVertexAttrib4f_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4f(glVertexAttrib4f_PACKED *_dst glVertexAttrib4f_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4f_PTR)(glVertexAttrib4f_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4fARB_RETURN
#define glVertexAttrib4fARB_RETURN void
#define glVertexAttrib4fARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4fARB_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexAttrib4fARB_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4fARB_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glVertexAttrib4fARB(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4fARB(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4fARB(packed, ret_v) do { \
    glVertexAttrib4fARB_PACKED *unpacked = (glVertexAttrib4fARB_PACKED *)packed; \
    glVertexAttrib4fARB_ARGS *args = (glVertexAttrib4fARB_ARGS *)&unpacked->args; \
    glVertexAttrib4fARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4fARB(glVertexAttrib4fARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4fARB(glVertexAttrib4fARB_PACKED *_dst glVertexAttrib4fARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4fARB_PTR)(glVertexAttrib4fARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4fNV_RETURN
#define glVertexAttrib4fNV_RETURN void
#define glVertexAttrib4fNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4fNV_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexAttrib4fNV_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4fNV_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glVertexAttrib4fNV(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4fNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4fNV(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4fNV(packed, ret_v) do { \
    glVertexAttrib4fNV_PACKED *unpacked = (glVertexAttrib4fNV_PACKED *)packed; \
    glVertexAttrib4fNV_ARGS *args = (glVertexAttrib4fNV_ARGS *)&unpacked->args; \
    glVertexAttrib4fNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4fNV(glVertexAttrib4fNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4fNV(glVertexAttrib4fNV_PACKED *_dst glVertexAttrib4fNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4fNV_PTR)(glVertexAttrib4fNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4fv_RETURN
#define glVertexAttrib4fv_RETURN void
#define glVertexAttrib4fv_ARG_NAMES index, v
#define glVertexAttrib4fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib4fv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4fv_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib4fv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4fv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4fv(packed, ret_v) do { \
    glVertexAttrib4fv_PACKED *unpacked = (glVertexAttrib4fv_PACKED *)packed; \
    glVertexAttrib4fv_ARGS *args = (glVertexAttrib4fv_ARGS *)&unpacked->args; \
    glVertexAttrib4fv(args->index, args->v);; \
} while(0)
void glVertexAttrib4fv(glVertexAttrib4fv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4fv(glVertexAttrib4fv_PACKED *_dst glVertexAttrib4fv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4fv_PTR)(glVertexAttrib4fv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4fvARB_RETURN
#define glVertexAttrib4fvARB_RETURN void
#define glVertexAttrib4fvARB_ARG_NAMES index, v
#define glVertexAttrib4fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib4fvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4fvARB_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib4fvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4fvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4fvARB(packed, ret_v) do { \
    glVertexAttrib4fvARB_PACKED *unpacked = (glVertexAttrib4fvARB_PACKED *)packed; \
    glVertexAttrib4fvARB_ARGS *args = (glVertexAttrib4fvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4fvARB(glVertexAttrib4fvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4fvARB(glVertexAttrib4fvARB_PACKED *_dst glVertexAttrib4fvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4fvARB_PTR)(glVertexAttrib4fvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4fvNV_RETURN
#define glVertexAttrib4fvNV_RETURN void
#define glVertexAttrib4fvNV_ARG_NAMES index, v
#define glVertexAttrib4fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib4fvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4fvNV_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glVertexAttrib4fvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4fvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4fvNV(packed, ret_v) do { \
    glVertexAttrib4fvNV_PACKED *unpacked = (glVertexAttrib4fvNV_PACKED *)packed; \
    glVertexAttrib4fvNV_ARGS *args = (glVertexAttrib4fvNV_ARGS *)&unpacked->args; \
    glVertexAttrib4fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4fvNV(glVertexAttrib4fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4fvNV(glVertexAttrib4fvNV_PACKED *_dst glVertexAttrib4fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4fvNV_PTR)(glVertexAttrib4fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4hNV_RETURN
#define glVertexAttrib4hNV_RETURN void
#define glVertexAttrib4hNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4hNV_ARG_EXPAND GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w
#define glVertexAttrib4hNV_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4hNV_ARG_EXPAND_TAIL , GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w
#define forward_glVertexAttrib4hNV(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4hNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4hNV(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4hNV(packed, ret_v) do { \
    glVertexAttrib4hNV_PACKED *unpacked = (glVertexAttrib4hNV_PACKED *)packed; \
    glVertexAttrib4hNV_ARGS *args = (glVertexAttrib4hNV_ARGS *)&unpacked->args; \
    glVertexAttrib4hNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4hNV(glVertexAttrib4hNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4hNV(glVertexAttrib4hNV_PACKED *_dst glVertexAttrib4hNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4hNV_PTR)(glVertexAttrib4hNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4hvNV_RETURN
#define glVertexAttrib4hvNV_RETURN void
#define glVertexAttrib4hvNV_ARG_NAMES index, v
#define glVertexAttrib4hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib4hvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4hvNV_ARG_EXPAND_TAIL , GLuint index, const GLhalfNV * v
#define forward_glVertexAttrib4hvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4hvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4hvNV(packed, ret_v) do { \
    glVertexAttrib4hvNV_PACKED *unpacked = (glVertexAttrib4hvNV_PACKED *)packed; \
    glVertexAttrib4hvNV_ARGS *args = (glVertexAttrib4hvNV_ARGS *)&unpacked->args; \
    glVertexAttrib4hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4hvNV(glVertexAttrib4hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4hvNV(glVertexAttrib4hvNV_PACKED *_dst glVertexAttrib4hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4hvNV_PTR)(glVertexAttrib4hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4iv_RETURN
#define glVertexAttrib4iv_RETURN void
#define glVertexAttrib4iv_ARG_NAMES index, v
#define glVertexAttrib4iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4iv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4iv_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttrib4iv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4iv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4iv(packed, ret_v) do { \
    glVertexAttrib4iv_PACKED *unpacked = (glVertexAttrib4iv_PACKED *)packed; \
    glVertexAttrib4iv_ARGS *args = (glVertexAttrib4iv_ARGS *)&unpacked->args; \
    glVertexAttrib4iv(args->index, args->v);; \
} while(0)
void glVertexAttrib4iv(glVertexAttrib4iv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4iv(glVertexAttrib4iv_PACKED *_dst glVertexAttrib4iv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4iv_PTR)(glVertexAttrib4iv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4ivARB_RETURN
#define glVertexAttrib4ivARB_RETURN void
#define glVertexAttrib4ivARB_ARG_NAMES index, v
#define glVertexAttrib4ivARB_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4ivARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4ivARB_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttrib4ivARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4ivARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4ivARB(packed, ret_v) do { \
    glVertexAttrib4ivARB_PACKED *unpacked = (glVertexAttrib4ivARB_PACKED *)packed; \
    glVertexAttrib4ivARB_ARGS *args = (glVertexAttrib4ivARB_ARGS *)&unpacked->args; \
    glVertexAttrib4ivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4ivARB(glVertexAttrib4ivARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4ivARB(glVertexAttrib4ivARB_PACKED *_dst glVertexAttrib4ivARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4ivARB_PTR)(glVertexAttrib4ivARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4s_RETURN
#define glVertexAttrib4s_RETURN void
#define glVertexAttrib4s_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4s_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexAttrib4s_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4s_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define forward_glVertexAttrib4s(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4s(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4s(packed, ret_v) do { \
    glVertexAttrib4s_PACKED *unpacked = (glVertexAttrib4s_PACKED *)packed; \
    glVertexAttrib4s_ARGS *args = (glVertexAttrib4s_ARGS *)&unpacked->args; \
    glVertexAttrib4s(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4s(glVertexAttrib4s_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4s(glVertexAttrib4s_PACKED *_dst glVertexAttrib4s_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4s_PTR)(glVertexAttrib4s_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4sARB_RETURN
#define glVertexAttrib4sARB_RETURN void
#define glVertexAttrib4sARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4sARB_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexAttrib4sARB_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4sARB_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define forward_glVertexAttrib4sARB(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4sARB(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4sARB(packed, ret_v) do { \
    glVertexAttrib4sARB_PACKED *unpacked = (glVertexAttrib4sARB_PACKED *)packed; \
    glVertexAttrib4sARB_ARGS *args = (glVertexAttrib4sARB_ARGS *)&unpacked->args; \
    glVertexAttrib4sARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4sARB(glVertexAttrib4sARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4sARB(glVertexAttrib4sARB_PACKED *_dst glVertexAttrib4sARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4sARB_PTR)(glVertexAttrib4sARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4sNV_RETURN
#define glVertexAttrib4sNV_RETURN void
#define glVertexAttrib4sNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4sNV_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexAttrib4sNV_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4sNV_ARG_EXPAND_TAIL , GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define forward_glVertexAttrib4sNV(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4sNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4sNV(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4sNV(packed, ret_v) do { \
    glVertexAttrib4sNV_PACKED *unpacked = (glVertexAttrib4sNV_PACKED *)packed; \
    glVertexAttrib4sNV_ARGS *args = (glVertexAttrib4sNV_ARGS *)&unpacked->args; \
    glVertexAttrib4sNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4sNV(glVertexAttrib4sNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4sNV(glVertexAttrib4sNV_PACKED *_dst glVertexAttrib4sNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4sNV_PTR)(glVertexAttrib4sNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4sv_RETURN
#define glVertexAttrib4sv_RETURN void
#define glVertexAttrib4sv_ARG_NAMES index, v
#define glVertexAttrib4sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4sv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4sv_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib4sv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4sv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4sv(packed, ret_v) do { \
    glVertexAttrib4sv_PACKED *unpacked = (glVertexAttrib4sv_PACKED *)packed; \
    glVertexAttrib4sv_ARGS *args = (glVertexAttrib4sv_ARGS *)&unpacked->args; \
    glVertexAttrib4sv(args->index, args->v);; \
} while(0)
void glVertexAttrib4sv(glVertexAttrib4sv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4sv(glVertexAttrib4sv_PACKED *_dst glVertexAttrib4sv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4sv_PTR)(glVertexAttrib4sv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4svARB_RETURN
#define glVertexAttrib4svARB_RETURN void
#define glVertexAttrib4svARB_ARG_NAMES index, v
#define glVertexAttrib4svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4svARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4svARB_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib4svARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4svARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4svARB(packed, ret_v) do { \
    glVertexAttrib4svARB_PACKED *unpacked = (glVertexAttrib4svARB_PACKED *)packed; \
    glVertexAttrib4svARB_ARGS *args = (glVertexAttrib4svARB_ARGS *)&unpacked->args; \
    glVertexAttrib4svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4svARB(glVertexAttrib4svARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4svARB(glVertexAttrib4svARB_PACKED *_dst glVertexAttrib4svARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4svARB_PTR)(glVertexAttrib4svARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4svNV_RETURN
#define glVertexAttrib4svNV_RETURN void
#define glVertexAttrib4svNV_ARG_NAMES index, v
#define glVertexAttrib4svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4svNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4svNV_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttrib4svNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4svNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4svNV(packed, ret_v) do { \
    glVertexAttrib4svNV_PACKED *unpacked = (glVertexAttrib4svNV_PACKED *)packed; \
    glVertexAttrib4svNV_ARGS *args = (glVertexAttrib4svNV_ARGS *)&unpacked->args; \
    glVertexAttrib4svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4svNV(glVertexAttrib4svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4svNV(glVertexAttrib4svNV_PACKED *_dst glVertexAttrib4svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4svNV_PTR)(glVertexAttrib4svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4ubNV_RETURN
#define glVertexAttrib4ubNV_RETURN void
#define glVertexAttrib4ubNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4ubNV_ARG_EXPAND GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define glVertexAttrib4ubNV_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttrib4ubNV_ARG_EXPAND_TAIL , GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define forward_glVertexAttrib4ubNV(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4ubNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4ubNV(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttrib4ubNV(packed, ret_v) do { \
    glVertexAttrib4ubNV_PACKED *unpacked = (glVertexAttrib4ubNV_PACKED *)packed; \
    glVertexAttrib4ubNV_ARGS *args = (glVertexAttrib4ubNV_ARGS *)&unpacked->args; \
    glVertexAttrib4ubNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4ubNV(glVertexAttrib4ubNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4ubNV(glVertexAttrib4ubNV_PACKED *_dst glVertexAttrib4ubNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4ubNV_PTR)(glVertexAttrib4ubNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4ubv_RETURN
#define glVertexAttrib4ubv_RETURN void
#define glVertexAttrib4ubv_ARG_NAMES index, v
#define glVertexAttrib4ubv_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4ubv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4ubv_ARG_EXPAND_TAIL , GLuint index, const GLubyte * v
#define forward_glVertexAttrib4ubv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4ubv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4ubv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4ubv(packed, ret_v) do { \
    glVertexAttrib4ubv_PACKED *unpacked = (glVertexAttrib4ubv_PACKED *)packed; \
    glVertexAttrib4ubv_ARGS *args = (glVertexAttrib4ubv_ARGS *)&unpacked->args; \
    glVertexAttrib4ubv(args->index, args->v);; \
} while(0)
void glVertexAttrib4ubv(glVertexAttrib4ubv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4ubv(glVertexAttrib4ubv_PACKED *_dst glVertexAttrib4ubv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4ubv_PTR)(glVertexAttrib4ubv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4ubvARB_RETURN
#define glVertexAttrib4ubvARB_RETURN void
#define glVertexAttrib4ubvARB_ARG_NAMES index, v
#define glVertexAttrib4ubvARB_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4ubvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4ubvARB_ARG_EXPAND_TAIL , GLuint index, const GLubyte * v
#define forward_glVertexAttrib4ubvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4ubvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4ubvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4ubvARB(packed, ret_v) do { \
    glVertexAttrib4ubvARB_PACKED *unpacked = (glVertexAttrib4ubvARB_PACKED *)packed; \
    glVertexAttrib4ubvARB_ARGS *args = (glVertexAttrib4ubvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4ubvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4ubvARB(glVertexAttrib4ubvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4ubvARB(glVertexAttrib4ubvARB_PACKED *_dst glVertexAttrib4ubvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4ubvARB_PTR)(glVertexAttrib4ubvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4ubvNV_RETURN
#define glVertexAttrib4ubvNV_RETURN void
#define glVertexAttrib4ubvNV_ARG_NAMES index, v
#define glVertexAttrib4ubvNV_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4ubvNV_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4ubvNV_ARG_EXPAND_TAIL , GLuint index, const GLubyte * v
#define forward_glVertexAttrib4ubvNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4ubvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4ubvNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4ubvNV(packed, ret_v) do { \
    glVertexAttrib4ubvNV_PACKED *unpacked = (glVertexAttrib4ubvNV_PACKED *)packed; \
    glVertexAttrib4ubvNV_ARGS *args = (glVertexAttrib4ubvNV_ARGS *)&unpacked->args; \
    glVertexAttrib4ubvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4ubvNV(glVertexAttrib4ubvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4ubvNV(glVertexAttrib4ubvNV_PACKED *_dst glVertexAttrib4ubvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4ubvNV_PTR)(glVertexAttrib4ubvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4uiv_RETURN
#define glVertexAttrib4uiv_RETURN void
#define glVertexAttrib4uiv_ARG_NAMES index, v
#define glVertexAttrib4uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4uiv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4uiv_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttrib4uiv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4uiv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4uiv(packed, ret_v) do { \
    glVertexAttrib4uiv_PACKED *unpacked = (glVertexAttrib4uiv_PACKED *)packed; \
    glVertexAttrib4uiv_ARGS *args = (glVertexAttrib4uiv_ARGS *)&unpacked->args; \
    glVertexAttrib4uiv(args->index, args->v);; \
} while(0)
void glVertexAttrib4uiv(glVertexAttrib4uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4uiv(glVertexAttrib4uiv_PACKED *_dst glVertexAttrib4uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4uiv_PTR)(glVertexAttrib4uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4uivARB_RETURN
#define glVertexAttrib4uivARB_RETURN void
#define glVertexAttrib4uivARB_ARG_NAMES index, v
#define glVertexAttrib4uivARB_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4uivARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4uivARB_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttrib4uivARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4uivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4uivARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4uivARB(packed, ret_v) do { \
    glVertexAttrib4uivARB_PACKED *unpacked = (glVertexAttrib4uivARB_PACKED *)packed; \
    glVertexAttrib4uivARB_ARGS *args = (glVertexAttrib4uivARB_ARGS *)&unpacked->args; \
    glVertexAttrib4uivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4uivARB(glVertexAttrib4uivARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4uivARB(glVertexAttrib4uivARB_PACKED *_dst glVertexAttrib4uivARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4uivARB_PTR)(glVertexAttrib4uivARB_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4usv_RETURN
#define glVertexAttrib4usv_RETURN void
#define glVertexAttrib4usv_ARG_NAMES index, v
#define glVertexAttrib4usv_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4usv_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4usv_ARG_EXPAND_TAIL , GLuint index, const GLushort * v
#define forward_glVertexAttrib4usv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4usv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4usv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4usv(packed, ret_v) do { \
    glVertexAttrib4usv_PACKED *unpacked = (glVertexAttrib4usv_PACKED *)packed; \
    glVertexAttrib4usv_ARGS *args = (glVertexAttrib4usv_ARGS *)&unpacked->args; \
    glVertexAttrib4usv(args->index, args->v);; \
} while(0)
void glVertexAttrib4usv(glVertexAttrib4usv_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4usv(glVertexAttrib4usv_PACKED *_dst glVertexAttrib4usv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4usv_PTR)(glVertexAttrib4usv_ARG_EXPAND);
#endif
#ifndef glVertexAttrib4usvARB_RETURN
#define glVertexAttrib4usvARB_RETURN void
#define glVertexAttrib4usvARB_ARG_NAMES index, v
#define glVertexAttrib4usvARB_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4usvARB_ARG_NAMES_TAIL , index, v
#define glVertexAttrib4usvARB_ARG_EXPAND_TAIL , GLuint index, const GLushort * v
#define forward_glVertexAttrib4usvARB(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttrib4usvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttrib4usvARB(dst, _index, _v), NULL); \
    });
#define call_glVertexAttrib4usvARB(packed, ret_v) do { \
    glVertexAttrib4usvARB_PACKED *unpacked = (glVertexAttrib4usvARB_PACKED *)packed; \
    glVertexAttrib4usvARB_ARGS *args = (glVertexAttrib4usvARB_ARGS *)&unpacked->args; \
    glVertexAttrib4usvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4usvARB(glVertexAttrib4usvARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttrib4usvARB(glVertexAttrib4usvARB_PACKED *_dst glVertexAttrib4usvARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttrib4usvARB_PTR)(glVertexAttrib4usvARB_ARG_EXPAND);
#endif
#ifndef glVertexAttribArrayObjectATI_RETURN
#define glVertexAttribArrayObjectATI_RETURN void
#define glVertexAttribArrayObjectATI_ARG_NAMES index, size, type, normalized, stride, buffer, offset
#define glVertexAttribArrayObjectATI_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset
#define glVertexAttribArrayObjectATI_ARG_NAMES_TAIL , index, size, type, normalized, stride, buffer, offset
#define glVertexAttribArrayObjectATI_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset
#define forward_glVertexAttribArrayObjectATI(_index, _size, _type, _normalized, _stride, _buffer, _offset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribArrayObjectATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribArrayObjectATI(dst, _index, _size, _type, _normalized, _stride, _buffer, _offset), NULL); \
    });
#define call_glVertexAttribArrayObjectATI(packed, ret_v) do { \
    glVertexAttribArrayObjectATI_PACKED *unpacked = (glVertexAttribArrayObjectATI_PACKED *)packed; \
    glVertexAttribArrayObjectATI_ARGS *args = (glVertexAttribArrayObjectATI_ARGS *)&unpacked->args; \
    glVertexAttribArrayObjectATI(args->index, args->size, args->type, args->normalized, args->stride, args->buffer, args->offset);; \
} while(0)
void glVertexAttribArrayObjectATI(glVertexAttribArrayObjectATI_ARG_EXPAND);
packed_call_t *pack_glVertexAttribArrayObjectATI(glVertexAttribArrayObjectATI_PACKED *_dst glVertexAttribArrayObjectATI_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribArrayObjectATI_PTR)(glVertexAttribArrayObjectATI_ARG_EXPAND);
#endif
#ifndef glVertexAttribBinding_RETURN
#define glVertexAttribBinding_RETURN void
#define glVertexAttribBinding_ARG_NAMES attribindex, bindingindex
#define glVertexAttribBinding_ARG_EXPAND GLuint attribindex, GLuint bindingindex
#define glVertexAttribBinding_ARG_NAMES_TAIL , attribindex, bindingindex
#define glVertexAttribBinding_ARG_EXPAND_TAIL , GLuint attribindex, GLuint bindingindex
#define forward_glVertexAttribBinding(_attribindex, _bindingindex) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribBinding_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribBinding(dst, _attribindex, _bindingindex), NULL); \
    });
#define call_glVertexAttribBinding(packed, ret_v) do { \
    glVertexAttribBinding_PACKED *unpacked = (glVertexAttribBinding_PACKED *)packed; \
    glVertexAttribBinding_ARGS *args = (glVertexAttribBinding_ARGS *)&unpacked->args; \
    glVertexAttribBinding(args->attribindex, args->bindingindex);; \
} while(0)
void glVertexAttribBinding(glVertexAttribBinding_ARG_EXPAND);
packed_call_t *pack_glVertexAttribBinding(glVertexAttribBinding_PACKED *_dst glVertexAttribBinding_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribBinding_PTR)(glVertexAttribBinding_ARG_EXPAND);
#endif
#ifndef glVertexAttribDivisor_RETURN
#define glVertexAttribDivisor_RETURN void
#define glVertexAttribDivisor_ARG_NAMES index, divisor
#define glVertexAttribDivisor_ARG_EXPAND GLuint index, GLuint divisor
#define glVertexAttribDivisor_ARG_NAMES_TAIL , index, divisor
#define glVertexAttribDivisor_ARG_EXPAND_TAIL , GLuint index, GLuint divisor
#define forward_glVertexAttribDivisor(_index, _divisor) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribDivisor_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribDivisor(dst, _index, _divisor), NULL); \
    });
#define call_glVertexAttribDivisor(packed, ret_v) do { \
    glVertexAttribDivisor_PACKED *unpacked = (glVertexAttribDivisor_PACKED *)packed; \
    glVertexAttribDivisor_ARGS *args = (glVertexAttribDivisor_ARGS *)&unpacked->args; \
    glVertexAttribDivisor(args->index, args->divisor);; \
} while(0)
void glVertexAttribDivisor(glVertexAttribDivisor_ARG_EXPAND);
packed_call_t *pack_glVertexAttribDivisor(glVertexAttribDivisor_PACKED *_dst glVertexAttribDivisor_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribDivisor_PTR)(glVertexAttribDivisor_ARG_EXPAND);
#endif
#ifndef glVertexAttribDivisorARB_RETURN
#define glVertexAttribDivisorARB_RETURN void
#define glVertexAttribDivisorARB_ARG_NAMES index, divisor
#define glVertexAttribDivisorARB_ARG_EXPAND GLuint index, GLuint divisor
#define glVertexAttribDivisorARB_ARG_NAMES_TAIL , index, divisor
#define glVertexAttribDivisorARB_ARG_EXPAND_TAIL , GLuint index, GLuint divisor
#define forward_glVertexAttribDivisorARB(_index, _divisor) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribDivisorARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribDivisorARB(dst, _index, _divisor), NULL); \
    });
#define call_glVertexAttribDivisorARB(packed, ret_v) do { \
    glVertexAttribDivisorARB_PACKED *unpacked = (glVertexAttribDivisorARB_PACKED *)packed; \
    glVertexAttribDivisorARB_ARGS *args = (glVertexAttribDivisorARB_ARGS *)&unpacked->args; \
    glVertexAttribDivisorARB(args->index, args->divisor);; \
} while(0)
void glVertexAttribDivisorARB(glVertexAttribDivisorARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttribDivisorARB(glVertexAttribDivisorARB_PACKED *_dst glVertexAttribDivisorARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribDivisorARB_PTR)(glVertexAttribDivisorARB_ARG_EXPAND);
#endif
#ifndef glVertexAttribFormat_RETURN
#define glVertexAttribFormat_RETURN void
#define glVertexAttribFormat_ARG_NAMES attribindex, size, type, normalized, relativeoffset
#define glVertexAttribFormat_ARG_EXPAND GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset
#define glVertexAttribFormat_ARG_NAMES_TAIL , attribindex, size, type, normalized, relativeoffset
#define glVertexAttribFormat_ARG_EXPAND_TAIL , GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset
#define forward_glVertexAttribFormat(_attribindex, _size, _type, _normalized, _relativeoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribFormat_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribFormat(dst, _attribindex, _size, _type, _normalized, _relativeoffset), NULL); \
    });
#define call_glVertexAttribFormat(packed, ret_v) do { \
    glVertexAttribFormat_PACKED *unpacked = (glVertexAttribFormat_PACKED *)packed; \
    glVertexAttribFormat_ARGS *args = (glVertexAttribFormat_ARGS *)&unpacked->args; \
    glVertexAttribFormat(args->attribindex, args->size, args->type, args->normalized, args->relativeoffset);; \
} while(0)
void glVertexAttribFormat(glVertexAttribFormat_ARG_EXPAND);
packed_call_t *pack_glVertexAttribFormat(glVertexAttribFormat_PACKED *_dst glVertexAttribFormat_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribFormat_PTR)(glVertexAttribFormat_ARG_EXPAND);
#endif
#ifndef glVertexAttribFormatNV_RETURN
#define glVertexAttribFormatNV_RETURN void
#define glVertexAttribFormatNV_ARG_NAMES index, size, type, normalized, stride
#define glVertexAttribFormatNV_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride
#define glVertexAttribFormatNV_ARG_NAMES_TAIL , index, size, type, normalized, stride
#define glVertexAttribFormatNV_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride
#define forward_glVertexAttribFormatNV(_index, _size, _type, _normalized, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribFormatNV(dst, _index, _size, _type, _normalized, _stride), NULL); \
    });
#define call_glVertexAttribFormatNV(packed, ret_v) do { \
    glVertexAttribFormatNV_PACKED *unpacked = (glVertexAttribFormatNV_PACKED *)packed; \
    glVertexAttribFormatNV_ARGS *args = (glVertexAttribFormatNV_ARGS *)&unpacked->args; \
    glVertexAttribFormatNV(args->index, args->size, args->type, args->normalized, args->stride);; \
} while(0)
void glVertexAttribFormatNV(glVertexAttribFormatNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribFormatNV(glVertexAttribFormatNV_PACKED *_dst glVertexAttribFormatNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribFormatNV_PTR)(glVertexAttribFormatNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1i_RETURN
#define glVertexAttribI1i_RETURN void
#define glVertexAttribI1i_ARG_NAMES index, x
#define glVertexAttribI1i_ARG_EXPAND GLuint index, GLint x
#define glVertexAttribI1i_ARG_NAMES_TAIL , index, x
#define glVertexAttribI1i_ARG_EXPAND_TAIL , GLuint index, GLint x
#define forward_glVertexAttribI1i(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1i(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribI1i(packed, ret_v) do { \
    glVertexAttribI1i_PACKED *unpacked = (glVertexAttribI1i_PACKED *)packed; \
    glVertexAttribI1i_ARGS *args = (glVertexAttribI1i_ARGS *)&unpacked->args; \
    glVertexAttribI1i(args->index, args->x);; \
} while(0)
void glVertexAttribI1i(glVertexAttribI1i_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1i(glVertexAttribI1i_PACKED *_dst glVertexAttribI1i_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1i_PTR)(glVertexAttribI1i_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1iEXT_RETURN
#define glVertexAttribI1iEXT_RETURN void
#define glVertexAttribI1iEXT_ARG_NAMES index, x
#define glVertexAttribI1iEXT_ARG_EXPAND GLuint index, GLint x
#define glVertexAttribI1iEXT_ARG_NAMES_TAIL , index, x
#define glVertexAttribI1iEXT_ARG_EXPAND_TAIL , GLuint index, GLint x
#define forward_glVertexAttribI1iEXT(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1iEXT(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribI1iEXT(packed, ret_v) do { \
    glVertexAttribI1iEXT_PACKED *unpacked = (glVertexAttribI1iEXT_PACKED *)packed; \
    glVertexAttribI1iEXT_ARGS *args = (glVertexAttribI1iEXT_ARGS *)&unpacked->args; \
    glVertexAttribI1iEXT(args->index, args->x);; \
} while(0)
void glVertexAttribI1iEXT(glVertexAttribI1iEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1iEXT(glVertexAttribI1iEXT_PACKED *_dst glVertexAttribI1iEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1iEXT_PTR)(glVertexAttribI1iEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1iv_RETURN
#define glVertexAttribI1iv_RETURN void
#define glVertexAttribI1iv_ARG_NAMES index, v
#define glVertexAttribI1iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI1iv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI1iv_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI1iv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1iv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI1iv(packed, ret_v) do { \
    glVertexAttribI1iv_PACKED *unpacked = (glVertexAttribI1iv_PACKED *)packed; \
    glVertexAttribI1iv_ARGS *args = (glVertexAttribI1iv_ARGS *)&unpacked->args; \
    glVertexAttribI1iv(args->index, args->v);; \
} while(0)
void glVertexAttribI1iv(glVertexAttribI1iv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1iv(glVertexAttribI1iv_PACKED *_dst glVertexAttribI1iv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1iv_PTR)(glVertexAttribI1iv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1ivEXT_RETURN
#define glVertexAttribI1ivEXT_RETURN void
#define glVertexAttribI1ivEXT_ARG_NAMES index, v
#define glVertexAttribI1ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI1ivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI1ivEXT_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI1ivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1ivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI1ivEXT(packed, ret_v) do { \
    glVertexAttribI1ivEXT_PACKED *unpacked = (glVertexAttribI1ivEXT_PACKED *)packed; \
    glVertexAttribI1ivEXT_ARGS *args = (glVertexAttribI1ivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI1ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI1ivEXT(glVertexAttribI1ivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1ivEXT(glVertexAttribI1ivEXT_PACKED *_dst glVertexAttribI1ivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1ivEXT_PTR)(glVertexAttribI1ivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1ui_RETURN
#define glVertexAttribI1ui_RETURN void
#define glVertexAttribI1ui_ARG_NAMES index, x
#define glVertexAttribI1ui_ARG_EXPAND GLuint index, GLuint x
#define glVertexAttribI1ui_ARG_NAMES_TAIL , index, x
#define glVertexAttribI1ui_ARG_EXPAND_TAIL , GLuint index, GLuint x
#define forward_glVertexAttribI1ui(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1ui(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribI1ui(packed, ret_v) do { \
    glVertexAttribI1ui_PACKED *unpacked = (glVertexAttribI1ui_PACKED *)packed; \
    glVertexAttribI1ui_ARGS *args = (glVertexAttribI1ui_ARGS *)&unpacked->args; \
    glVertexAttribI1ui(args->index, args->x);; \
} while(0)
void glVertexAttribI1ui(glVertexAttribI1ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1ui(glVertexAttribI1ui_PACKED *_dst glVertexAttribI1ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1ui_PTR)(glVertexAttribI1ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1uiEXT_RETURN
#define glVertexAttribI1uiEXT_RETURN void
#define glVertexAttribI1uiEXT_ARG_NAMES index, x
#define glVertexAttribI1uiEXT_ARG_EXPAND GLuint index, GLuint x
#define glVertexAttribI1uiEXT_ARG_NAMES_TAIL , index, x
#define glVertexAttribI1uiEXT_ARG_EXPAND_TAIL , GLuint index, GLuint x
#define forward_glVertexAttribI1uiEXT(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1uiEXT(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribI1uiEXT(packed, ret_v) do { \
    glVertexAttribI1uiEXT_PACKED *unpacked = (glVertexAttribI1uiEXT_PACKED *)packed; \
    glVertexAttribI1uiEXT_ARGS *args = (glVertexAttribI1uiEXT_ARGS *)&unpacked->args; \
    glVertexAttribI1uiEXT(args->index, args->x);; \
} while(0)
void glVertexAttribI1uiEXT(glVertexAttribI1uiEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1uiEXT(glVertexAttribI1uiEXT_PACKED *_dst glVertexAttribI1uiEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1uiEXT_PTR)(glVertexAttribI1uiEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1uiv_RETURN
#define glVertexAttribI1uiv_RETURN void
#define glVertexAttribI1uiv_ARG_NAMES index, v
#define glVertexAttribI1uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI1uiv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI1uiv_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI1uiv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1uiv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI1uiv(packed, ret_v) do { \
    glVertexAttribI1uiv_PACKED *unpacked = (glVertexAttribI1uiv_PACKED *)packed; \
    glVertexAttribI1uiv_ARGS *args = (glVertexAttribI1uiv_ARGS *)&unpacked->args; \
    glVertexAttribI1uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI1uiv(glVertexAttribI1uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1uiv(glVertexAttribI1uiv_PACKED *_dst glVertexAttribI1uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1uiv_PTR)(glVertexAttribI1uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI1uivEXT_RETURN
#define glVertexAttribI1uivEXT_RETURN void
#define glVertexAttribI1uivEXT_ARG_NAMES index, v
#define glVertexAttribI1uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI1uivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI1uivEXT_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI1uivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI1uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI1uivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI1uivEXT(packed, ret_v) do { \
    glVertexAttribI1uivEXT_PACKED *unpacked = (glVertexAttribI1uivEXT_PACKED *)packed; \
    glVertexAttribI1uivEXT_ARGS *args = (glVertexAttribI1uivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI1uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI1uivEXT(glVertexAttribI1uivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI1uivEXT(glVertexAttribI1uivEXT_PACKED *_dst glVertexAttribI1uivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI1uivEXT_PTR)(glVertexAttribI1uivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2i_RETURN
#define glVertexAttribI2i_RETURN void
#define glVertexAttribI2i_ARG_NAMES index, x, y
#define glVertexAttribI2i_ARG_EXPAND GLuint index, GLint x, GLint y
#define glVertexAttribI2i_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribI2i_ARG_EXPAND_TAIL , GLuint index, GLint x, GLint y
#define forward_glVertexAttribI2i(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2i(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribI2i(packed, ret_v) do { \
    glVertexAttribI2i_PACKED *unpacked = (glVertexAttribI2i_PACKED *)packed; \
    glVertexAttribI2i_ARGS *args = (glVertexAttribI2i_ARGS *)&unpacked->args; \
    glVertexAttribI2i(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2i(glVertexAttribI2i_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2i(glVertexAttribI2i_PACKED *_dst glVertexAttribI2i_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2i_PTR)(glVertexAttribI2i_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2iEXT_RETURN
#define glVertexAttribI2iEXT_RETURN void
#define glVertexAttribI2iEXT_ARG_NAMES index, x, y
#define glVertexAttribI2iEXT_ARG_EXPAND GLuint index, GLint x, GLint y
#define glVertexAttribI2iEXT_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribI2iEXT_ARG_EXPAND_TAIL , GLuint index, GLint x, GLint y
#define forward_glVertexAttribI2iEXT(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2iEXT(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribI2iEXT(packed, ret_v) do { \
    glVertexAttribI2iEXT_PACKED *unpacked = (glVertexAttribI2iEXT_PACKED *)packed; \
    glVertexAttribI2iEXT_ARGS *args = (glVertexAttribI2iEXT_ARGS *)&unpacked->args; \
    glVertexAttribI2iEXT(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2iEXT(glVertexAttribI2iEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2iEXT(glVertexAttribI2iEXT_PACKED *_dst glVertexAttribI2iEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2iEXT_PTR)(glVertexAttribI2iEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2iv_RETURN
#define glVertexAttribI2iv_RETURN void
#define glVertexAttribI2iv_ARG_NAMES index, v
#define glVertexAttribI2iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI2iv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI2iv_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI2iv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2iv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI2iv(packed, ret_v) do { \
    glVertexAttribI2iv_PACKED *unpacked = (glVertexAttribI2iv_PACKED *)packed; \
    glVertexAttribI2iv_ARGS *args = (glVertexAttribI2iv_ARGS *)&unpacked->args; \
    glVertexAttribI2iv(args->index, args->v);; \
} while(0)
void glVertexAttribI2iv(glVertexAttribI2iv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2iv(glVertexAttribI2iv_PACKED *_dst glVertexAttribI2iv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2iv_PTR)(glVertexAttribI2iv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2ivEXT_RETURN
#define glVertexAttribI2ivEXT_RETURN void
#define glVertexAttribI2ivEXT_ARG_NAMES index, v
#define glVertexAttribI2ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI2ivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI2ivEXT_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI2ivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2ivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI2ivEXT(packed, ret_v) do { \
    glVertexAttribI2ivEXT_PACKED *unpacked = (glVertexAttribI2ivEXT_PACKED *)packed; \
    glVertexAttribI2ivEXT_ARGS *args = (glVertexAttribI2ivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI2ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI2ivEXT(glVertexAttribI2ivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2ivEXT(glVertexAttribI2ivEXT_PACKED *_dst glVertexAttribI2ivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2ivEXT_PTR)(glVertexAttribI2ivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2ui_RETURN
#define glVertexAttribI2ui_RETURN void
#define glVertexAttribI2ui_ARG_NAMES index, x, y
#define glVertexAttribI2ui_ARG_EXPAND GLuint index, GLuint x, GLuint y
#define glVertexAttribI2ui_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribI2ui_ARG_EXPAND_TAIL , GLuint index, GLuint x, GLuint y
#define forward_glVertexAttribI2ui(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2ui(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribI2ui(packed, ret_v) do { \
    glVertexAttribI2ui_PACKED *unpacked = (glVertexAttribI2ui_PACKED *)packed; \
    glVertexAttribI2ui_ARGS *args = (glVertexAttribI2ui_ARGS *)&unpacked->args; \
    glVertexAttribI2ui(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2ui(glVertexAttribI2ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2ui(glVertexAttribI2ui_PACKED *_dst glVertexAttribI2ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2ui_PTR)(glVertexAttribI2ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2uiEXT_RETURN
#define glVertexAttribI2uiEXT_RETURN void
#define glVertexAttribI2uiEXT_ARG_NAMES index, x, y
#define glVertexAttribI2uiEXT_ARG_EXPAND GLuint index, GLuint x, GLuint y
#define glVertexAttribI2uiEXT_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribI2uiEXT_ARG_EXPAND_TAIL , GLuint index, GLuint x, GLuint y
#define forward_glVertexAttribI2uiEXT(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2uiEXT(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribI2uiEXT(packed, ret_v) do { \
    glVertexAttribI2uiEXT_PACKED *unpacked = (glVertexAttribI2uiEXT_PACKED *)packed; \
    glVertexAttribI2uiEXT_ARGS *args = (glVertexAttribI2uiEXT_ARGS *)&unpacked->args; \
    glVertexAttribI2uiEXT(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2uiEXT(glVertexAttribI2uiEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2uiEXT(glVertexAttribI2uiEXT_PACKED *_dst glVertexAttribI2uiEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2uiEXT_PTR)(glVertexAttribI2uiEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2uiv_RETURN
#define glVertexAttribI2uiv_RETURN void
#define glVertexAttribI2uiv_ARG_NAMES index, v
#define glVertexAttribI2uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI2uiv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI2uiv_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI2uiv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2uiv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI2uiv(packed, ret_v) do { \
    glVertexAttribI2uiv_PACKED *unpacked = (glVertexAttribI2uiv_PACKED *)packed; \
    glVertexAttribI2uiv_ARGS *args = (glVertexAttribI2uiv_ARGS *)&unpacked->args; \
    glVertexAttribI2uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI2uiv(glVertexAttribI2uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2uiv(glVertexAttribI2uiv_PACKED *_dst glVertexAttribI2uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2uiv_PTR)(glVertexAttribI2uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI2uivEXT_RETURN
#define glVertexAttribI2uivEXT_RETURN void
#define glVertexAttribI2uivEXT_ARG_NAMES index, v
#define glVertexAttribI2uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI2uivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI2uivEXT_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI2uivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI2uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI2uivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI2uivEXT(packed, ret_v) do { \
    glVertexAttribI2uivEXT_PACKED *unpacked = (glVertexAttribI2uivEXT_PACKED *)packed; \
    glVertexAttribI2uivEXT_ARGS *args = (glVertexAttribI2uivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI2uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI2uivEXT(glVertexAttribI2uivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI2uivEXT(glVertexAttribI2uivEXT_PACKED *_dst glVertexAttribI2uivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI2uivEXT_PTR)(glVertexAttribI2uivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3i_RETURN
#define glVertexAttribI3i_RETURN void
#define glVertexAttribI3i_ARG_NAMES index, x, y, z
#define glVertexAttribI3i_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z
#define glVertexAttribI3i_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribI3i_ARG_EXPAND_TAIL , GLuint index, GLint x, GLint y, GLint z
#define forward_glVertexAttribI3i(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3i(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribI3i(packed, ret_v) do { \
    glVertexAttribI3i_PACKED *unpacked = (glVertexAttribI3i_PACKED *)packed; \
    glVertexAttribI3i_ARGS *args = (glVertexAttribI3i_ARGS *)&unpacked->args; \
    glVertexAttribI3i(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3i(glVertexAttribI3i_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3i(glVertexAttribI3i_PACKED *_dst glVertexAttribI3i_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3i_PTR)(glVertexAttribI3i_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3iEXT_RETURN
#define glVertexAttribI3iEXT_RETURN void
#define glVertexAttribI3iEXT_ARG_NAMES index, x, y, z
#define glVertexAttribI3iEXT_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z
#define glVertexAttribI3iEXT_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribI3iEXT_ARG_EXPAND_TAIL , GLuint index, GLint x, GLint y, GLint z
#define forward_glVertexAttribI3iEXT(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3iEXT(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribI3iEXT(packed, ret_v) do { \
    glVertexAttribI3iEXT_PACKED *unpacked = (glVertexAttribI3iEXT_PACKED *)packed; \
    glVertexAttribI3iEXT_ARGS *args = (glVertexAttribI3iEXT_ARGS *)&unpacked->args; \
    glVertexAttribI3iEXT(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3iEXT(glVertexAttribI3iEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3iEXT(glVertexAttribI3iEXT_PACKED *_dst glVertexAttribI3iEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3iEXT_PTR)(glVertexAttribI3iEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3iv_RETURN
#define glVertexAttribI3iv_RETURN void
#define glVertexAttribI3iv_ARG_NAMES index, v
#define glVertexAttribI3iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI3iv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI3iv_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI3iv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3iv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI3iv(packed, ret_v) do { \
    glVertexAttribI3iv_PACKED *unpacked = (glVertexAttribI3iv_PACKED *)packed; \
    glVertexAttribI3iv_ARGS *args = (glVertexAttribI3iv_ARGS *)&unpacked->args; \
    glVertexAttribI3iv(args->index, args->v);; \
} while(0)
void glVertexAttribI3iv(glVertexAttribI3iv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3iv(glVertexAttribI3iv_PACKED *_dst glVertexAttribI3iv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3iv_PTR)(glVertexAttribI3iv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3ivEXT_RETURN
#define glVertexAttribI3ivEXT_RETURN void
#define glVertexAttribI3ivEXT_ARG_NAMES index, v
#define glVertexAttribI3ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI3ivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI3ivEXT_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI3ivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3ivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI3ivEXT(packed, ret_v) do { \
    glVertexAttribI3ivEXT_PACKED *unpacked = (glVertexAttribI3ivEXT_PACKED *)packed; \
    glVertexAttribI3ivEXT_ARGS *args = (glVertexAttribI3ivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI3ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI3ivEXT(glVertexAttribI3ivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3ivEXT(glVertexAttribI3ivEXT_PACKED *_dst glVertexAttribI3ivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3ivEXT_PTR)(glVertexAttribI3ivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3ui_RETURN
#define glVertexAttribI3ui_RETURN void
#define glVertexAttribI3ui_ARG_NAMES index, x, y, z
#define glVertexAttribI3ui_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z
#define glVertexAttribI3ui_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribI3ui_ARG_EXPAND_TAIL , GLuint index, GLuint x, GLuint y, GLuint z
#define forward_glVertexAttribI3ui(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3ui(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribI3ui(packed, ret_v) do { \
    glVertexAttribI3ui_PACKED *unpacked = (glVertexAttribI3ui_PACKED *)packed; \
    glVertexAttribI3ui_ARGS *args = (glVertexAttribI3ui_ARGS *)&unpacked->args; \
    glVertexAttribI3ui(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3ui(glVertexAttribI3ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3ui(glVertexAttribI3ui_PACKED *_dst glVertexAttribI3ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3ui_PTR)(glVertexAttribI3ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3uiEXT_RETURN
#define glVertexAttribI3uiEXT_RETURN void
#define glVertexAttribI3uiEXT_ARG_NAMES index, x, y, z
#define glVertexAttribI3uiEXT_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z
#define glVertexAttribI3uiEXT_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribI3uiEXT_ARG_EXPAND_TAIL , GLuint index, GLuint x, GLuint y, GLuint z
#define forward_glVertexAttribI3uiEXT(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3uiEXT(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribI3uiEXT(packed, ret_v) do { \
    glVertexAttribI3uiEXT_PACKED *unpacked = (glVertexAttribI3uiEXT_PACKED *)packed; \
    glVertexAttribI3uiEXT_ARGS *args = (glVertexAttribI3uiEXT_ARGS *)&unpacked->args; \
    glVertexAttribI3uiEXT(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3uiEXT(glVertexAttribI3uiEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3uiEXT(glVertexAttribI3uiEXT_PACKED *_dst glVertexAttribI3uiEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3uiEXT_PTR)(glVertexAttribI3uiEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3uiv_RETURN
#define glVertexAttribI3uiv_RETURN void
#define glVertexAttribI3uiv_ARG_NAMES index, v
#define glVertexAttribI3uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI3uiv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI3uiv_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI3uiv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3uiv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI3uiv(packed, ret_v) do { \
    glVertexAttribI3uiv_PACKED *unpacked = (glVertexAttribI3uiv_PACKED *)packed; \
    glVertexAttribI3uiv_ARGS *args = (glVertexAttribI3uiv_ARGS *)&unpacked->args; \
    glVertexAttribI3uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI3uiv(glVertexAttribI3uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3uiv(glVertexAttribI3uiv_PACKED *_dst glVertexAttribI3uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3uiv_PTR)(glVertexAttribI3uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI3uivEXT_RETURN
#define glVertexAttribI3uivEXT_RETURN void
#define glVertexAttribI3uivEXT_ARG_NAMES index, v
#define glVertexAttribI3uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI3uivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI3uivEXT_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI3uivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI3uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI3uivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI3uivEXT(packed, ret_v) do { \
    glVertexAttribI3uivEXT_PACKED *unpacked = (glVertexAttribI3uivEXT_PACKED *)packed; \
    glVertexAttribI3uivEXT_ARGS *args = (glVertexAttribI3uivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI3uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI3uivEXT(glVertexAttribI3uivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI3uivEXT(glVertexAttribI3uivEXT_PACKED *_dst glVertexAttribI3uivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI3uivEXT_PTR)(glVertexAttribI3uivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4bv_RETURN
#define glVertexAttribI4bv_RETURN void
#define glVertexAttribI4bv_ARG_NAMES index, v
#define glVertexAttribI4bv_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttribI4bv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4bv_ARG_EXPAND_TAIL , GLuint index, const GLbyte * v
#define forward_glVertexAttribI4bv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4bv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4bv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4bv(packed, ret_v) do { \
    glVertexAttribI4bv_PACKED *unpacked = (glVertexAttribI4bv_PACKED *)packed; \
    glVertexAttribI4bv_ARGS *args = (glVertexAttribI4bv_ARGS *)&unpacked->args; \
    glVertexAttribI4bv(args->index, args->v);; \
} while(0)
void glVertexAttribI4bv(glVertexAttribI4bv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4bv(glVertexAttribI4bv_PACKED *_dst glVertexAttribI4bv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4bv_PTR)(glVertexAttribI4bv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4bvEXT_RETURN
#define glVertexAttribI4bvEXT_RETURN void
#define glVertexAttribI4bvEXT_ARG_NAMES index, v
#define glVertexAttribI4bvEXT_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttribI4bvEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4bvEXT_ARG_EXPAND_TAIL , GLuint index, const GLbyte * v
#define forward_glVertexAttribI4bvEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4bvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4bvEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4bvEXT(packed, ret_v) do { \
    glVertexAttribI4bvEXT_PACKED *unpacked = (glVertexAttribI4bvEXT_PACKED *)packed; \
    glVertexAttribI4bvEXT_ARGS *args = (glVertexAttribI4bvEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4bvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4bvEXT(glVertexAttribI4bvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4bvEXT(glVertexAttribI4bvEXT_PACKED *_dst glVertexAttribI4bvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4bvEXT_PTR)(glVertexAttribI4bvEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4i_RETURN
#define glVertexAttribI4i_RETURN void
#define glVertexAttribI4i_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4i_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z, GLint w
#define glVertexAttribI4i_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribI4i_ARG_EXPAND_TAIL , GLuint index, GLint x, GLint y, GLint z, GLint w
#define forward_glVertexAttribI4i(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4i(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribI4i(packed, ret_v) do { \
    glVertexAttribI4i_PACKED *unpacked = (glVertexAttribI4i_PACKED *)packed; \
    glVertexAttribI4i_ARGS *args = (glVertexAttribI4i_ARGS *)&unpacked->args; \
    glVertexAttribI4i(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4i(glVertexAttribI4i_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4i(glVertexAttribI4i_PACKED *_dst glVertexAttribI4i_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4i_PTR)(glVertexAttribI4i_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4iEXT_RETURN
#define glVertexAttribI4iEXT_RETURN void
#define glVertexAttribI4iEXT_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4iEXT_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z, GLint w
#define glVertexAttribI4iEXT_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribI4iEXT_ARG_EXPAND_TAIL , GLuint index, GLint x, GLint y, GLint z, GLint w
#define forward_glVertexAttribI4iEXT(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4iEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4iEXT(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribI4iEXT(packed, ret_v) do { \
    glVertexAttribI4iEXT_PACKED *unpacked = (glVertexAttribI4iEXT_PACKED *)packed; \
    glVertexAttribI4iEXT_ARGS *args = (glVertexAttribI4iEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4iEXT(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4iEXT(glVertexAttribI4iEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4iEXT(glVertexAttribI4iEXT_PACKED *_dst glVertexAttribI4iEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4iEXT_PTR)(glVertexAttribI4iEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4iv_RETURN
#define glVertexAttribI4iv_RETURN void
#define glVertexAttribI4iv_ARG_NAMES index, v
#define glVertexAttribI4iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI4iv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4iv_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI4iv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4iv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4iv(packed, ret_v) do { \
    glVertexAttribI4iv_PACKED *unpacked = (glVertexAttribI4iv_PACKED *)packed; \
    glVertexAttribI4iv_ARGS *args = (glVertexAttribI4iv_ARGS *)&unpacked->args; \
    glVertexAttribI4iv(args->index, args->v);; \
} while(0)
void glVertexAttribI4iv(glVertexAttribI4iv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4iv(glVertexAttribI4iv_PACKED *_dst glVertexAttribI4iv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4iv_PTR)(glVertexAttribI4iv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4ivEXT_RETURN
#define glVertexAttribI4ivEXT_RETURN void
#define glVertexAttribI4ivEXT_ARG_NAMES index, v
#define glVertexAttribI4ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI4ivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4ivEXT_ARG_EXPAND_TAIL , GLuint index, const GLint * v
#define forward_glVertexAttribI4ivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4ivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4ivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4ivEXT(packed, ret_v) do { \
    glVertexAttribI4ivEXT_PACKED *unpacked = (glVertexAttribI4ivEXT_PACKED *)packed; \
    glVertexAttribI4ivEXT_ARGS *args = (glVertexAttribI4ivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4ivEXT(glVertexAttribI4ivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4ivEXT(glVertexAttribI4ivEXT_PACKED *_dst glVertexAttribI4ivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4ivEXT_PTR)(glVertexAttribI4ivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4sv_RETURN
#define glVertexAttribI4sv_RETURN void
#define glVertexAttribI4sv_ARG_NAMES index, v
#define glVertexAttribI4sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttribI4sv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4sv_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttribI4sv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4sv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4sv(packed, ret_v) do { \
    glVertexAttribI4sv_PACKED *unpacked = (glVertexAttribI4sv_PACKED *)packed; \
    glVertexAttribI4sv_ARGS *args = (glVertexAttribI4sv_ARGS *)&unpacked->args; \
    glVertexAttribI4sv(args->index, args->v);; \
} while(0)
void glVertexAttribI4sv(glVertexAttribI4sv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4sv(glVertexAttribI4sv_PACKED *_dst glVertexAttribI4sv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4sv_PTR)(glVertexAttribI4sv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4svEXT_RETURN
#define glVertexAttribI4svEXT_RETURN void
#define glVertexAttribI4svEXT_ARG_NAMES index, v
#define glVertexAttribI4svEXT_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttribI4svEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4svEXT_ARG_EXPAND_TAIL , GLuint index, const GLshort * v
#define forward_glVertexAttribI4svEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4svEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4svEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4svEXT(packed, ret_v) do { \
    glVertexAttribI4svEXT_PACKED *unpacked = (glVertexAttribI4svEXT_PACKED *)packed; \
    glVertexAttribI4svEXT_ARGS *args = (glVertexAttribI4svEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4svEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4svEXT(glVertexAttribI4svEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4svEXT(glVertexAttribI4svEXT_PACKED *_dst glVertexAttribI4svEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4svEXT_PTR)(glVertexAttribI4svEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4ubv_RETURN
#define glVertexAttribI4ubv_RETURN void
#define glVertexAttribI4ubv_ARG_NAMES index, v
#define glVertexAttribI4ubv_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttribI4ubv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4ubv_ARG_EXPAND_TAIL , GLuint index, const GLubyte * v
#define forward_glVertexAttribI4ubv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4ubv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4ubv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4ubv(packed, ret_v) do { \
    glVertexAttribI4ubv_PACKED *unpacked = (glVertexAttribI4ubv_PACKED *)packed; \
    glVertexAttribI4ubv_ARGS *args = (glVertexAttribI4ubv_ARGS *)&unpacked->args; \
    glVertexAttribI4ubv(args->index, args->v);; \
} while(0)
void glVertexAttribI4ubv(glVertexAttribI4ubv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4ubv(glVertexAttribI4ubv_PACKED *_dst glVertexAttribI4ubv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4ubv_PTR)(glVertexAttribI4ubv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4ubvEXT_RETURN
#define glVertexAttribI4ubvEXT_RETURN void
#define glVertexAttribI4ubvEXT_ARG_NAMES index, v
#define glVertexAttribI4ubvEXT_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttribI4ubvEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4ubvEXT_ARG_EXPAND_TAIL , GLuint index, const GLubyte * v
#define forward_glVertexAttribI4ubvEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4ubvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4ubvEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4ubvEXT(packed, ret_v) do { \
    glVertexAttribI4ubvEXT_PACKED *unpacked = (glVertexAttribI4ubvEXT_PACKED *)packed; \
    glVertexAttribI4ubvEXT_ARGS *args = (glVertexAttribI4ubvEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4ubvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4ubvEXT(glVertexAttribI4ubvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4ubvEXT(glVertexAttribI4ubvEXT_PACKED *_dst glVertexAttribI4ubvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4ubvEXT_PTR)(glVertexAttribI4ubvEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4ui_RETURN
#define glVertexAttribI4ui_RETURN void
#define glVertexAttribI4ui_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4ui_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glVertexAttribI4ui_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribI4ui_ARG_EXPAND_TAIL , GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define forward_glVertexAttribI4ui(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4ui(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribI4ui(packed, ret_v) do { \
    glVertexAttribI4ui_PACKED *unpacked = (glVertexAttribI4ui_PACKED *)packed; \
    glVertexAttribI4ui_ARGS *args = (glVertexAttribI4ui_ARGS *)&unpacked->args; \
    glVertexAttribI4ui(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4ui(glVertexAttribI4ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4ui(glVertexAttribI4ui_PACKED *_dst glVertexAttribI4ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4ui_PTR)(glVertexAttribI4ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4uiEXT_RETURN
#define glVertexAttribI4uiEXT_RETURN void
#define glVertexAttribI4uiEXT_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4uiEXT_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glVertexAttribI4uiEXT_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribI4uiEXT_ARG_EXPAND_TAIL , GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define forward_glVertexAttribI4uiEXT(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4uiEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4uiEXT(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribI4uiEXT(packed, ret_v) do { \
    glVertexAttribI4uiEXT_PACKED *unpacked = (glVertexAttribI4uiEXT_PACKED *)packed; \
    glVertexAttribI4uiEXT_ARGS *args = (glVertexAttribI4uiEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4uiEXT(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4uiEXT(glVertexAttribI4uiEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4uiEXT(glVertexAttribI4uiEXT_PACKED *_dst glVertexAttribI4uiEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4uiEXT_PTR)(glVertexAttribI4uiEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4uiv_RETURN
#define glVertexAttribI4uiv_RETURN void
#define glVertexAttribI4uiv_ARG_NAMES index, v
#define glVertexAttribI4uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI4uiv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4uiv_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI4uiv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4uiv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4uiv(packed, ret_v) do { \
    glVertexAttribI4uiv_PACKED *unpacked = (glVertexAttribI4uiv_PACKED *)packed; \
    glVertexAttribI4uiv_ARGS *args = (glVertexAttribI4uiv_ARGS *)&unpacked->args; \
    glVertexAttribI4uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI4uiv(glVertexAttribI4uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4uiv(glVertexAttribI4uiv_PACKED *_dst glVertexAttribI4uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4uiv_PTR)(glVertexAttribI4uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4uivEXT_RETURN
#define glVertexAttribI4uivEXT_RETURN void
#define glVertexAttribI4uivEXT_ARG_NAMES index, v
#define glVertexAttribI4uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI4uivEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4uivEXT_ARG_EXPAND_TAIL , GLuint index, const GLuint * v
#define forward_glVertexAttribI4uivEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4uivEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4uivEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4uivEXT(packed, ret_v) do { \
    glVertexAttribI4uivEXT_PACKED *unpacked = (glVertexAttribI4uivEXT_PACKED *)packed; \
    glVertexAttribI4uivEXT_ARGS *args = (glVertexAttribI4uivEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4uivEXT(glVertexAttribI4uivEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4uivEXT(glVertexAttribI4uivEXT_PACKED *_dst glVertexAttribI4uivEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4uivEXT_PTR)(glVertexAttribI4uivEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4usv_RETURN
#define glVertexAttribI4usv_RETURN void
#define glVertexAttribI4usv_ARG_NAMES index, v
#define glVertexAttribI4usv_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttribI4usv_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4usv_ARG_EXPAND_TAIL , GLuint index, const GLushort * v
#define forward_glVertexAttribI4usv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4usv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4usv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4usv(packed, ret_v) do { \
    glVertexAttribI4usv_PACKED *unpacked = (glVertexAttribI4usv_PACKED *)packed; \
    glVertexAttribI4usv_ARGS *args = (glVertexAttribI4usv_ARGS *)&unpacked->args; \
    glVertexAttribI4usv(args->index, args->v);; \
} while(0)
void glVertexAttribI4usv(glVertexAttribI4usv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4usv(glVertexAttribI4usv_PACKED *_dst glVertexAttribI4usv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4usv_PTR)(glVertexAttribI4usv_ARG_EXPAND);
#endif
#ifndef glVertexAttribI4usvEXT_RETURN
#define glVertexAttribI4usvEXT_RETURN void
#define glVertexAttribI4usvEXT_ARG_NAMES index, v
#define glVertexAttribI4usvEXT_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttribI4usvEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribI4usvEXT_ARG_EXPAND_TAIL , GLuint index, const GLushort * v
#define forward_glVertexAttribI4usvEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribI4usvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribI4usvEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribI4usvEXT(packed, ret_v) do { \
    glVertexAttribI4usvEXT_PACKED *unpacked = (glVertexAttribI4usvEXT_PACKED *)packed; \
    glVertexAttribI4usvEXT_ARGS *args = (glVertexAttribI4usvEXT_ARGS *)&unpacked->args; \
    glVertexAttribI4usvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4usvEXT(glVertexAttribI4usvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribI4usvEXT(glVertexAttribI4usvEXT_PACKED *_dst glVertexAttribI4usvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribI4usvEXT_PTR)(glVertexAttribI4usvEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribIFormat_RETURN
#define glVertexAttribIFormat_RETURN void
#define glVertexAttribIFormat_ARG_NAMES attribindex, size, type, relativeoffset
#define glVertexAttribIFormat_ARG_EXPAND GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexAttribIFormat_ARG_NAMES_TAIL , attribindex, size, type, relativeoffset
#define glVertexAttribIFormat_ARG_EXPAND_TAIL , GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define forward_glVertexAttribIFormat(_attribindex, _size, _type, _relativeoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribIFormat_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribIFormat(dst, _attribindex, _size, _type, _relativeoffset), NULL); \
    });
#define call_glVertexAttribIFormat(packed, ret_v) do { \
    glVertexAttribIFormat_PACKED *unpacked = (glVertexAttribIFormat_PACKED *)packed; \
    glVertexAttribIFormat_ARGS *args = (glVertexAttribIFormat_ARGS *)&unpacked->args; \
    glVertexAttribIFormat(args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexAttribIFormat(glVertexAttribIFormat_ARG_EXPAND);
packed_call_t *pack_glVertexAttribIFormat(glVertexAttribIFormat_PACKED *_dst glVertexAttribIFormat_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribIFormat_PTR)(glVertexAttribIFormat_ARG_EXPAND);
#endif
#ifndef glVertexAttribIFormatNV_RETURN
#define glVertexAttribIFormatNV_RETURN void
#define glVertexAttribIFormatNV_ARG_NAMES index, size, type, stride
#define glVertexAttribIFormatNV_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride
#define glVertexAttribIFormatNV_ARG_NAMES_TAIL , index, size, type, stride
#define glVertexAttribIFormatNV_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLsizei stride
#define forward_glVertexAttribIFormatNV(_index, _size, _type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribIFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribIFormatNV(dst, _index, _size, _type, _stride), NULL); \
    });
#define call_glVertexAttribIFormatNV(packed, ret_v) do { \
    glVertexAttribIFormatNV_PACKED *unpacked = (glVertexAttribIFormatNV_PACKED *)packed; \
    glVertexAttribIFormatNV_ARGS *args = (glVertexAttribIFormatNV_ARGS *)&unpacked->args; \
    glVertexAttribIFormatNV(args->index, args->size, args->type, args->stride);; \
} while(0)
void glVertexAttribIFormatNV(glVertexAttribIFormatNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribIFormatNV(glVertexAttribIFormatNV_PACKED *_dst glVertexAttribIFormatNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribIFormatNV_PTR)(glVertexAttribIFormatNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribIPointer_RETURN
#define glVertexAttribIPointer_RETURN void
#define glVertexAttribIPointer_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribIPointer_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribIPointer_ARG_NAMES_TAIL , index, size, type, stride, pointer
#define glVertexAttribIPointer_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glVertexAttribIPointer(_index, _size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribIPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribIPointer(dst, _index, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glVertexAttribIPointer(packed, ret_v) do { \
    glVertexAttribIPointer_PACKED *unpacked = (glVertexAttribIPointer_PACKED *)packed; \
    glVertexAttribIPointer_ARGS *args = (glVertexAttribIPointer_ARGS *)&unpacked->args; \
    glVertexAttribIPointer(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribIPointer(glVertexAttribIPointer_ARG_EXPAND);
packed_call_t *pack_glVertexAttribIPointer(glVertexAttribIPointer_PACKED *_dst glVertexAttribIPointer_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribIPointer_PTR)(glVertexAttribIPointer_ARG_EXPAND);
#endif
#ifndef glVertexAttribIPointerEXT_RETURN
#define glVertexAttribIPointerEXT_RETURN void
#define glVertexAttribIPointerEXT_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribIPointerEXT_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribIPointerEXT_ARG_NAMES_TAIL , index, size, type, stride, pointer
#define glVertexAttribIPointerEXT_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glVertexAttribIPointerEXT(_index, _size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribIPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribIPointerEXT(dst, _index, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glVertexAttribIPointerEXT(packed, ret_v) do { \
    glVertexAttribIPointerEXT_PACKED *unpacked = (glVertexAttribIPointerEXT_PACKED *)packed; \
    glVertexAttribIPointerEXT_ARGS *args = (glVertexAttribIPointerEXT_ARGS *)&unpacked->args; \
    glVertexAttribIPointerEXT(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribIPointerEXT(glVertexAttribIPointerEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribIPointerEXT(glVertexAttribIPointerEXT_PACKED *_dst glVertexAttribIPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribIPointerEXT_PTR)(glVertexAttribIPointerEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1d_RETURN
#define glVertexAttribL1d_RETURN void
#define glVertexAttribL1d_ARG_NAMES index, x
#define glVertexAttribL1d_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttribL1d_ARG_NAMES_TAIL , index, x
#define glVertexAttribL1d_ARG_EXPAND_TAIL , GLuint index, GLdouble x
#define forward_glVertexAttribL1d(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1d(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribL1d(packed, ret_v) do { \
    glVertexAttribL1d_PACKED *unpacked = (glVertexAttribL1d_PACKED *)packed; \
    glVertexAttribL1d_ARGS *args = (glVertexAttribL1d_ARGS *)&unpacked->args; \
    glVertexAttribL1d(args->index, args->x);; \
} while(0)
void glVertexAttribL1d(glVertexAttribL1d_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1d(glVertexAttribL1d_PACKED *_dst glVertexAttribL1d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1d_PTR)(glVertexAttribL1d_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1dEXT_RETURN
#define glVertexAttribL1dEXT_RETURN void
#define glVertexAttribL1dEXT_ARG_NAMES index, x
#define glVertexAttribL1dEXT_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttribL1dEXT_ARG_NAMES_TAIL , index, x
#define glVertexAttribL1dEXT_ARG_EXPAND_TAIL , GLuint index, GLdouble x
#define forward_glVertexAttribL1dEXT(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1dEXT(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribL1dEXT(packed, ret_v) do { \
    glVertexAttribL1dEXT_PACKED *unpacked = (glVertexAttribL1dEXT_PACKED *)packed; \
    glVertexAttribL1dEXT_ARGS *args = (glVertexAttribL1dEXT_ARGS *)&unpacked->args; \
    glVertexAttribL1dEXT(args->index, args->x);; \
} while(0)
void glVertexAttribL1dEXT(glVertexAttribL1dEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1dEXT(glVertexAttribL1dEXT_PACKED *_dst glVertexAttribL1dEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1dEXT_PTR)(glVertexAttribL1dEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1dv_RETURN
#define glVertexAttribL1dv_RETURN void
#define glVertexAttribL1dv_ARG_NAMES index, v
#define glVertexAttribL1dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL1dv_ARG_NAMES_TAIL , index, v
#define glVertexAttribL1dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL1dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL1dv(packed, ret_v) do { \
    glVertexAttribL1dv_PACKED *unpacked = (glVertexAttribL1dv_PACKED *)packed; \
    glVertexAttribL1dv_ARGS *args = (glVertexAttribL1dv_ARGS *)&unpacked->args; \
    glVertexAttribL1dv(args->index, args->v);; \
} while(0)
void glVertexAttribL1dv(glVertexAttribL1dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1dv(glVertexAttribL1dv_PACKED *_dst glVertexAttribL1dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1dv_PTR)(glVertexAttribL1dv_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1dvEXT_RETURN
#define glVertexAttribL1dvEXT_RETURN void
#define glVertexAttribL1dvEXT_ARG_NAMES index, v
#define glVertexAttribL1dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL1dvEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribL1dvEXT_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL1dvEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1dvEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL1dvEXT(packed, ret_v) do { \
    glVertexAttribL1dvEXT_PACKED *unpacked = (glVertexAttribL1dvEXT_PACKED *)packed; \
    glVertexAttribL1dvEXT_ARGS *args = (glVertexAttribL1dvEXT_ARGS *)&unpacked->args; \
    glVertexAttribL1dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL1dvEXT(glVertexAttribL1dvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1dvEXT(glVertexAttribL1dvEXT_PACKED *_dst glVertexAttribL1dvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1dvEXT_PTR)(glVertexAttribL1dvEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1i64NV_RETURN
#define glVertexAttribL1i64NV_RETURN void
#define glVertexAttribL1i64NV_ARG_NAMES index, x
#define glVertexAttribL1i64NV_ARG_EXPAND GLuint index, GLint64EXT x
#define glVertexAttribL1i64NV_ARG_NAMES_TAIL , index, x
#define glVertexAttribL1i64NV_ARG_EXPAND_TAIL , GLuint index, GLint64EXT x
#define forward_glVertexAttribL1i64NV(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1i64NV(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribL1i64NV(packed, ret_v) do { \
    glVertexAttribL1i64NV_PACKED *unpacked = (glVertexAttribL1i64NV_PACKED *)packed; \
    glVertexAttribL1i64NV_ARGS *args = (glVertexAttribL1i64NV_ARGS *)&unpacked->args; \
    glVertexAttribL1i64NV(args->index, args->x);; \
} while(0)
void glVertexAttribL1i64NV(glVertexAttribL1i64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1i64NV(glVertexAttribL1i64NV_PACKED *_dst glVertexAttribL1i64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1i64NV_PTR)(glVertexAttribL1i64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1i64vNV_RETURN
#define glVertexAttribL1i64vNV_RETURN void
#define glVertexAttribL1i64vNV_ARG_NAMES index, v
#define glVertexAttribL1i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL1i64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL1i64vNV_ARG_EXPAND_TAIL , GLuint index, const GLint64EXT * v
#define forward_glVertexAttribL1i64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1i64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL1i64vNV(packed, ret_v) do { \
    glVertexAttribL1i64vNV_PACKED *unpacked = (glVertexAttribL1i64vNV_PACKED *)packed; \
    glVertexAttribL1i64vNV_ARGS *args = (glVertexAttribL1i64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL1i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL1i64vNV(glVertexAttribL1i64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1i64vNV(glVertexAttribL1i64vNV_PACKED *_dst glVertexAttribL1i64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1i64vNV_PTR)(glVertexAttribL1i64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1ui64NV_RETURN
#define glVertexAttribL1ui64NV_RETURN void
#define glVertexAttribL1ui64NV_ARG_NAMES index, x
#define glVertexAttribL1ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x
#define glVertexAttribL1ui64NV_ARG_NAMES_TAIL , index, x
#define glVertexAttribL1ui64NV_ARG_EXPAND_TAIL , GLuint index, GLuint64EXT x
#define forward_glVertexAttribL1ui64NV(_index, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1ui64NV(dst, _index, _x), NULL); \
    });
#define call_glVertexAttribL1ui64NV(packed, ret_v) do { \
    glVertexAttribL1ui64NV_PACKED *unpacked = (glVertexAttribL1ui64NV_PACKED *)packed; \
    glVertexAttribL1ui64NV_ARGS *args = (glVertexAttribL1ui64NV_ARGS *)&unpacked->args; \
    glVertexAttribL1ui64NV(args->index, args->x);; \
} while(0)
void glVertexAttribL1ui64NV(glVertexAttribL1ui64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1ui64NV(glVertexAttribL1ui64NV_PACKED *_dst glVertexAttribL1ui64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1ui64NV_PTR)(glVertexAttribL1ui64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL1ui64vNV_RETURN
#define glVertexAttribL1ui64vNV_RETURN void
#define glVertexAttribL1ui64vNV_ARG_NAMES index, v
#define glVertexAttribL1ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL1ui64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL1ui64vNV_ARG_EXPAND_TAIL , GLuint index, const GLuint64EXT * v
#define forward_glVertexAttribL1ui64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL1ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL1ui64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL1ui64vNV(packed, ret_v) do { \
    glVertexAttribL1ui64vNV_PACKED *unpacked = (glVertexAttribL1ui64vNV_PACKED *)packed; \
    glVertexAttribL1ui64vNV_ARGS *args = (glVertexAttribL1ui64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL1ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL1ui64vNV(glVertexAttribL1ui64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL1ui64vNV(glVertexAttribL1ui64vNV_PACKED *_dst glVertexAttribL1ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL1ui64vNV_PTR)(glVertexAttribL1ui64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2d_RETURN
#define glVertexAttribL2d_RETURN void
#define glVertexAttribL2d_ARG_NAMES index, x, y
#define glVertexAttribL2d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttribL2d_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribL2d_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y
#define forward_glVertexAttribL2d(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2d(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribL2d(packed, ret_v) do { \
    glVertexAttribL2d_PACKED *unpacked = (glVertexAttribL2d_PACKED *)packed; \
    glVertexAttribL2d_ARGS *args = (glVertexAttribL2d_ARGS *)&unpacked->args; \
    glVertexAttribL2d(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2d(glVertexAttribL2d_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2d(glVertexAttribL2d_PACKED *_dst glVertexAttribL2d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2d_PTR)(glVertexAttribL2d_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2dEXT_RETURN
#define glVertexAttribL2dEXT_RETURN void
#define glVertexAttribL2dEXT_ARG_NAMES index, x, y
#define glVertexAttribL2dEXT_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttribL2dEXT_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribL2dEXT_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y
#define forward_glVertexAttribL2dEXT(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2dEXT(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribL2dEXT(packed, ret_v) do { \
    glVertexAttribL2dEXT_PACKED *unpacked = (glVertexAttribL2dEXT_PACKED *)packed; \
    glVertexAttribL2dEXT_ARGS *args = (glVertexAttribL2dEXT_ARGS *)&unpacked->args; \
    glVertexAttribL2dEXT(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2dEXT(glVertexAttribL2dEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2dEXT(glVertexAttribL2dEXT_PACKED *_dst glVertexAttribL2dEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2dEXT_PTR)(glVertexAttribL2dEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2dv_RETURN
#define glVertexAttribL2dv_RETURN void
#define glVertexAttribL2dv_ARG_NAMES index, v
#define glVertexAttribL2dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL2dv_ARG_NAMES_TAIL , index, v
#define glVertexAttribL2dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL2dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL2dv(packed, ret_v) do { \
    glVertexAttribL2dv_PACKED *unpacked = (glVertexAttribL2dv_PACKED *)packed; \
    glVertexAttribL2dv_ARGS *args = (glVertexAttribL2dv_ARGS *)&unpacked->args; \
    glVertexAttribL2dv(args->index, args->v);; \
} while(0)
void glVertexAttribL2dv(glVertexAttribL2dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2dv(glVertexAttribL2dv_PACKED *_dst glVertexAttribL2dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2dv_PTR)(glVertexAttribL2dv_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2dvEXT_RETURN
#define glVertexAttribL2dvEXT_RETURN void
#define glVertexAttribL2dvEXT_ARG_NAMES index, v
#define glVertexAttribL2dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL2dvEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribL2dvEXT_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL2dvEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2dvEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL2dvEXT(packed, ret_v) do { \
    glVertexAttribL2dvEXT_PACKED *unpacked = (glVertexAttribL2dvEXT_PACKED *)packed; \
    glVertexAttribL2dvEXT_ARGS *args = (glVertexAttribL2dvEXT_ARGS *)&unpacked->args; \
    glVertexAttribL2dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL2dvEXT(glVertexAttribL2dvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2dvEXT(glVertexAttribL2dvEXT_PACKED *_dst glVertexAttribL2dvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2dvEXT_PTR)(glVertexAttribL2dvEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2i64NV_RETURN
#define glVertexAttribL2i64NV_RETURN void
#define glVertexAttribL2i64NV_ARG_NAMES index, x, y
#define glVertexAttribL2i64NV_ARG_EXPAND GLuint index, GLint64EXT x, GLint64EXT y
#define glVertexAttribL2i64NV_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribL2i64NV_ARG_EXPAND_TAIL , GLuint index, GLint64EXT x, GLint64EXT y
#define forward_glVertexAttribL2i64NV(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2i64NV(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribL2i64NV(packed, ret_v) do { \
    glVertexAttribL2i64NV_PACKED *unpacked = (glVertexAttribL2i64NV_PACKED *)packed; \
    glVertexAttribL2i64NV_ARGS *args = (glVertexAttribL2i64NV_ARGS *)&unpacked->args; \
    glVertexAttribL2i64NV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2i64NV(glVertexAttribL2i64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2i64NV(glVertexAttribL2i64NV_PACKED *_dst glVertexAttribL2i64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2i64NV_PTR)(glVertexAttribL2i64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2i64vNV_RETURN
#define glVertexAttribL2i64vNV_RETURN void
#define glVertexAttribL2i64vNV_ARG_NAMES index, v
#define glVertexAttribL2i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL2i64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL2i64vNV_ARG_EXPAND_TAIL , GLuint index, const GLint64EXT * v
#define forward_glVertexAttribL2i64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2i64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL2i64vNV(packed, ret_v) do { \
    glVertexAttribL2i64vNV_PACKED *unpacked = (glVertexAttribL2i64vNV_PACKED *)packed; \
    glVertexAttribL2i64vNV_ARGS *args = (glVertexAttribL2i64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL2i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL2i64vNV(glVertexAttribL2i64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2i64vNV(glVertexAttribL2i64vNV_PACKED *_dst glVertexAttribL2i64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2i64vNV_PTR)(glVertexAttribL2i64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2ui64NV_RETURN
#define glVertexAttribL2ui64NV_RETURN void
#define glVertexAttribL2ui64NV_ARG_NAMES index, x, y
#define glVertexAttribL2ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x, GLuint64EXT y
#define glVertexAttribL2ui64NV_ARG_NAMES_TAIL , index, x, y
#define glVertexAttribL2ui64NV_ARG_EXPAND_TAIL , GLuint index, GLuint64EXT x, GLuint64EXT y
#define forward_glVertexAttribL2ui64NV(_index, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2ui64NV(dst, _index, _x, _y), NULL); \
    });
#define call_glVertexAttribL2ui64NV(packed, ret_v) do { \
    glVertexAttribL2ui64NV_PACKED *unpacked = (glVertexAttribL2ui64NV_PACKED *)packed; \
    glVertexAttribL2ui64NV_ARGS *args = (glVertexAttribL2ui64NV_ARGS *)&unpacked->args; \
    glVertexAttribL2ui64NV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2ui64NV(glVertexAttribL2ui64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2ui64NV(glVertexAttribL2ui64NV_PACKED *_dst glVertexAttribL2ui64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2ui64NV_PTR)(glVertexAttribL2ui64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL2ui64vNV_RETURN
#define glVertexAttribL2ui64vNV_RETURN void
#define glVertexAttribL2ui64vNV_ARG_NAMES index, v
#define glVertexAttribL2ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL2ui64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL2ui64vNV_ARG_EXPAND_TAIL , GLuint index, const GLuint64EXT * v
#define forward_glVertexAttribL2ui64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL2ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL2ui64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL2ui64vNV(packed, ret_v) do { \
    glVertexAttribL2ui64vNV_PACKED *unpacked = (glVertexAttribL2ui64vNV_PACKED *)packed; \
    glVertexAttribL2ui64vNV_ARGS *args = (glVertexAttribL2ui64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL2ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL2ui64vNV(glVertexAttribL2ui64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL2ui64vNV(glVertexAttribL2ui64vNV_PACKED *_dst glVertexAttribL2ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL2ui64vNV_PTR)(glVertexAttribL2ui64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3d_RETURN
#define glVertexAttribL3d_RETURN void
#define glVertexAttribL3d_ARG_NAMES index, x, y, z
#define glVertexAttribL3d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttribL3d_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribL3d_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z
#define forward_glVertexAttribL3d(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3d(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribL3d(packed, ret_v) do { \
    glVertexAttribL3d_PACKED *unpacked = (glVertexAttribL3d_PACKED *)packed; \
    glVertexAttribL3d_ARGS *args = (glVertexAttribL3d_ARGS *)&unpacked->args; \
    glVertexAttribL3d(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3d(glVertexAttribL3d_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3d(glVertexAttribL3d_PACKED *_dst glVertexAttribL3d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3d_PTR)(glVertexAttribL3d_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3dEXT_RETURN
#define glVertexAttribL3dEXT_RETURN void
#define glVertexAttribL3dEXT_ARG_NAMES index, x, y, z
#define glVertexAttribL3dEXT_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttribL3dEXT_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribL3dEXT_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z
#define forward_glVertexAttribL3dEXT(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3dEXT(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribL3dEXT(packed, ret_v) do { \
    glVertexAttribL3dEXT_PACKED *unpacked = (glVertexAttribL3dEXT_PACKED *)packed; \
    glVertexAttribL3dEXT_ARGS *args = (glVertexAttribL3dEXT_ARGS *)&unpacked->args; \
    glVertexAttribL3dEXT(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3dEXT(glVertexAttribL3dEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3dEXT(glVertexAttribL3dEXT_PACKED *_dst glVertexAttribL3dEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3dEXT_PTR)(glVertexAttribL3dEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3dv_RETURN
#define glVertexAttribL3dv_RETURN void
#define glVertexAttribL3dv_ARG_NAMES index, v
#define glVertexAttribL3dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL3dv_ARG_NAMES_TAIL , index, v
#define glVertexAttribL3dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL3dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL3dv(packed, ret_v) do { \
    glVertexAttribL3dv_PACKED *unpacked = (glVertexAttribL3dv_PACKED *)packed; \
    glVertexAttribL3dv_ARGS *args = (glVertexAttribL3dv_ARGS *)&unpacked->args; \
    glVertexAttribL3dv(args->index, args->v);; \
} while(0)
void glVertexAttribL3dv(glVertexAttribL3dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3dv(glVertexAttribL3dv_PACKED *_dst glVertexAttribL3dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3dv_PTR)(glVertexAttribL3dv_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3dvEXT_RETURN
#define glVertexAttribL3dvEXT_RETURN void
#define glVertexAttribL3dvEXT_ARG_NAMES index, v
#define glVertexAttribL3dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL3dvEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribL3dvEXT_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL3dvEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3dvEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL3dvEXT(packed, ret_v) do { \
    glVertexAttribL3dvEXT_PACKED *unpacked = (glVertexAttribL3dvEXT_PACKED *)packed; \
    glVertexAttribL3dvEXT_ARGS *args = (glVertexAttribL3dvEXT_ARGS *)&unpacked->args; \
    glVertexAttribL3dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL3dvEXT(glVertexAttribL3dvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3dvEXT(glVertexAttribL3dvEXT_PACKED *_dst glVertexAttribL3dvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3dvEXT_PTR)(glVertexAttribL3dvEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3i64NV_RETURN
#define glVertexAttribL3i64NV_RETURN void
#define glVertexAttribL3i64NV_ARG_NAMES index, x, y, z
#define glVertexAttribL3i64NV_ARG_EXPAND GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define glVertexAttribL3i64NV_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribL3i64NV_ARG_EXPAND_TAIL , GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define forward_glVertexAttribL3i64NV(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3i64NV(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribL3i64NV(packed, ret_v) do { \
    glVertexAttribL3i64NV_PACKED *unpacked = (glVertexAttribL3i64NV_PACKED *)packed; \
    glVertexAttribL3i64NV_ARGS *args = (glVertexAttribL3i64NV_ARGS *)&unpacked->args; \
    glVertexAttribL3i64NV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3i64NV(glVertexAttribL3i64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3i64NV(glVertexAttribL3i64NV_PACKED *_dst glVertexAttribL3i64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3i64NV_PTR)(glVertexAttribL3i64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3i64vNV_RETURN
#define glVertexAttribL3i64vNV_RETURN void
#define glVertexAttribL3i64vNV_ARG_NAMES index, v
#define glVertexAttribL3i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL3i64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL3i64vNV_ARG_EXPAND_TAIL , GLuint index, const GLint64EXT * v
#define forward_glVertexAttribL3i64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3i64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL3i64vNV(packed, ret_v) do { \
    glVertexAttribL3i64vNV_PACKED *unpacked = (glVertexAttribL3i64vNV_PACKED *)packed; \
    glVertexAttribL3i64vNV_ARGS *args = (glVertexAttribL3i64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL3i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL3i64vNV(glVertexAttribL3i64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3i64vNV(glVertexAttribL3i64vNV_PACKED *_dst glVertexAttribL3i64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3i64vNV_PTR)(glVertexAttribL3i64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3ui64NV_RETURN
#define glVertexAttribL3ui64NV_RETURN void
#define glVertexAttribL3ui64NV_ARG_NAMES index, x, y, z
#define glVertexAttribL3ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define glVertexAttribL3ui64NV_ARG_NAMES_TAIL , index, x, y, z
#define glVertexAttribL3ui64NV_ARG_EXPAND_TAIL , GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define forward_glVertexAttribL3ui64NV(_index, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3ui64NV(dst, _index, _x, _y, _z), NULL); \
    });
#define call_glVertexAttribL3ui64NV(packed, ret_v) do { \
    glVertexAttribL3ui64NV_PACKED *unpacked = (glVertexAttribL3ui64NV_PACKED *)packed; \
    glVertexAttribL3ui64NV_ARGS *args = (glVertexAttribL3ui64NV_ARGS *)&unpacked->args; \
    glVertexAttribL3ui64NV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3ui64NV(glVertexAttribL3ui64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3ui64NV(glVertexAttribL3ui64NV_PACKED *_dst glVertexAttribL3ui64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3ui64NV_PTR)(glVertexAttribL3ui64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL3ui64vNV_RETURN
#define glVertexAttribL3ui64vNV_RETURN void
#define glVertexAttribL3ui64vNV_ARG_NAMES index, v
#define glVertexAttribL3ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL3ui64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL3ui64vNV_ARG_EXPAND_TAIL , GLuint index, const GLuint64EXT * v
#define forward_glVertexAttribL3ui64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL3ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL3ui64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL3ui64vNV(packed, ret_v) do { \
    glVertexAttribL3ui64vNV_PACKED *unpacked = (glVertexAttribL3ui64vNV_PACKED *)packed; \
    glVertexAttribL3ui64vNV_ARGS *args = (glVertexAttribL3ui64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL3ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL3ui64vNV(glVertexAttribL3ui64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL3ui64vNV(glVertexAttribL3ui64vNV_PACKED *_dst glVertexAttribL3ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL3ui64vNV_PTR)(glVertexAttribL3ui64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4d_RETURN
#define glVertexAttribL4d_RETURN void
#define glVertexAttribL4d_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttribL4d_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribL4d_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glVertexAttribL4d(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4d(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribL4d(packed, ret_v) do { \
    glVertexAttribL4d_PACKED *unpacked = (glVertexAttribL4d_PACKED *)packed; \
    glVertexAttribL4d_ARGS *args = (glVertexAttribL4d_ARGS *)&unpacked->args; \
    glVertexAttribL4d(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4d(glVertexAttribL4d_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4d(glVertexAttribL4d_PACKED *_dst glVertexAttribL4d_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4d_PTR)(glVertexAttribL4d_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4dEXT_RETURN
#define glVertexAttribL4dEXT_RETURN void
#define glVertexAttribL4dEXT_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4dEXT_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttribL4dEXT_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribL4dEXT_ARG_EXPAND_TAIL , GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glVertexAttribL4dEXT(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4dEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4dEXT(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribL4dEXT(packed, ret_v) do { \
    glVertexAttribL4dEXT_PACKED *unpacked = (glVertexAttribL4dEXT_PACKED *)packed; \
    glVertexAttribL4dEXT_ARGS *args = (glVertexAttribL4dEXT_ARGS *)&unpacked->args; \
    glVertexAttribL4dEXT(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4dEXT(glVertexAttribL4dEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4dEXT(glVertexAttribL4dEXT_PACKED *_dst glVertexAttribL4dEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4dEXT_PTR)(glVertexAttribL4dEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4dv_RETURN
#define glVertexAttribL4dv_RETURN void
#define glVertexAttribL4dv_ARG_NAMES index, v
#define glVertexAttribL4dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL4dv_ARG_NAMES_TAIL , index, v
#define glVertexAttribL4dv_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL4dv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4dv(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL4dv(packed, ret_v) do { \
    glVertexAttribL4dv_PACKED *unpacked = (glVertexAttribL4dv_PACKED *)packed; \
    glVertexAttribL4dv_ARGS *args = (glVertexAttribL4dv_ARGS *)&unpacked->args; \
    glVertexAttribL4dv(args->index, args->v);; \
} while(0)
void glVertexAttribL4dv(glVertexAttribL4dv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4dv(glVertexAttribL4dv_PACKED *_dst glVertexAttribL4dv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4dv_PTR)(glVertexAttribL4dv_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4dvEXT_RETURN
#define glVertexAttribL4dvEXT_RETURN void
#define glVertexAttribL4dvEXT_ARG_NAMES index, v
#define glVertexAttribL4dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL4dvEXT_ARG_NAMES_TAIL , index, v
#define glVertexAttribL4dvEXT_ARG_EXPAND_TAIL , GLuint index, const GLdouble * v
#define forward_glVertexAttribL4dvEXT(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4dvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4dvEXT(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL4dvEXT(packed, ret_v) do { \
    glVertexAttribL4dvEXT_PACKED *unpacked = (glVertexAttribL4dvEXT_PACKED *)packed; \
    glVertexAttribL4dvEXT_ARGS *args = (glVertexAttribL4dvEXT_ARGS *)&unpacked->args; \
    glVertexAttribL4dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL4dvEXT(glVertexAttribL4dvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4dvEXT(glVertexAttribL4dvEXT_PACKED *_dst glVertexAttribL4dvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4dvEXT_PTR)(glVertexAttribL4dvEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4i64NV_RETURN
#define glVertexAttribL4i64NV_RETURN void
#define glVertexAttribL4i64NV_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4i64NV_ARG_EXPAND GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define glVertexAttribL4i64NV_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribL4i64NV_ARG_EXPAND_TAIL , GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define forward_glVertexAttribL4i64NV(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4i64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4i64NV(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribL4i64NV(packed, ret_v) do { \
    glVertexAttribL4i64NV_PACKED *unpacked = (glVertexAttribL4i64NV_PACKED *)packed; \
    glVertexAttribL4i64NV_ARGS *args = (glVertexAttribL4i64NV_ARGS *)&unpacked->args; \
    glVertexAttribL4i64NV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4i64NV(glVertexAttribL4i64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4i64NV(glVertexAttribL4i64NV_PACKED *_dst glVertexAttribL4i64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4i64NV_PTR)(glVertexAttribL4i64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4i64vNV_RETURN
#define glVertexAttribL4i64vNV_RETURN void
#define glVertexAttribL4i64vNV_ARG_NAMES index, v
#define glVertexAttribL4i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL4i64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL4i64vNV_ARG_EXPAND_TAIL , GLuint index, const GLint64EXT * v
#define forward_glVertexAttribL4i64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4i64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4i64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL4i64vNV(packed, ret_v) do { \
    glVertexAttribL4i64vNV_PACKED *unpacked = (glVertexAttribL4i64vNV_PACKED *)packed; \
    glVertexAttribL4i64vNV_ARGS *args = (glVertexAttribL4i64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL4i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL4i64vNV(glVertexAttribL4i64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4i64vNV(glVertexAttribL4i64vNV_PACKED *_dst glVertexAttribL4i64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4i64vNV_PTR)(glVertexAttribL4i64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4ui64NV_RETURN
#define glVertexAttribL4ui64NV_RETURN void
#define glVertexAttribL4ui64NV_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define glVertexAttribL4ui64NV_ARG_NAMES_TAIL , index, x, y, z, w
#define glVertexAttribL4ui64NV_ARG_EXPAND_TAIL , GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define forward_glVertexAttribL4ui64NV(_index, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4ui64NV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4ui64NV(dst, _index, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexAttribL4ui64NV(packed, ret_v) do { \
    glVertexAttribL4ui64NV_PACKED *unpacked = (glVertexAttribL4ui64NV_PACKED *)packed; \
    glVertexAttribL4ui64NV_ARGS *args = (glVertexAttribL4ui64NV_ARGS *)&unpacked->args; \
    glVertexAttribL4ui64NV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4ui64NV(glVertexAttribL4ui64NV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4ui64NV(glVertexAttribL4ui64NV_PACKED *_dst glVertexAttribL4ui64NV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4ui64NV_PTR)(glVertexAttribL4ui64NV_ARG_EXPAND);
#endif
#ifndef glVertexAttribL4ui64vNV_RETURN
#define glVertexAttribL4ui64vNV_RETURN void
#define glVertexAttribL4ui64vNV_ARG_NAMES index, v
#define glVertexAttribL4ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL4ui64vNV_ARG_NAMES_TAIL , index, v
#define glVertexAttribL4ui64vNV_ARG_EXPAND_TAIL , GLuint index, const GLuint64EXT * v
#define forward_glVertexAttribL4ui64vNV(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribL4ui64vNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribL4ui64vNV(dst, _index, _v), NULL); \
    });
#define call_glVertexAttribL4ui64vNV(packed, ret_v) do { \
    glVertexAttribL4ui64vNV_PACKED *unpacked = (glVertexAttribL4ui64vNV_PACKED *)packed; \
    glVertexAttribL4ui64vNV_ARGS *args = (glVertexAttribL4ui64vNV_ARGS *)&unpacked->args; \
    glVertexAttribL4ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL4ui64vNV(glVertexAttribL4ui64vNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribL4ui64vNV(glVertexAttribL4ui64vNV_PACKED *_dst glVertexAttribL4ui64vNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribL4ui64vNV_PTR)(glVertexAttribL4ui64vNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribLFormat_RETURN
#define glVertexAttribLFormat_RETURN void
#define glVertexAttribLFormat_ARG_NAMES attribindex, size, type, relativeoffset
#define glVertexAttribLFormat_ARG_EXPAND GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexAttribLFormat_ARG_NAMES_TAIL , attribindex, size, type, relativeoffset
#define glVertexAttribLFormat_ARG_EXPAND_TAIL , GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define forward_glVertexAttribLFormat(_attribindex, _size, _type, _relativeoffset) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribLFormat_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribLFormat(dst, _attribindex, _size, _type, _relativeoffset), NULL); \
    });
#define call_glVertexAttribLFormat(packed, ret_v) do { \
    glVertexAttribLFormat_PACKED *unpacked = (glVertexAttribLFormat_PACKED *)packed; \
    glVertexAttribLFormat_ARGS *args = (glVertexAttribLFormat_ARGS *)&unpacked->args; \
    glVertexAttribLFormat(args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexAttribLFormat(glVertexAttribLFormat_ARG_EXPAND);
packed_call_t *pack_glVertexAttribLFormat(glVertexAttribLFormat_PACKED *_dst glVertexAttribLFormat_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribLFormat_PTR)(glVertexAttribLFormat_ARG_EXPAND);
#endif
#ifndef glVertexAttribLFormatNV_RETURN
#define glVertexAttribLFormatNV_RETURN void
#define glVertexAttribLFormatNV_ARG_NAMES index, size, type, stride
#define glVertexAttribLFormatNV_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride
#define glVertexAttribLFormatNV_ARG_NAMES_TAIL , index, size, type, stride
#define glVertexAttribLFormatNV_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLsizei stride
#define forward_glVertexAttribLFormatNV(_index, _size, _type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribLFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribLFormatNV(dst, _index, _size, _type, _stride), NULL); \
    });
#define call_glVertexAttribLFormatNV(packed, ret_v) do { \
    glVertexAttribLFormatNV_PACKED *unpacked = (glVertexAttribLFormatNV_PACKED *)packed; \
    glVertexAttribLFormatNV_ARGS *args = (glVertexAttribLFormatNV_ARGS *)&unpacked->args; \
    glVertexAttribLFormatNV(args->index, args->size, args->type, args->stride);; \
} while(0)
void glVertexAttribLFormatNV(glVertexAttribLFormatNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribLFormatNV(glVertexAttribLFormatNV_PACKED *_dst glVertexAttribLFormatNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribLFormatNV_PTR)(glVertexAttribLFormatNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribLPointer_RETURN
#define glVertexAttribLPointer_RETURN void
#define glVertexAttribLPointer_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribLPointer_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribLPointer_ARG_NAMES_TAIL , index, size, type, stride, pointer
#define glVertexAttribLPointer_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glVertexAttribLPointer(_index, _size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribLPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribLPointer(dst, _index, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glVertexAttribLPointer(packed, ret_v) do { \
    glVertexAttribLPointer_PACKED *unpacked = (glVertexAttribLPointer_PACKED *)packed; \
    glVertexAttribLPointer_ARGS *args = (glVertexAttribLPointer_ARGS *)&unpacked->args; \
    glVertexAttribLPointer(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribLPointer(glVertexAttribLPointer_ARG_EXPAND);
packed_call_t *pack_glVertexAttribLPointer(glVertexAttribLPointer_PACKED *_dst glVertexAttribLPointer_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribLPointer_PTR)(glVertexAttribLPointer_ARG_EXPAND);
#endif
#ifndef glVertexAttribLPointerEXT_RETURN
#define glVertexAttribLPointerEXT_RETURN void
#define glVertexAttribLPointerEXT_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribLPointerEXT_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribLPointerEXT_ARG_NAMES_TAIL , index, size, type, stride, pointer
#define glVertexAttribLPointerEXT_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glVertexAttribLPointerEXT(_index, _size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribLPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribLPointerEXT(dst, _index, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glVertexAttribLPointerEXT(packed, ret_v) do { \
    glVertexAttribLPointerEXT_PACKED *unpacked = (glVertexAttribLPointerEXT_PACKED *)packed; \
    glVertexAttribLPointerEXT_ARGS *args = (glVertexAttribLPointerEXT_ARGS *)&unpacked->args; \
    glVertexAttribLPointerEXT(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribLPointerEXT(glVertexAttribLPointerEXT_ARG_EXPAND);
packed_call_t *pack_glVertexAttribLPointerEXT(glVertexAttribLPointerEXT_PACKED *_dst glVertexAttribLPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribLPointerEXT_PTR)(glVertexAttribLPointerEXT_ARG_EXPAND);
#endif
#ifndef glVertexAttribP1ui_RETURN
#define glVertexAttribP1ui_RETURN void
#define glVertexAttribP1ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP1ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP1ui_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP1ui_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, GLuint value
#define forward_glVertexAttribP1ui(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP1ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP1ui(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP1ui(packed, ret_v) do { \
    glVertexAttribP1ui_PACKED *unpacked = (glVertexAttribP1ui_PACKED *)packed; \
    glVertexAttribP1ui_ARGS *args = (glVertexAttribP1ui_ARGS *)&unpacked->args; \
    glVertexAttribP1ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP1ui(glVertexAttribP1ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP1ui(glVertexAttribP1ui_PACKED *_dst glVertexAttribP1ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP1ui_PTR)(glVertexAttribP1ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribP1uiv_RETURN
#define glVertexAttribP1uiv_RETURN void
#define glVertexAttribP1uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP1uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP1uiv_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP1uiv_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define forward_glVertexAttribP1uiv(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP1uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP1uiv(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP1uiv(packed, ret_v) do { \
    glVertexAttribP1uiv_PACKED *unpacked = (glVertexAttribP1uiv_PACKED *)packed; \
    glVertexAttribP1uiv_ARGS *args = (glVertexAttribP1uiv_ARGS *)&unpacked->args; \
    glVertexAttribP1uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP1uiv(glVertexAttribP1uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP1uiv(glVertexAttribP1uiv_PACKED *_dst glVertexAttribP1uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP1uiv_PTR)(glVertexAttribP1uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribP2ui_RETURN
#define glVertexAttribP2ui_RETURN void
#define glVertexAttribP2ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP2ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP2ui_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP2ui_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, GLuint value
#define forward_glVertexAttribP2ui(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP2ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP2ui(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP2ui(packed, ret_v) do { \
    glVertexAttribP2ui_PACKED *unpacked = (glVertexAttribP2ui_PACKED *)packed; \
    glVertexAttribP2ui_ARGS *args = (glVertexAttribP2ui_ARGS *)&unpacked->args; \
    glVertexAttribP2ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP2ui(glVertexAttribP2ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP2ui(glVertexAttribP2ui_PACKED *_dst glVertexAttribP2ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP2ui_PTR)(glVertexAttribP2ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribP2uiv_RETURN
#define glVertexAttribP2uiv_RETURN void
#define glVertexAttribP2uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP2uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP2uiv_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP2uiv_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define forward_glVertexAttribP2uiv(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP2uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP2uiv(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP2uiv(packed, ret_v) do { \
    glVertexAttribP2uiv_PACKED *unpacked = (glVertexAttribP2uiv_PACKED *)packed; \
    glVertexAttribP2uiv_ARGS *args = (glVertexAttribP2uiv_ARGS *)&unpacked->args; \
    glVertexAttribP2uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP2uiv(glVertexAttribP2uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP2uiv(glVertexAttribP2uiv_PACKED *_dst glVertexAttribP2uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP2uiv_PTR)(glVertexAttribP2uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribP3ui_RETURN
#define glVertexAttribP3ui_RETURN void
#define glVertexAttribP3ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP3ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP3ui_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP3ui_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, GLuint value
#define forward_glVertexAttribP3ui(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP3ui(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP3ui(packed, ret_v) do { \
    glVertexAttribP3ui_PACKED *unpacked = (glVertexAttribP3ui_PACKED *)packed; \
    glVertexAttribP3ui_ARGS *args = (glVertexAttribP3ui_ARGS *)&unpacked->args; \
    glVertexAttribP3ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP3ui(glVertexAttribP3ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP3ui(glVertexAttribP3ui_PACKED *_dst glVertexAttribP3ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP3ui_PTR)(glVertexAttribP3ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribP3uiv_RETURN
#define glVertexAttribP3uiv_RETURN void
#define glVertexAttribP3uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP3uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP3uiv_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP3uiv_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define forward_glVertexAttribP3uiv(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP3uiv(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP3uiv(packed, ret_v) do { \
    glVertexAttribP3uiv_PACKED *unpacked = (glVertexAttribP3uiv_PACKED *)packed; \
    glVertexAttribP3uiv_ARGS *args = (glVertexAttribP3uiv_ARGS *)&unpacked->args; \
    glVertexAttribP3uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP3uiv(glVertexAttribP3uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP3uiv(glVertexAttribP3uiv_PACKED *_dst glVertexAttribP3uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP3uiv_PTR)(glVertexAttribP3uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribP4ui_RETURN
#define glVertexAttribP4ui_RETURN void
#define glVertexAttribP4ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP4ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP4ui_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP4ui_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, GLuint value
#define forward_glVertexAttribP4ui(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP4ui(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP4ui(packed, ret_v) do { \
    glVertexAttribP4ui_PACKED *unpacked = (glVertexAttribP4ui_PACKED *)packed; \
    glVertexAttribP4ui_ARGS *args = (glVertexAttribP4ui_ARGS *)&unpacked->args; \
    glVertexAttribP4ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP4ui(glVertexAttribP4ui_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP4ui(glVertexAttribP4ui_PACKED *_dst glVertexAttribP4ui_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP4ui_PTR)(glVertexAttribP4ui_ARG_EXPAND);
#endif
#ifndef glVertexAttribP4uiv_RETURN
#define glVertexAttribP4uiv_RETURN void
#define glVertexAttribP4uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP4uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP4uiv_ARG_NAMES_TAIL , index, type, normalized, value
#define glVertexAttribP4uiv_ARG_EXPAND_TAIL , GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define forward_glVertexAttribP4uiv(_index, _type, _normalized, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribP4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribP4uiv(dst, _index, _type, _normalized, _value), NULL); \
    });
#define call_glVertexAttribP4uiv(packed, ret_v) do { \
    glVertexAttribP4uiv_PACKED *unpacked = (glVertexAttribP4uiv_PACKED *)packed; \
    glVertexAttribP4uiv_ARGS *args = (glVertexAttribP4uiv_ARGS *)&unpacked->args; \
    glVertexAttribP4uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP4uiv(glVertexAttribP4uiv_ARG_EXPAND);
packed_call_t *pack_glVertexAttribP4uiv(glVertexAttribP4uiv_PACKED *_dst glVertexAttribP4uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribP4uiv_PTR)(glVertexAttribP4uiv_ARG_EXPAND);
#endif
#ifndef glVertexAttribPointer_RETURN
#define glVertexAttribPointer_RETURN void
#define glVertexAttribPointer_ARG_NAMES index, size, type, normalized, stride, pointer
#define glVertexAttribPointer_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer
#define glVertexAttribPointer_ARG_NAMES_TAIL , index, size, type, normalized, stride, pointer
#define glVertexAttribPointer_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer
#define forward_glVertexAttribPointer(_index, _size, _type, _normalized, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribPointer(dst, _index, _size, _type, _normalized, _stride, _pointer), NULL); \
    });
#define call_glVertexAttribPointer(packed, ret_v) do { \
    glVertexAttribPointer_PACKED *unpacked = (glVertexAttribPointer_PACKED *)packed; \
    glVertexAttribPointer_ARGS *args = (glVertexAttribPointer_ARGS *)&unpacked->args; \
    glVertexAttribPointer(args->index, args->size, args->type, args->normalized, args->stride, args->pointer);; \
} while(0)
void glVertexAttribPointer(glVertexAttribPointer_ARG_EXPAND);
packed_call_t *pack_glVertexAttribPointer(glVertexAttribPointer_PACKED *_dst glVertexAttribPointer_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribPointer_PTR)(glVertexAttribPointer_ARG_EXPAND);
#endif
#ifndef glVertexAttribPointerARB_RETURN
#define glVertexAttribPointerARB_RETURN void
#define glVertexAttribPointerARB_ARG_NAMES index, size, type, normalized, stride, pointer
#define glVertexAttribPointerARB_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer
#define glVertexAttribPointerARB_ARG_NAMES_TAIL , index, size, type, normalized, stride, pointer
#define glVertexAttribPointerARB_ARG_EXPAND_TAIL , GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer
#define forward_glVertexAttribPointerARB(_index, _size, _type, _normalized, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribPointerARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribPointerARB(dst, _index, _size, _type, _normalized, _stride, _pointer), NULL); \
    });
#define call_glVertexAttribPointerARB(packed, ret_v) do { \
    glVertexAttribPointerARB_PACKED *unpacked = (glVertexAttribPointerARB_PACKED *)packed; \
    glVertexAttribPointerARB_ARGS *args = (glVertexAttribPointerARB_ARGS *)&unpacked->args; \
    glVertexAttribPointerARB(args->index, args->size, args->type, args->normalized, args->stride, args->pointer);; \
} while(0)
void glVertexAttribPointerARB(glVertexAttribPointerARB_ARG_EXPAND);
packed_call_t *pack_glVertexAttribPointerARB(glVertexAttribPointerARB_PACKED *_dst glVertexAttribPointerARB_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribPointerARB_PTR)(glVertexAttribPointerARB_ARG_EXPAND);
#endif
#ifndef glVertexAttribPointerNV_RETURN
#define glVertexAttribPointerNV_RETURN void
#define glVertexAttribPointerNV_ARG_NAMES index, fsize, type, stride, pointer
#define glVertexAttribPointerNV_ARG_EXPAND GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribPointerNV_ARG_NAMES_TAIL , index, fsize, type, stride, pointer
#define glVertexAttribPointerNV_ARG_EXPAND_TAIL , GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glVertexAttribPointerNV(_index, _fsize, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribPointerNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribPointerNV(dst, _index, _fsize, _type, _stride, _pointer), NULL); \
    });
#define call_glVertexAttribPointerNV(packed, ret_v) do { \
    glVertexAttribPointerNV_PACKED *unpacked = (glVertexAttribPointerNV_PACKED *)packed; \
    glVertexAttribPointerNV_ARGS *args = (glVertexAttribPointerNV_ARGS *)&unpacked->args; \
    glVertexAttribPointerNV(args->index, args->fsize, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribPointerNV(glVertexAttribPointerNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribPointerNV(glVertexAttribPointerNV_PACKED *_dst glVertexAttribPointerNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribPointerNV_PTR)(glVertexAttribPointerNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs1dvNV_RETURN
#define glVertexAttribs1dvNV_RETURN void
#define glVertexAttribs1dvNV_ARG_NAMES index, count, v
#define glVertexAttribs1dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs1dvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs1dvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLdouble * v
#define forward_glVertexAttribs1dvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs1dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs1dvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs1dvNV(packed, ret_v) do { \
    glVertexAttribs1dvNV_PACKED *unpacked = (glVertexAttribs1dvNV_PACKED *)packed; \
    glVertexAttribs1dvNV_ARGS *args = (glVertexAttribs1dvNV_ARGS *)&unpacked->args; \
    glVertexAttribs1dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs1dvNV(glVertexAttribs1dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs1dvNV(glVertexAttribs1dvNV_PACKED *_dst glVertexAttribs1dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs1dvNV_PTR)(glVertexAttribs1dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs1fvNV_RETURN
#define glVertexAttribs1fvNV_RETURN void
#define glVertexAttribs1fvNV_ARG_NAMES index, count, v
#define glVertexAttribs1fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs1fvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs1fvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLfloat * v
#define forward_glVertexAttribs1fvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs1fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs1fvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs1fvNV(packed, ret_v) do { \
    glVertexAttribs1fvNV_PACKED *unpacked = (glVertexAttribs1fvNV_PACKED *)packed; \
    glVertexAttribs1fvNV_ARGS *args = (glVertexAttribs1fvNV_ARGS *)&unpacked->args; \
    glVertexAttribs1fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs1fvNV(glVertexAttribs1fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs1fvNV(glVertexAttribs1fvNV_PACKED *_dst glVertexAttribs1fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs1fvNV_PTR)(glVertexAttribs1fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs1hvNV_RETURN
#define glVertexAttribs1hvNV_RETURN void
#define glVertexAttribs1hvNV_ARG_NAMES index, n, v
#define glVertexAttribs1hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs1hvNV_ARG_NAMES_TAIL , index, n, v
#define glVertexAttribs1hvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei n, const GLhalfNV * v
#define forward_glVertexAttribs1hvNV(_index, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs1hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs1hvNV(dst, _index, _n, _v), NULL); \
    });
#define call_glVertexAttribs1hvNV(packed, ret_v) do { \
    glVertexAttribs1hvNV_PACKED *unpacked = (glVertexAttribs1hvNV_PACKED *)packed; \
    glVertexAttribs1hvNV_ARGS *args = (glVertexAttribs1hvNV_ARGS *)&unpacked->args; \
    glVertexAttribs1hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs1hvNV(glVertexAttribs1hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs1hvNV(glVertexAttribs1hvNV_PACKED *_dst glVertexAttribs1hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs1hvNV_PTR)(glVertexAttribs1hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs1svNV_RETURN
#define glVertexAttribs1svNV_RETURN void
#define glVertexAttribs1svNV_ARG_NAMES index, count, v
#define glVertexAttribs1svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs1svNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs1svNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLshort * v
#define forward_glVertexAttribs1svNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs1svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs1svNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs1svNV(packed, ret_v) do { \
    glVertexAttribs1svNV_PACKED *unpacked = (glVertexAttribs1svNV_PACKED *)packed; \
    glVertexAttribs1svNV_ARGS *args = (glVertexAttribs1svNV_ARGS *)&unpacked->args; \
    glVertexAttribs1svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs1svNV(glVertexAttribs1svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs1svNV(glVertexAttribs1svNV_PACKED *_dst glVertexAttribs1svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs1svNV_PTR)(glVertexAttribs1svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs2dvNV_RETURN
#define glVertexAttribs2dvNV_RETURN void
#define glVertexAttribs2dvNV_ARG_NAMES index, count, v
#define glVertexAttribs2dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs2dvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs2dvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLdouble * v
#define forward_glVertexAttribs2dvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs2dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs2dvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs2dvNV(packed, ret_v) do { \
    glVertexAttribs2dvNV_PACKED *unpacked = (glVertexAttribs2dvNV_PACKED *)packed; \
    glVertexAttribs2dvNV_ARGS *args = (glVertexAttribs2dvNV_ARGS *)&unpacked->args; \
    glVertexAttribs2dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs2dvNV(glVertexAttribs2dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs2dvNV(glVertexAttribs2dvNV_PACKED *_dst glVertexAttribs2dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs2dvNV_PTR)(glVertexAttribs2dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs2fvNV_RETURN
#define glVertexAttribs2fvNV_RETURN void
#define glVertexAttribs2fvNV_ARG_NAMES index, count, v
#define glVertexAttribs2fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs2fvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs2fvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLfloat * v
#define forward_glVertexAttribs2fvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs2fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs2fvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs2fvNV(packed, ret_v) do { \
    glVertexAttribs2fvNV_PACKED *unpacked = (glVertexAttribs2fvNV_PACKED *)packed; \
    glVertexAttribs2fvNV_ARGS *args = (glVertexAttribs2fvNV_ARGS *)&unpacked->args; \
    glVertexAttribs2fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs2fvNV(glVertexAttribs2fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs2fvNV(glVertexAttribs2fvNV_PACKED *_dst glVertexAttribs2fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs2fvNV_PTR)(glVertexAttribs2fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs2hvNV_RETURN
#define glVertexAttribs2hvNV_RETURN void
#define glVertexAttribs2hvNV_ARG_NAMES index, n, v
#define glVertexAttribs2hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs2hvNV_ARG_NAMES_TAIL , index, n, v
#define glVertexAttribs2hvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei n, const GLhalfNV * v
#define forward_glVertexAttribs2hvNV(_index, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs2hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs2hvNV(dst, _index, _n, _v), NULL); \
    });
#define call_glVertexAttribs2hvNV(packed, ret_v) do { \
    glVertexAttribs2hvNV_PACKED *unpacked = (glVertexAttribs2hvNV_PACKED *)packed; \
    glVertexAttribs2hvNV_ARGS *args = (glVertexAttribs2hvNV_ARGS *)&unpacked->args; \
    glVertexAttribs2hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs2hvNV(glVertexAttribs2hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs2hvNV(glVertexAttribs2hvNV_PACKED *_dst glVertexAttribs2hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs2hvNV_PTR)(glVertexAttribs2hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs2svNV_RETURN
#define glVertexAttribs2svNV_RETURN void
#define glVertexAttribs2svNV_ARG_NAMES index, count, v
#define glVertexAttribs2svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs2svNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs2svNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLshort * v
#define forward_glVertexAttribs2svNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs2svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs2svNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs2svNV(packed, ret_v) do { \
    glVertexAttribs2svNV_PACKED *unpacked = (glVertexAttribs2svNV_PACKED *)packed; \
    glVertexAttribs2svNV_ARGS *args = (glVertexAttribs2svNV_ARGS *)&unpacked->args; \
    glVertexAttribs2svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs2svNV(glVertexAttribs2svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs2svNV(glVertexAttribs2svNV_PACKED *_dst glVertexAttribs2svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs2svNV_PTR)(glVertexAttribs2svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs3dvNV_RETURN
#define glVertexAttribs3dvNV_RETURN void
#define glVertexAttribs3dvNV_ARG_NAMES index, count, v
#define glVertexAttribs3dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs3dvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs3dvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLdouble * v
#define forward_glVertexAttribs3dvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs3dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs3dvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs3dvNV(packed, ret_v) do { \
    glVertexAttribs3dvNV_PACKED *unpacked = (glVertexAttribs3dvNV_PACKED *)packed; \
    glVertexAttribs3dvNV_ARGS *args = (glVertexAttribs3dvNV_ARGS *)&unpacked->args; \
    glVertexAttribs3dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs3dvNV(glVertexAttribs3dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs3dvNV(glVertexAttribs3dvNV_PACKED *_dst glVertexAttribs3dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs3dvNV_PTR)(glVertexAttribs3dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs3fvNV_RETURN
#define glVertexAttribs3fvNV_RETURN void
#define glVertexAttribs3fvNV_ARG_NAMES index, count, v
#define glVertexAttribs3fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs3fvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs3fvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLfloat * v
#define forward_glVertexAttribs3fvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs3fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs3fvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs3fvNV(packed, ret_v) do { \
    glVertexAttribs3fvNV_PACKED *unpacked = (glVertexAttribs3fvNV_PACKED *)packed; \
    glVertexAttribs3fvNV_ARGS *args = (glVertexAttribs3fvNV_ARGS *)&unpacked->args; \
    glVertexAttribs3fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs3fvNV(glVertexAttribs3fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs3fvNV(glVertexAttribs3fvNV_PACKED *_dst glVertexAttribs3fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs3fvNV_PTR)(glVertexAttribs3fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs3hvNV_RETURN
#define glVertexAttribs3hvNV_RETURN void
#define glVertexAttribs3hvNV_ARG_NAMES index, n, v
#define glVertexAttribs3hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs3hvNV_ARG_NAMES_TAIL , index, n, v
#define glVertexAttribs3hvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei n, const GLhalfNV * v
#define forward_glVertexAttribs3hvNV(_index, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs3hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs3hvNV(dst, _index, _n, _v), NULL); \
    });
#define call_glVertexAttribs3hvNV(packed, ret_v) do { \
    glVertexAttribs3hvNV_PACKED *unpacked = (glVertexAttribs3hvNV_PACKED *)packed; \
    glVertexAttribs3hvNV_ARGS *args = (glVertexAttribs3hvNV_ARGS *)&unpacked->args; \
    glVertexAttribs3hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs3hvNV(glVertexAttribs3hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs3hvNV(glVertexAttribs3hvNV_PACKED *_dst glVertexAttribs3hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs3hvNV_PTR)(glVertexAttribs3hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs3svNV_RETURN
#define glVertexAttribs3svNV_RETURN void
#define glVertexAttribs3svNV_ARG_NAMES index, count, v
#define glVertexAttribs3svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs3svNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs3svNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLshort * v
#define forward_glVertexAttribs3svNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs3svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs3svNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs3svNV(packed, ret_v) do { \
    glVertexAttribs3svNV_PACKED *unpacked = (glVertexAttribs3svNV_PACKED *)packed; \
    glVertexAttribs3svNV_ARGS *args = (glVertexAttribs3svNV_ARGS *)&unpacked->args; \
    glVertexAttribs3svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs3svNV(glVertexAttribs3svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs3svNV(glVertexAttribs3svNV_PACKED *_dst glVertexAttribs3svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs3svNV_PTR)(glVertexAttribs3svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs4dvNV_RETURN
#define glVertexAttribs4dvNV_RETURN void
#define glVertexAttribs4dvNV_ARG_NAMES index, count, v
#define glVertexAttribs4dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs4dvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs4dvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLdouble * v
#define forward_glVertexAttribs4dvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs4dvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs4dvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs4dvNV(packed, ret_v) do { \
    glVertexAttribs4dvNV_PACKED *unpacked = (glVertexAttribs4dvNV_PACKED *)packed; \
    glVertexAttribs4dvNV_ARGS *args = (glVertexAttribs4dvNV_ARGS *)&unpacked->args; \
    glVertexAttribs4dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4dvNV(glVertexAttribs4dvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs4dvNV(glVertexAttribs4dvNV_PACKED *_dst glVertexAttribs4dvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs4dvNV_PTR)(glVertexAttribs4dvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs4fvNV_RETURN
#define glVertexAttribs4fvNV_RETURN void
#define glVertexAttribs4fvNV_ARG_NAMES index, count, v
#define glVertexAttribs4fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs4fvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs4fvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLfloat * v
#define forward_glVertexAttribs4fvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs4fvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs4fvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs4fvNV(packed, ret_v) do { \
    glVertexAttribs4fvNV_PACKED *unpacked = (glVertexAttribs4fvNV_PACKED *)packed; \
    glVertexAttribs4fvNV_ARGS *args = (glVertexAttribs4fvNV_ARGS *)&unpacked->args; \
    glVertexAttribs4fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4fvNV(glVertexAttribs4fvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs4fvNV(glVertexAttribs4fvNV_PACKED *_dst glVertexAttribs4fvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs4fvNV_PTR)(glVertexAttribs4fvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs4hvNV_RETURN
#define glVertexAttribs4hvNV_RETURN void
#define glVertexAttribs4hvNV_ARG_NAMES index, n, v
#define glVertexAttribs4hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs4hvNV_ARG_NAMES_TAIL , index, n, v
#define glVertexAttribs4hvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei n, const GLhalfNV * v
#define forward_glVertexAttribs4hvNV(_index, _n, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs4hvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs4hvNV(dst, _index, _n, _v), NULL); \
    });
#define call_glVertexAttribs4hvNV(packed, ret_v) do { \
    glVertexAttribs4hvNV_PACKED *unpacked = (glVertexAttribs4hvNV_PACKED *)packed; \
    glVertexAttribs4hvNV_ARGS *args = (glVertexAttribs4hvNV_ARGS *)&unpacked->args; \
    glVertexAttribs4hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs4hvNV(glVertexAttribs4hvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs4hvNV(glVertexAttribs4hvNV_PACKED *_dst glVertexAttribs4hvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs4hvNV_PTR)(glVertexAttribs4hvNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs4svNV_RETURN
#define glVertexAttribs4svNV_RETURN void
#define glVertexAttribs4svNV_ARG_NAMES index, count, v
#define glVertexAttribs4svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs4svNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs4svNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLshort * v
#define forward_glVertexAttribs4svNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs4svNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs4svNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs4svNV(packed, ret_v) do { \
    glVertexAttribs4svNV_PACKED *unpacked = (glVertexAttribs4svNV_PACKED *)packed; \
    glVertexAttribs4svNV_ARGS *args = (glVertexAttribs4svNV_ARGS *)&unpacked->args; \
    glVertexAttribs4svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4svNV(glVertexAttribs4svNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs4svNV(glVertexAttribs4svNV_PACKED *_dst glVertexAttribs4svNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs4svNV_PTR)(glVertexAttribs4svNV_ARG_EXPAND);
#endif
#ifndef glVertexAttribs4ubvNV_RETURN
#define glVertexAttribs4ubvNV_RETURN void
#define glVertexAttribs4ubvNV_ARG_NAMES index, count, v
#define glVertexAttribs4ubvNV_ARG_EXPAND GLuint index, GLsizei count, const GLubyte * v
#define glVertexAttribs4ubvNV_ARG_NAMES_TAIL , index, count, v
#define glVertexAttribs4ubvNV_ARG_EXPAND_TAIL , GLuint index, GLsizei count, const GLubyte * v
#define forward_glVertexAttribs4ubvNV(_index, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexAttribs4ubvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexAttribs4ubvNV(dst, _index, _count, _v), NULL); \
    });
#define call_glVertexAttribs4ubvNV(packed, ret_v) do { \
    glVertexAttribs4ubvNV_PACKED *unpacked = (glVertexAttribs4ubvNV_PACKED *)packed; \
    glVertexAttribs4ubvNV_ARGS *args = (glVertexAttribs4ubvNV_ARGS *)&unpacked->args; \
    glVertexAttribs4ubvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4ubvNV(glVertexAttribs4ubvNV_ARG_EXPAND);
packed_call_t *pack_glVertexAttribs4ubvNV(glVertexAttribs4ubvNV_PACKED *_dst glVertexAttribs4ubvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexAttribs4ubvNV_PTR)(glVertexAttribs4ubvNV_ARG_EXPAND);
#endif
#ifndef glVertexBindingDivisor_RETURN
#define glVertexBindingDivisor_RETURN void
#define glVertexBindingDivisor_ARG_NAMES bindingindex, divisor
#define glVertexBindingDivisor_ARG_EXPAND GLuint bindingindex, GLuint divisor
#define glVertexBindingDivisor_ARG_NAMES_TAIL , bindingindex, divisor
#define glVertexBindingDivisor_ARG_EXPAND_TAIL , GLuint bindingindex, GLuint divisor
#define forward_glVertexBindingDivisor(_bindingindex, _divisor) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexBindingDivisor_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexBindingDivisor(dst, _bindingindex, _divisor), NULL); \
    });
#define call_glVertexBindingDivisor(packed, ret_v) do { \
    glVertexBindingDivisor_PACKED *unpacked = (glVertexBindingDivisor_PACKED *)packed; \
    glVertexBindingDivisor_ARGS *args = (glVertexBindingDivisor_ARGS *)&unpacked->args; \
    glVertexBindingDivisor(args->bindingindex, args->divisor);; \
} while(0)
void glVertexBindingDivisor(glVertexBindingDivisor_ARG_EXPAND);
packed_call_t *pack_glVertexBindingDivisor(glVertexBindingDivisor_PACKED *_dst glVertexBindingDivisor_ARG_EXPAND_TAIL);
typedef void (*glVertexBindingDivisor_PTR)(glVertexBindingDivisor_ARG_EXPAND);
#endif
#ifndef glVertexBlendARB_RETURN
#define glVertexBlendARB_RETURN void
#define glVertexBlendARB_ARG_NAMES count
#define glVertexBlendARB_ARG_EXPAND GLint count
#define glVertexBlendARB_ARG_NAMES_TAIL , count
#define glVertexBlendARB_ARG_EXPAND_TAIL , GLint count
#define forward_glVertexBlendARB(_count) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexBlendARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexBlendARB(dst, _count), NULL); \
    });
#define call_glVertexBlendARB(packed, ret_v) do { \
    glVertexBlendARB_PACKED *unpacked = (glVertexBlendARB_PACKED *)packed; \
    glVertexBlendARB_ARGS *args = (glVertexBlendARB_ARGS *)&unpacked->args; \
    glVertexBlendARB(args->count);; \
} while(0)
void glVertexBlendARB(glVertexBlendARB_ARG_EXPAND);
packed_call_t *pack_glVertexBlendARB(glVertexBlendARB_PACKED *_dst glVertexBlendARB_ARG_EXPAND_TAIL);
typedef void (*glVertexBlendARB_PTR)(glVertexBlendARB_ARG_EXPAND);
#endif
#ifndef glVertexBlendEnvfATI_RETURN
#define glVertexBlendEnvfATI_RETURN void
#define glVertexBlendEnvfATI_ARG_NAMES pname, param
#define glVertexBlendEnvfATI_ARG_EXPAND GLenum pname, GLfloat param
#define glVertexBlendEnvfATI_ARG_NAMES_TAIL , pname, param
#define glVertexBlendEnvfATI_ARG_EXPAND_TAIL , GLenum pname, GLfloat param
#define forward_glVertexBlendEnvfATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexBlendEnvfATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexBlendEnvfATI(dst, _pname, _param), NULL); \
    });
#define call_glVertexBlendEnvfATI(packed, ret_v) do { \
    glVertexBlendEnvfATI_PACKED *unpacked = (glVertexBlendEnvfATI_PACKED *)packed; \
    glVertexBlendEnvfATI_ARGS *args = (glVertexBlendEnvfATI_ARGS *)&unpacked->args; \
    glVertexBlendEnvfATI(args->pname, args->param);; \
} while(0)
void glVertexBlendEnvfATI(glVertexBlendEnvfATI_ARG_EXPAND);
packed_call_t *pack_glVertexBlendEnvfATI(glVertexBlendEnvfATI_PACKED *_dst glVertexBlendEnvfATI_ARG_EXPAND_TAIL);
typedef void (*glVertexBlendEnvfATI_PTR)(glVertexBlendEnvfATI_ARG_EXPAND);
#endif
#ifndef glVertexBlendEnviATI_RETURN
#define glVertexBlendEnviATI_RETURN void
#define glVertexBlendEnviATI_ARG_NAMES pname, param
#define glVertexBlendEnviATI_ARG_EXPAND GLenum pname, GLint param
#define glVertexBlendEnviATI_ARG_NAMES_TAIL , pname, param
#define glVertexBlendEnviATI_ARG_EXPAND_TAIL , GLenum pname, GLint param
#define forward_glVertexBlendEnviATI(_pname, _param) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexBlendEnviATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexBlendEnviATI(dst, _pname, _param), NULL); \
    });
#define call_glVertexBlendEnviATI(packed, ret_v) do { \
    glVertexBlendEnviATI_PACKED *unpacked = (glVertexBlendEnviATI_PACKED *)packed; \
    glVertexBlendEnviATI_ARGS *args = (glVertexBlendEnviATI_ARGS *)&unpacked->args; \
    glVertexBlendEnviATI(args->pname, args->param);; \
} while(0)
void glVertexBlendEnviATI(glVertexBlendEnviATI_ARG_EXPAND);
packed_call_t *pack_glVertexBlendEnviATI(glVertexBlendEnviATI_PACKED *_dst glVertexBlendEnviATI_ARG_EXPAND_TAIL);
typedef void (*glVertexBlendEnviATI_PTR)(glVertexBlendEnviATI_ARG_EXPAND);
#endif
#ifndef glVertexFormatNV_RETURN
#define glVertexFormatNV_RETURN void
#define glVertexFormatNV_ARG_NAMES size, type, stride
#define glVertexFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glVertexFormatNV_ARG_NAMES_TAIL , size, type, stride
#define glVertexFormatNV_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride
#define forward_glVertexFormatNV(_size, _type, _stride) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexFormatNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexFormatNV(dst, _size, _type, _stride), NULL); \
    });
#define call_glVertexFormatNV(packed, ret_v) do { \
    glVertexFormatNV_PACKED *unpacked = (glVertexFormatNV_PACKED *)packed; \
    glVertexFormatNV_ARGS *args = (glVertexFormatNV_ARGS *)&unpacked->args; \
    glVertexFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glVertexFormatNV(glVertexFormatNV_ARG_EXPAND);
packed_call_t *pack_glVertexFormatNV(glVertexFormatNV_PACKED *_dst glVertexFormatNV_ARG_EXPAND_TAIL);
typedef void (*glVertexFormatNV_PTR)(glVertexFormatNV_ARG_EXPAND);
#endif
#ifndef glVertexP2ui_RETURN
#define glVertexP2ui_RETURN void
#define glVertexP2ui_ARG_NAMES type, value
#define glVertexP2ui_ARG_EXPAND GLenum type, GLuint value
#define glVertexP2ui_ARG_NAMES_TAIL , type, value
#define glVertexP2ui_ARG_EXPAND_TAIL , GLenum type, GLuint value
#define forward_glVertexP2ui(_type, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexP2ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexP2ui(dst, _type, _value), NULL); \
    });
#define call_glVertexP2ui(packed, ret_v) do { \
    glVertexP2ui_PACKED *unpacked = (glVertexP2ui_PACKED *)packed; \
    glVertexP2ui_ARGS *args = (glVertexP2ui_ARGS *)&unpacked->args; \
    glVertexP2ui(args->type, args->value);; \
} while(0)
void glVertexP2ui(glVertexP2ui_ARG_EXPAND);
packed_call_t *pack_glVertexP2ui(glVertexP2ui_PACKED *_dst glVertexP2ui_ARG_EXPAND_TAIL);
typedef void (*glVertexP2ui_PTR)(glVertexP2ui_ARG_EXPAND);
#endif
#ifndef glVertexP2uiv_RETURN
#define glVertexP2uiv_RETURN void
#define glVertexP2uiv_ARG_NAMES type, value
#define glVertexP2uiv_ARG_EXPAND GLenum type, const GLuint * value
#define glVertexP2uiv_ARG_NAMES_TAIL , type, value
#define glVertexP2uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * value
#define forward_glVertexP2uiv(_type, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexP2uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexP2uiv(dst, _type, _value), NULL); \
    });
#define call_glVertexP2uiv(packed, ret_v) do { \
    glVertexP2uiv_PACKED *unpacked = (glVertexP2uiv_PACKED *)packed; \
    glVertexP2uiv_ARGS *args = (glVertexP2uiv_ARGS *)&unpacked->args; \
    glVertexP2uiv(args->type, args->value);; \
} while(0)
void glVertexP2uiv(glVertexP2uiv_ARG_EXPAND);
packed_call_t *pack_glVertexP2uiv(glVertexP2uiv_PACKED *_dst glVertexP2uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexP2uiv_PTR)(glVertexP2uiv_ARG_EXPAND);
#endif
#ifndef glVertexP3ui_RETURN
#define glVertexP3ui_RETURN void
#define glVertexP3ui_ARG_NAMES type, value
#define glVertexP3ui_ARG_EXPAND GLenum type, GLuint value
#define glVertexP3ui_ARG_NAMES_TAIL , type, value
#define glVertexP3ui_ARG_EXPAND_TAIL , GLenum type, GLuint value
#define forward_glVertexP3ui(_type, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexP3ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexP3ui(dst, _type, _value), NULL); \
    });
#define call_glVertexP3ui(packed, ret_v) do { \
    glVertexP3ui_PACKED *unpacked = (glVertexP3ui_PACKED *)packed; \
    glVertexP3ui_ARGS *args = (glVertexP3ui_ARGS *)&unpacked->args; \
    glVertexP3ui(args->type, args->value);; \
} while(0)
void glVertexP3ui(glVertexP3ui_ARG_EXPAND);
packed_call_t *pack_glVertexP3ui(glVertexP3ui_PACKED *_dst glVertexP3ui_ARG_EXPAND_TAIL);
typedef void (*glVertexP3ui_PTR)(glVertexP3ui_ARG_EXPAND);
#endif
#ifndef glVertexP3uiv_RETURN
#define glVertexP3uiv_RETURN void
#define glVertexP3uiv_ARG_NAMES type, value
#define glVertexP3uiv_ARG_EXPAND GLenum type, const GLuint * value
#define glVertexP3uiv_ARG_NAMES_TAIL , type, value
#define glVertexP3uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * value
#define forward_glVertexP3uiv(_type, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexP3uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexP3uiv(dst, _type, _value), NULL); \
    });
#define call_glVertexP3uiv(packed, ret_v) do { \
    glVertexP3uiv_PACKED *unpacked = (glVertexP3uiv_PACKED *)packed; \
    glVertexP3uiv_ARGS *args = (glVertexP3uiv_ARGS *)&unpacked->args; \
    glVertexP3uiv(args->type, args->value);; \
} while(0)
void glVertexP3uiv(glVertexP3uiv_ARG_EXPAND);
packed_call_t *pack_glVertexP3uiv(glVertexP3uiv_PACKED *_dst glVertexP3uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexP3uiv_PTR)(glVertexP3uiv_ARG_EXPAND);
#endif
#ifndef glVertexP4ui_RETURN
#define glVertexP4ui_RETURN void
#define glVertexP4ui_ARG_NAMES type, value
#define glVertexP4ui_ARG_EXPAND GLenum type, GLuint value
#define glVertexP4ui_ARG_NAMES_TAIL , type, value
#define glVertexP4ui_ARG_EXPAND_TAIL , GLenum type, GLuint value
#define forward_glVertexP4ui(_type, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexP4ui_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexP4ui(dst, _type, _value), NULL); \
    });
#define call_glVertexP4ui(packed, ret_v) do { \
    glVertexP4ui_PACKED *unpacked = (glVertexP4ui_PACKED *)packed; \
    glVertexP4ui_ARGS *args = (glVertexP4ui_ARGS *)&unpacked->args; \
    glVertexP4ui(args->type, args->value);; \
} while(0)
void glVertexP4ui(glVertexP4ui_ARG_EXPAND);
packed_call_t *pack_glVertexP4ui(glVertexP4ui_PACKED *_dst glVertexP4ui_ARG_EXPAND_TAIL);
typedef void (*glVertexP4ui_PTR)(glVertexP4ui_ARG_EXPAND);
#endif
#ifndef glVertexP4uiv_RETURN
#define glVertexP4uiv_RETURN void
#define glVertexP4uiv_ARG_NAMES type, value
#define glVertexP4uiv_ARG_EXPAND GLenum type, const GLuint * value
#define glVertexP4uiv_ARG_NAMES_TAIL , type, value
#define glVertexP4uiv_ARG_EXPAND_TAIL , GLenum type, const GLuint * value
#define forward_glVertexP4uiv(_type, _value) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexP4uiv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexP4uiv(dst, _type, _value), NULL); \
    });
#define call_glVertexP4uiv(packed, ret_v) do { \
    glVertexP4uiv_PACKED *unpacked = (glVertexP4uiv_PACKED *)packed; \
    glVertexP4uiv_ARGS *args = (glVertexP4uiv_ARGS *)&unpacked->args; \
    glVertexP4uiv(args->type, args->value);; \
} while(0)
void glVertexP4uiv(glVertexP4uiv_ARG_EXPAND);
packed_call_t *pack_glVertexP4uiv(glVertexP4uiv_PACKED *_dst glVertexP4uiv_ARG_EXPAND_TAIL);
typedef void (*glVertexP4uiv_PTR)(glVertexP4uiv_ARG_EXPAND);
#endif
#ifndef glVertexPointer_RETURN
#define glVertexPointer_RETURN void
#define glVertexPointer_ARG_NAMES size, type, stride, pointer
#define glVertexPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexPointer_ARG_NAMES_TAIL , size, type, stride, pointer
#define glVertexPointer_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glVertexPointer(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexPointer_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexPointer(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glVertexPointer(packed, ret_v) do { \
    glVertexPointer_PACKED *unpacked = (glVertexPointer_PACKED *)packed; \
    glVertexPointer_ARGS *args = (glVertexPointer_ARGS *)&unpacked->args; \
    glVertexPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexPointer(glVertexPointer_ARG_EXPAND);
packed_call_t *pack_glVertexPointer(glVertexPointer_PACKED *_dst glVertexPointer_ARG_EXPAND_TAIL);
typedef void (*glVertexPointer_PTR)(glVertexPointer_ARG_EXPAND);
#endif
#ifndef glVertexPointerEXT_RETURN
#define glVertexPointerEXT_RETURN void
#define glVertexPointerEXT_ARG_NAMES size, type, stride, count, pointer
#define glVertexPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glVertexPointerEXT_ARG_NAMES_TAIL , size, type, stride, count, pointer
#define glVertexPointerEXT_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define forward_glVertexPointerEXT(_size, _type, _stride, _count, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexPointerEXT(dst, _size, _type, _stride, _count, _pointer), NULL); \
    });
#define call_glVertexPointerEXT(packed, ret_v) do { \
    glVertexPointerEXT_PACKED *unpacked = (glVertexPointerEXT_PACKED *)packed; \
    glVertexPointerEXT_ARGS *args = (glVertexPointerEXT_ARGS *)&unpacked->args; \
    glVertexPointerEXT(args->size, args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glVertexPointerEXT(glVertexPointerEXT_ARG_EXPAND);
packed_call_t *pack_glVertexPointerEXT(glVertexPointerEXT_PACKED *_dst glVertexPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexPointerEXT_PTR)(glVertexPointerEXT_ARG_EXPAND);
#endif
#ifndef glVertexPointerListIBM_RETURN
#define glVertexPointerListIBM_RETURN void
#define glVertexPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glVertexPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glVertexPointerListIBM_ARG_NAMES_TAIL , size, type, stride, pointer, ptrstride
#define glVertexPointerListIBM_ARG_EXPAND_TAIL , GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define forward_glVertexPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexPointerListIBM_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexPointerListIBM(dst, _size, _type, _stride, _pointer, _ptrstride), NULL); \
    });
#define call_glVertexPointerListIBM(packed, ret_v) do { \
    glVertexPointerListIBM_PACKED *unpacked = (glVertexPointerListIBM_PACKED *)packed; \
    glVertexPointerListIBM_ARGS *args = (glVertexPointerListIBM_ARGS *)&unpacked->args; \
    glVertexPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glVertexPointerListIBM(glVertexPointerListIBM_ARG_EXPAND);
packed_call_t *pack_glVertexPointerListIBM(glVertexPointerListIBM_PACKED *_dst glVertexPointerListIBM_ARG_EXPAND_TAIL);
typedef void (*glVertexPointerListIBM_PTR)(glVertexPointerListIBM_ARG_EXPAND);
#endif
#ifndef glVertexPointervINTEL_RETURN
#define glVertexPointervINTEL_RETURN void
#define glVertexPointervINTEL_ARG_NAMES size, type, pointer
#define glVertexPointervINTEL_ARG_EXPAND GLint size, GLenum type, const GLvoid * pointer
#define glVertexPointervINTEL_ARG_NAMES_TAIL , size, type, pointer
#define glVertexPointervINTEL_ARG_EXPAND_TAIL , GLint size, GLenum type, const GLvoid * pointer
#define forward_glVertexPointervINTEL(_size, _type, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexPointervINTEL_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexPointervINTEL(dst, _size, _type, _pointer), NULL); \
    });
#define call_glVertexPointervINTEL(packed, ret_v) do { \
    glVertexPointervINTEL_PACKED *unpacked = (glVertexPointervINTEL_PACKED *)packed; \
    glVertexPointervINTEL_ARGS *args = (glVertexPointervINTEL_ARGS *)&unpacked->args; \
    glVertexPointervINTEL(args->size, args->type, args->pointer);; \
} while(0)
void glVertexPointervINTEL(glVertexPointervINTEL_ARG_EXPAND);
packed_call_t *pack_glVertexPointervINTEL(glVertexPointervINTEL_PACKED *_dst glVertexPointervINTEL_ARG_EXPAND_TAIL);
typedef void (*glVertexPointervINTEL_PTR)(glVertexPointervINTEL_ARG_EXPAND);
#endif
#ifndef glVertexStream1dATI_RETURN
#define glVertexStream1dATI_RETURN void
#define glVertexStream1dATI_ARG_NAMES stream, x
#define glVertexStream1dATI_ARG_EXPAND GLenum stream, GLdouble x
#define glVertexStream1dATI_ARG_NAMES_TAIL , stream, x
#define glVertexStream1dATI_ARG_EXPAND_TAIL , GLenum stream, GLdouble x
#define forward_glVertexStream1dATI(_stream, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1dATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1dATI(dst, _stream, _x), NULL); \
    });
#define call_glVertexStream1dATI(packed, ret_v) do { \
    glVertexStream1dATI_PACKED *unpacked = (glVertexStream1dATI_PACKED *)packed; \
    glVertexStream1dATI_ARGS *args = (glVertexStream1dATI_ARGS *)&unpacked->args; \
    glVertexStream1dATI(args->stream, args->x);; \
} while(0)
void glVertexStream1dATI(glVertexStream1dATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1dATI(glVertexStream1dATI_PACKED *_dst glVertexStream1dATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1dATI_PTR)(glVertexStream1dATI_ARG_EXPAND);
#endif
#ifndef glVertexStream1dvATI_RETURN
#define glVertexStream1dvATI_RETURN void
#define glVertexStream1dvATI_ARG_NAMES stream, coords
#define glVertexStream1dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream1dvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream1dvATI_ARG_EXPAND_TAIL , GLenum stream, const GLdouble * coords
#define forward_glVertexStream1dvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1dvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1dvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream1dvATI(packed, ret_v) do { \
    glVertexStream1dvATI_PACKED *unpacked = (glVertexStream1dvATI_PACKED *)packed; \
    glVertexStream1dvATI_ARGS *args = (glVertexStream1dvATI_ARGS *)&unpacked->args; \
    glVertexStream1dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1dvATI(glVertexStream1dvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1dvATI(glVertexStream1dvATI_PACKED *_dst glVertexStream1dvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1dvATI_PTR)(glVertexStream1dvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream1fATI_RETURN
#define glVertexStream1fATI_RETURN void
#define glVertexStream1fATI_ARG_NAMES stream, x
#define glVertexStream1fATI_ARG_EXPAND GLenum stream, GLfloat x
#define glVertexStream1fATI_ARG_NAMES_TAIL , stream, x
#define glVertexStream1fATI_ARG_EXPAND_TAIL , GLenum stream, GLfloat x
#define forward_glVertexStream1fATI(_stream, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1fATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1fATI(dst, _stream, _x), NULL); \
    });
#define call_glVertexStream1fATI(packed, ret_v) do { \
    glVertexStream1fATI_PACKED *unpacked = (glVertexStream1fATI_PACKED *)packed; \
    glVertexStream1fATI_ARGS *args = (glVertexStream1fATI_ARGS *)&unpacked->args; \
    glVertexStream1fATI(args->stream, args->x);; \
} while(0)
void glVertexStream1fATI(glVertexStream1fATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1fATI(glVertexStream1fATI_PACKED *_dst glVertexStream1fATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1fATI_PTR)(glVertexStream1fATI_ARG_EXPAND);
#endif
#ifndef glVertexStream1fvATI_RETURN
#define glVertexStream1fvATI_RETURN void
#define glVertexStream1fvATI_ARG_NAMES stream, coords
#define glVertexStream1fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream1fvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream1fvATI_ARG_EXPAND_TAIL , GLenum stream, const GLfloat * coords
#define forward_glVertexStream1fvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1fvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1fvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream1fvATI(packed, ret_v) do { \
    glVertexStream1fvATI_PACKED *unpacked = (glVertexStream1fvATI_PACKED *)packed; \
    glVertexStream1fvATI_ARGS *args = (glVertexStream1fvATI_ARGS *)&unpacked->args; \
    glVertexStream1fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1fvATI(glVertexStream1fvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1fvATI(glVertexStream1fvATI_PACKED *_dst glVertexStream1fvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1fvATI_PTR)(glVertexStream1fvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream1iATI_RETURN
#define glVertexStream1iATI_RETURN void
#define glVertexStream1iATI_ARG_NAMES stream, x
#define glVertexStream1iATI_ARG_EXPAND GLenum stream, GLint x
#define glVertexStream1iATI_ARG_NAMES_TAIL , stream, x
#define glVertexStream1iATI_ARG_EXPAND_TAIL , GLenum stream, GLint x
#define forward_glVertexStream1iATI(_stream, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1iATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1iATI(dst, _stream, _x), NULL); \
    });
#define call_glVertexStream1iATI(packed, ret_v) do { \
    glVertexStream1iATI_PACKED *unpacked = (glVertexStream1iATI_PACKED *)packed; \
    glVertexStream1iATI_ARGS *args = (glVertexStream1iATI_ARGS *)&unpacked->args; \
    glVertexStream1iATI(args->stream, args->x);; \
} while(0)
void glVertexStream1iATI(glVertexStream1iATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1iATI(glVertexStream1iATI_PACKED *_dst glVertexStream1iATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1iATI_PTR)(glVertexStream1iATI_ARG_EXPAND);
#endif
#ifndef glVertexStream1ivATI_RETURN
#define glVertexStream1ivATI_RETURN void
#define glVertexStream1ivATI_ARG_NAMES stream, coords
#define glVertexStream1ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream1ivATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream1ivATI_ARG_EXPAND_TAIL , GLenum stream, const GLint * coords
#define forward_glVertexStream1ivATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1ivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1ivATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream1ivATI(packed, ret_v) do { \
    glVertexStream1ivATI_PACKED *unpacked = (glVertexStream1ivATI_PACKED *)packed; \
    glVertexStream1ivATI_ARGS *args = (glVertexStream1ivATI_ARGS *)&unpacked->args; \
    glVertexStream1ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1ivATI(glVertexStream1ivATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1ivATI(glVertexStream1ivATI_PACKED *_dst glVertexStream1ivATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1ivATI_PTR)(glVertexStream1ivATI_ARG_EXPAND);
#endif
#ifndef glVertexStream1sATI_RETURN
#define glVertexStream1sATI_RETURN void
#define glVertexStream1sATI_ARG_NAMES stream, x
#define glVertexStream1sATI_ARG_EXPAND GLenum stream, GLshort x
#define glVertexStream1sATI_ARG_NAMES_TAIL , stream, x
#define glVertexStream1sATI_ARG_EXPAND_TAIL , GLenum stream, GLshort x
#define forward_glVertexStream1sATI(_stream, _x) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1sATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1sATI(dst, _stream, _x), NULL); \
    });
#define call_glVertexStream1sATI(packed, ret_v) do { \
    glVertexStream1sATI_PACKED *unpacked = (glVertexStream1sATI_PACKED *)packed; \
    glVertexStream1sATI_ARGS *args = (glVertexStream1sATI_ARGS *)&unpacked->args; \
    glVertexStream1sATI(args->stream, args->x);; \
} while(0)
void glVertexStream1sATI(glVertexStream1sATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1sATI(glVertexStream1sATI_PACKED *_dst glVertexStream1sATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1sATI_PTR)(glVertexStream1sATI_ARG_EXPAND);
#endif
#ifndef glVertexStream1svATI_RETURN
#define glVertexStream1svATI_RETURN void
#define glVertexStream1svATI_ARG_NAMES stream, coords
#define glVertexStream1svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream1svATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream1svATI_ARG_EXPAND_TAIL , GLenum stream, const GLshort * coords
#define forward_glVertexStream1svATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream1svATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream1svATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream1svATI(packed, ret_v) do { \
    glVertexStream1svATI_PACKED *unpacked = (glVertexStream1svATI_PACKED *)packed; \
    glVertexStream1svATI_ARGS *args = (glVertexStream1svATI_ARGS *)&unpacked->args; \
    glVertexStream1svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1svATI(glVertexStream1svATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream1svATI(glVertexStream1svATI_PACKED *_dst glVertexStream1svATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream1svATI_PTR)(glVertexStream1svATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2dATI_RETURN
#define glVertexStream2dATI_RETURN void
#define glVertexStream2dATI_ARG_NAMES stream, x, y
#define glVertexStream2dATI_ARG_EXPAND GLenum stream, GLdouble x, GLdouble y
#define glVertexStream2dATI_ARG_NAMES_TAIL , stream, x, y
#define glVertexStream2dATI_ARG_EXPAND_TAIL , GLenum stream, GLdouble x, GLdouble y
#define forward_glVertexStream2dATI(_stream, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2dATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2dATI(dst, _stream, _x, _y), NULL); \
    });
#define call_glVertexStream2dATI(packed, ret_v) do { \
    glVertexStream2dATI_PACKED *unpacked = (glVertexStream2dATI_PACKED *)packed; \
    glVertexStream2dATI_ARGS *args = (glVertexStream2dATI_ARGS *)&unpacked->args; \
    glVertexStream2dATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2dATI(glVertexStream2dATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2dATI(glVertexStream2dATI_PACKED *_dst glVertexStream2dATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2dATI_PTR)(glVertexStream2dATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2dvATI_RETURN
#define glVertexStream2dvATI_RETURN void
#define glVertexStream2dvATI_ARG_NAMES stream, coords
#define glVertexStream2dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream2dvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream2dvATI_ARG_EXPAND_TAIL , GLenum stream, const GLdouble * coords
#define forward_glVertexStream2dvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2dvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2dvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream2dvATI(packed, ret_v) do { \
    glVertexStream2dvATI_PACKED *unpacked = (glVertexStream2dvATI_PACKED *)packed; \
    glVertexStream2dvATI_ARGS *args = (glVertexStream2dvATI_ARGS *)&unpacked->args; \
    glVertexStream2dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2dvATI(glVertexStream2dvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2dvATI(glVertexStream2dvATI_PACKED *_dst glVertexStream2dvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2dvATI_PTR)(glVertexStream2dvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2fATI_RETURN
#define glVertexStream2fATI_RETURN void
#define glVertexStream2fATI_ARG_NAMES stream, x, y
#define glVertexStream2fATI_ARG_EXPAND GLenum stream, GLfloat x, GLfloat y
#define glVertexStream2fATI_ARG_NAMES_TAIL , stream, x, y
#define glVertexStream2fATI_ARG_EXPAND_TAIL , GLenum stream, GLfloat x, GLfloat y
#define forward_glVertexStream2fATI(_stream, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2fATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2fATI(dst, _stream, _x, _y), NULL); \
    });
#define call_glVertexStream2fATI(packed, ret_v) do { \
    glVertexStream2fATI_PACKED *unpacked = (glVertexStream2fATI_PACKED *)packed; \
    glVertexStream2fATI_ARGS *args = (glVertexStream2fATI_ARGS *)&unpacked->args; \
    glVertexStream2fATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2fATI(glVertexStream2fATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2fATI(glVertexStream2fATI_PACKED *_dst glVertexStream2fATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2fATI_PTR)(glVertexStream2fATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2fvATI_RETURN
#define glVertexStream2fvATI_RETURN void
#define glVertexStream2fvATI_ARG_NAMES stream, coords
#define glVertexStream2fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream2fvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream2fvATI_ARG_EXPAND_TAIL , GLenum stream, const GLfloat * coords
#define forward_glVertexStream2fvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2fvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2fvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream2fvATI(packed, ret_v) do { \
    glVertexStream2fvATI_PACKED *unpacked = (glVertexStream2fvATI_PACKED *)packed; \
    glVertexStream2fvATI_ARGS *args = (glVertexStream2fvATI_ARGS *)&unpacked->args; \
    glVertexStream2fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2fvATI(glVertexStream2fvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2fvATI(glVertexStream2fvATI_PACKED *_dst glVertexStream2fvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2fvATI_PTR)(glVertexStream2fvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2iATI_RETURN
#define glVertexStream2iATI_RETURN void
#define glVertexStream2iATI_ARG_NAMES stream, x, y
#define glVertexStream2iATI_ARG_EXPAND GLenum stream, GLint x, GLint y
#define glVertexStream2iATI_ARG_NAMES_TAIL , stream, x, y
#define glVertexStream2iATI_ARG_EXPAND_TAIL , GLenum stream, GLint x, GLint y
#define forward_glVertexStream2iATI(_stream, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2iATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2iATI(dst, _stream, _x, _y), NULL); \
    });
#define call_glVertexStream2iATI(packed, ret_v) do { \
    glVertexStream2iATI_PACKED *unpacked = (glVertexStream2iATI_PACKED *)packed; \
    glVertexStream2iATI_ARGS *args = (glVertexStream2iATI_ARGS *)&unpacked->args; \
    glVertexStream2iATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2iATI(glVertexStream2iATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2iATI(glVertexStream2iATI_PACKED *_dst glVertexStream2iATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2iATI_PTR)(glVertexStream2iATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2ivATI_RETURN
#define glVertexStream2ivATI_RETURN void
#define glVertexStream2ivATI_ARG_NAMES stream, coords
#define glVertexStream2ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream2ivATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream2ivATI_ARG_EXPAND_TAIL , GLenum stream, const GLint * coords
#define forward_glVertexStream2ivATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2ivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2ivATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream2ivATI(packed, ret_v) do { \
    glVertexStream2ivATI_PACKED *unpacked = (glVertexStream2ivATI_PACKED *)packed; \
    glVertexStream2ivATI_ARGS *args = (glVertexStream2ivATI_ARGS *)&unpacked->args; \
    glVertexStream2ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2ivATI(glVertexStream2ivATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2ivATI(glVertexStream2ivATI_PACKED *_dst glVertexStream2ivATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2ivATI_PTR)(glVertexStream2ivATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2sATI_RETURN
#define glVertexStream2sATI_RETURN void
#define glVertexStream2sATI_ARG_NAMES stream, x, y
#define glVertexStream2sATI_ARG_EXPAND GLenum stream, GLshort x, GLshort y
#define glVertexStream2sATI_ARG_NAMES_TAIL , stream, x, y
#define glVertexStream2sATI_ARG_EXPAND_TAIL , GLenum stream, GLshort x, GLshort y
#define forward_glVertexStream2sATI(_stream, _x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2sATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2sATI(dst, _stream, _x, _y), NULL); \
    });
#define call_glVertexStream2sATI(packed, ret_v) do { \
    glVertexStream2sATI_PACKED *unpacked = (glVertexStream2sATI_PACKED *)packed; \
    glVertexStream2sATI_ARGS *args = (glVertexStream2sATI_ARGS *)&unpacked->args; \
    glVertexStream2sATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2sATI(glVertexStream2sATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2sATI(glVertexStream2sATI_PACKED *_dst glVertexStream2sATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2sATI_PTR)(glVertexStream2sATI_ARG_EXPAND);
#endif
#ifndef glVertexStream2svATI_RETURN
#define glVertexStream2svATI_RETURN void
#define glVertexStream2svATI_ARG_NAMES stream, coords
#define glVertexStream2svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream2svATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream2svATI_ARG_EXPAND_TAIL , GLenum stream, const GLshort * coords
#define forward_glVertexStream2svATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream2svATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream2svATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream2svATI(packed, ret_v) do { \
    glVertexStream2svATI_PACKED *unpacked = (glVertexStream2svATI_PACKED *)packed; \
    glVertexStream2svATI_ARGS *args = (glVertexStream2svATI_ARGS *)&unpacked->args; \
    glVertexStream2svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2svATI(glVertexStream2svATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream2svATI(glVertexStream2svATI_PACKED *_dst glVertexStream2svATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream2svATI_PTR)(glVertexStream2svATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3dATI_RETURN
#define glVertexStream3dATI_RETURN void
#define glVertexStream3dATI_ARG_NAMES stream, x, y, z
#define glVertexStream3dATI_ARG_EXPAND GLenum stream, GLdouble x, GLdouble y, GLdouble z
#define glVertexStream3dATI_ARG_NAMES_TAIL , stream, x, y, z
#define glVertexStream3dATI_ARG_EXPAND_TAIL , GLenum stream, GLdouble x, GLdouble y, GLdouble z
#define forward_glVertexStream3dATI(_stream, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3dATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3dATI(dst, _stream, _x, _y, _z), NULL); \
    });
#define call_glVertexStream3dATI(packed, ret_v) do { \
    glVertexStream3dATI_PACKED *unpacked = (glVertexStream3dATI_PACKED *)packed; \
    glVertexStream3dATI_ARGS *args = (glVertexStream3dATI_ARGS *)&unpacked->args; \
    glVertexStream3dATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3dATI(glVertexStream3dATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3dATI(glVertexStream3dATI_PACKED *_dst glVertexStream3dATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3dATI_PTR)(glVertexStream3dATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3dvATI_RETURN
#define glVertexStream3dvATI_RETURN void
#define glVertexStream3dvATI_ARG_NAMES stream, coords
#define glVertexStream3dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream3dvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream3dvATI_ARG_EXPAND_TAIL , GLenum stream, const GLdouble * coords
#define forward_glVertexStream3dvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3dvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3dvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream3dvATI(packed, ret_v) do { \
    glVertexStream3dvATI_PACKED *unpacked = (glVertexStream3dvATI_PACKED *)packed; \
    glVertexStream3dvATI_ARGS *args = (glVertexStream3dvATI_ARGS *)&unpacked->args; \
    glVertexStream3dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3dvATI(glVertexStream3dvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3dvATI(glVertexStream3dvATI_PACKED *_dst glVertexStream3dvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3dvATI_PTR)(glVertexStream3dvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3fATI_RETURN
#define glVertexStream3fATI_RETURN void
#define glVertexStream3fATI_ARG_NAMES stream, x, y, z
#define glVertexStream3fATI_ARG_EXPAND GLenum stream, GLfloat x, GLfloat y, GLfloat z
#define glVertexStream3fATI_ARG_NAMES_TAIL , stream, x, y, z
#define glVertexStream3fATI_ARG_EXPAND_TAIL , GLenum stream, GLfloat x, GLfloat y, GLfloat z
#define forward_glVertexStream3fATI(_stream, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3fATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3fATI(dst, _stream, _x, _y, _z), NULL); \
    });
#define call_glVertexStream3fATI(packed, ret_v) do { \
    glVertexStream3fATI_PACKED *unpacked = (glVertexStream3fATI_PACKED *)packed; \
    glVertexStream3fATI_ARGS *args = (glVertexStream3fATI_ARGS *)&unpacked->args; \
    glVertexStream3fATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3fATI(glVertexStream3fATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3fATI(glVertexStream3fATI_PACKED *_dst glVertexStream3fATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3fATI_PTR)(glVertexStream3fATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3fvATI_RETURN
#define glVertexStream3fvATI_RETURN void
#define glVertexStream3fvATI_ARG_NAMES stream, coords
#define glVertexStream3fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream3fvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream3fvATI_ARG_EXPAND_TAIL , GLenum stream, const GLfloat * coords
#define forward_glVertexStream3fvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3fvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3fvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream3fvATI(packed, ret_v) do { \
    glVertexStream3fvATI_PACKED *unpacked = (glVertexStream3fvATI_PACKED *)packed; \
    glVertexStream3fvATI_ARGS *args = (glVertexStream3fvATI_ARGS *)&unpacked->args; \
    glVertexStream3fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3fvATI(glVertexStream3fvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3fvATI(glVertexStream3fvATI_PACKED *_dst glVertexStream3fvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3fvATI_PTR)(glVertexStream3fvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3iATI_RETURN
#define glVertexStream3iATI_RETURN void
#define glVertexStream3iATI_ARG_NAMES stream, x, y, z
#define glVertexStream3iATI_ARG_EXPAND GLenum stream, GLint x, GLint y, GLint z
#define glVertexStream3iATI_ARG_NAMES_TAIL , stream, x, y, z
#define glVertexStream3iATI_ARG_EXPAND_TAIL , GLenum stream, GLint x, GLint y, GLint z
#define forward_glVertexStream3iATI(_stream, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3iATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3iATI(dst, _stream, _x, _y, _z), NULL); \
    });
#define call_glVertexStream3iATI(packed, ret_v) do { \
    glVertexStream3iATI_PACKED *unpacked = (glVertexStream3iATI_PACKED *)packed; \
    glVertexStream3iATI_ARGS *args = (glVertexStream3iATI_ARGS *)&unpacked->args; \
    glVertexStream3iATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3iATI(glVertexStream3iATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3iATI(glVertexStream3iATI_PACKED *_dst glVertexStream3iATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3iATI_PTR)(glVertexStream3iATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3ivATI_RETURN
#define glVertexStream3ivATI_RETURN void
#define glVertexStream3ivATI_ARG_NAMES stream, coords
#define glVertexStream3ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream3ivATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream3ivATI_ARG_EXPAND_TAIL , GLenum stream, const GLint * coords
#define forward_glVertexStream3ivATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3ivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3ivATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream3ivATI(packed, ret_v) do { \
    glVertexStream3ivATI_PACKED *unpacked = (glVertexStream3ivATI_PACKED *)packed; \
    glVertexStream3ivATI_ARGS *args = (glVertexStream3ivATI_ARGS *)&unpacked->args; \
    glVertexStream3ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3ivATI(glVertexStream3ivATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3ivATI(glVertexStream3ivATI_PACKED *_dst glVertexStream3ivATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3ivATI_PTR)(glVertexStream3ivATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3sATI_RETURN
#define glVertexStream3sATI_RETURN void
#define glVertexStream3sATI_ARG_NAMES stream, x, y, z
#define glVertexStream3sATI_ARG_EXPAND GLenum stream, GLshort x, GLshort y, GLshort z
#define glVertexStream3sATI_ARG_NAMES_TAIL , stream, x, y, z
#define glVertexStream3sATI_ARG_EXPAND_TAIL , GLenum stream, GLshort x, GLshort y, GLshort z
#define forward_glVertexStream3sATI(_stream, _x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3sATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3sATI(dst, _stream, _x, _y, _z), NULL); \
    });
#define call_glVertexStream3sATI(packed, ret_v) do { \
    glVertexStream3sATI_PACKED *unpacked = (glVertexStream3sATI_PACKED *)packed; \
    glVertexStream3sATI_ARGS *args = (glVertexStream3sATI_ARGS *)&unpacked->args; \
    glVertexStream3sATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3sATI(glVertexStream3sATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3sATI(glVertexStream3sATI_PACKED *_dst glVertexStream3sATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3sATI_PTR)(glVertexStream3sATI_ARG_EXPAND);
#endif
#ifndef glVertexStream3svATI_RETURN
#define glVertexStream3svATI_RETURN void
#define glVertexStream3svATI_ARG_NAMES stream, coords
#define glVertexStream3svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream3svATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream3svATI_ARG_EXPAND_TAIL , GLenum stream, const GLshort * coords
#define forward_glVertexStream3svATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream3svATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream3svATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream3svATI(packed, ret_v) do { \
    glVertexStream3svATI_PACKED *unpacked = (glVertexStream3svATI_PACKED *)packed; \
    glVertexStream3svATI_ARGS *args = (glVertexStream3svATI_ARGS *)&unpacked->args; \
    glVertexStream3svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3svATI(glVertexStream3svATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream3svATI(glVertexStream3svATI_PACKED *_dst glVertexStream3svATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream3svATI_PTR)(glVertexStream3svATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4dATI_RETURN
#define glVertexStream4dATI_RETURN void
#define glVertexStream4dATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4dATI_ARG_EXPAND GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexStream4dATI_ARG_NAMES_TAIL , stream, x, y, z, w
#define glVertexStream4dATI_ARG_EXPAND_TAIL , GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glVertexStream4dATI(_stream, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4dATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4dATI(dst, _stream, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexStream4dATI(packed, ret_v) do { \
    glVertexStream4dATI_PACKED *unpacked = (glVertexStream4dATI_PACKED *)packed; \
    glVertexStream4dATI_ARGS *args = (glVertexStream4dATI_ARGS *)&unpacked->args; \
    glVertexStream4dATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4dATI(glVertexStream4dATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4dATI(glVertexStream4dATI_PACKED *_dst glVertexStream4dATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4dATI_PTR)(glVertexStream4dATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4dvATI_RETURN
#define glVertexStream4dvATI_RETURN void
#define glVertexStream4dvATI_ARG_NAMES stream, coords
#define glVertexStream4dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream4dvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream4dvATI_ARG_EXPAND_TAIL , GLenum stream, const GLdouble * coords
#define forward_glVertexStream4dvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4dvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4dvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream4dvATI(packed, ret_v) do { \
    glVertexStream4dvATI_PACKED *unpacked = (glVertexStream4dvATI_PACKED *)packed; \
    glVertexStream4dvATI_ARGS *args = (glVertexStream4dvATI_ARGS *)&unpacked->args; \
    glVertexStream4dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4dvATI(glVertexStream4dvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4dvATI(glVertexStream4dvATI_PACKED *_dst glVertexStream4dvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4dvATI_PTR)(glVertexStream4dvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4fATI_RETURN
#define glVertexStream4fATI_RETURN void
#define glVertexStream4fATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4fATI_ARG_EXPAND GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexStream4fATI_ARG_NAMES_TAIL , stream, x, y, z, w
#define glVertexStream4fATI_ARG_EXPAND_TAIL , GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glVertexStream4fATI(_stream, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4fATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4fATI(dst, _stream, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexStream4fATI(packed, ret_v) do { \
    glVertexStream4fATI_PACKED *unpacked = (glVertexStream4fATI_PACKED *)packed; \
    glVertexStream4fATI_ARGS *args = (glVertexStream4fATI_ARGS *)&unpacked->args; \
    glVertexStream4fATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4fATI(glVertexStream4fATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4fATI(glVertexStream4fATI_PACKED *_dst glVertexStream4fATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4fATI_PTR)(glVertexStream4fATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4fvATI_RETURN
#define glVertexStream4fvATI_RETURN void
#define glVertexStream4fvATI_ARG_NAMES stream, coords
#define glVertexStream4fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream4fvATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream4fvATI_ARG_EXPAND_TAIL , GLenum stream, const GLfloat * coords
#define forward_glVertexStream4fvATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4fvATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4fvATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream4fvATI(packed, ret_v) do { \
    glVertexStream4fvATI_PACKED *unpacked = (glVertexStream4fvATI_PACKED *)packed; \
    glVertexStream4fvATI_ARGS *args = (glVertexStream4fvATI_ARGS *)&unpacked->args; \
    glVertexStream4fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4fvATI(glVertexStream4fvATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4fvATI(glVertexStream4fvATI_PACKED *_dst glVertexStream4fvATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4fvATI_PTR)(glVertexStream4fvATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4iATI_RETURN
#define glVertexStream4iATI_RETURN void
#define glVertexStream4iATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4iATI_ARG_EXPAND GLenum stream, GLint x, GLint y, GLint z, GLint w
#define glVertexStream4iATI_ARG_NAMES_TAIL , stream, x, y, z, w
#define glVertexStream4iATI_ARG_EXPAND_TAIL , GLenum stream, GLint x, GLint y, GLint z, GLint w
#define forward_glVertexStream4iATI(_stream, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4iATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4iATI(dst, _stream, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexStream4iATI(packed, ret_v) do { \
    glVertexStream4iATI_PACKED *unpacked = (glVertexStream4iATI_PACKED *)packed; \
    glVertexStream4iATI_ARGS *args = (glVertexStream4iATI_ARGS *)&unpacked->args; \
    glVertexStream4iATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4iATI(glVertexStream4iATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4iATI(glVertexStream4iATI_PACKED *_dst glVertexStream4iATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4iATI_PTR)(glVertexStream4iATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4ivATI_RETURN
#define glVertexStream4ivATI_RETURN void
#define glVertexStream4ivATI_ARG_NAMES stream, coords
#define glVertexStream4ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream4ivATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream4ivATI_ARG_EXPAND_TAIL , GLenum stream, const GLint * coords
#define forward_glVertexStream4ivATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4ivATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4ivATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream4ivATI(packed, ret_v) do { \
    glVertexStream4ivATI_PACKED *unpacked = (glVertexStream4ivATI_PACKED *)packed; \
    glVertexStream4ivATI_ARGS *args = (glVertexStream4ivATI_ARGS *)&unpacked->args; \
    glVertexStream4ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4ivATI(glVertexStream4ivATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4ivATI(glVertexStream4ivATI_PACKED *_dst glVertexStream4ivATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4ivATI_PTR)(glVertexStream4ivATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4sATI_RETURN
#define glVertexStream4sATI_RETURN void
#define glVertexStream4sATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4sATI_ARG_EXPAND GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexStream4sATI_ARG_NAMES_TAIL , stream, x, y, z, w
#define glVertexStream4sATI_ARG_EXPAND_TAIL , GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w
#define forward_glVertexStream4sATI(_stream, _x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4sATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4sATI(dst, _stream, _x, _y, _z, _w), NULL); \
    });
#define call_glVertexStream4sATI(packed, ret_v) do { \
    glVertexStream4sATI_PACKED *unpacked = (glVertexStream4sATI_PACKED *)packed; \
    glVertexStream4sATI_ARGS *args = (glVertexStream4sATI_ARGS *)&unpacked->args; \
    glVertexStream4sATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4sATI(glVertexStream4sATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4sATI(glVertexStream4sATI_PACKED *_dst glVertexStream4sATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4sATI_PTR)(glVertexStream4sATI_ARG_EXPAND);
#endif
#ifndef glVertexStream4svATI_RETURN
#define glVertexStream4svATI_RETURN void
#define glVertexStream4svATI_ARG_NAMES stream, coords
#define glVertexStream4svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream4svATI_ARG_NAMES_TAIL , stream, coords
#define glVertexStream4svATI_ARG_EXPAND_TAIL , GLenum stream, const GLshort * coords
#define forward_glVertexStream4svATI(_stream, _coords) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexStream4svATI_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexStream4svATI(dst, _stream, _coords), NULL); \
    });
#define call_glVertexStream4svATI(packed, ret_v) do { \
    glVertexStream4svATI_PACKED *unpacked = (glVertexStream4svATI_PACKED *)packed; \
    glVertexStream4svATI_ARGS *args = (glVertexStream4svATI_ARGS *)&unpacked->args; \
    glVertexStream4svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4svATI(glVertexStream4svATI_ARG_EXPAND);
packed_call_t *pack_glVertexStream4svATI(glVertexStream4svATI_PACKED *_dst glVertexStream4svATI_ARG_EXPAND_TAIL);
typedef void (*glVertexStream4svATI_PTR)(glVertexStream4svATI_ARG_EXPAND);
#endif
#ifndef glVertexWeightPointerEXT_RETURN
#define glVertexWeightPointerEXT_RETURN void
#define glVertexWeightPointerEXT_ARG_NAMES size, type, stride, pointer
#define glVertexWeightPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexWeightPointerEXT_ARG_NAMES_TAIL , size, type, stride, pointer
#define glVertexWeightPointerEXT_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glVertexWeightPointerEXT(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexWeightPointerEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexWeightPointerEXT(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glVertexWeightPointerEXT(packed, ret_v) do { \
    glVertexWeightPointerEXT_PACKED *unpacked = (glVertexWeightPointerEXT_PACKED *)packed; \
    glVertexWeightPointerEXT_ARGS *args = (glVertexWeightPointerEXT_ARGS *)&unpacked->args; \
    glVertexWeightPointerEXT(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexWeightPointerEXT(glVertexWeightPointerEXT_ARG_EXPAND);
packed_call_t *pack_glVertexWeightPointerEXT(glVertexWeightPointerEXT_PACKED *_dst glVertexWeightPointerEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexWeightPointerEXT_PTR)(glVertexWeightPointerEXT_ARG_EXPAND);
#endif
#ifndef glVertexWeightfEXT_RETURN
#define glVertexWeightfEXT_RETURN void
#define glVertexWeightfEXT_ARG_NAMES weight
#define glVertexWeightfEXT_ARG_EXPAND GLfloat weight
#define glVertexWeightfEXT_ARG_NAMES_TAIL , weight
#define glVertexWeightfEXT_ARG_EXPAND_TAIL , GLfloat weight
#define forward_glVertexWeightfEXT(_weight) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexWeightfEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexWeightfEXT(dst, _weight), NULL); \
    });
#define call_glVertexWeightfEXT(packed, ret_v) do { \
    glVertexWeightfEXT_PACKED *unpacked = (glVertexWeightfEXT_PACKED *)packed; \
    glVertexWeightfEXT_ARGS *args = (glVertexWeightfEXT_ARGS *)&unpacked->args; \
    glVertexWeightfEXT(args->weight);; \
} while(0)
void glVertexWeightfEXT(glVertexWeightfEXT_ARG_EXPAND);
packed_call_t *pack_glVertexWeightfEXT(glVertexWeightfEXT_PACKED *_dst glVertexWeightfEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexWeightfEXT_PTR)(glVertexWeightfEXT_ARG_EXPAND);
#endif
#ifndef glVertexWeightfvEXT_RETURN
#define glVertexWeightfvEXT_RETURN void
#define glVertexWeightfvEXT_ARG_NAMES weight
#define glVertexWeightfvEXT_ARG_EXPAND const GLfloat * weight
#define glVertexWeightfvEXT_ARG_NAMES_TAIL , weight
#define glVertexWeightfvEXT_ARG_EXPAND_TAIL , const GLfloat * weight
#define forward_glVertexWeightfvEXT(_weight) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexWeightfvEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexWeightfvEXT(dst, _weight), NULL); \
    });
#define call_glVertexWeightfvEXT(packed, ret_v) do { \
    glVertexWeightfvEXT_PACKED *unpacked = (glVertexWeightfvEXT_PACKED *)packed; \
    glVertexWeightfvEXT_ARGS *args = (glVertexWeightfvEXT_ARGS *)&unpacked->args; \
    glVertexWeightfvEXT(args->weight);; \
} while(0)
void glVertexWeightfvEXT(glVertexWeightfvEXT_ARG_EXPAND);
packed_call_t *pack_glVertexWeightfvEXT(glVertexWeightfvEXT_PACKED *_dst glVertexWeightfvEXT_ARG_EXPAND_TAIL);
typedef void (*glVertexWeightfvEXT_PTR)(glVertexWeightfvEXT_ARG_EXPAND);
#endif
#ifndef glVertexWeighthNV_RETURN
#define glVertexWeighthNV_RETURN void
#define glVertexWeighthNV_ARG_NAMES weight
#define glVertexWeighthNV_ARG_EXPAND GLhalfNV weight
#define glVertexWeighthNV_ARG_NAMES_TAIL , weight
#define glVertexWeighthNV_ARG_EXPAND_TAIL , GLhalfNV weight
#define forward_glVertexWeighthNV(_weight) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexWeighthNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexWeighthNV(dst, _weight), NULL); \
    });
#define call_glVertexWeighthNV(packed, ret_v) do { \
    glVertexWeighthNV_PACKED *unpacked = (glVertexWeighthNV_PACKED *)packed; \
    glVertexWeighthNV_ARGS *args = (glVertexWeighthNV_ARGS *)&unpacked->args; \
    glVertexWeighthNV(args->weight);; \
} while(0)
void glVertexWeighthNV(glVertexWeighthNV_ARG_EXPAND);
packed_call_t *pack_glVertexWeighthNV(glVertexWeighthNV_PACKED *_dst glVertexWeighthNV_ARG_EXPAND_TAIL);
typedef void (*glVertexWeighthNV_PTR)(glVertexWeighthNV_ARG_EXPAND);
#endif
#ifndef glVertexWeighthvNV_RETURN
#define glVertexWeighthvNV_RETURN void
#define glVertexWeighthvNV_ARG_NAMES weight
#define glVertexWeighthvNV_ARG_EXPAND const GLhalfNV * weight
#define glVertexWeighthvNV_ARG_NAMES_TAIL , weight
#define glVertexWeighthvNV_ARG_EXPAND_TAIL , const GLhalfNV * weight
#define forward_glVertexWeighthvNV(_weight) \
    ({ \
        void *dst = remote_dma(sizeof(glVertexWeighthvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVertexWeighthvNV(dst, _weight), NULL); \
    });
#define call_glVertexWeighthvNV(packed, ret_v) do { \
    glVertexWeighthvNV_PACKED *unpacked = (glVertexWeighthvNV_PACKED *)packed; \
    glVertexWeighthvNV_ARGS *args = (glVertexWeighthvNV_ARGS *)&unpacked->args; \
    glVertexWeighthvNV(args->weight);; \
} while(0)
void glVertexWeighthvNV(glVertexWeighthvNV_ARG_EXPAND);
packed_call_t *pack_glVertexWeighthvNV(glVertexWeighthvNV_PACKED *_dst glVertexWeighthvNV_ARG_EXPAND_TAIL);
typedef void (*glVertexWeighthvNV_PTR)(glVertexWeighthvNV_ARG_EXPAND);
#endif
#ifndef glVideoCaptureNV_RETURN
#define glVideoCaptureNV_RETURN GLenum
#define glVideoCaptureNV_ARG_NAMES video_capture_slot, sequence_num, capture_time
#define glVideoCaptureNV_ARG_EXPAND GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time
#define glVideoCaptureNV_ARG_NAMES_TAIL , video_capture_slot, sequence_num, capture_time
#define glVideoCaptureNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time
#define forward_glVideoCaptureNV(_video_capture_slot, _sequence_num, _capture_time) \
    ({ \
        void *dst = remote_dma(sizeof(glVideoCaptureNV_PACKED)); \
        GLenum ret = (GLenum)0; \
        remote_dma_send((packed_call_t *)pack_glVideoCaptureNV(dst, _video_capture_slot, _sequence_num, _capture_time), &ret); \
        ret; \
    });
#define call_glVideoCaptureNV(packed, ret_v) do { \
    glVideoCaptureNV_PACKED *unpacked = (glVideoCaptureNV_PACKED *)packed; \
    glVideoCaptureNV_ARGS *args = (glVideoCaptureNV_ARGS *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glVideoCaptureNV(args->video_capture_slot, args->sequence_num, args->capture_time);; \
    } else { \
        glVideoCaptureNV(args->video_capture_slot, args->sequence_num, args->capture_time);; \
    } \
} while(0)
GLenum glVideoCaptureNV(glVideoCaptureNV_ARG_EXPAND);
packed_call_t *pack_glVideoCaptureNV(glVideoCaptureNV_PACKED *_dst glVideoCaptureNV_ARG_EXPAND_TAIL);
typedef GLenum (*glVideoCaptureNV_PTR)(glVideoCaptureNV_ARG_EXPAND);
#endif
#ifndef glVideoCaptureStreamParameterdvNV_RETURN
#define glVideoCaptureStreamParameterdvNV_RETURN void
#define glVideoCaptureStreamParameterdvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterdvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params
#define glVideoCaptureStreamParameterdvNV_ARG_NAMES_TAIL , video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterdvNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params
#define forward_glVideoCaptureStreamParameterdvNV(_video_capture_slot, _stream, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glVideoCaptureStreamParameterdvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVideoCaptureStreamParameterdvNV(dst, _video_capture_slot, _stream, _pname, _params), NULL); \
    });
#define call_glVideoCaptureStreamParameterdvNV(packed, ret_v) do { \
    glVideoCaptureStreamParameterdvNV_PACKED *unpacked = (glVideoCaptureStreamParameterdvNV_PACKED *)packed; \
    glVideoCaptureStreamParameterdvNV_ARGS *args = (glVideoCaptureStreamParameterdvNV_ARGS *)&unpacked->args; \
    glVideoCaptureStreamParameterdvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glVideoCaptureStreamParameterdvNV(glVideoCaptureStreamParameterdvNV_ARG_EXPAND);
packed_call_t *pack_glVideoCaptureStreamParameterdvNV(glVideoCaptureStreamParameterdvNV_PACKED *_dst glVideoCaptureStreamParameterdvNV_ARG_EXPAND_TAIL);
typedef void (*glVideoCaptureStreamParameterdvNV_PTR)(glVideoCaptureStreamParameterdvNV_ARG_EXPAND);
#endif
#ifndef glVideoCaptureStreamParameterfvNV_RETURN
#define glVideoCaptureStreamParameterfvNV_RETURN void
#define glVideoCaptureStreamParameterfvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterfvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params
#define glVideoCaptureStreamParameterfvNV_ARG_NAMES_TAIL , video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterfvNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params
#define forward_glVideoCaptureStreamParameterfvNV(_video_capture_slot, _stream, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glVideoCaptureStreamParameterfvNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVideoCaptureStreamParameterfvNV(dst, _video_capture_slot, _stream, _pname, _params), NULL); \
    });
#define call_glVideoCaptureStreamParameterfvNV(packed, ret_v) do { \
    glVideoCaptureStreamParameterfvNV_PACKED *unpacked = (glVideoCaptureStreamParameterfvNV_PACKED *)packed; \
    glVideoCaptureStreamParameterfvNV_ARGS *args = (glVideoCaptureStreamParameterfvNV_ARGS *)&unpacked->args; \
    glVideoCaptureStreamParameterfvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glVideoCaptureStreamParameterfvNV(glVideoCaptureStreamParameterfvNV_ARG_EXPAND);
packed_call_t *pack_glVideoCaptureStreamParameterfvNV(glVideoCaptureStreamParameterfvNV_PACKED *_dst glVideoCaptureStreamParameterfvNV_ARG_EXPAND_TAIL);
typedef void (*glVideoCaptureStreamParameterfvNV_PTR)(glVideoCaptureStreamParameterfvNV_ARG_EXPAND);
#endif
#ifndef glVideoCaptureStreamParameterivNV_RETURN
#define glVideoCaptureStreamParameterivNV_RETURN void
#define glVideoCaptureStreamParameterivNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterivNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params
#define glVideoCaptureStreamParameterivNV_ARG_NAMES_TAIL , video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterivNV_ARG_EXPAND_TAIL , GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params
#define forward_glVideoCaptureStreamParameterivNV(_video_capture_slot, _stream, _pname, _params) \
    ({ \
        void *dst = remote_dma(sizeof(glVideoCaptureStreamParameterivNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glVideoCaptureStreamParameterivNV(dst, _video_capture_slot, _stream, _pname, _params), NULL); \
    });
#define call_glVideoCaptureStreamParameterivNV(packed, ret_v) do { \
    glVideoCaptureStreamParameterivNV_PACKED *unpacked = (glVideoCaptureStreamParameterivNV_PACKED *)packed; \
    glVideoCaptureStreamParameterivNV_ARGS *args = (glVideoCaptureStreamParameterivNV_ARGS *)&unpacked->args; \
    glVideoCaptureStreamParameterivNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glVideoCaptureStreamParameterivNV(glVideoCaptureStreamParameterivNV_ARG_EXPAND);
packed_call_t *pack_glVideoCaptureStreamParameterivNV(glVideoCaptureStreamParameterivNV_PACKED *_dst glVideoCaptureStreamParameterivNV_ARG_EXPAND_TAIL);
typedef void (*glVideoCaptureStreamParameterivNV_PTR)(glVideoCaptureStreamParameterivNV_ARG_EXPAND);
#endif
#ifndef glViewport_RETURN
#define glViewport_RETURN void
#define glViewport_ARG_NAMES x, y, width, height
#define glViewport_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height
#define glViewport_ARG_NAMES_TAIL , x, y, width, height
#define glViewport_ARG_EXPAND_TAIL , GLint x, GLint y, GLsizei width, GLsizei height
#define forward_glViewport(_x, _y, _width, _height) \
    ({ \
        void *dst = remote_dma(sizeof(glViewport_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glViewport(dst, _x, _y, _width, _height), NULL); \
    });
#define call_glViewport(packed, ret_v) do { \
    glViewport_PACKED *unpacked = (glViewport_PACKED *)packed; \
    glViewport_ARGS *args = (glViewport_ARGS *)&unpacked->args; \
    glViewport(args->x, args->y, args->width, args->height);; \
} while(0)
void glViewport(glViewport_ARG_EXPAND);
packed_call_t *pack_glViewport(glViewport_PACKED *_dst glViewport_ARG_EXPAND_TAIL);
typedef void (*glViewport_PTR)(glViewport_ARG_EXPAND);
#endif
#ifndef glViewportArrayv_RETURN
#define glViewportArrayv_RETURN void
#define glViewportArrayv_ARG_NAMES first, count, v
#define glViewportArrayv_ARG_EXPAND GLuint first, GLsizei count, const GLfloat * v
#define glViewportArrayv_ARG_NAMES_TAIL , first, count, v
#define glViewportArrayv_ARG_EXPAND_TAIL , GLuint first, GLsizei count, const GLfloat * v
#define forward_glViewportArrayv(_first, _count, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glViewportArrayv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glViewportArrayv(dst, _first, _count, _v), NULL); \
    });
#define call_glViewportArrayv(packed, ret_v) do { \
    glViewportArrayv_PACKED *unpacked = (glViewportArrayv_PACKED *)packed; \
    glViewportArrayv_ARGS *args = (glViewportArrayv_ARGS *)&unpacked->args; \
    glViewportArrayv(args->first, args->count, args->v);; \
} while(0)
void glViewportArrayv(glViewportArrayv_ARG_EXPAND);
packed_call_t *pack_glViewportArrayv(glViewportArrayv_PACKED *_dst glViewportArrayv_ARG_EXPAND_TAIL);
typedef void (*glViewportArrayv_PTR)(glViewportArrayv_ARG_EXPAND);
#endif
#ifndef glViewportIndexedf_RETURN
#define glViewportIndexedf_RETURN void
#define glViewportIndexedf_ARG_NAMES index, x, y, w, h
#define glViewportIndexedf_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h
#define glViewportIndexedf_ARG_NAMES_TAIL , index, x, y, w, h
#define glViewportIndexedf_ARG_EXPAND_TAIL , GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h
#define forward_glViewportIndexedf(_index, _x, _y, _w, _h) \
    ({ \
        void *dst = remote_dma(sizeof(glViewportIndexedf_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glViewportIndexedf(dst, _index, _x, _y, _w, _h), NULL); \
    });
#define call_glViewportIndexedf(packed, ret_v) do { \
    glViewportIndexedf_PACKED *unpacked = (glViewportIndexedf_PACKED *)packed; \
    glViewportIndexedf_ARGS *args = (glViewportIndexedf_ARGS *)&unpacked->args; \
    glViewportIndexedf(args->index, args->x, args->y, args->w, args->h);; \
} while(0)
void glViewportIndexedf(glViewportIndexedf_ARG_EXPAND);
packed_call_t *pack_glViewportIndexedf(glViewportIndexedf_PACKED *_dst glViewportIndexedf_ARG_EXPAND_TAIL);
typedef void (*glViewportIndexedf_PTR)(glViewportIndexedf_ARG_EXPAND);
#endif
#ifndef glViewportIndexedfv_RETURN
#define glViewportIndexedfv_RETURN void
#define glViewportIndexedfv_ARG_NAMES index, v
#define glViewportIndexedfv_ARG_EXPAND GLuint index, const GLfloat * v
#define glViewportIndexedfv_ARG_NAMES_TAIL , index, v
#define glViewportIndexedfv_ARG_EXPAND_TAIL , GLuint index, const GLfloat * v
#define forward_glViewportIndexedfv(_index, _v) \
    ({ \
        void *dst = remote_dma(sizeof(glViewportIndexedfv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glViewportIndexedfv(dst, _index, _v), NULL); \
    });
#define call_glViewportIndexedfv(packed, ret_v) do { \
    glViewportIndexedfv_PACKED *unpacked = (glViewportIndexedfv_PACKED *)packed; \
    glViewportIndexedfv_ARGS *args = (glViewportIndexedfv_ARGS *)&unpacked->args; \
    glViewportIndexedfv(args->index, args->v);; \
} while(0)
void glViewportIndexedfv(glViewportIndexedfv_ARG_EXPAND);
packed_call_t *pack_glViewportIndexedfv(glViewportIndexedfv_PACKED *_dst glViewportIndexedfv_ARG_EXPAND_TAIL);
typedef void (*glViewportIndexedfv_PTR)(glViewportIndexedfv_ARG_EXPAND);
#endif
#ifndef glWaitSync_RETURN
#define glWaitSync_RETURN void
#define glWaitSync_ARG_NAMES sync, flags, timeout
#define glWaitSync_ARG_EXPAND GLsync sync, GLbitfield flags, GLuint64 timeout
#define glWaitSync_ARG_NAMES_TAIL , sync, flags, timeout
#define glWaitSync_ARG_EXPAND_TAIL , GLsync sync, GLbitfield flags, GLuint64 timeout
#define forward_glWaitSync(_sync, _flags, _timeout) \
    ({ \
        void *dst = remote_dma(sizeof(glWaitSync_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWaitSync(dst, _sync, _flags, _timeout), NULL); \
    });
#define call_glWaitSync(packed, ret_v) do { \
    glWaitSync_PACKED *unpacked = (glWaitSync_PACKED *)packed; \
    glWaitSync_ARGS *args = (glWaitSync_ARGS *)&unpacked->args; \
    glWaitSync(args->sync, args->flags, args->timeout);; \
} while(0)
void glWaitSync(glWaitSync_ARG_EXPAND);
packed_call_t *pack_glWaitSync(glWaitSync_PACKED *_dst glWaitSync_ARG_EXPAND_TAIL);
typedef void (*glWaitSync_PTR)(glWaitSync_ARG_EXPAND);
#endif
#ifndef glWeightPathsNV_RETURN
#define glWeightPathsNV_RETURN void
#define glWeightPathsNV_ARG_NAMES resultPath, numPaths, paths, weights
#define glWeightPathsNV_ARG_EXPAND GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights
#define glWeightPathsNV_ARG_NAMES_TAIL , resultPath, numPaths, paths, weights
#define glWeightPathsNV_ARG_EXPAND_TAIL , GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights
#define forward_glWeightPathsNV(_resultPath, _numPaths, _paths, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightPathsNV_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightPathsNV(dst, _resultPath, _numPaths, _paths, _weights), NULL); \
    });
#define call_glWeightPathsNV(packed, ret_v) do { \
    glWeightPathsNV_PACKED *unpacked = (glWeightPathsNV_PACKED *)packed; \
    glWeightPathsNV_ARGS *args = (glWeightPathsNV_ARGS *)&unpacked->args; \
    glWeightPathsNV(args->resultPath, args->numPaths, args->paths, args->weights);; \
} while(0)
void glWeightPathsNV(glWeightPathsNV_ARG_EXPAND);
packed_call_t *pack_glWeightPathsNV(glWeightPathsNV_PACKED *_dst glWeightPathsNV_ARG_EXPAND_TAIL);
typedef void (*glWeightPathsNV_PTR)(glWeightPathsNV_ARG_EXPAND);
#endif
#ifndef glWeightPointerARB_RETURN
#define glWeightPointerARB_RETURN void
#define glWeightPointerARB_ARG_NAMES size, type, stride, pointer
#define glWeightPointerARB_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glWeightPointerARB_ARG_NAMES_TAIL , size, type, stride, pointer
#define glWeightPointerARB_ARG_EXPAND_TAIL , GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define forward_glWeightPointerARB(_size, _type, _stride, _pointer) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightPointerARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightPointerARB(dst, _size, _type, _stride, _pointer), NULL); \
    });
#define call_glWeightPointerARB(packed, ret_v) do { \
    glWeightPointerARB_PACKED *unpacked = (glWeightPointerARB_PACKED *)packed; \
    glWeightPointerARB_ARGS *args = (glWeightPointerARB_ARGS *)&unpacked->args; \
    glWeightPointerARB(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glWeightPointerARB(glWeightPointerARB_ARG_EXPAND);
packed_call_t *pack_glWeightPointerARB(glWeightPointerARB_PACKED *_dst glWeightPointerARB_ARG_EXPAND_TAIL);
typedef void (*glWeightPointerARB_PTR)(glWeightPointerARB_ARG_EXPAND);
#endif
#ifndef glWeightbvARB_RETURN
#define glWeightbvARB_RETURN void
#define glWeightbvARB_ARG_NAMES size, weights
#define glWeightbvARB_ARG_EXPAND GLint size, const GLbyte * weights
#define glWeightbvARB_ARG_NAMES_TAIL , size, weights
#define glWeightbvARB_ARG_EXPAND_TAIL , GLint size, const GLbyte * weights
#define forward_glWeightbvARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightbvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightbvARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightbvARB(packed, ret_v) do { \
    glWeightbvARB_PACKED *unpacked = (glWeightbvARB_PACKED *)packed; \
    glWeightbvARB_ARGS *args = (glWeightbvARB_ARGS *)&unpacked->args; \
    glWeightbvARB(args->size, args->weights);; \
} while(0)
void glWeightbvARB(glWeightbvARB_ARG_EXPAND);
packed_call_t *pack_glWeightbvARB(glWeightbvARB_PACKED *_dst glWeightbvARB_ARG_EXPAND_TAIL);
typedef void (*glWeightbvARB_PTR)(glWeightbvARB_ARG_EXPAND);
#endif
#ifndef glWeightdvARB_RETURN
#define glWeightdvARB_RETURN void
#define glWeightdvARB_ARG_NAMES size, weights
#define glWeightdvARB_ARG_EXPAND GLint size, const GLdouble * weights
#define glWeightdvARB_ARG_NAMES_TAIL , size, weights
#define glWeightdvARB_ARG_EXPAND_TAIL , GLint size, const GLdouble * weights
#define forward_glWeightdvARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightdvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightdvARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightdvARB(packed, ret_v) do { \
    glWeightdvARB_PACKED *unpacked = (glWeightdvARB_PACKED *)packed; \
    glWeightdvARB_ARGS *args = (glWeightdvARB_ARGS *)&unpacked->args; \
    glWeightdvARB(args->size, args->weights);; \
} while(0)
void glWeightdvARB(glWeightdvARB_ARG_EXPAND);
packed_call_t *pack_glWeightdvARB(glWeightdvARB_PACKED *_dst glWeightdvARB_ARG_EXPAND_TAIL);
typedef void (*glWeightdvARB_PTR)(glWeightdvARB_ARG_EXPAND);
#endif
#ifndef glWeightfvARB_RETURN
#define glWeightfvARB_RETURN void
#define glWeightfvARB_ARG_NAMES size, weights
#define glWeightfvARB_ARG_EXPAND GLint size, const GLfloat * weights
#define glWeightfvARB_ARG_NAMES_TAIL , size, weights
#define glWeightfvARB_ARG_EXPAND_TAIL , GLint size, const GLfloat * weights
#define forward_glWeightfvARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightfvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightfvARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightfvARB(packed, ret_v) do { \
    glWeightfvARB_PACKED *unpacked = (glWeightfvARB_PACKED *)packed; \
    glWeightfvARB_ARGS *args = (glWeightfvARB_ARGS *)&unpacked->args; \
    glWeightfvARB(args->size, args->weights);; \
} while(0)
void glWeightfvARB(glWeightfvARB_ARG_EXPAND);
packed_call_t *pack_glWeightfvARB(glWeightfvARB_PACKED *_dst glWeightfvARB_ARG_EXPAND_TAIL);
typedef void (*glWeightfvARB_PTR)(glWeightfvARB_ARG_EXPAND);
#endif
#ifndef glWeightivARB_RETURN
#define glWeightivARB_RETURN void
#define glWeightivARB_ARG_NAMES size, weights
#define glWeightivARB_ARG_EXPAND GLint size, const GLint * weights
#define glWeightivARB_ARG_NAMES_TAIL , size, weights
#define glWeightivARB_ARG_EXPAND_TAIL , GLint size, const GLint * weights
#define forward_glWeightivARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightivARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightivARB(packed, ret_v) do { \
    glWeightivARB_PACKED *unpacked = (glWeightivARB_PACKED *)packed; \
    glWeightivARB_ARGS *args = (glWeightivARB_ARGS *)&unpacked->args; \
    glWeightivARB(args->size, args->weights);; \
} while(0)
void glWeightivARB(glWeightivARB_ARG_EXPAND);
packed_call_t *pack_glWeightivARB(glWeightivARB_PACKED *_dst glWeightivARB_ARG_EXPAND_TAIL);
typedef void (*glWeightivARB_PTR)(glWeightivARB_ARG_EXPAND);
#endif
#ifndef glWeightsvARB_RETURN
#define glWeightsvARB_RETURN void
#define glWeightsvARB_ARG_NAMES size, weights
#define glWeightsvARB_ARG_EXPAND GLint size, const GLshort * weights
#define glWeightsvARB_ARG_NAMES_TAIL , size, weights
#define glWeightsvARB_ARG_EXPAND_TAIL , GLint size, const GLshort * weights
#define forward_glWeightsvARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightsvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightsvARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightsvARB(packed, ret_v) do { \
    glWeightsvARB_PACKED *unpacked = (glWeightsvARB_PACKED *)packed; \
    glWeightsvARB_ARGS *args = (glWeightsvARB_ARGS *)&unpacked->args; \
    glWeightsvARB(args->size, args->weights);; \
} while(0)
void glWeightsvARB(glWeightsvARB_ARG_EXPAND);
packed_call_t *pack_glWeightsvARB(glWeightsvARB_PACKED *_dst glWeightsvARB_ARG_EXPAND_TAIL);
typedef void (*glWeightsvARB_PTR)(glWeightsvARB_ARG_EXPAND);
#endif
#ifndef glWeightubvARB_RETURN
#define glWeightubvARB_RETURN void
#define glWeightubvARB_ARG_NAMES size, weights
#define glWeightubvARB_ARG_EXPAND GLint size, const GLubyte * weights
#define glWeightubvARB_ARG_NAMES_TAIL , size, weights
#define glWeightubvARB_ARG_EXPAND_TAIL , GLint size, const GLubyte * weights
#define forward_glWeightubvARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightubvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightubvARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightubvARB(packed, ret_v) do { \
    glWeightubvARB_PACKED *unpacked = (glWeightubvARB_PACKED *)packed; \
    glWeightubvARB_ARGS *args = (glWeightubvARB_ARGS *)&unpacked->args; \
    glWeightubvARB(args->size, args->weights);; \
} while(0)
void glWeightubvARB(glWeightubvARB_ARG_EXPAND);
packed_call_t *pack_glWeightubvARB(glWeightubvARB_PACKED *_dst glWeightubvARB_ARG_EXPAND_TAIL);
typedef void (*glWeightubvARB_PTR)(glWeightubvARB_ARG_EXPAND);
#endif
#ifndef glWeightuivARB_RETURN
#define glWeightuivARB_RETURN void
#define glWeightuivARB_ARG_NAMES size, weights
#define glWeightuivARB_ARG_EXPAND GLint size, const GLuint * weights
#define glWeightuivARB_ARG_NAMES_TAIL , size, weights
#define glWeightuivARB_ARG_EXPAND_TAIL , GLint size, const GLuint * weights
#define forward_glWeightuivARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightuivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightuivARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightuivARB(packed, ret_v) do { \
    glWeightuivARB_PACKED *unpacked = (glWeightuivARB_PACKED *)packed; \
    glWeightuivARB_ARGS *args = (glWeightuivARB_ARGS *)&unpacked->args; \
    glWeightuivARB(args->size, args->weights);; \
} while(0)
void glWeightuivARB(glWeightuivARB_ARG_EXPAND);
packed_call_t *pack_glWeightuivARB(glWeightuivARB_PACKED *_dst glWeightuivARB_ARG_EXPAND_TAIL);
typedef void (*glWeightuivARB_PTR)(glWeightuivARB_ARG_EXPAND);
#endif
#ifndef glWeightusvARB_RETURN
#define glWeightusvARB_RETURN void
#define glWeightusvARB_ARG_NAMES size, weights
#define glWeightusvARB_ARG_EXPAND GLint size, const GLushort * weights
#define glWeightusvARB_ARG_NAMES_TAIL , size, weights
#define glWeightusvARB_ARG_EXPAND_TAIL , GLint size, const GLushort * weights
#define forward_glWeightusvARB(_size, _weights) \
    ({ \
        void *dst = remote_dma(sizeof(glWeightusvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWeightusvARB(dst, _size, _weights), NULL); \
    });
#define call_glWeightusvARB(packed, ret_v) do { \
    glWeightusvARB_PACKED *unpacked = (glWeightusvARB_PACKED *)packed; \
    glWeightusvARB_ARGS *args = (glWeightusvARB_ARGS *)&unpacked->args; \
    glWeightusvARB(args->size, args->weights);; \
} while(0)
void glWeightusvARB(glWeightusvARB_ARG_EXPAND);
packed_call_t *pack_glWeightusvARB(glWeightusvARB_PACKED *_dst glWeightusvARB_ARG_EXPAND_TAIL);
typedef void (*glWeightusvARB_PTR)(glWeightusvARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2d_RETURN
#define glWindowPos2d_RETURN void
#define glWindowPos2d_ARG_NAMES x, y
#define glWindowPos2d_ARG_EXPAND GLdouble x, GLdouble y
#define glWindowPos2d_ARG_NAMES_TAIL , x, y
#define glWindowPos2d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y
#define forward_glWindowPos2d(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2d(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2d(packed, ret_v) do { \
    glWindowPos2d_PACKED *unpacked = (glWindowPos2d_PACKED *)packed; \
    glWindowPos2d_ARGS *args = (glWindowPos2d_ARGS *)&unpacked->args; \
    glWindowPos2d(args->x, args->y);; \
} while(0)
void glWindowPos2d(glWindowPos2d_ARG_EXPAND);
packed_call_t *pack_glWindowPos2d(glWindowPos2d_PACKED *_dst glWindowPos2d_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2d_PTR)(glWindowPos2d_ARG_EXPAND);
#endif
#ifndef glWindowPos2dARB_RETURN
#define glWindowPos2dARB_RETURN void
#define glWindowPos2dARB_ARG_NAMES x, y
#define glWindowPos2dARB_ARG_EXPAND GLdouble x, GLdouble y
#define glWindowPos2dARB_ARG_NAMES_TAIL , x, y
#define glWindowPos2dARB_ARG_EXPAND_TAIL , GLdouble x, GLdouble y
#define forward_glWindowPos2dARB(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2dARB(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2dARB(packed, ret_v) do { \
    glWindowPos2dARB_PACKED *unpacked = (glWindowPos2dARB_PACKED *)packed; \
    glWindowPos2dARB_ARGS *args = (glWindowPos2dARB_ARGS *)&unpacked->args; \
    glWindowPos2dARB(args->x, args->y);; \
} while(0)
void glWindowPos2dARB(glWindowPos2dARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2dARB(glWindowPos2dARB_PACKED *_dst glWindowPos2dARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2dARB_PTR)(glWindowPos2dARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2dMESA_RETURN
#define glWindowPos2dMESA_RETURN void
#define glWindowPos2dMESA_ARG_NAMES x, y
#define glWindowPos2dMESA_ARG_EXPAND GLdouble x, GLdouble y
#define glWindowPos2dMESA_ARG_NAMES_TAIL , x, y
#define glWindowPos2dMESA_ARG_EXPAND_TAIL , GLdouble x, GLdouble y
#define forward_glWindowPos2dMESA(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2dMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2dMESA(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2dMESA(packed, ret_v) do { \
    glWindowPos2dMESA_PACKED *unpacked = (glWindowPos2dMESA_PACKED *)packed; \
    glWindowPos2dMESA_ARGS *args = (glWindowPos2dMESA_ARGS *)&unpacked->args; \
    glWindowPos2dMESA(args->x, args->y);; \
} while(0)
void glWindowPos2dMESA(glWindowPos2dMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2dMESA(glWindowPos2dMESA_PACKED *_dst glWindowPos2dMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2dMESA_PTR)(glWindowPos2dMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos2dv_RETURN
#define glWindowPos2dv_RETURN void
#define glWindowPos2dv_ARG_NAMES v
#define glWindowPos2dv_ARG_EXPAND const GLdouble * v
#define glWindowPos2dv_ARG_NAMES_TAIL , v
#define glWindowPos2dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glWindowPos2dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2dv(dst, _v), NULL); \
    });
#define call_glWindowPos2dv(packed, ret_v) do { \
    glWindowPos2dv_PACKED *unpacked = (glWindowPos2dv_PACKED *)packed; \
    glWindowPos2dv_ARGS *args = (glWindowPos2dv_ARGS *)&unpacked->args; \
    glWindowPos2dv(args->v);; \
} while(0)
void glWindowPos2dv(glWindowPos2dv_ARG_EXPAND);
packed_call_t *pack_glWindowPos2dv(glWindowPos2dv_PACKED *_dst glWindowPos2dv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2dv_PTR)(glWindowPos2dv_ARG_EXPAND);
#endif
#ifndef glWindowPos2dvARB_RETURN
#define glWindowPos2dvARB_RETURN void
#define glWindowPos2dvARB_ARG_NAMES v
#define glWindowPos2dvARB_ARG_EXPAND const GLdouble * v
#define glWindowPos2dvARB_ARG_NAMES_TAIL , v
#define glWindowPos2dvARB_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glWindowPos2dvARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2dvARB(dst, _v), NULL); \
    });
#define call_glWindowPos2dvARB(packed, ret_v) do { \
    glWindowPos2dvARB_PACKED *unpacked = (glWindowPos2dvARB_PACKED *)packed; \
    glWindowPos2dvARB_ARGS *args = (glWindowPos2dvARB_ARGS *)&unpacked->args; \
    glWindowPos2dvARB(args->v);; \
} while(0)
void glWindowPos2dvARB(glWindowPos2dvARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2dvARB(glWindowPos2dvARB_PACKED *_dst glWindowPos2dvARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2dvARB_PTR)(glWindowPos2dvARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2dvMESA_RETURN
#define glWindowPos2dvMESA_RETURN void
#define glWindowPos2dvMESA_ARG_NAMES v
#define glWindowPos2dvMESA_ARG_EXPAND const GLdouble * v
#define glWindowPos2dvMESA_ARG_NAMES_TAIL , v
#define glWindowPos2dvMESA_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glWindowPos2dvMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2dvMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2dvMESA(dst, _v), NULL); \
    });
#define call_glWindowPos2dvMESA(packed, ret_v) do { \
    glWindowPos2dvMESA_PACKED *unpacked = (glWindowPos2dvMESA_PACKED *)packed; \
    glWindowPos2dvMESA_ARGS *args = (glWindowPos2dvMESA_ARGS *)&unpacked->args; \
    glWindowPos2dvMESA(args->v);; \
} while(0)
void glWindowPos2dvMESA(glWindowPos2dvMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2dvMESA(glWindowPos2dvMESA_PACKED *_dst glWindowPos2dvMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2dvMESA_PTR)(glWindowPos2dvMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos2f_RETURN
#define glWindowPos2f_RETURN void
#define glWindowPos2f_ARG_NAMES x, y
#define glWindowPos2f_ARG_EXPAND GLfloat x, GLfloat y
#define glWindowPos2f_ARG_NAMES_TAIL , x, y
#define glWindowPos2f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y
#define forward_glWindowPos2f(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2f(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2f(packed, ret_v) do { \
    glWindowPos2f_PACKED *unpacked = (glWindowPos2f_PACKED *)packed; \
    glWindowPos2f_ARGS *args = (glWindowPos2f_ARGS *)&unpacked->args; \
    glWindowPos2f(args->x, args->y);; \
} while(0)
void glWindowPos2f(glWindowPos2f_ARG_EXPAND);
packed_call_t *pack_glWindowPos2f(glWindowPos2f_PACKED *_dst glWindowPos2f_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2f_PTR)(glWindowPos2f_ARG_EXPAND);
#endif
#ifndef glWindowPos2fARB_RETURN
#define glWindowPos2fARB_RETURN void
#define glWindowPos2fARB_ARG_NAMES x, y
#define glWindowPos2fARB_ARG_EXPAND GLfloat x, GLfloat y
#define glWindowPos2fARB_ARG_NAMES_TAIL , x, y
#define glWindowPos2fARB_ARG_EXPAND_TAIL , GLfloat x, GLfloat y
#define forward_glWindowPos2fARB(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2fARB(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2fARB(packed, ret_v) do { \
    glWindowPos2fARB_PACKED *unpacked = (glWindowPos2fARB_PACKED *)packed; \
    glWindowPos2fARB_ARGS *args = (glWindowPos2fARB_ARGS *)&unpacked->args; \
    glWindowPos2fARB(args->x, args->y);; \
} while(0)
void glWindowPos2fARB(glWindowPos2fARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2fARB(glWindowPos2fARB_PACKED *_dst glWindowPos2fARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2fARB_PTR)(glWindowPos2fARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2fMESA_RETURN
#define glWindowPos2fMESA_RETURN void
#define glWindowPos2fMESA_ARG_NAMES x, y
#define glWindowPos2fMESA_ARG_EXPAND GLfloat x, GLfloat y
#define glWindowPos2fMESA_ARG_NAMES_TAIL , x, y
#define glWindowPos2fMESA_ARG_EXPAND_TAIL , GLfloat x, GLfloat y
#define forward_glWindowPos2fMESA(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2fMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2fMESA(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2fMESA(packed, ret_v) do { \
    glWindowPos2fMESA_PACKED *unpacked = (glWindowPos2fMESA_PACKED *)packed; \
    glWindowPos2fMESA_ARGS *args = (glWindowPos2fMESA_ARGS *)&unpacked->args; \
    glWindowPos2fMESA(args->x, args->y);; \
} while(0)
void glWindowPos2fMESA(glWindowPos2fMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2fMESA(glWindowPos2fMESA_PACKED *_dst glWindowPos2fMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2fMESA_PTR)(glWindowPos2fMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos2fv_RETURN
#define glWindowPos2fv_RETURN void
#define glWindowPos2fv_ARG_NAMES v
#define glWindowPos2fv_ARG_EXPAND const GLfloat * v
#define glWindowPos2fv_ARG_NAMES_TAIL , v
#define glWindowPos2fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glWindowPos2fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2fv(dst, _v), NULL); \
    });
#define call_glWindowPos2fv(packed, ret_v) do { \
    glWindowPos2fv_PACKED *unpacked = (glWindowPos2fv_PACKED *)packed; \
    glWindowPos2fv_ARGS *args = (glWindowPos2fv_ARGS *)&unpacked->args; \
    glWindowPos2fv(args->v);; \
} while(0)
void glWindowPos2fv(glWindowPos2fv_ARG_EXPAND);
packed_call_t *pack_glWindowPos2fv(glWindowPos2fv_PACKED *_dst glWindowPos2fv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2fv_PTR)(glWindowPos2fv_ARG_EXPAND);
#endif
#ifndef glWindowPos2fvARB_RETURN
#define glWindowPos2fvARB_RETURN void
#define glWindowPos2fvARB_ARG_NAMES v
#define glWindowPos2fvARB_ARG_EXPAND const GLfloat * v
#define glWindowPos2fvARB_ARG_NAMES_TAIL , v
#define glWindowPos2fvARB_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glWindowPos2fvARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2fvARB(dst, _v), NULL); \
    });
#define call_glWindowPos2fvARB(packed, ret_v) do { \
    glWindowPos2fvARB_PACKED *unpacked = (glWindowPos2fvARB_PACKED *)packed; \
    glWindowPos2fvARB_ARGS *args = (glWindowPos2fvARB_ARGS *)&unpacked->args; \
    glWindowPos2fvARB(args->v);; \
} while(0)
void glWindowPos2fvARB(glWindowPos2fvARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2fvARB(glWindowPos2fvARB_PACKED *_dst glWindowPos2fvARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2fvARB_PTR)(glWindowPos2fvARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2fvMESA_RETURN
#define glWindowPos2fvMESA_RETURN void
#define glWindowPos2fvMESA_ARG_NAMES v
#define glWindowPos2fvMESA_ARG_EXPAND const GLfloat * v
#define glWindowPos2fvMESA_ARG_NAMES_TAIL , v
#define glWindowPos2fvMESA_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glWindowPos2fvMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2fvMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2fvMESA(dst, _v), NULL); \
    });
#define call_glWindowPos2fvMESA(packed, ret_v) do { \
    glWindowPos2fvMESA_PACKED *unpacked = (glWindowPos2fvMESA_PACKED *)packed; \
    glWindowPos2fvMESA_ARGS *args = (glWindowPos2fvMESA_ARGS *)&unpacked->args; \
    glWindowPos2fvMESA(args->v);; \
} while(0)
void glWindowPos2fvMESA(glWindowPos2fvMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2fvMESA(glWindowPos2fvMESA_PACKED *_dst glWindowPos2fvMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2fvMESA_PTR)(glWindowPos2fvMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos2i_RETURN
#define glWindowPos2i_RETURN void
#define glWindowPos2i_ARG_NAMES x, y
#define glWindowPos2i_ARG_EXPAND GLint x, GLint y
#define glWindowPos2i_ARG_NAMES_TAIL , x, y
#define glWindowPos2i_ARG_EXPAND_TAIL , GLint x, GLint y
#define forward_glWindowPos2i(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2i(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2i(packed, ret_v) do { \
    glWindowPos2i_PACKED *unpacked = (glWindowPos2i_PACKED *)packed; \
    glWindowPos2i_ARGS *args = (glWindowPos2i_ARGS *)&unpacked->args; \
    glWindowPos2i(args->x, args->y);; \
} while(0)
void glWindowPos2i(glWindowPos2i_ARG_EXPAND);
packed_call_t *pack_glWindowPos2i(glWindowPos2i_PACKED *_dst glWindowPos2i_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2i_PTR)(glWindowPos2i_ARG_EXPAND);
#endif
#ifndef glWindowPos2iARB_RETURN
#define glWindowPos2iARB_RETURN void
#define glWindowPos2iARB_ARG_NAMES x, y
#define glWindowPos2iARB_ARG_EXPAND GLint x, GLint y
#define glWindowPos2iARB_ARG_NAMES_TAIL , x, y
#define glWindowPos2iARB_ARG_EXPAND_TAIL , GLint x, GLint y
#define forward_glWindowPos2iARB(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2iARB(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2iARB(packed, ret_v) do { \
    glWindowPos2iARB_PACKED *unpacked = (glWindowPos2iARB_PACKED *)packed; \
    glWindowPos2iARB_ARGS *args = (glWindowPos2iARB_ARGS *)&unpacked->args; \
    glWindowPos2iARB(args->x, args->y);; \
} while(0)
void glWindowPos2iARB(glWindowPos2iARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2iARB(glWindowPos2iARB_PACKED *_dst glWindowPos2iARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2iARB_PTR)(glWindowPos2iARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2iMESA_RETURN
#define glWindowPos2iMESA_RETURN void
#define glWindowPos2iMESA_ARG_NAMES x, y
#define glWindowPos2iMESA_ARG_EXPAND GLint x, GLint y
#define glWindowPos2iMESA_ARG_NAMES_TAIL , x, y
#define glWindowPos2iMESA_ARG_EXPAND_TAIL , GLint x, GLint y
#define forward_glWindowPos2iMESA(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2iMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2iMESA(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2iMESA(packed, ret_v) do { \
    glWindowPos2iMESA_PACKED *unpacked = (glWindowPos2iMESA_PACKED *)packed; \
    glWindowPos2iMESA_ARGS *args = (glWindowPos2iMESA_ARGS *)&unpacked->args; \
    glWindowPos2iMESA(args->x, args->y);; \
} while(0)
void glWindowPos2iMESA(glWindowPos2iMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2iMESA(glWindowPos2iMESA_PACKED *_dst glWindowPos2iMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2iMESA_PTR)(glWindowPos2iMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos2iv_RETURN
#define glWindowPos2iv_RETURN void
#define glWindowPos2iv_ARG_NAMES v
#define glWindowPos2iv_ARG_EXPAND const GLint * v
#define glWindowPos2iv_ARG_NAMES_TAIL , v
#define glWindowPos2iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glWindowPos2iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2iv(dst, _v), NULL); \
    });
#define call_glWindowPos2iv(packed, ret_v) do { \
    glWindowPos2iv_PACKED *unpacked = (glWindowPos2iv_PACKED *)packed; \
    glWindowPos2iv_ARGS *args = (glWindowPos2iv_ARGS *)&unpacked->args; \
    glWindowPos2iv(args->v);; \
} while(0)
void glWindowPos2iv(glWindowPos2iv_ARG_EXPAND);
packed_call_t *pack_glWindowPos2iv(glWindowPos2iv_PACKED *_dst glWindowPos2iv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2iv_PTR)(glWindowPos2iv_ARG_EXPAND);
#endif
#ifndef glWindowPos2ivARB_RETURN
#define glWindowPos2ivARB_RETURN void
#define glWindowPos2ivARB_ARG_NAMES v
#define glWindowPos2ivARB_ARG_EXPAND const GLint * v
#define glWindowPos2ivARB_ARG_NAMES_TAIL , v
#define glWindowPos2ivARB_ARG_EXPAND_TAIL , const GLint * v
#define forward_glWindowPos2ivARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2ivARB(dst, _v), NULL); \
    });
#define call_glWindowPos2ivARB(packed, ret_v) do { \
    glWindowPos2ivARB_PACKED *unpacked = (glWindowPos2ivARB_PACKED *)packed; \
    glWindowPos2ivARB_ARGS *args = (glWindowPos2ivARB_ARGS *)&unpacked->args; \
    glWindowPos2ivARB(args->v);; \
} while(0)
void glWindowPos2ivARB(glWindowPos2ivARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2ivARB(glWindowPos2ivARB_PACKED *_dst glWindowPos2ivARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2ivARB_PTR)(glWindowPos2ivARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2ivMESA_RETURN
#define glWindowPos2ivMESA_RETURN void
#define glWindowPos2ivMESA_ARG_NAMES v
#define glWindowPos2ivMESA_ARG_EXPAND const GLint * v
#define glWindowPos2ivMESA_ARG_NAMES_TAIL , v
#define glWindowPos2ivMESA_ARG_EXPAND_TAIL , const GLint * v
#define forward_glWindowPos2ivMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2ivMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2ivMESA(dst, _v), NULL); \
    });
#define call_glWindowPos2ivMESA(packed, ret_v) do { \
    glWindowPos2ivMESA_PACKED *unpacked = (glWindowPos2ivMESA_PACKED *)packed; \
    glWindowPos2ivMESA_ARGS *args = (glWindowPos2ivMESA_ARGS *)&unpacked->args; \
    glWindowPos2ivMESA(args->v);; \
} while(0)
void glWindowPos2ivMESA(glWindowPos2ivMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2ivMESA(glWindowPos2ivMESA_PACKED *_dst glWindowPos2ivMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2ivMESA_PTR)(glWindowPos2ivMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos2s_RETURN
#define glWindowPos2s_RETURN void
#define glWindowPos2s_ARG_NAMES x, y
#define glWindowPos2s_ARG_EXPAND GLshort x, GLshort y
#define glWindowPos2s_ARG_NAMES_TAIL , x, y
#define glWindowPos2s_ARG_EXPAND_TAIL , GLshort x, GLshort y
#define forward_glWindowPos2s(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2s(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2s(packed, ret_v) do { \
    glWindowPos2s_PACKED *unpacked = (glWindowPos2s_PACKED *)packed; \
    glWindowPos2s_ARGS *args = (glWindowPos2s_ARGS *)&unpacked->args; \
    glWindowPos2s(args->x, args->y);; \
} while(0)
void glWindowPos2s(glWindowPos2s_ARG_EXPAND);
packed_call_t *pack_glWindowPos2s(glWindowPos2s_PACKED *_dst glWindowPos2s_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2s_PTR)(glWindowPos2s_ARG_EXPAND);
#endif
#ifndef glWindowPos2sARB_RETURN
#define glWindowPos2sARB_RETURN void
#define glWindowPos2sARB_ARG_NAMES x, y
#define glWindowPos2sARB_ARG_EXPAND GLshort x, GLshort y
#define glWindowPos2sARB_ARG_NAMES_TAIL , x, y
#define glWindowPos2sARB_ARG_EXPAND_TAIL , GLshort x, GLshort y
#define forward_glWindowPos2sARB(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2sARB(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2sARB(packed, ret_v) do { \
    glWindowPos2sARB_PACKED *unpacked = (glWindowPos2sARB_PACKED *)packed; \
    glWindowPos2sARB_ARGS *args = (glWindowPos2sARB_ARGS *)&unpacked->args; \
    glWindowPos2sARB(args->x, args->y);; \
} while(0)
void glWindowPos2sARB(glWindowPos2sARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2sARB(glWindowPos2sARB_PACKED *_dst glWindowPos2sARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2sARB_PTR)(glWindowPos2sARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2sMESA_RETURN
#define glWindowPos2sMESA_RETURN void
#define glWindowPos2sMESA_ARG_NAMES x, y
#define glWindowPos2sMESA_ARG_EXPAND GLshort x, GLshort y
#define glWindowPos2sMESA_ARG_NAMES_TAIL , x, y
#define glWindowPos2sMESA_ARG_EXPAND_TAIL , GLshort x, GLshort y
#define forward_glWindowPos2sMESA(_x, _y) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2sMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2sMESA(dst, _x, _y), NULL); \
    });
#define call_glWindowPos2sMESA(packed, ret_v) do { \
    glWindowPos2sMESA_PACKED *unpacked = (glWindowPos2sMESA_PACKED *)packed; \
    glWindowPos2sMESA_ARGS *args = (glWindowPos2sMESA_ARGS *)&unpacked->args; \
    glWindowPos2sMESA(args->x, args->y);; \
} while(0)
void glWindowPos2sMESA(glWindowPos2sMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2sMESA(glWindowPos2sMESA_PACKED *_dst glWindowPos2sMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2sMESA_PTR)(glWindowPos2sMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos2sv_RETURN
#define glWindowPos2sv_RETURN void
#define glWindowPos2sv_ARG_NAMES v
#define glWindowPos2sv_ARG_EXPAND const GLshort * v
#define glWindowPos2sv_ARG_NAMES_TAIL , v
#define glWindowPos2sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glWindowPos2sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2sv(dst, _v), NULL); \
    });
#define call_glWindowPos2sv(packed, ret_v) do { \
    glWindowPos2sv_PACKED *unpacked = (glWindowPos2sv_PACKED *)packed; \
    glWindowPos2sv_ARGS *args = (glWindowPos2sv_ARGS *)&unpacked->args; \
    glWindowPos2sv(args->v);; \
} while(0)
void glWindowPos2sv(glWindowPos2sv_ARG_EXPAND);
packed_call_t *pack_glWindowPos2sv(glWindowPos2sv_PACKED *_dst glWindowPos2sv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2sv_PTR)(glWindowPos2sv_ARG_EXPAND);
#endif
#ifndef glWindowPos2svARB_RETURN
#define glWindowPos2svARB_RETURN void
#define glWindowPos2svARB_ARG_NAMES v
#define glWindowPos2svARB_ARG_EXPAND const GLshort * v
#define glWindowPos2svARB_ARG_NAMES_TAIL , v
#define glWindowPos2svARB_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glWindowPos2svARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2svARB(dst, _v), NULL); \
    });
#define call_glWindowPos2svARB(packed, ret_v) do { \
    glWindowPos2svARB_PACKED *unpacked = (glWindowPos2svARB_PACKED *)packed; \
    glWindowPos2svARB_ARGS *args = (glWindowPos2svARB_ARGS *)&unpacked->args; \
    glWindowPos2svARB(args->v);; \
} while(0)
void glWindowPos2svARB(glWindowPos2svARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos2svARB(glWindowPos2svARB_PACKED *_dst glWindowPos2svARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2svARB_PTR)(glWindowPos2svARB_ARG_EXPAND);
#endif
#ifndef glWindowPos2svMESA_RETURN
#define glWindowPos2svMESA_RETURN void
#define glWindowPos2svMESA_ARG_NAMES v
#define glWindowPos2svMESA_ARG_EXPAND const GLshort * v
#define glWindowPos2svMESA_ARG_NAMES_TAIL , v
#define glWindowPos2svMESA_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glWindowPos2svMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos2svMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos2svMESA(dst, _v), NULL); \
    });
#define call_glWindowPos2svMESA(packed, ret_v) do { \
    glWindowPos2svMESA_PACKED *unpacked = (glWindowPos2svMESA_PACKED *)packed; \
    glWindowPos2svMESA_ARGS *args = (glWindowPos2svMESA_ARGS *)&unpacked->args; \
    glWindowPos2svMESA(args->v);; \
} while(0)
void glWindowPos2svMESA(glWindowPos2svMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos2svMESA(glWindowPos2svMESA_PACKED *_dst glWindowPos2svMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos2svMESA_PTR)(glWindowPos2svMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3d_RETURN
#define glWindowPos3d_RETURN void
#define glWindowPos3d_ARG_NAMES x, y, z
#define glWindowPos3d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glWindowPos3d_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3d_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z
#define forward_glWindowPos3d(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3d_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3d(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3d(packed, ret_v) do { \
    glWindowPos3d_PACKED *unpacked = (glWindowPos3d_PACKED *)packed; \
    glWindowPos3d_ARGS *args = (glWindowPos3d_ARGS *)&unpacked->args; \
    glWindowPos3d(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3d(glWindowPos3d_ARG_EXPAND);
packed_call_t *pack_glWindowPos3d(glWindowPos3d_PACKED *_dst glWindowPos3d_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3d_PTR)(glWindowPos3d_ARG_EXPAND);
#endif
#ifndef glWindowPos3dARB_RETURN
#define glWindowPos3dARB_RETURN void
#define glWindowPos3dARB_ARG_NAMES x, y, z
#define glWindowPos3dARB_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glWindowPos3dARB_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3dARB_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z
#define forward_glWindowPos3dARB(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3dARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3dARB(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3dARB(packed, ret_v) do { \
    glWindowPos3dARB_PACKED *unpacked = (glWindowPos3dARB_PACKED *)packed; \
    glWindowPos3dARB_ARGS *args = (glWindowPos3dARB_ARGS *)&unpacked->args; \
    glWindowPos3dARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3dARB(glWindowPos3dARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3dARB(glWindowPos3dARB_PACKED *_dst glWindowPos3dARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3dARB_PTR)(glWindowPos3dARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3dMESA_RETURN
#define glWindowPos3dMESA_RETURN void
#define glWindowPos3dMESA_ARG_NAMES x, y, z
#define glWindowPos3dMESA_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glWindowPos3dMESA_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3dMESA_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z
#define forward_glWindowPos3dMESA(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3dMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3dMESA(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3dMESA(packed, ret_v) do { \
    glWindowPos3dMESA_PACKED *unpacked = (glWindowPos3dMESA_PACKED *)packed; \
    glWindowPos3dMESA_ARGS *args = (glWindowPos3dMESA_ARGS *)&unpacked->args; \
    glWindowPos3dMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3dMESA(glWindowPos3dMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3dMESA(glWindowPos3dMESA_PACKED *_dst glWindowPos3dMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3dMESA_PTR)(glWindowPos3dMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3dv_RETURN
#define glWindowPos3dv_RETURN void
#define glWindowPos3dv_ARG_NAMES v
#define glWindowPos3dv_ARG_EXPAND const GLdouble * v
#define glWindowPos3dv_ARG_NAMES_TAIL , v
#define glWindowPos3dv_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glWindowPos3dv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3dv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3dv(dst, _v), NULL); \
    });
#define call_glWindowPos3dv(packed, ret_v) do { \
    glWindowPos3dv_PACKED *unpacked = (glWindowPos3dv_PACKED *)packed; \
    glWindowPos3dv_ARGS *args = (glWindowPos3dv_ARGS *)&unpacked->args; \
    glWindowPos3dv(args->v);; \
} while(0)
void glWindowPos3dv(glWindowPos3dv_ARG_EXPAND);
packed_call_t *pack_glWindowPos3dv(glWindowPos3dv_PACKED *_dst glWindowPos3dv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3dv_PTR)(glWindowPos3dv_ARG_EXPAND);
#endif
#ifndef glWindowPos3dvARB_RETURN
#define glWindowPos3dvARB_RETURN void
#define glWindowPos3dvARB_ARG_NAMES v
#define glWindowPos3dvARB_ARG_EXPAND const GLdouble * v
#define glWindowPos3dvARB_ARG_NAMES_TAIL , v
#define glWindowPos3dvARB_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glWindowPos3dvARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3dvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3dvARB(dst, _v), NULL); \
    });
#define call_glWindowPos3dvARB(packed, ret_v) do { \
    glWindowPos3dvARB_PACKED *unpacked = (glWindowPos3dvARB_PACKED *)packed; \
    glWindowPos3dvARB_ARGS *args = (glWindowPos3dvARB_ARGS *)&unpacked->args; \
    glWindowPos3dvARB(args->v);; \
} while(0)
void glWindowPos3dvARB(glWindowPos3dvARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3dvARB(glWindowPos3dvARB_PACKED *_dst glWindowPos3dvARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3dvARB_PTR)(glWindowPos3dvARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3dvMESA_RETURN
#define glWindowPos3dvMESA_RETURN void
#define glWindowPos3dvMESA_ARG_NAMES v
#define glWindowPos3dvMESA_ARG_EXPAND const GLdouble * v
#define glWindowPos3dvMESA_ARG_NAMES_TAIL , v
#define glWindowPos3dvMESA_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glWindowPos3dvMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3dvMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3dvMESA(dst, _v), NULL); \
    });
#define call_glWindowPos3dvMESA(packed, ret_v) do { \
    glWindowPos3dvMESA_PACKED *unpacked = (glWindowPos3dvMESA_PACKED *)packed; \
    glWindowPos3dvMESA_ARGS *args = (glWindowPos3dvMESA_ARGS *)&unpacked->args; \
    glWindowPos3dvMESA(args->v);; \
} while(0)
void glWindowPos3dvMESA(glWindowPos3dvMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3dvMESA(glWindowPos3dvMESA_PACKED *_dst glWindowPos3dvMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3dvMESA_PTR)(glWindowPos3dvMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3f_RETURN
#define glWindowPos3f_RETURN void
#define glWindowPos3f_ARG_NAMES x, y, z
#define glWindowPos3f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glWindowPos3f_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3f_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z
#define forward_glWindowPos3f(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3f_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3f(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3f(packed, ret_v) do { \
    glWindowPos3f_PACKED *unpacked = (glWindowPos3f_PACKED *)packed; \
    glWindowPos3f_ARGS *args = (glWindowPos3f_ARGS *)&unpacked->args; \
    glWindowPos3f(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3f(glWindowPos3f_ARG_EXPAND);
packed_call_t *pack_glWindowPos3f(glWindowPos3f_PACKED *_dst glWindowPos3f_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3f_PTR)(glWindowPos3f_ARG_EXPAND);
#endif
#ifndef glWindowPos3fARB_RETURN
#define glWindowPos3fARB_RETURN void
#define glWindowPos3fARB_ARG_NAMES x, y, z
#define glWindowPos3fARB_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glWindowPos3fARB_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3fARB_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z
#define forward_glWindowPos3fARB(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3fARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3fARB(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3fARB(packed, ret_v) do { \
    glWindowPos3fARB_PACKED *unpacked = (glWindowPos3fARB_PACKED *)packed; \
    glWindowPos3fARB_ARGS *args = (glWindowPos3fARB_ARGS *)&unpacked->args; \
    glWindowPos3fARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3fARB(glWindowPos3fARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3fARB(glWindowPos3fARB_PACKED *_dst glWindowPos3fARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3fARB_PTR)(glWindowPos3fARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3fMESA_RETURN
#define glWindowPos3fMESA_RETURN void
#define glWindowPos3fMESA_ARG_NAMES x, y, z
#define glWindowPos3fMESA_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glWindowPos3fMESA_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3fMESA_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z
#define forward_glWindowPos3fMESA(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3fMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3fMESA(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3fMESA(packed, ret_v) do { \
    glWindowPos3fMESA_PACKED *unpacked = (glWindowPos3fMESA_PACKED *)packed; \
    glWindowPos3fMESA_ARGS *args = (glWindowPos3fMESA_ARGS *)&unpacked->args; \
    glWindowPos3fMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3fMESA(glWindowPos3fMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3fMESA(glWindowPos3fMESA_PACKED *_dst glWindowPos3fMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3fMESA_PTR)(glWindowPos3fMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3fv_RETURN
#define glWindowPos3fv_RETURN void
#define glWindowPos3fv_ARG_NAMES v
#define glWindowPos3fv_ARG_EXPAND const GLfloat * v
#define glWindowPos3fv_ARG_NAMES_TAIL , v
#define glWindowPos3fv_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glWindowPos3fv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3fv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3fv(dst, _v), NULL); \
    });
#define call_glWindowPos3fv(packed, ret_v) do { \
    glWindowPos3fv_PACKED *unpacked = (glWindowPos3fv_PACKED *)packed; \
    glWindowPos3fv_ARGS *args = (glWindowPos3fv_ARGS *)&unpacked->args; \
    glWindowPos3fv(args->v);; \
} while(0)
void glWindowPos3fv(glWindowPos3fv_ARG_EXPAND);
packed_call_t *pack_glWindowPos3fv(glWindowPos3fv_PACKED *_dst glWindowPos3fv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3fv_PTR)(glWindowPos3fv_ARG_EXPAND);
#endif
#ifndef glWindowPos3fvARB_RETURN
#define glWindowPos3fvARB_RETURN void
#define glWindowPos3fvARB_ARG_NAMES v
#define glWindowPos3fvARB_ARG_EXPAND const GLfloat * v
#define glWindowPos3fvARB_ARG_NAMES_TAIL , v
#define glWindowPos3fvARB_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glWindowPos3fvARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3fvARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3fvARB(dst, _v), NULL); \
    });
#define call_glWindowPos3fvARB(packed, ret_v) do { \
    glWindowPos3fvARB_PACKED *unpacked = (glWindowPos3fvARB_PACKED *)packed; \
    glWindowPos3fvARB_ARGS *args = (glWindowPos3fvARB_ARGS *)&unpacked->args; \
    glWindowPos3fvARB(args->v);; \
} while(0)
void glWindowPos3fvARB(glWindowPos3fvARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3fvARB(glWindowPos3fvARB_PACKED *_dst glWindowPos3fvARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3fvARB_PTR)(glWindowPos3fvARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3fvMESA_RETURN
#define glWindowPos3fvMESA_RETURN void
#define glWindowPos3fvMESA_ARG_NAMES v
#define glWindowPos3fvMESA_ARG_EXPAND const GLfloat * v
#define glWindowPos3fvMESA_ARG_NAMES_TAIL , v
#define glWindowPos3fvMESA_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glWindowPos3fvMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3fvMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3fvMESA(dst, _v), NULL); \
    });
#define call_glWindowPos3fvMESA(packed, ret_v) do { \
    glWindowPos3fvMESA_PACKED *unpacked = (glWindowPos3fvMESA_PACKED *)packed; \
    glWindowPos3fvMESA_ARGS *args = (glWindowPos3fvMESA_ARGS *)&unpacked->args; \
    glWindowPos3fvMESA(args->v);; \
} while(0)
void glWindowPos3fvMESA(glWindowPos3fvMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3fvMESA(glWindowPos3fvMESA_PACKED *_dst glWindowPos3fvMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3fvMESA_PTR)(glWindowPos3fvMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3i_RETURN
#define glWindowPos3i_RETURN void
#define glWindowPos3i_ARG_NAMES x, y, z
#define glWindowPos3i_ARG_EXPAND GLint x, GLint y, GLint z
#define glWindowPos3i_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3i_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z
#define forward_glWindowPos3i(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3i_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3i(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3i(packed, ret_v) do { \
    glWindowPos3i_PACKED *unpacked = (glWindowPos3i_PACKED *)packed; \
    glWindowPos3i_ARGS *args = (glWindowPos3i_ARGS *)&unpacked->args; \
    glWindowPos3i(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3i(glWindowPos3i_ARG_EXPAND);
packed_call_t *pack_glWindowPos3i(glWindowPos3i_PACKED *_dst glWindowPos3i_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3i_PTR)(glWindowPos3i_ARG_EXPAND);
#endif
#ifndef glWindowPos3iARB_RETURN
#define glWindowPos3iARB_RETURN void
#define glWindowPos3iARB_ARG_NAMES x, y, z
#define glWindowPos3iARB_ARG_EXPAND GLint x, GLint y, GLint z
#define glWindowPos3iARB_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3iARB_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z
#define forward_glWindowPos3iARB(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3iARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3iARB(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3iARB(packed, ret_v) do { \
    glWindowPos3iARB_PACKED *unpacked = (glWindowPos3iARB_PACKED *)packed; \
    glWindowPos3iARB_ARGS *args = (glWindowPos3iARB_ARGS *)&unpacked->args; \
    glWindowPos3iARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3iARB(glWindowPos3iARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3iARB(glWindowPos3iARB_PACKED *_dst glWindowPos3iARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3iARB_PTR)(glWindowPos3iARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3iMESA_RETURN
#define glWindowPos3iMESA_RETURN void
#define glWindowPos3iMESA_ARG_NAMES x, y, z
#define glWindowPos3iMESA_ARG_EXPAND GLint x, GLint y, GLint z
#define glWindowPos3iMESA_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3iMESA_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z
#define forward_glWindowPos3iMESA(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3iMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3iMESA(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3iMESA(packed, ret_v) do { \
    glWindowPos3iMESA_PACKED *unpacked = (glWindowPos3iMESA_PACKED *)packed; \
    glWindowPos3iMESA_ARGS *args = (glWindowPos3iMESA_ARGS *)&unpacked->args; \
    glWindowPos3iMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3iMESA(glWindowPos3iMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3iMESA(glWindowPos3iMESA_PACKED *_dst glWindowPos3iMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3iMESA_PTR)(glWindowPos3iMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3iv_RETURN
#define glWindowPos3iv_RETURN void
#define glWindowPos3iv_ARG_NAMES v
#define glWindowPos3iv_ARG_EXPAND const GLint * v
#define glWindowPos3iv_ARG_NAMES_TAIL , v
#define glWindowPos3iv_ARG_EXPAND_TAIL , const GLint * v
#define forward_glWindowPos3iv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3iv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3iv(dst, _v), NULL); \
    });
#define call_glWindowPos3iv(packed, ret_v) do { \
    glWindowPos3iv_PACKED *unpacked = (glWindowPos3iv_PACKED *)packed; \
    glWindowPos3iv_ARGS *args = (glWindowPos3iv_ARGS *)&unpacked->args; \
    glWindowPos3iv(args->v);; \
} while(0)
void glWindowPos3iv(glWindowPos3iv_ARG_EXPAND);
packed_call_t *pack_glWindowPos3iv(glWindowPos3iv_PACKED *_dst glWindowPos3iv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3iv_PTR)(glWindowPos3iv_ARG_EXPAND);
#endif
#ifndef glWindowPos3ivARB_RETURN
#define glWindowPos3ivARB_RETURN void
#define glWindowPos3ivARB_ARG_NAMES v
#define glWindowPos3ivARB_ARG_EXPAND const GLint * v
#define glWindowPos3ivARB_ARG_NAMES_TAIL , v
#define glWindowPos3ivARB_ARG_EXPAND_TAIL , const GLint * v
#define forward_glWindowPos3ivARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3ivARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3ivARB(dst, _v), NULL); \
    });
#define call_glWindowPos3ivARB(packed, ret_v) do { \
    glWindowPos3ivARB_PACKED *unpacked = (glWindowPos3ivARB_PACKED *)packed; \
    glWindowPos3ivARB_ARGS *args = (glWindowPos3ivARB_ARGS *)&unpacked->args; \
    glWindowPos3ivARB(args->v);; \
} while(0)
void glWindowPos3ivARB(glWindowPos3ivARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3ivARB(glWindowPos3ivARB_PACKED *_dst glWindowPos3ivARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3ivARB_PTR)(glWindowPos3ivARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3ivMESA_RETURN
#define glWindowPos3ivMESA_RETURN void
#define glWindowPos3ivMESA_ARG_NAMES v
#define glWindowPos3ivMESA_ARG_EXPAND const GLint * v
#define glWindowPos3ivMESA_ARG_NAMES_TAIL , v
#define glWindowPos3ivMESA_ARG_EXPAND_TAIL , const GLint * v
#define forward_glWindowPos3ivMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3ivMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3ivMESA(dst, _v), NULL); \
    });
#define call_glWindowPos3ivMESA(packed, ret_v) do { \
    glWindowPos3ivMESA_PACKED *unpacked = (glWindowPos3ivMESA_PACKED *)packed; \
    glWindowPos3ivMESA_ARGS *args = (glWindowPos3ivMESA_ARGS *)&unpacked->args; \
    glWindowPos3ivMESA(args->v);; \
} while(0)
void glWindowPos3ivMESA(glWindowPos3ivMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3ivMESA(glWindowPos3ivMESA_PACKED *_dst glWindowPos3ivMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3ivMESA_PTR)(glWindowPos3ivMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3s_RETURN
#define glWindowPos3s_RETURN void
#define glWindowPos3s_ARG_NAMES x, y, z
#define glWindowPos3s_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glWindowPos3s_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3s_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z
#define forward_glWindowPos3s(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3s_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3s(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3s(packed, ret_v) do { \
    glWindowPos3s_PACKED *unpacked = (glWindowPos3s_PACKED *)packed; \
    glWindowPos3s_ARGS *args = (glWindowPos3s_ARGS *)&unpacked->args; \
    glWindowPos3s(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3s(glWindowPos3s_ARG_EXPAND);
packed_call_t *pack_glWindowPos3s(glWindowPos3s_PACKED *_dst glWindowPos3s_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3s_PTR)(glWindowPos3s_ARG_EXPAND);
#endif
#ifndef glWindowPos3sARB_RETURN
#define glWindowPos3sARB_RETURN void
#define glWindowPos3sARB_ARG_NAMES x, y, z
#define glWindowPos3sARB_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glWindowPos3sARB_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3sARB_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z
#define forward_glWindowPos3sARB(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3sARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3sARB(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3sARB(packed, ret_v) do { \
    glWindowPos3sARB_PACKED *unpacked = (glWindowPos3sARB_PACKED *)packed; \
    glWindowPos3sARB_ARGS *args = (glWindowPos3sARB_ARGS *)&unpacked->args; \
    glWindowPos3sARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3sARB(glWindowPos3sARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3sARB(glWindowPos3sARB_PACKED *_dst glWindowPos3sARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3sARB_PTR)(glWindowPos3sARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3sMESA_RETURN
#define glWindowPos3sMESA_RETURN void
#define glWindowPos3sMESA_ARG_NAMES x, y, z
#define glWindowPos3sMESA_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glWindowPos3sMESA_ARG_NAMES_TAIL , x, y, z
#define glWindowPos3sMESA_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z
#define forward_glWindowPos3sMESA(_x, _y, _z) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3sMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3sMESA(dst, _x, _y, _z), NULL); \
    });
#define call_glWindowPos3sMESA(packed, ret_v) do { \
    glWindowPos3sMESA_PACKED *unpacked = (glWindowPos3sMESA_PACKED *)packed; \
    glWindowPos3sMESA_ARGS *args = (glWindowPos3sMESA_ARGS *)&unpacked->args; \
    glWindowPos3sMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3sMESA(glWindowPos3sMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3sMESA(glWindowPos3sMESA_PACKED *_dst glWindowPos3sMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3sMESA_PTR)(glWindowPos3sMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos3sv_RETURN
#define glWindowPos3sv_RETURN void
#define glWindowPos3sv_ARG_NAMES v
#define glWindowPos3sv_ARG_EXPAND const GLshort * v
#define glWindowPos3sv_ARG_NAMES_TAIL , v
#define glWindowPos3sv_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glWindowPos3sv(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3sv_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3sv(dst, _v), NULL); \
    });
#define call_glWindowPos3sv(packed, ret_v) do { \
    glWindowPos3sv_PACKED *unpacked = (glWindowPos3sv_PACKED *)packed; \
    glWindowPos3sv_ARGS *args = (glWindowPos3sv_ARGS *)&unpacked->args; \
    glWindowPos3sv(args->v);; \
} while(0)
void glWindowPos3sv(glWindowPos3sv_ARG_EXPAND);
packed_call_t *pack_glWindowPos3sv(glWindowPos3sv_PACKED *_dst glWindowPos3sv_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3sv_PTR)(glWindowPos3sv_ARG_EXPAND);
#endif
#ifndef glWindowPos3svARB_RETURN
#define glWindowPos3svARB_RETURN void
#define glWindowPos3svARB_ARG_NAMES v
#define glWindowPos3svARB_ARG_EXPAND const GLshort * v
#define glWindowPos3svARB_ARG_NAMES_TAIL , v
#define glWindowPos3svARB_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glWindowPos3svARB(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3svARB_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3svARB(dst, _v), NULL); \
    });
#define call_glWindowPos3svARB(packed, ret_v) do { \
    glWindowPos3svARB_PACKED *unpacked = (glWindowPos3svARB_PACKED *)packed; \
    glWindowPos3svARB_ARGS *args = (glWindowPos3svARB_ARGS *)&unpacked->args; \
    glWindowPos3svARB(args->v);; \
} while(0)
void glWindowPos3svARB(glWindowPos3svARB_ARG_EXPAND);
packed_call_t *pack_glWindowPos3svARB(glWindowPos3svARB_PACKED *_dst glWindowPos3svARB_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3svARB_PTR)(glWindowPos3svARB_ARG_EXPAND);
#endif
#ifndef glWindowPos3svMESA_RETURN
#define glWindowPos3svMESA_RETURN void
#define glWindowPos3svMESA_ARG_NAMES v
#define glWindowPos3svMESA_ARG_EXPAND const GLshort * v
#define glWindowPos3svMESA_ARG_NAMES_TAIL , v
#define glWindowPos3svMESA_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glWindowPos3svMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos3svMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos3svMESA(dst, _v), NULL); \
    });
#define call_glWindowPos3svMESA(packed, ret_v) do { \
    glWindowPos3svMESA_PACKED *unpacked = (glWindowPos3svMESA_PACKED *)packed; \
    glWindowPos3svMESA_ARGS *args = (glWindowPos3svMESA_ARGS *)&unpacked->args; \
    glWindowPos3svMESA(args->v);; \
} while(0)
void glWindowPos3svMESA(glWindowPos3svMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos3svMESA(glWindowPos3svMESA_PACKED *_dst glWindowPos3svMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos3svMESA_PTR)(glWindowPos3svMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4dMESA_RETURN
#define glWindowPos4dMESA_RETURN void
#define glWindowPos4dMESA_ARG_NAMES x, y, z, w
#define glWindowPos4dMESA_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glWindowPos4dMESA_ARG_NAMES_TAIL , x, y, z, w
#define glWindowPos4dMESA_ARG_EXPAND_TAIL , GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define forward_glWindowPos4dMESA(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4dMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4dMESA(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glWindowPos4dMESA(packed, ret_v) do { \
    glWindowPos4dMESA_PACKED *unpacked = (glWindowPos4dMESA_PACKED *)packed; \
    glWindowPos4dMESA_ARGS *args = (glWindowPos4dMESA_ARGS *)&unpacked->args; \
    glWindowPos4dMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4dMESA(glWindowPos4dMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4dMESA(glWindowPos4dMESA_PACKED *_dst glWindowPos4dMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4dMESA_PTR)(glWindowPos4dMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4dvMESA_RETURN
#define glWindowPos4dvMESA_RETURN void
#define glWindowPos4dvMESA_ARG_NAMES v
#define glWindowPos4dvMESA_ARG_EXPAND const GLdouble * v
#define glWindowPos4dvMESA_ARG_NAMES_TAIL , v
#define glWindowPos4dvMESA_ARG_EXPAND_TAIL , const GLdouble * v
#define forward_glWindowPos4dvMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4dvMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4dvMESA(dst, _v), NULL); \
    });
#define call_glWindowPos4dvMESA(packed, ret_v) do { \
    glWindowPos4dvMESA_PACKED *unpacked = (glWindowPos4dvMESA_PACKED *)packed; \
    glWindowPos4dvMESA_ARGS *args = (glWindowPos4dvMESA_ARGS *)&unpacked->args; \
    glWindowPos4dvMESA(args->v);; \
} while(0)
void glWindowPos4dvMESA(glWindowPos4dvMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4dvMESA(glWindowPos4dvMESA_PACKED *_dst glWindowPos4dvMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4dvMESA_PTR)(glWindowPos4dvMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4fMESA_RETURN
#define glWindowPos4fMESA_RETURN void
#define glWindowPos4fMESA_ARG_NAMES x, y, z, w
#define glWindowPos4fMESA_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glWindowPos4fMESA_ARG_NAMES_TAIL , x, y, z, w
#define glWindowPos4fMESA_ARG_EXPAND_TAIL , GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define forward_glWindowPos4fMESA(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4fMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4fMESA(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glWindowPos4fMESA(packed, ret_v) do { \
    glWindowPos4fMESA_PACKED *unpacked = (glWindowPos4fMESA_PACKED *)packed; \
    glWindowPos4fMESA_ARGS *args = (glWindowPos4fMESA_ARGS *)&unpacked->args; \
    glWindowPos4fMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4fMESA(glWindowPos4fMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4fMESA(glWindowPos4fMESA_PACKED *_dst glWindowPos4fMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4fMESA_PTR)(glWindowPos4fMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4fvMESA_RETURN
#define glWindowPos4fvMESA_RETURN void
#define glWindowPos4fvMESA_ARG_NAMES v
#define glWindowPos4fvMESA_ARG_EXPAND const GLfloat * v
#define glWindowPos4fvMESA_ARG_NAMES_TAIL , v
#define glWindowPos4fvMESA_ARG_EXPAND_TAIL , const GLfloat * v
#define forward_glWindowPos4fvMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4fvMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4fvMESA(dst, _v), NULL); \
    });
#define call_glWindowPos4fvMESA(packed, ret_v) do { \
    glWindowPos4fvMESA_PACKED *unpacked = (glWindowPos4fvMESA_PACKED *)packed; \
    glWindowPos4fvMESA_ARGS *args = (glWindowPos4fvMESA_ARGS *)&unpacked->args; \
    glWindowPos4fvMESA(args->v);; \
} while(0)
void glWindowPos4fvMESA(glWindowPos4fvMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4fvMESA(glWindowPos4fvMESA_PACKED *_dst glWindowPos4fvMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4fvMESA_PTR)(glWindowPos4fvMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4iMESA_RETURN
#define glWindowPos4iMESA_RETURN void
#define glWindowPos4iMESA_ARG_NAMES x, y, z, w
#define glWindowPos4iMESA_ARG_EXPAND GLint x, GLint y, GLint z, GLint w
#define glWindowPos4iMESA_ARG_NAMES_TAIL , x, y, z, w
#define glWindowPos4iMESA_ARG_EXPAND_TAIL , GLint x, GLint y, GLint z, GLint w
#define forward_glWindowPos4iMESA(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4iMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4iMESA(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glWindowPos4iMESA(packed, ret_v) do { \
    glWindowPos4iMESA_PACKED *unpacked = (glWindowPos4iMESA_PACKED *)packed; \
    glWindowPos4iMESA_ARGS *args = (glWindowPos4iMESA_ARGS *)&unpacked->args; \
    glWindowPos4iMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4iMESA(glWindowPos4iMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4iMESA(glWindowPos4iMESA_PACKED *_dst glWindowPos4iMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4iMESA_PTR)(glWindowPos4iMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4ivMESA_RETURN
#define glWindowPos4ivMESA_RETURN void
#define glWindowPos4ivMESA_ARG_NAMES v
#define glWindowPos4ivMESA_ARG_EXPAND const GLint * v
#define glWindowPos4ivMESA_ARG_NAMES_TAIL , v
#define glWindowPos4ivMESA_ARG_EXPAND_TAIL , const GLint * v
#define forward_glWindowPos4ivMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4ivMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4ivMESA(dst, _v), NULL); \
    });
#define call_glWindowPos4ivMESA(packed, ret_v) do { \
    glWindowPos4ivMESA_PACKED *unpacked = (glWindowPos4ivMESA_PACKED *)packed; \
    glWindowPos4ivMESA_ARGS *args = (glWindowPos4ivMESA_ARGS *)&unpacked->args; \
    glWindowPos4ivMESA(args->v);; \
} while(0)
void glWindowPos4ivMESA(glWindowPos4ivMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4ivMESA(glWindowPos4ivMESA_PACKED *_dst glWindowPos4ivMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4ivMESA_PTR)(glWindowPos4ivMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4sMESA_RETURN
#define glWindowPos4sMESA_RETURN void
#define glWindowPos4sMESA_ARG_NAMES x, y, z, w
#define glWindowPos4sMESA_ARG_EXPAND GLshort x, GLshort y, GLshort z, GLshort w
#define glWindowPos4sMESA_ARG_NAMES_TAIL , x, y, z, w
#define glWindowPos4sMESA_ARG_EXPAND_TAIL , GLshort x, GLshort y, GLshort z, GLshort w
#define forward_glWindowPos4sMESA(_x, _y, _z, _w) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4sMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4sMESA(dst, _x, _y, _z, _w), NULL); \
    });
#define call_glWindowPos4sMESA(packed, ret_v) do { \
    glWindowPos4sMESA_PACKED *unpacked = (glWindowPos4sMESA_PACKED *)packed; \
    glWindowPos4sMESA_ARGS *args = (glWindowPos4sMESA_ARGS *)&unpacked->args; \
    glWindowPos4sMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4sMESA(glWindowPos4sMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4sMESA(glWindowPos4sMESA_PACKED *_dst glWindowPos4sMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4sMESA_PTR)(glWindowPos4sMESA_ARG_EXPAND);
#endif
#ifndef glWindowPos4svMESA_RETURN
#define glWindowPos4svMESA_RETURN void
#define glWindowPos4svMESA_ARG_NAMES v
#define glWindowPos4svMESA_ARG_EXPAND const GLshort * v
#define glWindowPos4svMESA_ARG_NAMES_TAIL , v
#define glWindowPos4svMESA_ARG_EXPAND_TAIL , const GLshort * v
#define forward_glWindowPos4svMESA(_v) \
    ({ \
        void *dst = remote_dma(sizeof(glWindowPos4svMESA_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWindowPos4svMESA(dst, _v), NULL); \
    });
#define call_glWindowPos4svMESA(packed, ret_v) do { \
    glWindowPos4svMESA_PACKED *unpacked = (glWindowPos4svMESA_PACKED *)packed; \
    glWindowPos4svMESA_ARGS *args = (glWindowPos4svMESA_ARGS *)&unpacked->args; \
    glWindowPos4svMESA(args->v);; \
} while(0)
void glWindowPos4svMESA(glWindowPos4svMESA_ARG_EXPAND);
packed_call_t *pack_glWindowPos4svMESA(glWindowPos4svMESA_PACKED *_dst glWindowPos4svMESA_ARG_EXPAND_TAIL);
typedef void (*glWindowPos4svMESA_PTR)(glWindowPos4svMESA_ARG_EXPAND);
#endif
#ifndef glWriteMaskEXT_RETURN
#define glWriteMaskEXT_RETURN void
#define glWriteMaskEXT_ARG_NAMES res, in, outX, outY, outZ, outW
#define glWriteMaskEXT_ARG_EXPAND GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW
#define glWriteMaskEXT_ARG_NAMES_TAIL , res, in, outX, outY, outZ, outW
#define glWriteMaskEXT_ARG_EXPAND_TAIL , GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW
#define forward_glWriteMaskEXT(_res, _in, _outX, _outY, _outZ, _outW) \
    ({ \
        void *dst = remote_dma(sizeof(glWriteMaskEXT_PACKED)); \
        remote_dma_send((packed_call_t *)pack_glWriteMaskEXT(dst, _res, _in, _outX, _outY, _outZ, _outW), NULL); \
    });
#define call_glWriteMaskEXT(packed, ret_v) do { \
    glWriteMaskEXT_PACKED *unpacked = (glWriteMaskEXT_PACKED *)packed; \
    glWriteMaskEXT_ARGS *args = (glWriteMaskEXT_ARGS *)&unpacked->args; \
    glWriteMaskEXT(args->res, args->in, args->outX, args->outY, args->outZ, args->outW);; \
} while(0)
void glWriteMaskEXT(glWriteMaskEXT_ARG_EXPAND);
packed_call_t *pack_glWriteMaskEXT(glWriteMaskEXT_PACKED *_dst glWriteMaskEXT_ARG_EXPAND_TAIL);
typedef void (*glWriteMaskEXT_PTR)(glWriteMaskEXT_ARG_EXPAND);
#endif

#endif
